This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursor/plans/ui-overhaul---tone-interpreter-7b37f7a4.plan.md
.cursorignore
.gitignore
backend/firebase.env
backend/Makefile
backend/package.json
backend/start_log.txt
backend/supabase/.gitignore
backend/supabase/config.toml
backend/supabase/db/test/.gitkeep
backend/supabase/db/test/rls_messages_tap.sql
backend/supabase/db/test/rls_participants_tap.sql
backend/supabase/db/triggers/.gitkeep
backend/supabase/db/triggers/messages_notify.sql
backend/supabase/db/triggers/receipts_notify.sql
backend/supabase/functions/_shared/nlp/action-item-extractor.ts
backend/supabase/functions/_shared/nlp/question-detector.ts
backend/supabase/functions/_shared/openai-client.ts
backend/supabase/functions/_shared/prompts/__tests__/alternative-interpretations.test.ts
backend/supabase/functions/_shared/prompts/__tests__/enhanced-tone-analysis.test.ts
backend/supabase/functions/_shared/prompts/__tests__/evidence-extractor.test.ts
backend/supabase/functions/_shared/prompts/__tests__/rsd-detection.test.ts
backend/supabase/functions/_shared/prompts/alternative-interpretations.ts
backend/supabase/functions/_shared/prompts/draft_analysis.ts
backend/supabase/functions/_shared/prompts/enhanced-tone-analysis.ts
backend/supabase/functions/_shared/prompts/evidence-extractor.ts
backend/supabase/functions/_shared/prompts/message-formatter.ts
backend/supabase/functions/_shared/prompts/rsd-detection.ts
backend/supabase/functions/_shared/prompts/situation-detector.ts
backend/supabase/functions/_shared/prompts/tone-analysis-v1.backup.ts
backend/supabase/functions/_shared/prompts/tone-analysis.ts
backend/supabase/functions/_shared/rag/embedding-generator.ts
backend/supabase/functions/_shared/rag/relationship-builder.ts
backend/supabase/functions/_shared/rag/vector-search.ts
backend/supabase/functions/_shared/templates/apologizing-templates.ts
backend/supabase/functions/_shared/templates/boundary-templates.ts
backend/supabase/functions/_shared/templates/clarifying-templates.ts
backend/supabase/functions/_shared/templates/declining-templates.ts
backend/supabase/functions/_shared/templates/index.ts
backend/supabase/functions/_shared/templates/info-dump-templates.ts
backend/supabase/functions/ai_analyze_draft/index.ts
backend/supabase/functions/ai_analyze_tone/index.ts
backend/supabase/functions/ai-context-preloader/index.ts
backend/supabase/functions/ai-extract-followups/index.ts
backend/supabase/functions/ai-format-message/index.ts
backend/supabase/functions/ai-generate-embeddings/index.ts
backend/supabase/functions/ai-interpret-message/index.ts
backend/supabase/functions/ai-relationship-summary/index.ts
backend/supabase/functions/create_group/index.ts
backend/supabase/functions/messages_send/index.ts
backend/supabase/functions/push_notify/index.ts
backend/supabase/functions/receipts_ack/index.ts
backend/supabase/migrations/.gitkeep
backend/supabase/migrations/20251231_000001_smart_interpreter.sql
backend/supabase/migrations/20260101_000001_response_assistant.sql
backend/supabase/migrations/20260102_000001_context_system.sql
backend/supabase/migrations/20260103_000001_followup_system.sql
backend/supabase/policies/conversations.sql
backend/supabase/policies/messages.sql
backend/supabase/policies/participants.sql
backend/supabase/policies/receipts.sql
backend/supabase/storage/buckets.sql
backend/test_message_insert.js
contracts/events/message_inserted.schema.json
contracts/events/receipt_inserted.schema.json
contracts/openapi.yaml
contracts/openapitools.json
contracts/package.json
contracts/scripts/generate_dart.sh
docs/Architecture.puml
docs/ERD.puml
frontend/.gitignore
frontend/.metadata
frontend/analysis_options.yaml
frontend/android/.gitignore
frontend/android/app/build.gradle.kts
frontend/android/app/src/debug/AndroidManifest.xml
frontend/android/app/src/main/AndroidManifest.xml
frontend/android/app/src/main/kotlin/com/example/messageai/MainActivity.kt
frontend/android/app/src/main/res/drawable-v21/launch_background.xml
frontend/android/app/src/main/res/drawable/launch_background.xml
frontend/android/app/src/main/res/mipmap-hdpi/ic_launcher.png
frontend/android/app/src/main/res/mipmap-mdpi/ic_launcher.png
frontend/android/app/src/main/res/mipmap-xhdpi/ic_launcher.png
frontend/android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png
frontend/android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
frontend/android/app/src/main/res/values-night/styles.xml
frontend/android/app/src/main/res/values/styles.xml
frontend/android/build.gradle.kts
frontend/android/gradle.properties
frontend/android/settings.gradle.kts
frontend/devtools_options.yaml
frontend/firebase.json
frontend/integration_test/ai_flow_test.dart
frontend/integration_test/context_system_test.dart
frontend/integration_test/enhanced_tone_analysis_test.dart
frontend/lib/app.dart
frontend/lib/core/env.dart
frontend/lib/core/errors/app_error.dart
frontend/lib/core/errors/error_handler.dart
frontend/lib/core/errors/error_ui.dart
frontend/lib/core/theme/app_theme.dart
frontend/lib/data/drift/app_db.dart
frontend/lib/data/drift/daos/ai_analysis_dao_cached.dart.backup
frontend/lib/data/drift/daos/conversation_dao.dart
frontend/lib/data/drift/daos/message_dao.dart
frontend/lib/data/drift/daos/participant_dao.dart
frontend/lib/data/drift/daos/pending_outbox_dao.dart
frontend/lib/data/drift/daos/receipt_dao.dart
frontend/lib/data/drift/entities/ai_analysis_cached.drift.backup
frontend/lib/data/drift/entities/conversation.drift
frontend/lib/data/remote/supabase_client.dart
frontend/lib/data/repositories/group_repository.dart
frontend/lib/data/repositories/message_repository.dart
frontend/lib/data/repositories/receipt_repository.dart
frontend/lib/features/auth/screens/auth_screen.dart
frontend/lib/features/conversations/screens/conversations_list_screen.dart
frontend/lib/features/conversations/widgets/context_preview_card.dart
frontend/lib/features/conversations/widgets/message_bubble.dart
frontend/lib/features/conversations/widgets/relationship_summary_sheet.dart
frontend/lib/features/conversations/widgets/who_is_this_button.dart
frontend/lib/features/followups/screens/follow_up_dashboard_screen.dart
frontend/lib/features/followups/widgets/action_item_badge.dart
frontend/lib/features/followups/widgets/follow_up_card.dart
frontend/lib/features/messages/screens/message_screen.dart
frontend/lib/features/messages/widgets/ai_insights_background.dart
frontend/lib/features/messages/widgets/ai_insights_panel.dart
frontend/lib/features/messages/widgets/draft_feedback_panel.dart
frontend/lib/features/messages/widgets/evidence_viewer.dart
frontend/lib/features/messages/widgets/interpretation_options.dart
frontend/lib/features/messages/widgets/message_formatter_panel.dart
frontend/lib/features/messages/widgets/message_list_panel.dart
frontend/lib/features/messages/widgets/relationship_type_selector.dart
frontend/lib/features/messages/widgets/rsd_alert_card.dart
frontend/lib/features/messages/widgets/template_picker.dart
frontend/lib/features/messages/widgets/tone_badge.dart
frontend/lib/features/messages/widgets/tone_detail_sheet.dart
frontend/lib/features/notifications/widgets/notification_widgets.dart
frontend/lib/features/settings/screens/settings_screen.dart
frontend/lib/firebase_options.dart
frontend/lib/gen/api/api.dart
frontend/lib/gen/api/clients/messages_api.dart
frontend/lib/gen/api/clients/receipts_api.dart
frontend/lib/gen/api/models/message_payload.dart
frontend/lib/gen/api/models/receipt_payload.dart
frontend/lib/main.dart
frontend/lib/models/action_item.dart
frontend/lib/models/ai_analysis.dart
frontend/lib/models/context_trigger.dart
frontend/lib/models/conversation_context.dart
frontend/lib/models/draft_analysis.dart
frontend/lib/models/follow_up_item.dart
frontend/lib/models/formatted_message.dart
frontend/lib/models/relationship_profile.dart
frontend/lib/models/response_template.dart
frontend/lib/models/safe_topic.dart
frontend/lib/models/situation_type.dart
frontend/lib/services/ai_analysis_service_cached.dart.backup
frontend/lib/services/ai_analysis_service.dart
frontend/lib/services/auth_service.dart
frontend/lib/services/avatar_service.dart
frontend/lib/services/context_preloader_service.dart
frontend/lib/services/conversation_service.dart
frontend/lib/services/deep_link_handler.dart
frontend/lib/services/device_registration_service.dart
frontend/lib/services/draft_analysis_service.dart
frontend/lib/services/follow_up_service.dart
frontend/lib/services/local_notification_service.dart
frontend/lib/services/media_service.dart
frontend/lib/services/message_formatter_service.dart
frontend/lib/services/message_service.dart
frontend/lib/services/network_connectivity_service.dart
frontend/lib/services/notification_service.dart
frontend/lib/services/offline_queue_service.dart
frontend/lib/services/presence_service.dart
frontend/lib/services/realtime_diagnostic_service.dart
frontend/lib/services/realtime_message_service.dart
frontend/lib/services/relationship_service.dart
frontend/lib/services/response_template_service.dart
frontend/lib/services/retry_service.dart
frontend/lib/services/typing_indicator_service.dart
frontend/lib/state/ai_providers_cached.dart.backup
frontend/lib/state/ai_providers.dart
frontend/lib/state/database_provider.dart
frontend/lib/state/notification_providers.dart
frontend/lib/state/presence_providers.dart
frontend/lib/state/providers.dart
frontend/lib/state/realtime_providers.dart
frontend/lib/state/repository_providers.dart
frontend/lib/state/send_queue.dart
frontend/lib/state/typing_providers.dart
frontend/lib/widgets/network_status_banner.dart
frontend/lib/widgets/sliding_panel.dart
frontend/lib/widgets/user_avatar.dart
frontend/Makefile
frontend/pubspec.yaml
frontend/repomix-output.xml
frontend/test/models/action_item_test.dart
frontend/test/models/ai_analysis_enhanced_test.dart
frontend/test/models/ai_analysis_phase1_test.dart
frontend/test/models/ai_analysis_test.dart
frontend/test/models/conversation_context_test.dart
frontend/test/models/evidence_test.dart
frontend/test/models/follow_up_item_test.dart
frontend/test/models/message_interpretation_test.dart
frontend/test/models/relationship_profile_test.dart
frontend/test/models/rsd_trigger_test.dart
frontend/test/models/safe_topic_test.dart
frontend/test/offline_queue_test.dart
frontend/test/realtime_diagnostic_test.dart
frontend/test/services/ai_analysis_service_test.dart
frontend/test/services/context_preloader_service_test.dart
frontend/test/services/relationship_service_test.dart
frontend/test/widget_test.dart
frontend/test/widgets/context_preview_card_test.dart
frontend/test/widgets/tone_badge_enhanced_test.dart
frontend/test/widgets/tone_badge_test.dart
frontend/test/widgets/who_is_this_button_test.dart
frontend/web/favicon.png
frontend/web/icons/Icon-192.png
frontend/web/icons/Icon-512.png
frontend/web/icons/Icon-maskable-192.png
frontend/web/icons/Icon-maskable-512.png
frontend/web/index.html
frontend/web/manifest.json
frontend/windows/.gitignore
frontend/windows/CMakeLists.txt
frontend/windows/flutter/CMakeLists.txt
frontend/windows/runner/CMakeLists.txt
frontend/windows/runner/flutter_window.cpp
frontend/windows/runner/flutter_window.h
frontend/windows/runner/main.cpp
frontend/windows/runner/resource.h
frontend/windows/runner/resources/app_icon.ico
frontend/windows/runner/runner.exe.manifest
frontend/windows/runner/Runner.rc
frontend/windows/runner/utils.cpp
frontend/windows/runner/utils.h
frontend/windows/runner/win32_window.cpp
frontend/windows/runner/win32_window.h
messageai-integration-guide.md
package.json
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/plans/ui-overhaul---tone-interpreter-7b37f7a4.plan.md">
<!-- 7b37f7a4-3027-4e7b-9964-6637b59b8d85 21469e5d-48e5-4034-9f64-a4f84a3ddc1c -->
# UI Overhaul + Tone Interpreter Implementation

## Architecture Vision

The message screen becomes a layered interface:

- **Background Layer**: AI insights, tone analysis, suggestions (always present)
- **Foreground Layer**: Message list in a sliding panel that slides up/down
- **Default State**: Message panel slides up (80% height), showing peek of AI content
- **AI View**: User swipes down to reveal full AI analysis behind messages

## Phase 1: Theme System Overhaul

### Update Theme to Black/White Minimal

- Replace burnt orange theme with monochrome palette
- Use `theme_guide.md` as reference but implement black/white/gray only
- Accent colors only for critical actions (send button, online status)
- Remove all color gradients, use sharp shadows and clean lines

**Files to modify:**

- `frontend/lib/app.dart` - Replace entire `ThemeData` configuration
  - Light theme: White backgrounds (#FFFFFF), black text (#000000), gray surfaces (#F5F5F5)
  - Dark theme: True black backgrounds (#000000), white text (#FFFFFF), dark gray surfaces (#1A1A1A)
  - Minimal accent: Single green for online, single blue for actions

### Update existing screens with new theme

- `frontend/lib/features/conversations/screens/conversations_list_screen.dart`
  - Cleaner list items, sharper dividers
  - Remove colored avatars, use monochrome initials
  - Flat design with subtle shadows

- `frontend/lib/features/auth/screens/auth_screen.dart`
  - Minimal input fields with black borders
  - Clean button design

- `frontend/lib/features/settings/screens/settings_screen.dart`
  - Flat list design matching new aesthetic

### Create shared theme constants

**New file:** `frontend/lib/core/theme/app_theme.dart`

- Define color constants from theme guide (Gray scale only)
- Typography system (sizes, weights)
- Spacing constants
- Border radius constants
- Shadow definitions

## Phase 2: Sliding Panel Architecture

### Build sliding panel widget system

**New file:** `frontend/lib/widgets/sliding_panel.dart`

- `SlidingPanel` widget using `DraggableScrollableSheet`
- Min height: 0.2 (20% - peek view)
- Max height: 0.95 (95% - nearly full screen)
- Initial height: 0.8 (80% - standard messaging view)
- Snap positions at 0.2, 0.5, 0.8, 0.95
- Smooth animations with custom curves
- Handle decorations: Rounded top corners, drag handle indicator

### Redesign Message Screen with layers

**Modify:** `frontend/lib/features/messages/screens/message_screen.dart`

- Restructure layout:
  ```dart
  Stack(
    children: [
      // Background: AI Insights Panel
      _buildAIInsightsBackground(),
      
      // Foreground: Sliding Message Panel
      SlidingPanel(
        child: MessageListView(),
        onSlide: (position) => setState(() => _panelPosition = position),
      ),
    ],
  )
  ```

- Extract message list into separate widget
- Create AI background placeholder (will populate with tone analysis)

**New file:** `frontend/lib/features/messages/widgets/message_list_panel.dart`

- Extract current message list building logic
- Include compose bar at bottom of panel
- Maintain all existing functionality (typing indicators, receipts, etc.)

**New file:** `frontend/lib/features/messages/widgets/ai_insights_background.dart`

- Background container for AI features
- Initially shows: "Pull down to see AI insights"
- Will display tone analysis when implemented

## Phase 3: Tone Interpreter Backend

### Database Schema

**New file:** `backend/supabase/migrations/20251024_000002_ai_analysis.sql`

```sql
CREATE TABLE message_ai_analysis (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  message_id UUID REFERENCES messages(id) ON DELETE CASCADE,
  tone TEXT NOT NULL,
  urgency_level TEXT,
  intent TEXT,
  confidence_score FLOAT,
  analysis_timestamp BIGINT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_ai_analysis_message ON message_ai_analysis(message_id);
CREATE INDEX idx_ai_analysis_timestamp ON message_ai_analysis(analysis_timestamp);
```

### Anthropic Client Setup

**New file:** `backend/supabase/functions/_shared/anthropic-client.ts`

- Wrapper for Anthropic API using Claude Sonnet 4
- Type-safe message formatting
- Error handling and retries
- Rate limiting considerations

**New file:** `backend/supabase/functions/_shared/prompts/tone-analysis.ts`

- Prompt engineering for tone detection
- System prompt defining tone categories
- Context inclusion strategy
- JSON response formatting

### Edge Function for Analysis

**New file:** `backend/supabase/functions/ai_analyze_tone/index.ts`

- Accept: `{ message_id, message_body, conversation_context? }`
- Call Anthropic API with message + context
- Parse response into structured data
- Store analysis in `message_ai_analysis` table
- Return: `{ tone, urgency_level, intent, confidence_score }`

Tone categories:

- Friendly, Professional, Urgent, Casual, Formal, Concerned, Excited, Neutral

Urgency levels:

- Low, Medium, High, Critical

**Modify:** `backend/supabase/config.toml`

- Add new Edge Function configuration
- Set environment variables for Anthropic API key

### RPC Function for Bulk Analysis

**Add to migration:** `backend/supabase/migrations/20251024_000002_ai_analysis.sql`

```sql
CREATE OR REPLACE FUNCTION get_conversation_ai_analysis(p_conversation_id UUID)
RETURNS TABLE (
  message_id UUID,
  tone TEXT,
  urgency_level TEXT,
  intent TEXT,
  confidence_score FLOAT
) AS $$
BEGIN
  RETURN QUERY
  SELECT a.message_id, a.tone, a.urgency_level, a.intent, a.confidence_score
  FROM message_ai_analysis a
  JOIN messages m ON a.message_id = m.id
  WHERE m.conversation_id = p_conversation_id
  ORDER BY m.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## Phase 4: Tone Interpreter Frontend (Remote-Only, No Local Cache)

### AI Service Layer - Simplified

**New file:** `frontend/lib/services/ai_analysis_service.dart`

- Request analysis for a message (calls Edge Function)
- Fetch analysis directly from Supabase (no local cache)
- Debounce requests to avoid spam
- Simple in-memory caching for current session only
- Returns data directly from API calls

### State Management

**New file:** `frontend/lib/state/ai_providers.dart`

```dart
// Provider for conversation-wide AI analysis
final conversationAIAnalysisProvider = FutureProvider.family<Map<String, AIAnalysis>, String>(
  (ref, conversationId) async {
    final service = AIAnalysisService();
    return await service.getConversationAnalysis(conversationId);
  },
);

// Provider for triggering analysis
final requestAnalysisProvider = Provider((ref) => AIAnalysisService());
```

### UI Components for Tone Display

**New file:** `frontend/lib/features/messages/widgets/tone_badge.dart`

- Small badge showing tone emoji + label
- Color coding: Urgent=red, Professional=blue, Friendly=green, etc.
- Tap to expand details
- Position: Bottom-right of message bubble (subtle, non-intrusive)

**New file:** `frontend/lib/features/messages/widgets/ai_insights_panel.dart`

- Replaces `ai_insights_background.dart` placeholder
- Shows conversation-level insights:
  - Overall tone of conversation
  - Most recent message analysis
  - Urgency indicators
  - Detected intents
- Visual design: Cards with minimal shadows, clean typography
- "Analyze Message" button for manual triggers

**Modify:** `frontend/lib/features/messages/widgets/message_list_panel.dart`

- Add tone badges to message bubbles
- Wire up tap handlers to show detail sheet

**New file:** `frontend/lib/features/messages/widgets/tone_detail_sheet.dart`

- Bottom sheet showing full analysis
- Display: Tone, urgency, intent, confidence score
- Feedback mechanism: "Was this helpful?" thumbs up/down
- Future: User corrections to improve model

### Integration with Message Flow

**Modify:** `frontend/lib/services/message_service.dart`

- After sending message, trigger tone analysis asynchronously
- Don't block message send on analysis
- Store message ID for later analysis result

**Modify:** `frontend/lib/features/messages/screens/message_screen.dart`

- Pass AI analysis data to `AIInsightsPanel`
- Show loading state while analysis pending
- Update UI when analysis completes via Riverpod listener

## Phase 5: Polish & Testing

### Update Documentation

- Update `theme_guide.md` with implemented black/white palette
- Update `technical_implementation (1).md` with completed PR #1-2
- Add comments explaining sliding panel architecture

### Settings Integration

**Modify:** `frontend/lib/features/settings/screens/settings_screen.dart`

- Add "AI Features" section
- Toggle: Enable/disable tone analysis
- Option: Auto-analyze all messages vs manual trigger
- Privacy notice about AI processing

### Testing Checklist

- Sliding panel smooth on various devices
- Tone analysis works for different message types
- Theme consistent across light/dark modes
- No performance issues with analysis
- Graceful error handling when API fails
- Works offline (shows cached analysis only)

## Implementation Order

1. Theme system first (provides foundation)
2. Sliding panel architecture (core UX pattern)
3. Backend tone analysis (can test independently)
4. Frontend AI display (brings it all together)
5. Integration and polish

### To-dos

- [ ] Create black/white theme system and update app.dart with new ThemeData
- [ ] Update existing screens (conversations list, auth, settings) with minimal design
- [ ] Build SlidingPanel widget with DraggableScrollableSheet
- [ ] Restructure message screen with Stack layout (background + sliding panel)
- [ ] Create migration for message_ai_analysis table
- [ ] Create Anthropic client wrapper and tone analysis prompts
- [ ] Implement ai_analyze_tone Edge Function
- [ ] Add ai_analysis Drift table and DAO
- [ ] Create AIAnalysisService and state providers
- [ ] Build tone badge, insights panel, and detail sheet widgets
- [ ] Wire up message flow with AI analysis and test end-to-end
- [ ] Add AI settings toggles and update documentation
</file>

<file path="backend/supabase/functions/_shared/nlp/action-item-extractor.ts">
/**
 * Extracts action items from messages
 * Detects implicit commitments like "I'll send you..."
 */

import { OpenAIClient } from '../openai-client.ts';

export interface ActionItem {
  action_type: string; // send, call, meet, review, etc.
  action_target: string; // What/who
  commitment_text: string; // Original text
  mentioned_deadline?: string; // "this afternoon"
  confidence: number; // 0.0-1.0
}

export const ACTION_ITEM_EXTRACTION_PROMPT = `You are an expert at identifying commitments and action items in conversations.

**Your task:** Extract action items from messages where someone commits to doing something.

**Action Types:**
- **send**: Sending something (email, file, link, message)
- **call**: Making a phone call
- **meet**: Meeting in person or video
- **review**: Reviewing/reading something
- **decide**: Making a decision
- **follow_up**: Following up later
- **check**: Checking on something
- **schedule**: Scheduling something
- **other**: Other commitment

**Examples:**

Input: "I'll send you the report this afternoon"
Output:
{
  "action_type": "send",
  "action_target": "report",
  "commitment_text": "I'll send you the report this afternoon",
  "mentioned_deadline": "this afternoon",
  "confidence": 0.95
}

Input: "Let me check and get back to you tomorrow"
Output:
{
  "action_type": "follow_up",
  "action_target": "answer to question",
  "commitment_text": "Let me check and get back to you tomorrow",
  "mentioned_deadline": "tomorrow",
  "confidence": 0.90
}

Input: "We should grab coffee sometime"
Output:
{
  "action_type": "meet",
  "action_target": "coffee meeting",
  "commitment_text": "We should grab coffee sometime",
  "mentioned_deadline": null,
  "confidence": 0.70
}

**Commitment Indicators:**
- "I'll", "I will"
- "Let me"
- "I can"
- "I'm going to"
- "I need to"
- "I should"
- "We should"

**Response Format:**
Return array of action items. If no commitments found, return empty array: []`;

export class ActionItemExtractor {
  private openai: OpenAIClient;

  constructor() {
    this.openai = new OpenAIClient();
  }

  /**
   * Extract action items from message
   */
  async extractActionItems(
    messageBody: string,
    senderId: string,
    currentUserId: string
  ): Promise<ActionItem[]> {
    // Only extract from user's own messages
    if (senderId !== currentUserId) {
      return [];
    }

    // Quick check for commitment indicators
    const hasCommitment = [
      "i'll", "i will", "let me", "i can", "i'm going to",
      "i need to", "i should", "we should"
    ].some(indicator => messageBody.toLowerCase().includes(indicator));

    if (!hasCommitment) {
      return [];
    }

    try {
      const userPrompt = `Extract action items from this message:\n\n"${messageBody}"`;
      
      const result = await this.openai.sendMessageForJSON<ActionItem[]>(
        userPrompt,
        ACTION_ITEM_EXTRACTION_PROMPT,
        { temperature: 0.2, max_tokens: 500 }
      );

      // Filter by confidence threshold
      return (Array.isArray(result) ? result : [])
        .filter(item => item.confidence >= 0.7);
    } catch (error) {
      console.error('Error extracting action items:', error);
      return [];
    }
  }

  /**
   * Parse deadline from natural language
   */
  parseDeadline(deadlineText: string): number | null {
    const now = Math.floor(Date.now() / 1000);
    const lowerText = deadlineText.toLowerCase();

    // Today
    if (lowerText.includes('today') || lowerText.includes('this afternoon')) {
      return now + 6 * 3600; // 6 hours from now
    }

    // Tomorrow
    if (lowerText.includes('tomorrow')) {
      return now + 24 * 3600;
    }

    // This week
    if (lowerText.includes('this week') || lowerText.includes('by friday')) {
      return now + 5 * 24 * 3600; // 5 days
    }

    // Next week
    if (lowerText.includes('next week')) {
      return now + 7 * 24 * 3600;
    }

    // Fallback: 2 days
    return now + 2 * 24 * 3600;
  }
}
</file>

<file path="backend/supabase/functions/_shared/nlp/question-detector.ts">
/**
 * Detects unanswered questions in conversations
 */

export interface UnansweredQuestion {
  message_id: string;
  question_text: string;
  question_type: string; // when, where, what, who, why, how, yes/no
  context: string;
  asked_at: number;
  confidence: number;
}

export class QuestionDetector {
  /**
   * Find unanswered questions in conversation
   */
  async findUnansweredQuestions(
    messages: Array<{ id: string; body: string; sender_id: string; created_at: number }>,
    currentUserId: string
  ): Promise<UnansweredQuestion[]> {
    const unanswered: UnansweredQuestion[] = [];

    for (let i = messages.length - 1; i >= 0; i--) {
      const message = messages[i];
      
      // Only check questions FROM others TO user
      if (message.sender_id === currentUserId) {
        continue;
      }

      // Check if message contains question
      if (!message.body.includes('?')) {
        continue;
      }

      // Check if user responded after this question
      const hasResponse = messages
        .slice(i + 1)
        .some(m => m.sender_id === currentUserId);

      if (!hasResponse) {
        // Extract question type
        const questionType = this.detectQuestionType(message.body);
        
        unanswered.push({
          message_id: message.id,
          question_text: message.body,
          question_type: questionType,
          context: this.extractContext(messages, i),
          asked_at: message.created_at,
          confidence: 0.9,
        });
      }
    }

    return unanswered;
  }

  /**
   * Detect question type
   */
  private detectQuestionType(text: string): string {
    const lowerText = text.toLowerCase();

    if (lowerText.startsWith('when ')) return 'when';
    if (lowerText.startsWith('where ')) return 'where';
    if (lowerText.startsWith('what ')) return 'what';
    if (lowerText.startsWith('who ')) return 'who';
    if (lowerText.startsWith('why ')) return 'why';
    if (lowerText.startsWith('how ')) return 'how';
    
    // Check for yes/no questions
    const yesNoIndicators = ['can you', 'could you', 'would you', 'will you', 'do you', 'are you'];
    if (yesNoIndicators.some(indicator => lowerText.includes(indicator))) {
      return 'yes/no';
    }

    return 'other';
  }

  /**
   * Extract context around question
   */
  private extractContext(
    messages: Array<{ body: string }>,
    questionIndex: number
  ): string {
    const contextRange = 2;
    const start = Math.max(0, questionIndex - contextRange);
    const contextMessages = messages.slice(start, questionIndex);
    
    return contextMessages.map(m => m.body).join(' ');
  }
}
</file>

<file path="backend/supabase/functions/_shared/openai-client.ts">
/**
 * OpenAI API Client
 * Provides type-safe wrapper for GPT-4 interactions
 */

export interface OpenAIMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

export interface OpenAIResponse {
  id: string;
  object: string;
  created: number;
  model: string;
  choices: Array<{
    index: number;
    message: {
      role: string;
      content: string;
    };
    finish_reason: string;
  }>;
  usage: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

export interface OpenAIRequestOptions {
  model?: string;
  temperature?: number;
  max_tokens?: number;
  response_format?: { type: 'json_object' };
}

export class OpenAIClient {
  private apiKey: string;
  private baseUrl = 'https://api.openai.com/v1/chat/completions';
  private defaultModel = 'gpt-4-turbo-preview';

  constructor(apiKey: string) {
    if (!apiKey) {
      throw new Error('OpenAI API key is required');
    }
    this.apiKey = apiKey;
  }

  /**
   * Send messages to GPT-4 and get a response
   */
  async sendMessages(
    messages: OpenAIMessage[],
    options: OpenAIRequestOptions = {}
  ): Promise<OpenAIResponse> {
    const {
      model = this.defaultModel,
      temperature = 0.7,
      max_tokens = 1000,
      response_format,
    } = options;

    const requestBody: any = {
      model,
      messages,
      temperature,
      max_tokens,
    };

    if (response_format) {
      requestBody.response_format = response_format;
    }

    try {
      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`,
        },
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(
          `OpenAI API error (${response.status}): ${errorBody}`
        );
      }

      const data: OpenAIResponse = await response.json();
      return data;
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to call OpenAI API: ${error.message}`);
      }
      throw error;
    }
  }

  /**
   * Extract text content from the response
   */
  extractTextContent(response: OpenAIResponse): string {
    return response.choices[0]?.message?.content || '';
  }

  /**
   * Send a simple single-turn message and get text response
   */
  async sendSimpleMessage(
    userMessage: string,
    systemPrompt?: string,
    options: Partial<OpenAIRequestOptions> = {}
  ): Promise<string> {
    const messages: OpenAIMessage[] = [];
    
    if (systemPrompt) {
      messages.push({
        role: 'system',
        content: systemPrompt,
      });
    }
    
    messages.push({
      role: 'user',
      content: userMessage,
    });

    const response = await this.sendMessages(messages, options);
    return this.extractTextContent(response);
  }

  /**
   * Parse JSON from GPT's response
   * Handles cases where GPT wraps JSON in markdown code blocks
   */
  parseJSONResponse<T>(responseText: string): T {
    // Remove markdown code blocks if present
    let cleaned = responseText.trim();
    
    // Remove ```json and ``` markers
    if (cleaned.startsWith('```json')) {
      cleaned = cleaned.slice(7);
    } else if (cleaned.startsWith('```')) {
      cleaned = cleaned.slice(3);
    }
    
    if (cleaned.endsWith('```')) {
      cleaned = cleaned.slice(0, -3);
    }
    
    cleaned = cleaned.trim();
    
    try {
      return JSON.parse(cleaned) as T;
    } catch (error) {
      throw new Error(
        `Failed to parse JSON response: ${error instanceof Error ? error.message : 'Unknown error'}\n` +
        `Response: ${cleaned}`
      );
    }
  }

  /**
   * Send a message and parse JSON response
   * Uses OpenAI's structured JSON output mode for reliable formatting
   */
  async sendMessageForJSON<T>(
    userMessage: string,
    systemPrompt: string,
    options: Partial<OpenAIRequestOptions> = {}
  ): Promise<T> {
    const responseText = await this.sendSimpleMessage(
      userMessage,
      systemPrompt,
      {
        ...options,
        temperature: 0.3, // Lower temperature for more consistent JSON
        response_format: { type: 'json_object' }, // Request JSON format
      }
    );

    return this.parseJSONResponse<T>(responseText);
  }
}

/**
 * Create an OpenAI client with API key from environment
 */
export function createOpenAIClient(): OpenAIClient {
  const apiKey = Deno.env.get('OPENAI_API_KEY');
  
  if (!apiKey) {
    throw new Error(
      'OPENAI_API_KEY environment variable is not set. ' +
      'Please configure it in Supabase Edge Function secrets.'
    );
  }

  return new OpenAIClient(apiKey);
}
</file>

<file path="backend/supabase/functions/_shared/prompts/__tests__/alternative-interpretations.test.ts">
import { assertEquals } from 'https://deno.land/std@0.168.0/testing/asserts.ts';
import { shouldGenerateAlternatives } from '../alternative-interpretations.ts';

Deno.test('shouldGenerateAlternatives - with RSD triggers', () => {
  const result = shouldGenerateAlternatives('ok', 1, 0.85);
  assertEquals(result, true, 'Should generate alternatives when RSD triggers detected');
});

Deno.test('shouldGenerateAlternatives - low confidence', () => {
  const result = shouldGenerateAlternatives('maybe...', 0, 0.5);
  assertEquals(result, true, 'Should generate alternatives when confidence < 0.7');
});

Deno.test('shouldGenerateAlternatives - short message', () => {
  const result = shouldGenerateAlternatives('ok', 0, 0.85);
  assertEquals(result, true, 'Should generate alternatives for short messages (≤3 words)');
});

Deno.test('shouldGenerateAlternatives - normal message, high confidence', () => {
  const result = shouldGenerateAlternatives('Hey! How are you doing today?', 0, 0.9);
  assertEquals(result, false, 'Should NOT generate alternatives for normal messages with high confidence');
});

Deno.test('shouldGenerateAlternatives - edge case 3 words', () => {
  const result = shouldGenerateAlternatives('I am good', 0, 0.85);
  assertEquals(result, true, 'Should generate alternatives for exactly 3 words');
});

Deno.test('shouldGenerateAlternatives - edge case 4 words', () => {
  const result = shouldGenerateAlternatives('I am doing good', 0, 0.85);
  assertEquals(result, false, 'Should NOT generate alternatives for 4 words with high confidence');
});
</file>

<file path="backend/supabase/functions/_shared/prompts/__tests__/enhanced-tone-analysis.test.ts">
import { assertEquals, assertExists } from "https://deno.land/std@0.168.0/testing/asserts.ts";
import {
  validateToneAnalysis,
  extractToneIndicators,
  detectFigurativeLanguage,
  assessResponseAnxietyRisk,
  generateAnalysisPrompt,
  VALID_TONES,
  type ToneAnalysisResult,
} from "../enhanced-tone-analysis.ts";

// ============================================================================
// UNIT TESTS: Tone Indicator Extraction
// ============================================================================

Deno.test("extractToneIndicators - detects single tone indicator", () => {
  const message = "I'm just joking /j";
  const indicators = extractToneIndicators(message);
  assertEquals(indicators.length, 1);
  assertEquals(indicators[0], "/j");
});

Deno.test("extractToneIndicators - detects multiple tone indicators", () => {
  const message = "I'm serious about this /srs and not mad /nm";
  const indicators = extractToneIndicators(message);
  assertEquals(indicators.length, 2);
  assertEquals(indicators, ["/srs", "/nm"]);
});

Deno.test("extractToneIndicators - handles message with no indicators", () => {
  const message = "This is a normal message";
  const indicators = extractToneIndicators(message);
  assertEquals(indicators.length, 0);
});

Deno.test("extractToneIndicators - detects sarcasm indicator", () => {
  const message = "Oh great, another meeting /s";
  const indicators = extractToneIndicators(message);
  assertEquals(indicators, ["/s"]);
});

// ============================================================================
// UNIT TESTS: Figurative Language Detection
// ============================================================================

Deno.test("detectFigurativeLanguage - detects common idiom", () => {
  const message = "Let's break the ice with introductions";
  const result = detectFigurativeLanguage(message);
  assertEquals(result.has_figurative_language, true);
  assertEquals(result.examples.length, 1);
  assertEquals(result.examples[0], 'Idiom: "break the ice"');
});

Deno.test("detectFigurativeLanguage - detects multiple idioms", () => {
  const message = "This project is a piece of cake, I'm not under the weather";
  const result = detectFigurativeLanguage(message);
  assertEquals(result.has_figurative_language, true);
  assertEquals(result.examples.length, 2);
});

Deno.test("detectFigurativeLanguage - handles message with no idioms", () => {
  const message = "I will complete the task today";
  const result = detectFigurativeLanguage(message);
  assertEquals(result.has_figurative_language, false);
  assertEquals(result.examples.length, 0);
});

// ============================================================================
// UNIT TESTS: Validation
// ============================================================================

Deno.test("validateToneAnalysis - accepts valid result", () => {
  const validResult = {
    tone: "Friendly",
    intensity: "medium",
    urgency_level: "Low",
    intent: "greeting and checking in",
    confidence_score: 0.85,
    context_flags: {
      sarcasm_detected: false,
      tone_indicator_present: false,
    },
  };

  const validated = validateToneAnalysis(validResult);
  assertEquals(validated.tone, "Friendly");
  assertEquals(validated.intensity, "medium");
  assertEquals(validated.urgency_level, "Low");
});

Deno.test("validateToneAnalysis - accepts all 23 valid tones", () => {
  const testTones = [
    "Friendly", "Professional", "Urgent", "Casual", "Formal", "Concerned",
    "Excited", "Neutral", "Apologetic", "Appreciative", "Frustrated", "Playful",
    "Sarcastic", "Empathetic", "Inquisitive", "Assertive", "Tentative", "Defensive",
    "Encouraging", "Disappointed", "Overwhelmed", "Relieved", "Confused"
  ];

  testTones.forEach(tone => {
    const result = {
      tone,
      urgency_level: "Low",
      intent: "test intent",
      confidence_score: 0.8,
    };
    const validated = validateToneAnalysis(result);
    assertEquals(validated.tone, tone);
  });
});

Deno.test("validateToneAnalysis - rejects invalid tone", () => {
  const invalidResult = {
    tone: "InvalidTone",
    urgency_level: "Low",
    intent: "test",
    confidence_score: 0.8,
  };

  let errorThrown = false;
  try {
    validateToneAnalysis(invalidResult);
  } catch (e) {
    errorThrown = true;
    assertEquals(e.message.includes("Invalid tone"), true);
  }
  assertEquals(errorThrown, true);
});

Deno.test("validateToneAnalysis - rejects invalid intensity", () => {
  const invalidResult = {
    tone: "Friendly",
    intensity: "super_high",
    urgency_level: "Low",
    intent: "test",
    confidence_score: 0.8,
  };

  let errorThrown = false;
  try {
    validateToneAnalysis(invalidResult);
  } catch (e) {
    errorThrown = true;
    assertEquals(e.message.includes("Invalid intensity"), true);
  }
  assertEquals(errorThrown, true);
});

Deno.test("validateToneAnalysis - rejects invalid urgency", () => {
  const invalidResult = {
    tone: "Friendly",
    urgency_level: "SuperUrgent",
    intent: "test",
    confidence_score: 0.8,
  };

  let errorThrown = false;
  try {
    validateToneAnalysis(invalidResult);
  } catch (e) {
    errorThrown = true;
    assertEquals(e.message.includes("Invalid urgency level"), true);
  }
  assertEquals(errorThrown, true);
});

Deno.test("validateToneAnalysis - rejects invalid confidence score", () => {
  const invalidResult = {
    tone: "Friendly",
    urgency_level: "Low",
    intent: "test",
    confidence_score: 1.5, // > 1
  };

  let errorThrown = false;
  try {
    validateToneAnalysis(invalidResult);
  } catch (e) {
    errorThrown = true;
    assertEquals(e.message.includes("Confidence score"), true);
  }
  assertEquals(errorThrown, true);
});

// ============================================================================
// UNIT TESTS: Anxiety Assessment
// ============================================================================

Deno.test("assessResponseAnxietyRisk - high urgency triggers high risk", () => {
  const analysis: ToneAnalysisResult = {
    tone: "Urgent",
    urgency_level: "Critical",
    intent: "needs immediate response",
    confidence_score: 0.9,
  };

  const assessment = assessResponseAnxietyRisk(analysis);
  assertEquals(assessment.risk_level, "high");
  assertEquals(assessment.mitigation_suggestions.length > 0, true);
});

Deno.test("assessResponseAnxietyRisk - sarcasm triggers medium risk", () => {
  const analysis: ToneAnalysisResult = {
    tone: "Sarcastic",
    urgency_level: "Low",
    intent: "making a joke",
    confidence_score: 0.85,
    context_flags: {
      sarcasm_detected: true,
    },
  };

  const assessment = assessResponseAnxietyRisk(analysis);
  assertEquals(assessment.risk_level, "medium");
  assertEquals(assessment.mitigation_suggestions.length > 0, true);
});

Deno.test("assessResponseAnxietyRisk - friendly message is low risk", () => {
  const analysis: ToneAnalysisResult = {
    tone: "Friendly",
    urgency_level: "Low",
    intent: "casual greeting",
    confidence_score: 0.9,
  };

  const assessment = assessResponseAnxietyRisk(analysis);
  assertEquals(assessment.risk_level, "low");
});

// ============================================================================
// UNIT TESTS: Prompt Generation
// ============================================================================

Deno.test("generateAnalysisPrompt - creates prompt without context", () => {
  const message = "Hello, how are you?";
  const prompt = generateAnalysisPrompt(message);
  
  assertEquals(prompt.includes(message), true);
  assertEquals(prompt.includes("Analyze the following message"), true);
});

Deno.test("generateAnalysisPrompt - includes conversation context", () => {
  const message = "That sounds great!";
  const context = ["Want to get coffee?", "I'm free at 3pm"];
  const prompt = generateAnalysisPrompt(message, context);
  
  assertEquals(prompt.includes(message), true);
  assertEquals(prompt.includes("Conversation Context"), true);
  assertEquals(prompt.includes("Want to get coffee?"), true);
  assertEquals(prompt.includes("I'm free at 3pm"), true);
});

// ============================================================================
// INTEGRATION TESTS: Full Analysis Flow
// ============================================================================

Deno.test("INTEGRATION - analyze playful message with tone indicator", () => {
  const message = "Oh sure, that's a great idea /j";
  
  // Extract indicators
  const indicators = extractToneIndicators(message);
  assertEquals(indicators, ["/j"]);
  
  // Check figurative language
  const figurative = detectFigurativeLanguage(message);
  assertEquals(figurative.has_figurative_language, false);
  
  // Validate mock analysis result
  const mockResult = {
    tone: "Playful",
    intensity: "medium",
    urgency_level: "Low",
    intent: "joking about suggestion",
    confidence_score: 0.92,
    context_flags: {
      tone_indicator_present: true,
      sarcasm_detected: false,
    },
  };
  
  const validated = validateToneAnalysis(mockResult);
  assertEquals(validated.tone, "Playful");
  assertEquals(validated.context_flags?.tone_indicator_present, true);
  
  // Assess anxiety
  const anxiety = assessResponseAnxietyRisk(validated);
  assertEquals(anxiety.risk_level, "low");
});

Deno.test("INTEGRATION - analyze overwhelmed message", () => {
  const message = "I'm SO stressed about this deadline /srs";
  
  // Extract indicators
  const indicators = extractToneIndicators(message);
  assertEquals(indicators, ["/srs"]);
  
  // Validate mock analysis
  const mockResult = {
    tone: "Overwhelmed",
    intensity: "very_high",
    urgency_level: "High",
    intent: "expressing severe stress",
    confidence_score: 0.95,
    context_flags: {
      tone_indicator_present: true,
    },
  };
  
  const validated = validateToneAnalysis(mockResult);
  assertEquals(validated.tone, "Overwhelmed");
  assertEquals(validated.intensity, "very_high");
  
  // High urgency should trigger anxiety warning
  const anxiety = assessResponseAnxietyRisk(validated);
  assertEquals(anxiety.risk_level, "high");
});

console.log("✅ All enhanced tone analysis tests passed!");
</file>

<file path="backend/supabase/functions/_shared/prompts/__tests__/evidence-extractor.test.ts">
import { assertEquals } from 'https://deno.land/std@0.168.0/testing/asserts.ts';
import { formatEvidence, type Evidence } from '../evidence-extractor.ts';

Deno.test('formatEvidence - with evidence', () => {
  const evidence: Evidence[] = [
    {
      type: 'keyword',
      quote: 'ASAP',
      supports: 'urgency',
      reasoning: 'Explicit urgency marker'
    },
    {
      type: 'punctuation',
      quote: '!!!',
      supports: 'high intensity',
      reasoning: 'Multiple exclamation marks show strong emotion'
    }
  ];
  
  const formatted = formatEvidence(evidence);
  
  assertEquals(formatted.includes('ASAP'), true, 'Should include the quote');
  assertEquals(formatted.includes('keyword'), true, 'Should include the type');
  assertEquals(formatted.includes('urgency'), true, 'Should include what it supports');
});

Deno.test('formatEvidence - empty evidence', () => {
  const evidence: Evidence[] = [];
  const formatted = formatEvidence(evidence);
  
  assertEquals(formatted, 'No specific evidence found in message');
});

Deno.test('formatEvidence - multiple evidence types', () => {
  const evidence: Evidence[] = [
    {
      type: 'emoji',
      quote: '😊',
      supports: 'friendly tone',
      reasoning: 'Smiling emoji indicates friendliness'
    },
    {
      type: 'length',
      quote: 'very short',
      supports: 'brevity',
      reasoning: 'Message is only 2 words'
    }
  ];
  
  const formatted = formatEvidence(evidence);
  
  assertEquals(formatted.includes('😊'), true);
  assertEquals(formatted.includes('emoji'), true);
  assertEquals(formatted.includes('length'), true);
});
</file>

<file path="backend/supabase/functions/_shared/prompts/__tests__/rsd-detection.test.ts">
import { assertEquals } from 'https://deno.land/std@0.168.0/testing/asserts.ts';
import { detectRSDTriggers, generateRSDPromptAddition } from '../rsd-detection.ts';

Deno.test('RSD Detection - "ok" message', () => {
  const triggers = detectRSDTriggers('ok');
  
  assertEquals(triggers.length, 2, 'Should detect 2 triggers: "ok" pattern + short_response');
  assertEquals(triggers[0].pattern, 'ok');
  assertEquals(triggers[0].severity, 'high');
  assertEquals(triggers[1].pattern, 'short_response');
});

Deno.test('RSD Detection - "fine" message', () => {
  const triggers = detectRSDTriggers('fine');
  
  assertEquals(triggers.length, 2, 'Should detect "fine" pattern + short_response');
  assertEquals(triggers[0].pattern, 'fine');
  assertEquals(triggers[0].severity, 'high');
});

Deno.test('RSD Detection - "k" message', () => {
  const triggers = detectRSDTriggers('k');
  
  assertEquals(triggers.length, 2, 'Should detect "k" pattern + short_response');
  assertEquals(triggers[0].pattern, 'k');
  assertEquals(triggers[0].severity, 'high');
});

Deno.test('RSD Detection - "we need to talk" message', () => {
  const triggers = detectRSDTriggers('we need to talk');
  
  assertEquals(triggers.length, 1, 'Should only detect "we need to talk" pattern, not short_response');
  assertEquals(triggers[0].pattern, 'we need to talk');
  assertEquals(triggers[0].severity, 'high');
});

Deno.test('RSD Detection - "sure" message', () => {
  const triggers = detectRSDTriggers('sure');
  
  assertEquals(triggers.length, 2, 'Should detect "sure" pattern + short_response');
  assertEquals(triggers[0].pattern, 'sure');
  assertEquals(triggers[0].severity, 'medium');
});

Deno.test('RSD Detection - message with warmth indicators', () => {
  const triggers1 = detectRSDTriggers('ok!');
  const triggers2 = detectRSDTriggers('ok 😊');
  const triggers3 = detectRSDTriggers('ok ❤️');
  
  assertEquals(triggers1.length, 1, 'Should only detect "ok", not short_response (has !)');
  assertEquals(triggers2.length, 1, 'Should only detect "ok", not short_response (has emoji)');
  assertEquals(triggers3.length, 1, 'Should only detect "ok", not short_response (has emoji)');
});

Deno.test('RSD Detection - normal message', () => {
  const triggers = detectRSDTriggers('Hey! How are you doing today?');
  
  assertEquals(triggers.length, 0, 'Should not detect any triggers in normal message');
});

Deno.test('RSD Detection - longer message with "ok" in it', () => {
  const triggers = detectRSDTriggers('That sounds ok to me, let me know when you want to meet');
  
  assertEquals(triggers.length, 1, 'Should detect "ok" pattern but not short_response');
  assertEquals(triggers[0].pattern, 'ok');
});

Deno.test('generateRSDPromptAddition - with triggers', () => {
  const triggers = detectRSDTriggers('ok');
  const prompt = generateRSDPromptAddition(triggers);
  
  assertEquals(prompt.includes('RSD ALERT'), true, 'Should include RSD ALERT header');
  assertEquals(prompt.includes('ok'), true, 'Should mention the "ok" pattern');
  assertEquals(prompt.includes('high severity'), true, 'Should mention severity');
});

Deno.test('generateRSDPromptAddition - no triggers', () => {
  const triggers = detectRSDTriggers('Hey there!');
  const prompt = generateRSDPromptAddition(triggers);
  
  assertEquals(prompt, '', 'Should return empty string when no triggers');
});
</file>

<file path="backend/supabase/functions/_shared/prompts/alternative-interpretations.ts">
/**
 * Generates multiple possible interpretations of a message
 * Helps with ambiguity and reduces anxiety from uncertainty
 */

export interface MessageInterpretation {
  interpretation: string;
  tone: string;
  likelihood: number; // 0-100
  reasoning: string;
  context_clues: string[];
}

export const ALTERNATIVE_INTERPRETATIONS_PROMPT = `
**CRITICAL:** For messages that could be interpreted multiple ways, provide 2-3 alternative interpretations ranked by likelihood.

Consider:
1. **Literal interpretation:** What do the exact words mean?
2. **Positive interpretation:** Best-case scenario
3. **Neutral interpretation:** No hidden meaning
4. **Negative interpretation:** Worst-case (if genuinely possible)

For each interpretation, provide:
- The interpretation itself
- What tone it would reflect
- Likelihood (0-100%)
- Reasoning why this interpretation makes sense
- Context clues supporting it

**Example for "ok":**
[
  {
    "interpretation": "Simple acknowledgment, no hidden meaning",
    "tone": "Neutral",
    "likelihood": 70,
    "reasoning": "Most common use of 'ok' is just confirming receipt of information",
    "context_clues": ["No prior conflict", "Normal conversation flow"]
  },
  {
    "interpretation": "Mildly annoyed or disappointed but trying to be polite",
    "tone": "Frustrated",
    "likelihood": 20,
    "reasoning": "Very brief response could indicate frustration",
    "context_clues": ["Shorter than usual", "No warmth markers"]
  },
  {
    "interpretation": "In a rush, typing quickly",
    "tone": "Casual",
    "likelihood": 10,
    "reasoning": "Quick response suggests they're busy",
    "context_clues": ["Fast reply time"]
  }
]

**IMPORTANT:**
- Don't list unlikely interpretations just to fill space
- If message is clearly one tone, say so with high confidence
- For RSD triggers, emphasize most likely interpretation is benign
`;

export function shouldGenerateAlternatives(
  message: string,
  rsdTriggersDetected: number,
  baseConfidence: number
): boolean {
  // Generate alternatives if:
  // 1. RSD triggers present
  // 2. Message is ambiguous (low confidence)
  // 3. Very short message (could be misinterpreted)
  
  if (rsdTriggersDetected > 0) return true;
  if (baseConfidence < 0.7) return true;
  if (message.trim().split(/\s+/).length <= 3) return true;
  
  return false;
}
</file>

<file path="backend/supabase/functions/_shared/prompts/draft_analysis.ts">
/**
 * Draft Analysis for Message Confidence Checking
 * Extends enhanced tone analysis for draft/outgoing messages
 */

import {
  ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT,
  type ToneAnalysisResult,
} from './enhanced-tone-analysis.ts';

import {
  SITUATION_DETECTION_PROMPT,
  detectSituation,
  type SituationType,
  type SituationDetectionResult,
} from './situation-detector.ts';

import {
  ALL_TEMPLATES,
  DECLINING_TEMPLATES,
  BOUNDARY_TEMPLATES,
  INFO_DUMP_TEMPLATES,
  APOLOGIZING_TEMPLATES,
  CLARIFYING_TEMPLATES,
  type ResponseTemplate,
} from '../templates/index.ts';

export interface DraftAnalysisContext {
  draftMessage: string;
  conversationHistory?: string[];
  relationshipType?: 'boss' | 'colleague' | 'friend' | 'family' | 'client' | 'none';
  conversationTone?: string; // From previous tone analysis
  recipientInfo?: {
    name?: string;
    role?: string;
  };
}

export interface DraftAnalysisResult extends ToneAnalysisResult {
  // Extends tone analysis with draft-specific fields
  confidence_score: number; // 0-100
  appropriateness: 'excellent' | 'good' | 'okay' | 'needs_work';
  suggestions: string[];
  warnings: string[];
  strengths: string[];
  
  // NEW: Situation detection and template suggestions
  situation_detection?: SituationDetectionResult;
}

/**
 * Enhanced prompt for draft analysis - extends existing tone analysis with situation detection
 */
export const DRAFT_ANALYSIS_SYSTEM_PROMPT = `${ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT}

**ADDITIONAL CONTEXT: This is a DRAFT message being composed**

${SITUATION_DETECTION_PROMPT}

Provide additional draft-specific guidance to help the user send with confidence:

1. **Confidence Score** (0-100): How ready is this message to send?
   - 90-100: Excellent - Ready to send, no changes needed
   - 75-89: Good - Minor polish could help, but solid overall
   - 60-74: Okay - Some improvements recommended
   - Below 60: Needs Work - Consider revising before sending

2. **Appropriateness**: Overall assessment (excellent/good/okay/needs_work)

3. **Strengths** (What works well):
   - Highlight positive aspects
   - Encourage what's already good
   - Build confidence

4. **Suggestions** (Maximum 3 specific improvements):
   - Actionable changes
   - Prioritize most impactful
   - Be constructive

5. **Warnings** (Red flags to address):
   - Tone mismatches for relationship context
   - Potentially offensive/ambiguous phrasing
   - Missing key information

**Response Format (JSON):**
{
  "tone": "one of 23 categories",
  "intensity": "one of 5 levels",
  "urgency_level": "one of 4 levels",
  "intent": "3-8 word description",
  "confidence_score": 85,
  "appropriateness": "good",
  "strengths": [
    "Clear and direct communication",
    "Appropriate level of formality"
  ],
  "suggestions": [
    "Consider adding a brief greeting",
    "Could specify deadline more explicitly"
  ],
  "warnings": [],
  "context_flags": {
    "sarcasm_detected": false,
    "tone_indicator_present": false,
    "ambiguous": false
  },
  "situation_detection": {
    "situation_type": "declining",
    "confidence": 0.85,
    "reasoning": "Draft contains decline language",
    "suggested_templates": ["decline_polite", "decline_with_alternative"]
  },
  "reasoning": "Message is professional and clear. Confidence is high..."
}`;

export function generateDraftAnalysisPrompt(context: DraftAnalysisContext): string {
  let prompt = `Analyze this DRAFT message before sending:\n\n`;
  prompt += `**Draft Message:**\n"${context.draftMessage}"\n\n`;
  
  if (context.relationshipType && context.relationshipType !== 'none') {
    prompt += `**Relationship Context:** ${context.relationshipType}\n`;
  }
  
  if (context.conversationTone) {
    prompt += `**Recent Conversation Tone:** ${context.conversationTone}\n`;
  }
  
  if (context.conversationHistory && context.conversationHistory.length > 0) {
    prompt += `**Recent Messages (for context):**\n`;
    context.conversationHistory.slice(-3).forEach((msg, idx) => {
      prompt += `${idx + 1}. "${msg}"\n`;
    });
    prompt += '\n';
  }
  
  if (context.recipientInfo?.name || context.recipientInfo?.role) {
    prompt += `**Recipient:**\n`;
    if (context.recipientInfo.name) prompt += `- Name: ${context.recipientInfo.name}\n`;
    if (context.recipientInfo.role) prompt += `- Role: ${context.recipientInfo.role}\n`;
    prompt += '\n';
  }
  
  prompt += `Provide your analysis in JSON format as specified above.`;
  
  return prompt;
}

export function validateDraftAnalysis(result: any): DraftAnalysisResult {
  // Validate confidence score
  if (typeof result.confidence_score !== 'number' || 
      result.confidence_score < 0 || 
      result.confidence_score > 100) {
    throw new Error('Invalid confidence score');
  }
  
  // Validate appropriateness
  const validAppropriateness = ['excellent', 'good', 'okay', 'needs_work'];
  if (!validAppropriateness.includes(result.appropriateness)) {
    throw new Error('Invalid appropriateness level');
  }
  
  // Validate tone (inherited from ToneAnalysisResult)
  if (!result.tone || typeof result.tone !== 'string') {
    throw new Error('Invalid tone');
  }
  
  return {
    // Tone analysis fields
    tone: result.tone,
    intensity: result.intensity,
    urgency_level: result.urgency_level,
    intent: result.intent,
    confidence_score: result.confidence_score,
    reasoning: result.reasoning,
    context_flags: result.context_flags,
    
    // Draft-specific fields
    appropriateness: result.appropriateness,
    suggestions: result.suggestions || [],
    warnings: result.warnings || [],
    strengths: result.strengths || [],
    
    // NEW: Situation detection
    situation_detection: result.situation_detection,
  };
}

/**
 * Get suggested templates based on detected situation type
 */
export function getSuggestedTemplates(situationType: SituationType): ResponseTemplate[] {
  // Map situation types to template collections
  const templateMap: Record<SituationType, ResponseTemplate[]> = {
    declining: DECLINING_TEMPLATES,
    boundary_setting: BOUNDARY_TEMPLATES,
    info_dumping: INFO_DUMP_TEMPLATES,
    apologizing: APOLOGIZING_TEMPLATES,
    clarifying: CLARIFYING_TEMPLATES,
    casual_chat: [],
    work_professional: [],
    emotional_support: [],
    unknown: [],
  };
  
  return templateMap[situationType] || [];
}

/**
 * Find templates matching specific keywords from the draft
 */
export function findMatchingTemplates(
  draftMessage: string,
  maxResults: number = 5
): ResponseTemplate[] {
  const messageLower = draftMessage.toLowerCase();
  const matches: Array<{ template: ResponseTemplate; score: number }> = [];
  
  for (const template of ALL_TEMPLATES) {
    let score = 0;
    
    // Check context keywords
    for (const keyword of template.context) {
      if (messageLower.includes(keyword.toLowerCase())) {
        score += 1;
      }
    }
    
    // Boost score for neurodivergent-friendly templates
    if (template.neurodivergent_friendly) {
      score += 0.5;
    }
    
    if (score > 0) {
      matches.push({ template, score });
    }
  }
  
  // Sort by score and return top results
  matches.sort((a, b) => b.score - a.score);
  return matches.slice(0, maxResults).map(m => m.template);
}
</file>

<file path="backend/supabase/functions/_shared/prompts/enhanced-tone-analysis.ts">
/**
 * Enhanced Tone Analysis System for Neurodivergent Communication
 * Based on 2025 research: GoEmotions, Plutchik, neurodivergent communication studies
 */

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

export type IntensityLevel = 'very_low' | 'low' | 'medium' | 'high' | 'very_high';
export type UrgencyLevel = 'Low' | 'Medium' | 'High' | 'Critical';
export type EmotionalShift = 'escalating' | 'de-escalating' | 'stable';
export type NeurodivergentProfile = 'ADHD' | 'autism' | 'both' | 'social_anxiety' | 'none';

export interface ToneAnalysisResult {
  tone: string;
  intensity?: IntensityLevel;
  urgency_level: UrgencyLevel;
  intent: string;
  confidence_score: number;
  reasoning?: string;
  secondary_tones?: string[];
  emotion_blend?: EmotionCombination;
  context_flags?: ContextFlags;
  is_ambiguous?: boolean;
  alternative_interpretations?: AlternativeInterpretation[];
  response_anxiety_assessment?: ResponseAnxietyAssessment;
  figurative_language_detected?: FigurativeLanguageDetection;
}

export interface EmotionCombination {
  primary_emotion: string;
  secondary_emotion?: string;
  plutchik_blend?: string; // e.g., "love" = joy + trust
}

export interface ContextFlags {
  sarcasm_detected?: boolean;
  figurative_language?: boolean;
  tone_indicator_present?: boolean;
  ambiguous?: boolean;
  implicit_emotion?: boolean;
  emotional_shift?: EmotionalShift;
  urgency_mismatch?: boolean;
}

export interface AlternativeInterpretation {
  tone: string;
  intensity: IntensityLevel;
  probability: number;
  reasoning: string;
}

export interface ResponseAnxietyAssessment {
  risk_level: 'low' | 'medium' | 'high';
  mitigation_suggestions: string[];
}

export interface FigurativeLanguageDetection {
  has_figurative_language: boolean;
  examples: string[];
}

export interface ConversationMessage {
  message: string;
  timestamp: Date;
  tone_analysis?: ToneAnalysisResult;
  sender: 'user' | 'other';
}

export interface UserEmotionalBaseline {
  typical_tones: string[];
  average_intensity: IntensityLevel;
  neurodivergent_profile?: NeurodivergentProfile;
  preferences: string;
  baseline_indicators: string[];
}

export interface ToneDefinition {
  description: string;
  markers?: string[];
  intensity_variants?: string[];
  neurodivergent_consideration?: string;
}

// ============================================================================
// ENHANCED TONE CATEGORIES (23 TOTAL)
// ============================================================================

export const VALID_TONES = [
  'Friendly', 'Professional', 'Urgent', 'Casual', 'Formal', 'Concerned',
  'Excited', 'Neutral', 'Apologetic', 'Appreciative', 'Frustrated', 'Playful',
  'Sarcastic', 'Empathetic', 'Inquisitive', 'Assertive', 'Tentative', 'Defensive',
  'Encouraging', 'Disappointed', 'Overwhelmed', 'Relieved', 'Confused'
] as const;

export type ToneName = typeof VALID_TONES[number];

export const TONE_DEFINITIONS: Record<ToneName, ToneDefinition> = {
  Friendly: { description: "Warm, welcoming, personable" },
  Professional: { description: "Business-like, formal, respectful" },
  Urgent: { description: "Time-sensitive, pressing, immediate" },
  Casual: { description: "Relaxed, informal, conversational" },
  Formal: { description: "Structured, official, ceremonious" },
  Concerned: { description: "Worried, distressed, seeking support" },
  Excited: { description: "Enthusiastic, energetic, animated" },
  Neutral: { description: "Balanced, objective, matter-of-fact" },
  Apologetic: { description: "Expressing regret or sorry" },
  Appreciative: { description: "Showing gratitude or recognition" },
  Frustrated: { description: "Annoyed or irritated by obstacles" },
  Playful: { description: "Teasing, joking, lighthearted" },
  Sarcastic: { description: "Mocking tone with opposite meaning" },
  Empathetic: { description: "Understanding and supportive" },
  Inquisitive: { description: "Curious and seeking information" },
  Assertive: { description: "Confident and direct" },
  Tentative: { description: "Uncertain or hesitant" },
  Defensive: { description: "Protective or justifying actions" },
  Encouraging: { description: "Supportive and motivating" },
  Disappointed: { description: "Let down or dissatisfied" },
  Overwhelmed: { description: "Feeling excessive pressure or emotion" },
  Relieved: { description: "Feeling reassured or unburdened" },
  Confused: { description: "Unclear or uncertain about meaning" }
};

// ============================================================================
// TONE INDICATOR MAPPINGS
// ============================================================================

export const TONE_INDICATOR_MAP: Record<string, string> = {
  '/j': 'Playful',
  '/joking': 'Playful',
  '/srs': 'Assertive',
  '/serious': 'Assertive',
  '/s': 'Sarcastic',
  '/sarcasm': 'Sarcastic',
  '/nm': 'Neutral',
  '/notmad': 'Neutral',
  '/lh': 'Friendly',
  '/lighthearted': 'Friendly',
  '/gen': 'Inquisitive'
};

// ============================================================================
// VALIDATION FUNCTIONS
// ============================================================================

export function validateToneAnalysis(result: any): ToneAnalysisResult {
  const validIntensities: IntensityLevel[] = ['very_low', 'low', 'medium', 'high', 'very_high'];
  const validUrgencyLevels: UrgencyLevel[] = ['Low', 'Medium', 'High', 'Critical'];
  if (!result.tone || !VALID_TONES.includes(result.tone)) {
    throw new Error(`Invalid tone: ${result.tone}.`);
  }
  if (!result.urgency_level || !validUrgencyLevels.includes(result.urgency_level)) {
    throw new Error(`Invalid urgency level: ${result.urgency_level}.`);
  }
  if (!result.intent || typeof result.intent !== 'string') {
    throw new Error('Intent must be a non-empty string.');
  }
  if (
    typeof result.confidence_score !== 'number' ||
    result.confidence_score < 0 ||
    result.confidence_score > 1
  ) {
    throw new Error('Confidence score must be a number between 0 and 1.');
  }
  if (result.intensity !== undefined && !validIntensities.includes(result.intensity)) {
    throw new Error(`Invalid intensity: ${result.intensity}`);
  }
  if (result.secondary_tones) {
    if (!Array.isArray(result.secondary_tones)) {
      throw new Error('secondary_tones must be an array');
    }
    for (const tone of result.secondary_tones) {
      if (!VALID_TONES.includes(tone)) {
        throw new Error(`Invalid secondary tone: ${tone}`);
      }
    }
  }
  return {
    tone: result.tone,
    intensity: result.intensity,
    urgency_level: result.urgency_level,
    intent: result.intent,
    confidence_score: result.confidence_score,
    reasoning: result.reasoning,
    secondary_tones: result.secondary_tones,
    emotion_blend: result.emotion_blend,
    context_flags: result.context_flags,
    is_ambiguous: result.is_ambiguous,
    alternative_interpretations: result.alternative_interpretations,
    response_anxiety_assessment: result.response_anxiety_assessment,
    figurative_language_detected: result.figurative_language_detected
  };
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Extracts explicit tone indicators (e.g., /j, /s) from a message
export function extractToneIndicators(message: string): string[] {
  const toneIndicatorRegex = /\/([a-zA-Z]+)/g;
  const matches = message.match(toneIndicatorRegex) || [];
  return matches;
}

// Detects known figurative language idioms
export function detectFigurativeLanguage(message: string): { has_figurative_language: boolean, examples: string[] } {
  const idioms = ['break the ice', 'piece of cake', 'under the weather', 'spill the beans'];
  const detected: string[] = [];
  for (const idiom of idioms) {
    if (message.toLowerCase().includes(idiom)) {
      detected.push(`Idiom: "${idiom}"`);
    }
  }
  return { has_figurative_language: detected.length > 0, examples: detected };
}

// Assesses anxiety risk for neurodivergent users based on tone analysis
export function assessResponseAnxietyRisk(
  analysis: ToneAnalysisResult
): { risk_level: 'low' | 'medium' | 'high'; mitigation_suggestions: string[] } {
  let risk_level: 'low' | 'medium' | 'high' = 'low';
  const suggestions: string[] = [];
  if (analysis.urgency_level === 'High' || analysis.urgency_level === 'Critical') {
    risk_level = 'high';
    suggestions.push('Urgent tone detected. Consider asking for a specific timeline.');
  }
  if (analysis.context_flags?.sarcasm_detected) {
    risk_level = 'medium';
    suggestions.push('Sarcasm detected. Literal meaning may differ.');
  }
  return { risk_level, mitigation_suggestions: suggestions };
}

// Basic prompt generation, context optional
export function generateAnalysisPrompt(messageBody: string, conversationContext?: string[]): string {
  let prompt = `Analyze the following message:\n\n"${messageBody}"\n\n`;
  if (conversationContext && conversationContext.length > 0) {
    prompt += `**Conversation Context** (recent messages for context):\n`;
    conversationContext.forEach((msg, idx) => {
      prompt += `${idx + 1}. "${msg}"\n`;
    });
    prompt += '\n';
  }
  prompt += `Provide your analysis in JSON format as specified.`;
  return prompt;
}

// ============================================================================
// ENHANCED SYSTEM PROMPT
// ============================================================================

/**
 * Enhanced system prompt with 23 tones and neurodivergent support
 */
export const ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT = `You are an expert communication analyst specializing in understanding tone, intent, and urgency in messages, with specific expertise in neurodivergent communication patterns.

**CRITICAL PRIORITY: Neurodivergent Communication Considerations**

1. **Tone Indicator Detection** (HIGHEST PRIORITY):
   - If message contains /tone tags (e.g., "/j", "/srs", "/nm"), ALWAYS respect and cite them
   - These are explicit intent markers used by neurodivergent communities

**Enhanced Tone Categories** (23 total - choose ONE primary):

PRIMARY TONES (Original 8):
- Friendly: Warm, welcoming
- Professional: Business-like, formal
- Urgent: Time-sensitive, pressing
- Casual: Relaxed, informal
- Formal: Structured, official
- Concerned: Worried, distressed
- Excited: Enthusiastic, energetic
- Neutral: Balanced, objective

ADDITIONAL TONES (15 new):
- Apologetic: Expressing regret
- Appreciative: Showing gratitude
- Frustrated: Annoyed by obstacles
- Playful: Teasing, joking (/j)
- Sarcastic: Mocking with opposite meaning (/s)
- Empathetic: Understanding and supportive
- Inquisitive: Curious, seeking info
- Assertive: Confident and direct
- Tentative: Uncertain or hesitant
- Defensive: Protective or justifying
- Encouraging: Supportive and motivating
- Disappointed: Let down
- Overwhelmed: Excessive pressure
- Relieved: Reassured
- Confused: Unclear about meaning

**Intensity Levels** (choose ONE):
- very_low: Minimal expression
- low: Mild expression
- medium: Moderate expression
- high: Strong expression
- very_high: Extreme expression

**Urgency Levels** (choose ONE):
- Low: No time pressure
- Medium: Should be addressed soon
- High: Important and time-sensitive
- Critical: Extremely urgent

**Response Format (JSON):**
{
  "tone": "one of 23 categories",
  "intensity": "one of 5 levels",
  "urgency_level": "one of 4 levels",
  "intent": "3-8 word description",
  "confidence_score": 0.85,
  "context_flags": {
    "sarcasm_detected": false,
    "tone_indicator_present": false,
    "ambiguous": false
  },
  "reasoning": "explanation citing specific phrases"
}`;

// ============================================================================
// RSD & ALTERNATIVE INTERPRETATIONS (Feature 1 Enhancement)
// ============================================================================

import { 
  detectRSDTriggers, 
  generateRSDPromptAddition,
  type RSDTrigger 
} from './rsd-detection.ts';

import {
  shouldGenerateAlternatives,
  ALTERNATIVE_INTERPRETATIONS_PROMPT,
  type MessageInterpretation
} from './alternative-interpretations.ts';

import {
  EVIDENCE_EXTRACTION_PROMPT,
  formatEvidence,
  type Evidence
} from './evidence-extractor.ts';

// Extended result type with RSD/alternatives/evidence
export interface EnhancedToneAnalysisResult extends ToneAnalysisResult {
  rsd_triggers?: RSDTrigger[];
  message_interpretations?: MessageInterpretation[];
  evidence?: Evidence[];
}

// Enhanced system prompt that includes RSD detection
export const SMART_MESSAGE_INTERPRETER_PROMPT = `
${ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT}

${ALTERNATIVE_INTERPRETATIONS_PROMPT}

${EVIDENCE_EXTRACTION_PROMPT}

**NEURODIVERGENT-SPECIFIC ENHANCEMENTS:**

1. **RSD (Rejection Sensitive Dysphoria) Awareness:**
   - If analyzing short/ambiguous messages, explicitly address RSD concerns
   - Provide reassurance when messages are likely benign
   - Highlight lack of negative evidence when appropriate

2. **Literal Language Support:**
   - Explain idioms, metaphors, sarcasm literally
   - Flag when meaning differs from literal words
   - Provide "what they probably mean" translation

3. **Multiple Interpretations:**
   - For ambiguous messages, provide 2-3 interpretations
   - Rank by likelihood
   - Explain what context clues support each

4. **Evidence-Based:**
   - Always cite specific evidence
   - If no evidence exists, say so
   - Don't infer meaning without textual support

**Response Format:**
{
  "tone": "one of 23 categories",
  "intensity": "one of 5 levels",
  "urgency_level": "one of 4 levels",
  "intent": "3-8 word description",
  "confidence_score": 0.85,
  "context_flags": {...},
  "reasoning": "explanation",
  "rsd_triggers": [...], // If any detected
  "message_interpretations": [...], // If ambiguous
  "evidence": [...] // Always include
}
`;

// Enhanced prompt generator
export function generateSmartInterpretationPrompt(
  messageBody: string,
  conversationContext?: string[]
): string {
  // Detect RSD triggers
  const rsdTriggers = detectRSDTriggers(messageBody);
  const rsdAddition = generateRSDPromptAddition(rsdTriggers);

  let prompt = `Analyze the following message with RSD awareness:\n\n`;
  prompt += `**Message:** "${messageBody}"\n\n`;
  
  if (rsdAddition) {
    prompt += rsdAddition + '\n\n';
  }
  
  if (conversationContext && conversationContext.length > 0) {
    prompt += `**Conversation Context:**\n`;
    conversationContext.forEach((msg, idx) => {
      prompt += `${idx + 1}. "${msg}"\n`;
    });
    prompt += '\n';
  }
  
  prompt += `Provide comprehensive analysis including tone, RSD considerations, alternative interpretations (if ambiguous), and specific evidence.`;
  
  return prompt;
}

// Validation for enhanced result
export function validateEnhancedToneAnalysis(result: any): EnhancedToneAnalysisResult {
  // First validate base tone analysis
  const baseValidation = validateToneAnalysis(result);
  
  // Return with additional fields
  return {
    ...baseValidation,
    rsd_triggers: result.rsd_triggers || [],
    message_interpretations: result.message_interpretations || [],
    evidence: result.evidence || [],
  };
}

// ============================================================================
// EXPORT DEFAULTS
// ============================================================================

export default {
  VALID_TONES,
  TONE_DEFINITIONS,
  TONE_INDICATOR_MAP,
  validateToneAnalysis,
  extractToneIndicators,
  detectFigurativeLanguage,
  assessResponseAnxietyRisk,
  generateAnalysisPrompt,
  // Enhanced exports
  generateSmartInterpretationPrompt,
  validateEnhancedToneAnalysis,
};
</file>

<file path="backend/supabase/functions/_shared/prompts/evidence-extractor.ts">
/**
 * Extracts specific evidence from messages to support analysis
 * Helps neurodivergent users understand WHY the analysis is what it is
 */

export interface Evidence {
  type: 'keyword' | 'punctuation' | 'length' | 'emoji' | 'timing' | 'pattern';
  quote: string; // The actual evidence from message
  supports: string; // What it supports (e.g., "positive tone", "urgency")
  reasoning: string; // Why this is evidence
}

export const EVIDENCE_EXTRACTION_PROMPT = `
**EVIDENCE-BASED ANALYSIS:**
For your tone analysis, cite SPECIFIC evidence from the message that supports your conclusion.

Evidence types to look for:
1. **Keywords:** Specific words that indicate emotion ("love", "hate", "worried", "excited")
2. **Punctuation:** Exclamation marks (enthusiasm), question marks (inquiry), ellipsis (uncertainty)
3. **Capitalization:** ALL CAPS (strong emotion), mixed case (casual)
4. **Emoji:** 😊 (friendly), ❤️ (caring), 🙄 (sarcastic)
5. **Length:** Very short (busy/dismissive), very long (info-dumping/anxious)
6. **Tone indicators:** /j (joking), /srs (serious), /s (sarcastic)

**Format evidence as:**
[
  {
    "type": "keyword",
    "quote": "ASAP",
    "supports": "urgency",
    "reasoning": "Explicit urgency marker indicates time-sensitive need"
  },
  {
    "type": "punctuation",
    "quote": "!!!",
    "supports": "high intensity",
    "reasoning": "Multiple exclamation marks show strong emotion"
  }
]

**IMPORTANT:**
- Quote the exact text from the message
- Explain HOW it supports your analysis
- If there's NO evidence for something, say so explicitly
`;

export function formatEvidence(evidence: Evidence[]): string {
  if (evidence.length === 0) {
    return 'No specific evidence found in message';
  }

  return evidence.map(e => 
    `- "${e.quote}" (${e.type}): ${e.reasoning}`
  ).join('\n');
}
</file>

<file path="backend/supabase/functions/_shared/prompts/message-formatter.ts">
/**
 * Formats long messages into more digestible versions
 * Helps info-dumpers communicate without overwhelming
 */

export interface FormattingOptions {
  condense: boolean;      // Make it shorter
  chunk: boolean;         // Break into sections
  add_tldr: boolean;      // Add summary at top
  add_structure: boolean; // Add headers/bullets
}

export interface FormattedMessage {
  original_length: number;
  formatted_message: string;
  formatting_applied: string[];
  character_count: number;
  estimated_read_time: string; // "30 seconds", "2 minutes"
}

export const MESSAGE_FORMATTING_PROMPT = `You are helping someone format a message to be more digestible.

**Formatting Options Available:**

1. **CONDENSE** - Reduce length while keeping key points
   - Remove redundancy
   - Tighten language
   - Keep essential info only
   - Target: 50-70% of original length

2. **CHUNK** - Break into logical sections with headers
   - Add section headers
   - Group related ideas
   - Use bullet points
   - Add white space

3. **ADD_TLDR** - Add brief summary at top
   - 1-2 sentence overview
   - Clearly labeled "TL;DR:"
   - Captures main point

4. **ADD_STRUCTURE** - Improve organization
   - Add headings
   - Use numbered lists
   - Add emphasis (bold key phrases)
   - Improve flow

**Example Input:**
"I just finished reading this amazing book about productivity and it completely changed how I think about time management! The author argues that we shouldn't try to do more things but rather focus on doing the right things and one of the key concepts is something called time blocking where you schedule specific blocks of time for specific tasks instead of just having a to-do list and the research shows that this is way more effective because our brains work better when we're focused on one thing at a time rather than constantly switching between tasks which creates cognitive load and there's also this fascinating part about how successful people structure their mornings..."

**Example Output (CONDENSE + CHUNK + ADD_TLDR):**

TL;DR: Just read a game-changing book on productivity that recommends time blocking over to-do lists.

**Key Concept: Time Blocking**
- Schedule specific time blocks for specific tasks
- More effective than to-do lists
- Reduces cognitive load from task-switching

**The Science**
- Our brains work better with focused attention
- Constant task-switching drains mental energy
- Successful people structure their mornings intentionally

**Response Format:**
{
  "original_length": 450,
  "formatted_message": "...",
  "formatting_applied": ["condense", "chunk", "add_tldr"],
  "character_count": 280,
  "estimated_read_time": "45 seconds"
}`;

export function calculateReadTime(characterCount: number): string {
  // Average reading speed: 200-250 words/min = ~1000 chars/min
  const minutes = Math.ceil(characterCount / 1000);
  if (minutes < 1) return '30 seconds';
  if (minutes === 1) return '1 minute';
  return `${minutes} minutes`;
}

export function generateFormattingPrompt(
  message: string,
  options: FormattingOptions
): string {
  const selectedOptions = Object.entries(options)
    .filter(([_, enabled]) => enabled)
    .map(([option]) => option.toUpperCase())
    .join(', ');

  return `**Original Message:**
"${message}"

**Requested Formatting:**
${selectedOptions}

Apply the requested formatting and return the result.`;
}
</file>

<file path="backend/supabase/functions/_shared/prompts/rsd-detection.ts">
/**
 * RSD (Rejection Sensitive Dysphoria) Trigger Detection
 * Identifies messages that might be misinterpreted as rejection/criticism
 */

export interface RSDTrigger {
  pattern: string;
  severity: 'high' | 'medium' | 'low';
  explanation: string;
  reassurance: string;
}

export const RSD_TRIGGER_PATTERNS: RSDTrigger[] = [
  {
    pattern: 'ok',
    severity: 'high',
    explanation: 'Single-word responses like "ok" can trigger RSD as they feel dismissive',
    reassurance: 'This is likely just a quick acknowledgment, not disappointment'
  },
  {
    pattern: 'fine',
    severity: 'high',
    explanation: '"Fine" often feels passive-aggressive or dismissive',
    reassurance: 'They might genuinely mean "that works for me" without hidden meaning'
  },
  {
    pattern: 'we need to talk',
    severity: 'high',
    explanation: 'This phrase strongly triggers anxiety about impending criticism',
    reassurance: 'This doesn\'t always mean bad news - they may just want to discuss something'
  },
  {
    pattern: 'k',
    severity: 'high',
    explanation: 'Even shorter than "ok", feels very dismissive',
    reassurance: 'Some people just text quickly - not necessarily upset'
  },
  {
    pattern: 'whatever',
    severity: 'medium',
    explanation: 'Can feel like giving up or being annoyed',
    reassurance: 'Could mean "I\'m flexible" rather than "I don\'t care"'
  },
  {
    pattern: 'sure',
    severity: 'medium',
    explanation: 'Can sound sarcastic or unenthusiastic',
    reassurance: 'Often means genuine agreement, just casual phrasing'
  },
  {
    pattern: 'no worries',
    severity: 'low',
    explanation: 'Meant to be reassuring but can feel dismissive',
    reassurance: 'They\'re trying to make you feel better, not minimize your concern'
  },
];

export function detectRSDTriggers(message: string): RSDTrigger[] {
  const lowerMessage = message.toLowerCase().trim();
  const detected: RSDTrigger[] = [];

  for (const trigger of RSD_TRIGGER_PATTERNS) {
    // Match exact phrase or phrase within message
    if (lowerMessage === trigger.pattern || lowerMessage.includes(trigger.pattern)) {
      detected.push(trigger);
    }
  }

  // Additional checks for RSD patterns
  // Very short messages (1-3 words, no punctuation, no emoji)
  const words = message.trim().split(/\s+/);
  const hasWarmthIndicators = 
    message.includes('!') || 
    message.includes('😊') || 
    message.includes('❤️') ||
    message.includes('😄') ||
    message.includes('💕') ||
    message.includes('👍');

  if (words.length <= 3 && !hasWarmthIndicators) {
    detected.push({
      pattern: 'short_response',
      severity: 'medium',
      explanation: 'Very short responses without warmth indicators can feel cold',
      reassurance: 'Brief doesn\'t always mean upset - they might be busy or texting quickly'
    });
  }

  // Delayed response without explanation
  // (This would require timestamp comparison - implement in Edge Function)

  return detected;
}

export function generateRSDPromptAddition(triggers: RSDTrigger[]): string {
  if (triggers.length === 0) return '';

  return `
**RSD ALERT:** This message contains potential RSD triggers:
${triggers.map(t => `- "${t.pattern}" (${t.severity} severity): ${t.explanation}`).join('\n')}

When analyzing, consider:
1. Is the message genuinely negative or just brief/casual?
2. Are there hidden cues suggesting actual criticism?
3. What evidence supports a negative vs neutral interpretation?

Provide reassurance if this is likely not rejection/criticism.
`;
}
</file>

<file path="backend/supabase/functions/_shared/prompts/situation-detector.ts">
/**
 * Detects what type of response the user is trying to write
 * So we can suggest appropriate templates
 */

export type SituationType = 
  | 'declining'          // Saying no to something
  | 'boundary_setting'   // Setting or enforcing a boundary
  | 'info_dumping'       // Sharing enthusiasm/info
  | 'apologizing'        // Making an apology
  | 'clarifying'         // Asking for clarification
  | 'casual_chat'        // Just chatting
  | 'work_professional'  // Professional communication
  | 'emotional_support'  // Providing/seeking support
  | 'unknown';           // Can't determine

export interface SituationDetectionResult {
  situation_type: SituationType;
  confidence: number; // 0.0-1.0
  reasoning: string;
  suggested_templates: string[]; // Template IDs that might help
}

export const SITUATION_DETECTION_PROMPT = `Analyze the draft message and determine what type of response the user is trying to write.

**Situation Types:**

1. **declining** - User is saying no, turning down an invitation, or refusing a request
   - Keywords: "can't", "unable to", "won't be able", "have to pass", "sorry but"
   - Context: Following an invitation or request

2. **boundary_setting** - User is setting or enforcing a personal boundary
   - Keywords: "not comfortable", "need", "prefer", "don't", "stop"
   - Context: Asserting limits or needs

3. **info_dumping** - User is enthusiastically sharing detailed information
   - Keywords: "excited", "fascinating", "amazing", "let me explain"
   - Context: Long, detailed message about a topic they care about
   - Length: Usually longer than average

4. **apologizing** - User is making an apology
   - Keywords: "sorry", "apologize", "my fault", "my bad", "messed up"
   - Context: Acknowledging a mistake

5. **clarifying** - User is asking for clarification or checking understanding
   - Keywords: "confused", "not sure", "what do you mean", "can you explain"
   - Context: Seeking clarity

6. **casual_chat** - Just friendly conversation
   - Keywords: "hey", "how are you", "what's up"
   - Context: Social interaction

7. **work_professional** - Professional/business communication
   - Keywords: "regarding", "attached", "deadline", "meeting", "project"
   - Context: Work-related

8. **emotional_support** - Providing or seeking emotional support
   - Keywords: "sorry to hear", "here for you", "feeling", "struggling"
   - Context: Emotional/supportive conversation

**Response Format:**
{
  "situation_type": "declining",
  "confidence": 0.85,
  "reasoning": "Draft contains 'I won't be able to' and 'thanks for the invite', indicating a polite decline",
  "suggested_templates": ["decline_polite", "decline_with_alternative"]
}

**Instructions:**
- Consider both the draft content AND the context of what they're replying to
- Look for explicit keywords but also implicit patterns
- If multiple situations apply, choose the primary one
- Only suggest templates that actually match the situation
- Be honest about low confidence`;

export function detectSituation(
  draftMessage: string,
  conversationContext?: string[]
): string {
  let prompt = `**Draft Message:**\n"${draftMessage}"\n\n`;
  
  if (conversationContext && conversationContext.length > 0) {
    prompt += `**Replying To:**\n`;
    conversationContext.slice(-2).forEach((msg, idx) => {
      prompt += `${idx + 1}. "${msg}"\n`;
    });
    prompt += '\n';
  }
  
  prompt += `Analyze the situation type and suggest appropriate templates.`;
  
  return prompt;
}
</file>

<file path="backend/supabase/functions/_shared/prompts/tone-analysis-v1.backup.ts">
/**
 * Tone Analysis Prompts for AI Message Analysis
 */

export interface ToneAnalysisResult {
  tone: string;
  urgency_level: string;
  intent: string;
  confidence_score: number;
  reasoning?: string;
}

/**
 * System prompt for tone analysis
 * Defines the AI's role and the categories it should use
 */
export const TONE_ANALYSIS_SYSTEM_PROMPT = `You are an expert communication analyst specializing in understanding tone, intent, and urgency in messages. Your task is to analyze messages and provide structured insights to help neurodivergent individuals better understand communication nuances.

**Tone Categories** (choose ONE that best fits):
- Friendly: Warm, welcoming, personable (e.g., "Hey! How are you?", "Nice to hear from you")
- Professional: Business-like, formal, respectful (e.g., "Please review the attached", "Thank you for your time")
- Urgent: Time-sensitive, pressing, needs immediate attention (e.g., "ASAP", "urgent", "right now")
- Casual: Relaxed, informal, conversational (e.g., "hey", "what's up", "cool")
- Formal: Structured, official, ceremonious (e.g., "Dear Sir/Madam", "I am writing to inform")
- Concerned: Worried, distressed, seeking support (e.g., "I'm worried", "upset", "need help", "stressed")
- Excited: Enthusiastic, energetic, animated (e.g., "Amazing!", "Can't wait!", "So excited!")
- Neutral: Balanced, objective, matter-of-fact (e.g., "ok", "noted", "received")

**Critical Analysis Rules:**
1. **Emotion Detection**: Prioritize emotional keywords:
   - Negative emotions ("upset", "worried", "stressed", "sad", "angry") → "Concerned"
   - Positive emotions ("excited", "happy", "great", "amazing") → "Excited"
   - Neutral/minimal emotion → "Casual" or "Neutral"

2. **Short Messages**: For very brief messages (1-3 words):
   - Check for emotional keywords first
   - If greeting only ("hey", "hi") → "Friendly"
   - If response only ("ok", "yup", "got it") → "Neutral"
   - If question ("what's up", "how are you") → "Casual"

3. **Urgency Markers**: Look for time pressure indicators:
   - Explicit: "ASAP", "urgent", "immediately", "right now" → High/Critical
   - Implicit: "soon", "when you can", "later" → Medium
   - None: → Low

4. **Context Matters**: If conversation context provided, use it to refine tone

**Urgency Levels** (choose ONE):
- Low: No time pressure, can be addressed at convenience
- Medium: Should be addressed soon, but not critical
- High: Important and time-sensitive, needs prompt attention
- Critical: Extremely urgent, requires immediate action

**Intent** (describe the primary purpose in 3-8 words):
Examples: "greeting", "expressing distress", "asking question", "sharing update", "requesting help", "confirming", "expressing excitement"

**Response Format:**
Return your analysis as a JSON object with these fields:
{
  "tone": "one of the tone categories",
  "urgency_level": "one of the urgency levels",
  "intent": "brief description of message purpose",
  "confidence_score": 0.85,
  "reasoning": "1-2 sentence explanation focusing on key indicators"
}`;

/**
 * Generate user prompt for analyzing a message
 */
export function generateAnalysisPrompt(
  messageBody: string,
  conversationContext?: string[]
): string {
  let prompt = `Analyze the following message:\n\n"${messageBody}"\n\n`;
  
  if (conversationContext && conversationContext.length > 0) {
    prompt += `**Conversation Context** (recent messages for context):\n`;
    conversationContext.forEach((msg, idx) => {
      prompt += `${idx + 1}. "${msg}"\n`;
    });
    prompt += '\n';
  }
  
  prompt += `Provide your analysis in JSON format as specified.`;
  
  return prompt;
}

/**
 * Validate the tone analysis result
 */
export function validateToneAnalysis(result: any): ToneAnalysisResult {
  const validTones = [
    'Friendly',
    'Professional',
    'Urgent',
    'Casual',
    'Formal',
    'Concerned',
    'Excited',
    'Neutral',
  ];
  
  const validUrgencyLevels = ['Low', 'Medium', 'High', 'Critical'];
  
  if (!result.tone || !validTones.includes(result.tone)) {
    throw new Error(`Invalid tone: ${result.tone}. Must be one of: ${validTones.join(', ')}`);
  }
  
  if (!result.urgency_level || !validUrgencyLevels.includes(result.urgency_level)) {
    throw new Error(
      `Invalid urgency level: ${result.urgency_level}. Must be one of: ${validUrgencyLevels.join(', ')}`
    );
  }
  
  if (!result.intent || typeof result.intent !== 'string') {
    throw new Error('Intent must be a non-empty string');
  }
  
  if (
    typeof result.confidence_score !== 'number' ||
    result.confidence_score < 0 ||
    result.confidence_score > 1
  ) {
    throw new Error('Confidence score must be a number between 0 and 1');
  }
  
  return {
    tone: result.tone,
    urgency_level: result.urgency_level,
    intent: result.intent,
    confidence_score: result.confidence_score,
    reasoning: result.reasoning,
  };
}
</file>

<file path="backend/supabase/functions/_shared/prompts/tone-analysis.ts">
/**
 * Tone Analysis Prompts for AI Message Analysis
 */

export interface ToneAnalysisResult {
  tone: string;
  urgency_level: string;
  intent: string;
  confidence_score: number;
  reasoning?: string;
}

/**
 * System prompt for tone analysis
 * Defines the AI's role and the categories it should use
 */
export const TONE_ANALYSIS_SYSTEM_PROMPT = `You are an expert communication analyst specializing in understanding tone, intent, and urgency in messages. Your task is to analyze messages and provide structured insights to help neurodivergent individuals better understand communication nuances.

**Tone Categories** (choose ONE that best fits):
- Friendly: Warm, welcoming, personable (e.g., "Hey! How are you?", "Nice to hear from you")
- Professional: Business-like, formal, respectful (e.g., "Please review the attached", "Thank you for your time")
- Urgent: Time-sensitive, pressing, needs immediate attention (e.g., "ASAP", "urgent", "right now")
- Casual: Relaxed, informal, conversational (e.g., "hey", "what's up", "cool")
- Formal: Structured, official, ceremonious (e.g., "Dear Sir/Madam", "I am writing to inform")
- Concerned: Worried, distressed, seeking support (e.g., "I'm worried", "upset", "need help", "stressed")
- Excited: Enthusiastic, energetic, animated (e.g., "Amazing!", "Can't wait!", "So excited!")
- Neutral: Balanced, objective, matter-of-fact (e.g., "ok", "noted", "received")

**Critical Analysis Rules:**
1. **Emotion Detection**: Prioritize emotional keywords:
   - Negative emotions ("upset", "worried", "stressed", "sad", "angry") → "Concerned"
   - Positive emotions ("excited", "happy", "great", "amazing") → "Excited"
   - Neutral/minimal emotion → "Casual" or "Neutral"

2. **Short Messages**: For very brief messages (1-3 words):
   - Check for emotional keywords first
   - If greeting only ("hey", "hi") → "Friendly"
   - If response only ("ok", "yup", "got it") → "Neutral"
   - If question ("what's up", "how are you") → "Casual"

3. **Urgency Markers**: Look for time pressure indicators:
   - Explicit: "ASAP", "urgent", "immediately", "right now" → High/Critical
   - Implicit: "soon", "when you can", "later" → Medium
   - None: → Low

4. **Context Matters**: If conversation context provided, use it to refine tone

**Urgency Levels** (choose ONE):
- Low: No time pressure, can be addressed at convenience
- Medium: Should be addressed soon, but not critical
- High: Important and time-sensitive, needs prompt attention
- Critical: Extremely urgent, requires immediate action

**Intent** (describe the primary purpose in 3-8 words):
Examples: "greeting", "expressing distress", "asking question", "sharing update", "requesting help", "confirming", "expressing excitement"

**Response Format:**
Return your analysis as a JSON object with these fields:
{
  "tone": "one of the tone categories",
  "urgency_level": "one of the urgency levels",
  "intent": "brief description of message purpose",
  "confidence_score": 0.85,
  "reasoning": "1-2 sentence explanation focusing on key indicators"
}`;

/**
 * Generate user prompt for analyzing a message
 */
export function generateAnalysisPrompt(
  messageBody: string,
  conversationContext?: string[]
): string {
  let prompt = `Analyze the following message:\n\n"${messageBody}"\n\n`;
  
  if (conversationContext && conversationContext.length > 0) {
    prompt += `**Conversation Context** (recent messages for context):\n`;
    conversationContext.forEach((msg, idx) => {
      prompt += `${idx + 1}. "${msg}"\n`;
    });
    prompt += '\n';
  }
  
  prompt += `Provide your analysis in JSON format as specified.`;
  
  return prompt;
}

/**
 * Validate the tone analysis result
 */
export function validateToneAnalysis(result: any): ToneAnalysisResult {
  const validTones = [
    'Friendly',
    'Professional',
    'Urgent',
    'Casual',
    'Formal',
    'Concerned',
    'Excited',
    'Neutral',
  ];
  
  const validUrgencyLevels = ['Low', 'Medium', 'High', 'Critical'];
  
  if (!result.tone || !validTones.includes(result.tone)) {
    throw new Error(`Invalid tone: ${result.tone}. Must be one of: ${validTones.join(', ')}`);
  }
  
  if (!result.urgency_level || !validUrgencyLevels.includes(result.urgency_level)) {
    throw new Error(
      `Invalid urgency level: ${result.urgency_level}. Must be one of: ${validUrgencyLevels.join(', ')}`
    );
  }
  
  if (!result.intent || typeof result.intent !== 'string') {
    throw new Error('Intent must be a non-empty string');
  }
  
  if (
    typeof result.confidence_score !== 'number' ||
    result.confidence_score < 0 ||
    result.confidence_score > 1
  ) {
    throw new Error('Confidence score must be a number between 0 and 1');
  }
  
  return {
    tone: result.tone,
    urgency_level: result.urgency_level,
    intent: result.intent,
    confidence_score: result.confidence_score,
    reasoning: result.reasoning,
  };
}
</file>

<file path="backend/supabase/functions/_shared/rag/embedding-generator.ts">
/**
 * Generates OpenAI embeddings for semantic search
 */

export interface EmbeddingResult {
  embedding: number[];
  model: string;
  tokens_used: number;
}

export class EmbeddingGenerator {
  private apiKey: string;

  constructor() {
    const key = Deno.env.get('OPENAI_API_KEY');
    if (!key) {
      throw new Error('OPENAI_API_KEY not found in environment');
    }
    this.apiKey = key;
  }

  /**
   * Generate embedding for a single text
   */
  async generateEmbedding(text: string): Promise<EmbeddingResult> {
    try {
      const response = await fetch('https://api.openai.com/v1/embeddings', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          input: text,
          model: 'text-embedding-ada-002',
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`OpenAI API error: ${response.statusText} - ${errorText}`);
      }

      const data = await response.json();
      
      return {
        embedding: data.data[0].embedding,
        model: data.model,
        tokens_used: data.usage.total_tokens,
      };
    } catch (error) {
      console.error('Error generating embedding:', error);
      throw error;
    }
  }

  /**
   * Generate embeddings for multiple texts (batch)
   */
  async generateEmbeddings(texts: string[]): Promise<EmbeddingResult[]> {
    // OpenAI allows batch embeddings
    try {
      const response = await fetch('https://api.openai.com/v1/embeddings', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          input: texts,
          model: 'text-embedding-ada-002',
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`OpenAI API error: ${response.statusText} - ${errorText}`);
      }

      const data = await response.json();
      
      return data.data.map((item: any) => ({
        embedding: item.embedding,
        model: data.model,
        tokens_used: Math.ceil(data.usage.total_tokens / texts.length),
      }));
    } catch (error) {
      console.error('Error generating embeddings:', error);
      throw error;
    }
  }

  /**
   * Preprocess text for embedding
   * Removes noise and normalizes
   */
  preprocessText(text: string): string {
    // Remove excessive whitespace
    let processed = text.replace(/\s+/g, ' ').trim();
    
    // Remove URLs (they don't add semantic meaning)
    processed = processed.replace(/https?:\/\/\S+/g, '[link]');
    
    // Remove emails
    processed = processed.replace(/[\w.+-]+@[\w-]+\.[\w.-]+/g, '[email]');
    
    // Truncate to max tokens (8191 for ada-002)
    // Rough estimate: 1 token ≈ 4 characters
    const maxChars = 8191 * 4;
    if (processed.length > maxChars) {
      processed = processed.substring(0, maxChars);
    }
    
    return processed;
  }

  /**
   * Check if text is suitable for embedding
   */
  isValidText(text: string): boolean {
    if (!text || text.trim().length === 0) return false;
    if (text.length < 10) return false; // Too short
    if (text.length > 50000) return false; // Too long
    return true;
  }
}
</file>

<file path="backend/supabase/functions/_shared/rag/relationship-builder.ts">
/**
 * Builds and maintains relationship profiles
 */

import { OpenAIClient } from '../openai-client.ts';

export interface RelationshipProfile {
  participant_name: string;
  relationship_type: string;
  conversation_summary: string;
  safe_topics: string[];
  topics_to_avoid: string[];
  communication_style: string;
}

export const RELATIONSHIP_BUILDER_PROMPT = `Analyze this conversation history and create a relationship profile.

**Your task:**
1. Summarize the relationship in 2-3 sentences
2. Identify the relationship type (boss, colleague, friend, family, client, other)
3. Extract safe topics (topics that led to positive engagement)
4. Identify topics to avoid (if any caused tension)
5. Describe their communication style

**Relationship Types:**
- boss: Manager or supervisor
- colleague: Coworker or professional peer
- friend: Personal friend
- family: Family member
- client: Customer or client
- other: Other relationship type

**Response Format (JSON):**
{
  "relationship_type": "colleague",
  "conversation_summary": "Sarah is a coworker from the marketing team. You collaborate on project launches and she often asks for design feedback. Communication is professional but friendly.",
  "safe_topics": ["project launches", "design feedback", "team events"],
  "topics_to_avoid": [],
  "communication_style": "Direct and efficient. Prefers email for detailed requests, chat for quick questions. Usually responds within an hour during work hours."
}

**Instructions:**
- Be specific and helpful
- Include timing patterns if visible
- Note communication preferences
- Identify at least 3 safe topics
- Only list topics to avoid if there's clear evidence`;

export class RelationshipBuilder {
  private openai: OpenAIClient;

  constructor() {
    this.openai = new OpenAIClient();
  }

  /**
   * Build relationship profile from conversation history
   */
  async buildProfile(
    conversationHistory: Array<{ body: string; sender: string; created_at: number }>,
    participantName: string
  ): Promise<RelationshipProfile> {
    // Take last 50 messages for context
    const recentMessages = conversationHistory.slice(-50);
    
    if (recentMessages.length === 0) {
      throw new Error('No messages to analyze');
    }

    let userPrompt = `**Conversation History with ${participantName}:**\n\n`;
    recentMessages.forEach((msg, idx) => {
      const sender = msg.sender === 'self' ? 'You' : participantName;
      userPrompt += `${idx + 1}. [${sender}]: ${msg.body}\n`;
    });
    
    userPrompt += '\n\nAnalyze this conversation and create a relationship profile in JSON format.';

    console.log(`Building profile for ${participantName} (${recentMessages.length} messages)`);

    const result = await this.openai.sendMessageForJSON<RelationshipProfile>(
      userPrompt,
      RELATIONSHIP_BUILDER_PROMPT,
      { temperature: 0.3, max_tokens: 800 }
    );

    // Validate result
    if (!result.relationship_type || !result.conversation_summary) {
      throw new Error('Invalid relationship profile generated');
    }

    return {
      participant_name: participantName,
      relationship_type: result.relationship_type,
      conversation_summary: result.conversation_summary,
      safe_topics: result.safe_topics || [],
      topics_to_avoid: result.topics_to_avoid || [],
      communication_style: result.communication_style || 'Unknown',
    };
  }

  /**
   * Extract key topics from conversation
   */
  async extractTopics(messages: string[]): Promise<string[]> {
    if (messages.length === 0) return [];

    const prompt = `Extract 3-5 main topics discussed in these messages:\n\n`;
    const recentMessages = messages.slice(-20);
    recentMessages.forEach((msg, idx) => {
      prompt += `${idx + 1}. ${msg}\n`;
    });
    
    prompt += '\n\nReturn ONLY a JSON array of topics: ["topic1", "topic2", "topic3"]';

    try {
      const result = await this.openai.sendMessage(prompt, {
        temperature: 0.3,
        max_tokens: 200,
      });

      const topics = JSON.parse(result);
      if (Array.isArray(topics)) {
        return topics.filter(t => typeof t === 'string');
      }
      return [];
    } catch (error) {
      console.error('Error extracting topics:', error);
      return [];
    }
  }

  /**
   * Update profile with new conversation data
   */
  async updateProfile(
    existingProfile: RelationshipProfile,
    recentMessages: Array<{ body: string; sender: string }>,
    participantName: string
  ): Promise<Partial<RelationshipProfile>> {
    const prompt = `**Existing Profile for ${participantName}:**
${JSON.stringify(existingProfile, null, 2)}

**Recent Messages:**
${recentMessages.map((m, i) => `${i + 1}. [${m.sender}]: ${m.body}`).join('\n')}

Update the profile based on these new messages. Return ONLY the fields that have changed.
If nothing needs updating, return an empty object {}.

Response format (JSON):
{
  "conversation_summary": "updated summary if needed",
  "safe_topics": ["new topics to add"],
  "communication_style": "updated style if needed"
}`;

    try {
      const result = await this.openai.sendMessageForJSON(
        prompt,
        'You are updating a relationship profile. Only include fields that have changed.',
        { temperature: 0.3, max_tokens: 500 }
      );

      return result;
    } catch (error) {
      console.error('Error updating profile:', error);
      return {};
    }
  }

  /**
   * Calculate typical response time from conversation history
   */
  calculateResponseTime(
    messages: Array<{ sender: string; created_at: number }>
  ): number | null {
    const responseTimes: number[] = [];
    
    for (let i = 1; i < messages.length; i++) {
      const prev = messages[i - 1];
      const curr = messages[i];
      
      // Check if this is a response (different sender)
      if (prev.sender !== curr.sender && curr.sender !== 'self') {
        const timeDiff = curr.created_at - prev.created_at;
        // Only count responses within 24 hours
        if (timeDiff > 0 && timeDiff < 86400) {
          responseTimes.push(timeDiff);
        }
      }
    }

    if (responseTimes.length === 0) return null;

    // Return median response time
    responseTimes.sort((a, b) => a - b);
    const mid = Math.floor(responseTimes.length / 2);
    return responseTimes[mid];
  }
}
</file>

<file path="backend/supabase/functions/_shared/rag/vector-search.ts">
/**
 * Vector search functionality using pgvector
 */

import type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { EmbeddingGenerator } from './embedding-generator.ts';

export interface SearchResult {
  message_id: string;
  similarity: number;
  message_body: string;
  created_at: string;
}

export interface SearchOptions {
  limit?: number;
  similarity_threshold?: number; // 0.0-1.0
  conversation_id?: string;
}

export class VectorSearch {
  private embeddingGenerator: EmbeddingGenerator;

  constructor() {
    this.embeddingGenerator = new EmbeddingGenerator();
  }

  /**
   * Search for similar messages using semantic search
   */
  async searchMessages(
    query: string,
    userId: string,
    supabase: SupabaseClient,
    options: SearchOptions = {}
  ): Promise<SearchResult[]> {
    const {
      limit = 5,
      similarity_threshold = 0.7,
      conversation_id,
    } = options;

    console.log(`Searching for: "${query}" (threshold: ${similarity_threshold})`);

    // Generate embedding for query
    const preprocessed = this.embeddingGenerator.preprocessText(query);
    const { embedding } = await this.embeddingGenerator.generateEmbedding(preprocessed);

    console.log(`Generated embedding (${embedding.length} dimensions)`);

    // Search using RPC function
    const { data, error } = await supabase.rpc('search_similar_messages', {
      p_user_id: userId,
      p_query_embedding: embedding,
      p_limit: limit * 2, // Get more, filter by threshold
      p_conversation_id: conversation_id || null,
    });

    if (error) {
      console.error('Error searching messages:', error);
      throw error;
    }

    console.log(`Found ${data?.length || 0} results`);

    // Filter by similarity threshold
    const filtered = (data || [])
      .filter((result: SearchResult) => result.similarity >= similarity_threshold)
      .slice(0, limit);

    console.log(`Filtered to ${filtered.length} results above threshold`);

    return filtered;
  }

  /**
   * Find related conversations based on topic
   */
  async findRelatedConversations(
    topic: string,
    userId: string,
    supabase: SupabaseClient
  ): Promise<string[]> {
    const results = await this.searchMessages(topic, userId, supabase, {
      limit: 10,
      similarity_threshold: 0.75,
    });

    // Extract unique conversation IDs
    const conversationIds = new Set<string>();
    for (const result of results) {
      const { data } = await supabase
        .from('messages')
        .select('conversation_id')
        .eq('id', result.message_id)
        .single();
      
      if (data) {
        conversationIds.add(data.conversation_id);
      }
    }

    return Array.from(conversationIds);
  }

  /**
   * Store message embedding
   */
  async storeMessageEmbedding(
    messageId: string,
    messageBody: string,
    userId: string,
    supabase: SupabaseClient
  ): Promise<boolean> {
    try {
      // Check if embedding already exists
      const { data: existing } = await supabase
        .from('message_embeddings')
        .select('id')
        .eq('message_id', messageId)
        .single();

      if (existing) {
        console.log(`Embedding already exists for message ${messageId}`);
        return true;
      }

      // Generate embedding
      const preprocessed = this.embeddingGenerator.preprocessText(messageBody);
      if (!this.embeddingGenerator.isValidText(preprocessed)) {
        console.log(`Message ${messageId} not suitable for embedding`);
        return false;
      }

      const { embedding } = await this.embeddingGenerator.generateEmbedding(preprocessed);

      // Store in database
      const { error } = await supabase
        .from('message_embeddings')
        .insert({
          message_id: messageId,
          user_id: userId,
          embedding: embedding,
          message_length: messageBody.length,
        });

      if (error) {
        console.error('Error storing embedding:', error);
        return false;
      }

      console.log(`Stored embedding for message ${messageId}`);
      return true;
    } catch (error) {
      console.error('Error in storeMessageEmbedding:', error);
      return false;
    }
  }
}
</file>

<file path="backend/supabase/functions/_shared/templates/apologizing-templates.ts">
/**
 * Templates for appropriate apologies
 * Helps avoid over-apologizing (common in neurodivergent folks)
 */

import type { ResponseTemplate } from './declining-templates.ts';

export const APOLOGIZING_TEMPLATES: ResponseTemplate[] = [
  {
    id: 'apology_genuine',
    name: 'Genuine Apology',
    situation: 'When you actually did something wrong',
    template: "I'm sorry for {what_you_did}. I understand that {impact}. Going forward, I'll {corrective_action}.",
    tone: 'apologetic',
    context: ['mistake', 'wrong', 'messed up'],
    neurodivergent_friendly: true,
    customizable_fields: ['what_you_did', 'impact', 'corrective_action'],
  },
  {
    id: 'apology_no_need',
    name: 'Replace Unnecessary Apology',
    situation: 'When you\'re apologizing out of habit',
    template: "Thank you for {what_they_did}. I appreciate {specific_thing}.",
    tone: 'polite',
    context: ['sorry for', 'apologies for'],
    neurodivergent_friendly: true,
    customizable_fields: ['what_they_did', 'specific_thing'],
  },
  {
    id: 'apology_delay',
    name: 'Apology for Delay',
    situation: 'When you took longer than expected',
    template: "Thanks for your patience! Here's {what_they_asked_for}.",
    tone: 'casual',
    context: ['late', 'delay', 'took long'],
    neurodivergent_friendly: true,
    customizable_fields: ['what_they_asked_for'],
  },
];
</file>

<file path="backend/supabase/functions/_shared/templates/boundary-templates.ts">
/**
 * Templates for setting and maintaining boundaries
 * Critical for neurodivergent folks who struggle with people-pleasing
 */

import type { ResponseTemplate } from './declining-templates.ts';

export const BOUNDARY_TEMPLATES: ResponseTemplate[] = [
  {
    id: 'boundary_time',
    name: 'Time Boundary',
    situation: 'When someone expects you to be available 24/7',
    template: "I'm available to discuss this during {your_hours}. Can we schedule a time within those hours?",
    tone: 'direct',
    context: ['urgent', 'right now', 'immediately'],
    neurodivergent_friendly: true,
    customizable_fields: ['your_hours'],
  },
  {
    id: 'boundary_communication',
    name: 'Communication Preference',
    situation: 'When someone uses a communication method that doesn\'t work for you',
    template: "I process information better through {preferred_method}. Could we switch to that for this conversation?",
    tone: 'direct',
    context: ['call', 'video', 'meeting', 'voice'],
    neurodivergent_friendly: true,
    customizable_fields: ['preferred_method'],
  },
  {
    id: 'boundary_topic',
    name: 'Topic Boundary',
    situation: 'When someone brings up something you don\'t want to discuss',
    template: "I'm not comfortable discussing {topic}. Let's talk about something else.",
    tone: 'direct',
    context: ['personal', 'private', 'politics', 'religion'],
    neurodivergent_friendly: true,
    customizable_fields: ['topic'],
  },
  {
    id: 'boundary_physical',
    name: 'Physical Boundary',
    situation: 'When someone violates your physical space',
    template: "I need a bit more personal space. Could you {specific_request}?",
    tone: 'direct',
    context: ['hug', 'touch', 'close'],
    neurodivergent_friendly: true,
    customizable_fields: ['specific_request'],
  },
  {
    id: 'boundary_reassert',
    name: 'Re-Assert Boundary',
    situation: 'When someone ignores a boundary you\'ve already set',
    template: "I mentioned before that {previous_boundary}. I need you to respect that.",
    tone: 'direct',
    context: ['again', 'still', 'keep'],
    neurodivergent_friendly: true,
    customizable_fields: ['previous_boundary'],
  },
  {
    id: 'boundary_emotional',
    name: 'Emotional Labor Boundary',
    situation: 'When someone expects you to manage their emotions',
    template: "I care about you, but I'm not in a place to provide emotional support right now. Have you considered {alternative_resource}?",
    tone: 'polite',
    context: ['vent', 'support', 'help', 'listen'],
    neurodivergent_friendly: true,
    customizable_fields: ['alternative_resource'],
  },
  {
    id: 'boundary_work_life',
    name: 'Work-Life Boundary',
    situation: 'When work contacts you outside work hours',
    template: "I'm off the clock right now. I'll address this during my next work day ({day}). If it's truly urgent, please contact {emergency_contact}.",
    tone: 'direct',
    context: ['weekend', 'evening', 'vacation', 'off'],
    neurodivergent_friendly: true,
    customizable_fields: ['day', 'emergency_contact'],
  },
  {
    id: 'boundary_advice',
    name: 'Unwanted Advice Boundary',
    situation: 'When someone gives advice you didn\'t ask for',
    template: "I appreciate your concern, but I'm not looking for advice right now. I just needed to {what_you_need}.",
    tone: 'polite',
    context: ['should', 'you need to', 'try this'],
    neurodivergent_friendly: true,
    customizable_fields: ['what_you_need'],
  },
];
</file>

<file path="backend/supabase/functions/_shared/templates/clarifying-templates.ts">
/**
 * Templates for asking for clarification
 * Helps when you need things explained more clearly
 */

import type { ResponseTemplate } from './declining-templates.ts';

export const CLARIFYING_TEMPLATES: ResponseTemplate[] = [
  {
    id: 'clarify_misunderstand',
    name: 'Admit Confusion',
    situation: 'When you don\'t understand something',
    template: "I want to make sure I understand correctly. Are you saying {your_interpretation}?",
    tone: 'direct',
    context: ['confused', 'unclear', 'not sure'],
    neurodivergent_friendly: true,
    customizable_fields: ['your_interpretation'],
  },
  {
    id: 'clarify_literal',
    name: 'Ask for Literal Meaning',
    situation: 'When you need things stated directly',
    template: "I'm having trouble reading between the lines. Could you tell me directly what you need from me?",
    tone: 'direct',
    context: ['ambiguous', 'vague', 'hint'],
    neurodivergent_friendly: true,
  },
  {
    id: 'clarify_instructions',
    name: 'Request Specific Instructions',
    situation: 'When instructions are too vague',
    template: "Could you break that down into specific steps? It helps me to have a clear list of what to do.",
    tone: 'polite',
    context: ['task', 'project', 'assignment'],
    neurodivergent_friendly: true,
  },
  {
    id: 'clarify_tone',
    name: 'Check Tone',
    situation: 'When you\'re not sure if they\'re upset',
    template: "I can't tell if you're upset or just being direct. Could you let me know where we stand?",
    tone: 'direct',
    context: ['ok', 'fine', 'whatever'],
    neurodivergent_friendly: true,
  },
];
</file>

<file path="backend/supabase/functions/_shared/templates/declining-templates.ts">
/**
 * Templates for declining invitations, requests, or commitments
 * Helps people-pleasers and those who struggle to say no
 */

export interface ResponseTemplate {
  id: string;
  name: string;
  situation: string; // When to use this
  template: string; // The actual text
  tone: 'polite' | 'casual' | 'direct' | 'apologetic';
  context: string[]; // Keywords that trigger this template
  neurodivergent_friendly: boolean;
  customizable_fields?: string[]; // Fields user can fill in
}

export const DECLINING_TEMPLATES: ResponseTemplate[] = [
  {
    id: 'decline_polite',
    name: 'Polite Decline',
    situation: 'When you need to say no professionally',
    template: "Thank you for thinking of me! Unfortunately, I won't be able to {activity} {timeframe}. I appreciate your understanding.",
    tone: 'polite',
    context: ['can you', 'would you', 'invitation', 'request'],
    neurodivergent_friendly: true,
    customizable_fields: ['activity', 'timeframe'],
  },
  {
    id: 'decline_no_explanation',
    name: 'Direct Decline (No Explanation Required)',
    situation: 'When you don\'t owe an explanation',
    template: "Thanks for the invite, but I'm not able to join this time.",
    tone: 'direct',
    context: ['party', 'event', 'hangout', 'gathering'],
    neurodivergent_friendly: true,
  },
  {
    id: 'decline_with_alternative',
    name: 'Decline with Counter-Offer',
    situation: 'When you want to participate but need different terms',
    template: "I can't {original_request}, but I could {alternative}. Would that work?",
    tone: 'casual',
    context: ['meeting', 'call', 'hangout'],
    neurodivergent_friendly: true,
    customizable_fields: ['original_request', 'alternative'],
  },
  {
    id: 'decline_overcommitted',
    name: 'Already Overcommitted',
    situation: 'When your schedule is full',
    template: "I'd love to, but I'm already stretched thin this {period}. Can we revisit this {later_time}?",
    tone: 'polite',
    context: ['project', 'commitment', 'volunteer'],
    neurodivergent_friendly: true,
    customizable_fields: ['period', 'later_time'],
  },
  {
    id: 'decline_capacity',
    name: 'At Capacity (Mental Health)',
    situation: 'When you need to protect your energy',
    template: "I really appreciate you thinking of me, but I need to be mindful of my capacity right now. I'll have to pass on this one.",
    tone: 'apologetic',
    context: ['favor', 'help', 'support'],
    neurodivergent_friendly: true,
  },
  {
    id: 'decline_not_interested',
    name: 'Not Interested (Honest)',
    situation: 'When something just isn\'t for you',
    template: "Thanks for thinking of me, but {activity} isn't really my thing. Hope you find someone who's a better fit!",
    tone: 'casual',
    context: ['invitation', 'hobby', 'activity'],
    neurodivergent_friendly: true,
    customizable_fields: ['activity'],
  },
  {
    id: 'decline_work_request',
    name: 'Decline Extra Work',
    situation: 'When your boss/coworker asks for more work',
    template: "I want to help, but I'm currently focused on {current_priorities}. If this is urgent, which of my current tasks should I deprioritize?",
    tone: 'polite',
    context: ['project', 'deadline', 'work', 'task'],
    neurodivergent_friendly: true,
    customizable_fields: ['current_priorities'],
  },
  {
    id: 'decline_delay',
    name: 'Not Now, Maybe Later',
    situation: 'When you need more time to decide',
    template: "I need some time to think about this. Can I get back to you by {date/time}?",
    tone: 'direct',
    context: ['decision', 'commitment', 'request'],
    neurodivergent_friendly: true,
    customizable_fields: ['date/time'],
  },
];
</file>

<file path="backend/supabase/functions/_shared/templates/index.ts">
/**
 * Central export for all response templates
 */

export type { ResponseTemplate } from './declining-templates.ts';
export { DECLINING_TEMPLATES } from './declining-templates.ts';
export { BOUNDARY_TEMPLATES } from './boundary-templates.ts';
export { INFO_DUMP_TEMPLATES } from './info-dump-templates.ts';
export { APOLOGIZING_TEMPLATES } from './apologizing-templates.ts';
export { CLARIFYING_TEMPLATES } from './clarifying-templates.ts';

// Re-export all templates as a single array
export const ALL_TEMPLATES = [
  ...DECLINING_TEMPLATES,
  ...BOUNDARY_TEMPLATES,
  ...INFO_DUMP_TEMPLATES,
  ...APOLOGIZING_TEMPLATES,
  ...CLARIFYING_TEMPLATES,
];
</file>

<file path="backend/supabase/functions/_shared/templates/info-dump-templates.ts">
/**
 * Templates for sharing enthusiasm without overwhelming recipients
 * Helps neurodivergent folks who info-dump about special interests
 */

import type { ResponseTemplate } from './declining-templates.ts';

export const INFO_DUMP_TEMPLATES: ResponseTemplate[] = [
  {
    id: 'infodump_intro',
    name: 'Info-Dump with Warning',
    situation: 'When you want to share a lot about something you love',
    template: "I'm really excited about {topic}! Fair warning: I could talk about this for hours 😊 Are you interested in hearing more?",
    tone: 'casual',
    context: ['excited', 'interesting', 'found', 'learned'],
    neurodivergent_friendly: true,
    customizable_fields: ['topic'],
  },
  {
    id: 'infodump_chunked',
    name: 'Info-Dump in Chunks',
    situation: 'When you want to share but keep it digestible',
    template: "Quick version: {short_summary}\n\nWant the details? I can break it down into:\n1. {aspect_1}\n2. {aspect_2}\n3. {aspect_3}\n\nLet me know what interests you!",
    tone: 'casual',
    context: ['explain', 'tell', 'share'],
    neurodivergent_friendly: true,
    customizable_fields: ['short_summary', 'aspect_1', 'aspect_2', 'aspect_3'],
  },
  {
    id: 'infodump_structured',
    name: 'Structured Share',
    situation: 'When you want to info-dump in an organized way',
    template: "**The Short Version:** {tldr}\n\n**Why It's Cool:** {hook}\n\n**The Details** (optional read):\n{detailed_info}\n\n**Bottom Line:** {conclusion}",
    tone: 'casual',
    context: ['fascinating', 'amazing', 'incredible'],
    neurodivergent_friendly: true,
    customizable_fields: ['tldr', 'hook', 'detailed_info', 'conclusion'],
  },
  {
    id: 'infodump_ask_permission',
    name: 'Ask Permission First',
    situation: 'When you\'re not sure if they want to hear it',
    template: "I just learned something really interesting about {topic}. Do you have a few minutes for me to geek out about it? No pressure if not!",
    tone: 'casual',
    context: ['cool', 'interesting', 'fascinating'],
    neurodivergent_friendly: true,
    customizable_fields: ['topic'],
  },
  {
    id: 'infodump_link',
    name: 'Share a Link Instead',
    situation: 'When a link can do the explaining',
    template: "This {type_of_content} explains it way better than I could: {link}\n\nThe part that blew my mind: {specific_detail}",
    tone: 'casual',
    context: ['article', 'video', 'study', 'research'],
    neurodivergent_friendly: true,
    customizable_fields: ['type_of_content', 'link', 'specific_detail'],
  },
];
</file>

<file path="backend/supabase/functions/ai_analyze_draft/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";
import { createOpenAIClient } from "../_shared/openai-client.ts";
import {
  DRAFT_ANALYSIS_SYSTEM_PROMPT,
  generateDraftAnalysisPrompt,
  validateDraftAnalysis,
  getSuggestedTemplates,
  findMatchingTemplates,
  type DraftAnalysisContext,
  type DraftAnalysisResult,
} from "../_shared/prompts/draft_analysis.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

interface AnalyzeRequest {
  draft_message: string;
  conversation_id?: string;
  relationship_type?: 'boss' | 'colleague' | 'friend' | 'family' | 'client' | 'none';
  conversation_history?: string[];
}

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Verify authorization
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      throw new Error("Missing authorization header");
    }

    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Verify user
    const token = authHeader.replace("Bearer ", "");
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser(token);

    if (authError || !user) {
      throw new Error("Invalid authorization token");
    }

    // Parse request body
    const requestBody: AnalyzeRequest = await req.json();
    const { 
      draft_message,
      conversation_id,
      relationship_type,
      conversation_history,
    } = requestBody;

    if (!draft_message || typeof draft_message !== 'string') {
      throw new Error("draft_message is required");
    }

    console.log(`🔍 Analyzing draft for user ${user.id.substring(0, 8)}...`);

    // Get conversation context if conversation_id provided
    let conversationTone: string | undefined;
    let recipientInfo: { name?: string; role?: string } | undefined;
    let detectedRelationshipType = relationship_type;

    if (conversation_id) {
      // Get recent tone analysis for this conversation
      const { data: recentAnalysis } = await supabase
        .rpc('get_conversation_ai_analysis', { p_conversation_id: conversation_id })
        .limit(1)
        .single();

      if (recentAnalysis) {
        conversationTone = recentAnalysis.tone;
      }

      // Get conversation metadata
      const { data: conversation } = await supabase
        .from('conversations')
        .select('title, relationship_type')
        .eq('id', conversation_id)
        .single();

      // Use stored relationship type if not provided
      if (!detectedRelationshipType && conversation?.relationship_type) {
        detectedRelationshipType = conversation.relationship_type;
      }

      // Get recipient info
      const { data: participants } = await supabase
        .from('conversation_participants')
        .select('user_id')
        .eq('conversation_id', conversation_id)
        .neq('user_id', user.id)
        .limit(1);

      if (participants && participants.length > 0) {
        const { data: profile } = await supabase
          .from('profiles')
          .select('username, full_name, email')
          .eq('id', participants[0].user_id)
          .single();

        if (profile) {
          recipientInfo = {
            name: profile.full_name || profile.username,
          };
        }
      }
    }

    // Build context
    const context: DraftAnalysisContext = {
      draftMessage: draft_message,
      conversationHistory: conversation_history || [],
      relationshipType: detectedRelationshipType || 'none',
      conversationTone,
      recipientInfo,
    };

    // Generate prompt
    const userPrompt = generateDraftAnalysisPrompt(context);

    console.log('📤 Calling OpenAI for draft analysis...');

    // Call OpenAI
    const openai = createOpenAIClient();
    const analysisResult = await openai.sendMessageForJSON<DraftAnalysisResult>(
      userPrompt,
      DRAFT_ANALYSIS_SYSTEM_PROMPT
    );

    console.log('📥 OpenAI response received');

    // Validate result
    const validatedResult = validateDraftAnalysis(analysisResult);

    console.log(`✅ Draft analysis complete. Confidence: ${validatedResult.confidence_score}%`);

    // Get template suggestions based on situation detection
    let suggestedTemplates = [];
    if (validatedResult.situation_detection) {
      const situationType = validatedResult.situation_detection.situation_type;
      console.log(`📝 Detected situation: ${situationType}`);
      
      // Get templates for this situation type
      const templatesBySituation = getSuggestedTemplates(situationType);
      
      // Also find templates matching keywords in the draft
      const templatesByKeyword = findMatchingTemplates(draft_message, 3);
      
      // Combine and deduplicate (prefer situation-based templates)
      const templateIds = new Set();
      suggestedTemplates = [
        ...templatesBySituation,
        ...templatesByKeyword,
      ].filter(template => {
        if (templateIds.has(template.id)) {
          return false;
        }
        templateIds.add(template.id);
        return true;
      }).slice(0, 5); // Return max 5 templates
      
      console.log(`📋 Found ${suggestedTemplates.length} suggested templates`);
    }

    // Return analysis (no database storage for drafts - they're ephemeral)
    return new Response(
      JSON.stringify({
        success: true,
        analysis: {
          // Tone analysis fields
          tone: validatedResult.tone,
          intensity: validatedResult.intensity,
          urgency_level: validatedResult.urgency_level,
          intent: validatedResult.intent,
          context_flags: validatedResult.context_flags,
          reasoning: validatedResult.reasoning,
          
          // Draft-specific fields
          confidence_score: validatedResult.confidence_score,
          appropriateness: validatedResult.appropriateness,
          suggestions: validatedResult.suggestions,
          warnings: validatedResult.warnings,
          strengths: validatedResult.strengths,
          
          // NEW: Situation detection and templates
          situation_detection: validatedResult.situation_detection,
          suggested_templates: suggestedTemplates,
        },
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200,
      }
    );
  } catch (error) {
    console.error("❌ Error analyzing draft:", error);

    const errorMessage = error instanceof Error ? error.message : "Unknown error";

    return new Response(
      JSON.stringify({
        success: false,
        error: errorMessage,
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 400,
      }
    );
  }
});
</file>

<file path="backend/supabase/functions/ai_analyze_tone/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";
import { createOpenAIClient } from "../_shared/openai-client.ts";
import {
  ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT,
  generateAnalysisPrompt,
  validateToneAnalysis,
  extractToneIndicators,
  detectFigurativeLanguage,
  assessResponseAnxietyRisk,
  type ToneAnalysisResult,
} from "../_shared/prompts/enhanced-tone-analysis.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

interface AnalyzeRequest {
  message_id: string;
  message_body: string;
  conversation_context?: string[]; // Optional recent messages for context
}

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Get the authorization header
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      throw new Error("Missing authorization header");
    }

    // Create Supabase client
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Verify the user's token
    const token = authHeader.replace("Bearer ", "");
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser(token);

    if (authError || !user) {
      throw new Error("Invalid authorization token");
    }

    // Parse request body
    const requestBody: AnalyzeRequest = await req.json();
    const { message_id, message_body, conversation_context } = requestBody;

    if (!message_id || !message_body) {
      throw new Error("message_id and message_body are required");
    }

    console.log(`🔍 Analyzing message ${message_id.substring(0, 8)}...`);

    // Verify user has access to this message
    const { data: message, error: messageError } = await supabase
      .from("messages")
      .select("id, conversation_id")
      .eq("id", message_id)
      .single();

    if (messageError || !message) {
      throw new Error("Message not found");
    }

    // Verify user is a participant in the conversation
    const { data: participant, error: participantError } = await supabase
      .from("conversation_participants")
      .select("user_id")
      .eq("conversation_id", message.conversation_id)
      .eq("user_id", user.id)
      .single();

    if (participantError || !participant) {
      throw new Error("Access denied to this conversation");
    }

    // Create OpenAI client
    const openai = createOpenAIClient();

    // Extract tone indicators and figurative language
    const toneIndicators = extractToneIndicators(message_body);
    const figurativeLanguage = detectFigurativeLanguage(message_body);
    
    console.log("🏷️  Tone indicators found:", toneIndicators);
    console.log("💭 Figurative language:", figurativeLanguage);

    // Generate the analysis prompt
    const userPrompt = generateAnalysisPrompt(
      message_body,
      conversation_context
    );

    console.log("📤 Sending request to OpenAI...");

    // Call OpenAI API with enhanced prompt
    const analysisResult = await openai.sendMessageForJSON<ToneAnalysisResult>(
      userPrompt,
      ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT
    );

    console.log("📥 Received response from OpenAI");

    // Validate the result
    const validatedResult = validateToneAnalysis(analysisResult);

    // Assess response anxiety risk for neurodivergent users
    const anxietyAssessment = assessResponseAnxietyRisk(validatedResult);
    console.log("🧠 Anxiety assessment:", anxietyAssessment);

    console.log(`✅ Analysis complete: ${validatedResult.tone} (${validatedResult.urgency_level})`);

    // Store the analysis in the database
    const now = Math.floor(Date.now() / 1000);

    const { data: storedAnalysis, error: insertError } = await supabase
      .from("message_ai_analysis")
      .insert({
        message_id,
        tone: validatedResult.tone,
        urgency_level: validatedResult.urgency_level,
        intent: validatedResult.intent,
        confidence_score: validatedResult.confidence_score,
        analysis_timestamp: now,
        // ✅ NEW ENHANCED FIELDS
        intensity: validatedResult.intensity,
        secondary_tones: validatedResult.secondary_tones,
        context_flags: validatedResult.context_flags,
        anxiety_assessment: anxietyAssessment,
      })
      .select()
      .single();

    if (insertError) {
      console.error("❌ Failed to store analysis:", insertError);
      throw new Error(`Failed to store analysis: ${insertError.message}`);
    }

    console.log("💾 Analysis stored successfully");

    // Return the analysis result
    return new Response(
      JSON.stringify({
        success: true,
        analysis: {
          id: storedAnalysis.id,
          message_id,
          tone: validatedResult.tone,
          urgency_level: validatedResult.urgency_level,
          intent: validatedResult.intent,
          confidence_score: validatedResult.confidence_score,
          reasoning: validatedResult.reasoning,
          // Enhanced fields
          intensity: validatedResult.intensity,
          secondary_tones: validatedResult.secondary_tones,
          context_flags: validatedResult.context_flags,
          anxiety_assessment: anxietyAssessment,
          figurative_language_detected: figurativeLanguage,
        },
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200,
      }
    );
  } catch (error) {
    console.error("❌ Error in ai_analyze_tone:", error);

    const errorMessage = error instanceof Error ? error.message : "Unknown error";

    return new Response(
      JSON.stringify({
        success: false,
        error: errorMessage,
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 400,
      }
    );
  }
});
</file>

<file path="backend/supabase/functions/ai-context-preloader/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { OpenAIClient } from '../_shared/openai-client.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('Missing authorization header');
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      throw new Error('Unauthorized');
    }

    const body = await req.json();
    const { conversation_id } = body;

    if (!conversation_id) {
      throw new Error('Missing conversation_id');
    }

    console.log(`📋 Loading context for conversation ${conversation_id}, user ${user.id}`);

    // Check cache first
    const { data: cachedContextArray } = await supabase.rpc('get_conversation_context', {
      p_user_id: user.id,
      p_conversation_id: conversation_id,
    });

    if (cachedContextArray && cachedContextArray.length > 0) {
      const cache = cachedContextArray[0];
      // If cache is less than 1 hour old, return it
      if (cache.cache_age < 3600) {
        console.log('✅ Returning cached context');
        return new Response(
          JSON.stringify({
            success: true,
            context: {
              last_discussed: cache.last_discussed,
              key_points: cache.key_points,
              pending_questions: cache.pending_questions,
            },
            from_cache: true,
            cache_age: cache.cache_age,
          }),
          { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      }
    }

    // Generate fresh context
    console.log('🔄 Generating fresh context');

    // Get recent messages
    const { data: recentMessages } = await supabase
      .from('messages')
      .select('body, created_at, sender_id')
      .eq('conversation_id', conversation_id)
      .order('created_at', { ascending: false })
      .limit(20);

    if (!recentMessages || recentMessages.length === 0) {
      throw new Error('No messages found');
    }

    console.log(`Found ${recentMessages.length} recent messages`);

    // Use AI to extract context
    const openai = new OpenAIClient();
    
    const prompt = `Analyze these recent messages and extract:
1. What was last discussed (1 sentence)
2. 3-5 key points from the conversation
3. Any pending questions that need answers

**Recent Messages (newest first):**
${recentMessages.map((m, i) => `${i + 1}. ${m.body}`).join('\n')}

**Response Format (JSON):**
{
  "last_discussed": "brief summary of last topic",
  "key_points": [
    "key point 1",
    "key point 2",
    "key point 3"
  ],
  "pending_questions": [
    "unanswered question 1",
    "unanswered question 2"
  ]
}`;

    const result = await openai.sendMessageForJSON(
      prompt,
      'You are extracting conversation context. Be concise and helpful.',
      { temperature: 0.3, max_tokens: 500 }
    );

    const context = {
      last_discussed: result.last_discussed || 'Recent conversation',
      key_points: Array.isArray(result.key_points) ? result.key_points : [],
      pending_questions: Array.isArray(result.pending_questions) ? result.pending_questions : [],
    };

    console.log('✅ Context generated');

    // Cache the result
    const now = new Date();
    const expiresAt = new Date(now.getTime() + 3600 * 1000); // 1 hour

    const { error: cacheError } = await supabase
      .from('conversation_context_cache')
      .upsert({
        user_id: user.id,
        conversation_id: conversation_id,
        last_discussed: context.last_discussed,
        key_points: context.key_points,
        pending_questions: context.pending_questions,
        generated_at: now.toISOString(),
        expires_at: expiresAt.toISOString(),
      }, {
        onConflict: 'user_id,conversation_id',
      });

    if (cacheError) {
      console.error('Error caching context:', cacheError);
    }

    return new Response(
      JSON.stringify({
        success: true,
        context,
        from_cache: false,
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('❌ Error loading context:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
    );
  }
});
</file>

<file path="backend/supabase/functions/ai-extract-followups/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { ActionItemExtractor } from '../_shared/nlp/action-item-extractor.ts';
import { QuestionDetector } from '../_shared/nlp/question-detector.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('Missing authorization header');
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      throw new Error('Unauthorized');
    }

    const body = await req.json();
    const { conversation_id, scan_recent_messages } = body;

    if (!conversation_id) {
      throw new Error('Missing conversation_id');
    }

    console.log(`Extracting follow-ups for conversation ${conversation_id}`);

    // Get recent messages
    const messageCount = scan_recent_messages ? 50 : 10;
    const { data: messages } = await supabase
      .from('messages')
      .select('id, body, sender_id, created_at')
      .eq('conversation_id', conversation_id)
      .order('created_at', { ascending: false })
      .limit(messageCount);

    if (!messages || messages.length === 0) {
      return new Response(
        JSON.stringify({ success: true, follow_ups: [] }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const actionExtractor = new ActionItemExtractor();
    const questionDetector = new QuestionDetector();

    const followUps = [];
    const now = Math.floor(Date.now() / 1000);

    // Extract action items from user's messages
    for (const message of messages) {
      if (message.sender_id === user.id) {
        const actionItems = await actionExtractor.extractActionItems(
          message.body,
          message.sender_id,
          user.id
        );

        for (const action of actionItems) {
          // Create follow-up item
          const deadline = action.mentioned_deadline
            ? actionExtractor.parseDeadline(action.mentioned_deadline)
            : null;

          const { data: followUpItem } = await supabase
            .from('follow_up_items')
            .insert({
              user_id: user.id,
              conversation_id,
              message_id: message.id,
              item_type: 'action_item',
              title: `${action.action_type}: ${action.action_target}`,
              description: action.commitment_text,
              extracted_text: message.body,
              priority: 70,
              detected_at: now,
              remind_at: deadline,
              created_at: now,
              updated_at: now,
            })
            .select()
            .single();

          if (followUpItem) {
            // Store action item details
            await supabase
              .from('action_items')
              .insert({
                follow_up_item_id: followUpItem.id,
                action_type: action.action_type,
                action_target: action.action_target,
                commitment_text: action.commitment_text,
                mentioned_deadline: action.mentioned_deadline,
                extracted_deadline: deadline,
                created_at: now,
              });

            followUps.push(followUpItem);
          }
        }
      }
    }

    // Detect unanswered questions
    const unansweredQuestions = await questionDetector.findUnansweredQuestions(
      messages.reverse(),
      user.id
    );

    for (const question of unansweredQuestions) {
      // Check if user hasn't responded in 24+ hours
      const timeSinceAsked = now - question.asked_at;
      if (timeSinceAsked > 86400) { // 24 hours
        const { data: followUpItem } = await supabase
          .from('follow_up_items')
          .insert({
            user_id: user.id,
            conversation_id,
            message_id: question.message_id,
            item_type: 'unanswered_question',
            title: `Answer: ${question.question_text.substring(0, 50)}...`,
            description: question.question_text,
            extracted_text: question.question_text,
            priority: 60,
            detected_at: now,
            remind_at: now,
            created_at: now,
            updated_at: now,
          })
          .select()
          .single();

        if (followUpItem) {
          await supabase
            .from('unanswered_questions')
            .insert({
              follow_up_item_id: followUpItem.id,
              message_id: question.message_id,
              question_text: question.question_text,
              question_type: question.question_type,
              context: question.context,
              asked_at: question.asked_at,
              time_since_asked: timeSinceAsked,
              created_at: now,
            });

          followUps.push(followUpItem);
        }
      }
    }

    console.log(`Found ${followUps.length} follow-ups`);

    return new Response(
      JSON.stringify({
        success: true,
        follow_ups: followUps,
        action_items_count: followUps.filter(f => f.item_type === 'action_item').length,
        unanswered_questions_count: followUps.filter(f => f.item_type === 'unanswered_question').length,
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('Error extracting follow-ups:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
    );
  }
});
</file>

<file path="backend/supabase/functions/ai-format-message/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { OpenAIClient } from '../_shared/openai-client.ts';
import {
  MESSAGE_FORMATTING_PROMPT,
  generateFormattingPrompt,
  calculateReadTime,
  type FormattingOptions,
  type FormattedMessage,
} from '../_shared/prompts/message-formatter.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('Missing authorization header');
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      throw new Error('Unauthorized');
    }

    const body = await req.json();
    const { message, options } = body as { 
      message: string; 
      options: FormattingOptions 
    };

    if (!message) {
      throw new Error('Missing message');
    }

    console.log(`Formatting message for user ${user.id}`);
    console.log('Options:', options);

    // Generate the formatting prompt
    const userPrompt = generateFormattingPrompt(message, options);

    // Call OpenAI
    const openai = new OpenAIClient();
    const result = await openai.sendMessageForJSON<FormattedMessage>(
      userPrompt,
      MESSAGE_FORMATTING_PROMPT,
      { temperature: 0.3, max_tokens: 2000 }
    );

    // Ensure we have proper values
    const originalLength = message.length;
    const formattedLength = result.formatted_message?.length || 0;
    const readTime = calculateReadTime(formattedLength);

    const formattedResult: FormattedMessage = {
      original_length: originalLength,
      formatted_message: result.formatted_message || message,
      formatting_applied: result.formatting_applied || [],
      character_count: formattedLength,
      estimated_read_time: readTime,
    };

    console.log('Formatting complete');
    console.log(`Original: ${originalLength} chars -> Formatted: ${formattedLength} chars`);

    return new Response(
      JSON.stringify({
        success: true,
        formatted: formattedResult,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    console.error('Error formatting message:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      }
    );
  }
});
</file>

<file path="backend/supabase/functions/ai-generate-embeddings/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { VectorSearch } from '../_shared/rag/vector-search.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('Missing authorization header');
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      throw new Error('Unauthorized');
    }

    const body = await req.json();
    const { message_id, message_body, conversation_id, batch_mode } = body;

    console.log('🔮 Generating embeddings...');

    const vectorSearch = new VectorSearch();
    const results = {
      success: true,
      processed: 0,
      failed: 0,
      skipped: 0,
    };

    if (batch_mode && conversation_id) {
      // Batch mode: Generate embeddings for all messages in conversation
      console.log(`Batch processing conversation ${conversation_id}`);

      // Get all messages without embeddings
      const { data: messages } = await supabase
        .from('messages')
        .select('id, body, sender_id')
        .eq('conversation_id', conversation_id)
        .order('created_at', { ascending: true });

      if (!messages || messages.length === 0) {
        throw new Error('No messages found');
      }

      console.log(`Processing ${messages.length} messages`);

      for (const message of messages) {
        try {
          // Check if embedding exists
          const { data: existing } = await supabase
            .from('message_embeddings')
            .select('id')
            .eq('message_id', message.id)
            .single();

          if (existing) {
            results.skipped++;
            continue;
          }

          // Generate and store embedding
          const success = await vectorSearch.storeMessageEmbedding(
            message.id,
            message.body,
            message.sender_id,
            supabase
          );

          if (success) {
            results.processed++;
          } else {
            results.failed++;
          }

          // Rate limiting: small delay between requests
          await new Promise(resolve => setTimeout(resolve, 100));
        } catch (error) {
          console.error(`Error processing message ${message.id}:`, error);
          results.failed++;
        }
      }

      console.log(`✅ Batch complete: ${results.processed} processed, ${results.skipped} skipped, ${results.failed} failed`);
    } else if (message_id && message_body) {
      // Single message mode
      console.log(`Processing single message ${message_id}`);

      const success = await vectorSearch.storeMessageEmbedding(
        message_id,
        message_body,
        user.id,
        supabase
      );

      if (success) {
        results.processed = 1;
        console.log('✅ Embedding generated and stored');
      } else {
        results.failed = 1;
        throw new Error('Failed to generate embedding');
      }
    } else {
      throw new Error('Either provide message_id + message_body OR conversation_id with batch_mode=true');
    }

    return new Response(
      JSON.stringify(results),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('❌ Error generating embeddings:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
    );
  }
});
</file>

<file path="backend/supabase/functions/ai-interpret-message/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { OpenAIClient } from '../_shared/openai-client.ts';
import {
  SMART_MESSAGE_INTERPRETER_PROMPT,
  generateSmartInterpretationPrompt,
  validateEnhancedToneAnalysis,
  type EnhancedToneAnalysisResult,
} from '../_shared/prompts/enhanced-tone-analysis.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('Missing authorization header');
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      throw new Error('Unauthorized');
    }

    const body = await req.json();
    const { message_id, message_body, conversation_context } = body;

    if (!message_body) {
      throw new Error('Missing message_body');
    }

    console.log(`Interpreting message for user ${user.id}`);

    // Generate smart interpretation prompt
    const userPrompt = generateSmartInterpretationPrompt(
      message_body,
      conversation_context
    );

    // Call OpenAI with enhanced prompt
    const openai = new OpenAIClient();
    const analysisResult = await openai.sendMessageForJSON<EnhancedToneAnalysisResult>(
      userPrompt,
      SMART_MESSAGE_INTERPRETER_PROMPT,
      { temperature: 0.3, max_tokens: 1000 } // More tokens for detailed analysis
    );

    console.log('Analysis complete:', analysisResult);

    // Validate result
    const validatedResult = validateEnhancedToneAnalysis(analysisResult);

    // Store in database if message_id provided
    if (message_id) {
      const now = Math.floor(Date.now() / 1000);
      await supabase
        .from('message_ai_analysis')
        .upsert({
          message_id,
          user_id: user.id,
          tone: validatedResult.tone,
          urgency_level: validatedResult.urgency_level,
          intent: validatedResult.intent,
          confidence_score: validatedResult.confidence_score,
          intensity: validatedResult.intensity,
          context_flags: validatedResult.context_flags,
          // Enhanced fields
          rsd_triggers: validatedResult.rsd_triggers,
          alternative_interpretations: validatedResult.message_interpretations,
          evidence: validatedResult.evidence,
          analysis_timestamp: now,
          updated_at: now,
        });
      
      console.log(`Stored analysis for message ${message_id}`);
    }

    return new Response(
      JSON.stringify({
        success: true,
        interpretation: validatedResult,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    console.error('Error interpreting message:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      }
    );
  }
});
</file>

<file path="backend/supabase/functions/ai-relationship-summary/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { RelationshipBuilder } from '../_shared/rag/relationship-builder.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('Missing authorization header');
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      throw new Error('Unauthorized');
    }

    const body = await req.json();
    const { conversation_id, force_regenerate } = body;

    if (!conversation_id) {
      throw new Error('Missing conversation_id');
    }

    console.log(`👤 Building relationship profile for conversation ${conversation_id}`);

    // Check if profile already exists
    if (!force_regenerate) {
      const { data: existingProfile } = await supabase.rpc('get_relationship_profile', {
        p_user_id: user.id,
        p_conversation_id: conversation_id,
      });

      if (existingProfile && existingProfile.length > 0) {
        console.log('✅ Returning existing profile');
        return new Response(
          JSON.stringify({
            success: true,
            profile: existingProfile[0],
            regenerated: false,
          }),
          { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      }
    }

    // Get conversation participants
    const { data: participants } = await supabase
      .from('conversation_participants')
      .select('user_id')
      .eq('conversation_id', conversation_id)
      .neq('user_id', user.id);

    if (!participants || participants.length === 0) {
      throw new Error('No other participants found');
    }

    const participantId = participants[0].user_id;

    // Get participant name
    const { data: profile } = await supabase
      .from('profiles')
      .select('username, full_name')
      .eq('id', participantId)
      .single();

    const participantName = profile?.full_name || profile?.username || 'Unknown';

    // Get conversation history
    const { data: messages } = await supabase
      .from('messages')
      .select('body, sender_id, created_at')
      .eq('conversation_id', conversation_id)
      .order('created_at', { ascending: true })
      .limit(100);

    if (!messages || messages.length === 0) {
      throw new Error('No messages found');
    }

    console.log(`Analyzing ${messages.length} messages`);

    // Format messages for AI
    const formattedMessages = messages.map(m => ({
      body: m.body,
      sender: m.sender_id === user.id ? 'self' : 'other',
      created_at: new Date(m.created_at).getTime() / 1000,
    }));

    // Build profile
    const builder = new RelationshipBuilder();
    const relationshipProfile = await builder.buildProfile(
      formattedMessages,
      participantName
    );

    // Calculate response time
    const typicalResponseTime = builder.calculateResponseTime(formattedMessages);

    console.log('✅ Profile generated');

    // Store in database
    const now = new Date();
    const { data: storedProfile, error: insertError } = await supabase
      .from('relationship_profiles')
      .upsert({
        user_id: user.id,
        conversation_id: conversation_id,
        participant_name: participantName,
        participant_user_id: participantId,
        relationship_type: relationshipProfile.relationship_type,
        conversation_summary: relationshipProfile.conversation_summary,
        safe_topics: relationshipProfile.safe_topics,
        topics_to_avoid: relationshipProfile.topics_to_avoid,
        communication_style: relationshipProfile.communication_style,
        typical_response_time: typicalResponseTime,
        total_messages: messages.length,
        first_message_at: new Date(messages[0].created_at),
        last_message_at: new Date(messages[messages.length - 1].created_at),
        updated_at: now.toISOString(),
      }, {
        onConflict: 'user_id,conversation_id',
      })
      .select()
      .single();

    if (insertError) {
      console.error('Error storing profile:', insertError);
      throw insertError;
    }

    return new Response(
      JSON.stringify({
        success: true,
        profile: storedProfile,
        regenerated: true,
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('❌ Error building relationship profile:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
    );
  }
});
</file>

<file path="backend/supabase/migrations/20251231_000001_smart_interpreter.sql">
-- ============================================================
-- SMART MESSAGE INTERPRETER - Phase 1 Enhancements
-- Adds RSD detection, alternative interpretations, and evidence
-- ============================================================

-- Add enhanced fields to message_ai_analysis table
ALTER TABLE message_ai_analysis
  ADD COLUMN IF NOT EXISTS rsd_triggers JSONB DEFAULT '[]'::jsonb,
  ADD COLUMN IF NOT EXISTS alternative_interpretations JSONB DEFAULT '[]'::jsonb,
  ADD COLUMN IF NOT EXISTS evidence JSONB DEFAULT '[]'::jsonb;

-- Add indexes for the new JSONB fields (optional, for performance)
CREATE INDEX IF NOT EXISTS idx_ai_analysis_rsd_triggers 
  ON message_ai_analysis USING GIN (rsd_triggers);
CREATE INDEX IF NOT EXISTS idx_ai_analysis_alternatives 
  ON message_ai_analysis USING GIN (alternative_interpretations);
CREATE INDEX IF NOT EXISTS idx_ai_analysis_evidence 
  ON message_ai_analysis USING GIN (evidence);

-- Add helpful comment
COMMENT ON COLUMN message_ai_analysis.rsd_triggers IS 
  'RSD (Rejection Sensitive Dysphoria) triggers detected in message';
COMMENT ON COLUMN message_ai_analysis.alternative_interpretations IS 
  'Multiple possible interpretations for ambiguous messages';
COMMENT ON COLUMN message_ai_analysis.evidence IS 
  'Specific evidence supporting the tone analysis';
</file>

<file path="backend/supabase/migrations/20260101_000001_response_assistant.sql">
-- =====================================================
-- Phase 2: Adaptive Response Assistant Migration
-- Adds support for template suggestions and message formatting
-- =====================================================

-- Note: This phase doesn't require new database tables
-- Template data is stored in code (backend/supabase/functions/_shared/templates/)
-- Situation detection happens via AI analysis (no persistence needed)
-- Formatted messages are returned to client without storage

-- However, we can add optional user preferences for templates
CREATE TABLE IF NOT EXISTS user_template_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- Favorite templates (user can star templates for quick access)
  favorite_template_ids TEXT[] DEFAULT '{}',
  
  -- Custom templates (user can create their own)
  custom_templates JSONB DEFAULT '[]'::jsonb,
  
  -- Template usage history (for smart suggestions)
  template_usage_history JSONB DEFAULT '[]'::jsonb,
  
  -- Preferences
  show_template_suggestions BOOLEAN DEFAULT true,
  auto_detect_situation BOOLEAN DEFAULT true,
  preferred_tone TEXT, -- 'polite', 'casual', 'direct', 'apologetic'
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(user_id)
);

-- Index for quick user lookups
CREATE INDEX IF NOT EXISTS idx_template_prefs_user_id 
  ON user_template_preferences(user_id);

-- RLS Policies
ALTER TABLE user_template_preferences ENABLE ROW LEVEL SECURITY;

-- Users can only access their own preferences
CREATE POLICY "Users can view their own template preferences"
  ON user_template_preferences
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own template preferences"
  ON user_template_preferences
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own template preferences"
  ON user_template_preferences
  FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own template preferences"
  ON user_template_preferences
  FOR DELETE
  USING (auth.uid() = user_id);

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_template_preferences_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for updated_at
DROP TRIGGER IF EXISTS update_template_preferences_timestamp ON user_template_preferences;
CREATE TRIGGER update_template_preferences_timestamp
  BEFORE UPDATE ON user_template_preferences
  FOR EACH ROW
  EXECUTE FUNCTION update_template_preferences_timestamp();

-- Helper function to get or create user template preferences
CREATE OR REPLACE FUNCTION get_user_template_preferences(p_user_id UUID)
RETURNS TABLE (
  id UUID,
  user_id UUID,
  favorite_template_ids TEXT[],
  custom_templates JSONB,
  template_usage_history JSONB,
  show_template_suggestions BOOLEAN,
  auto_detect_situation BOOLEAN,
  preferred_tone TEXT,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
  -- Check authorization
  IF auth.uid() != p_user_id THEN
    RAISE EXCEPTION 'Access denied';
  END IF;
  
  -- Get or create preferences
  INSERT INTO user_template_preferences (user_id)
  VALUES (p_user_id)
  ON CONFLICT (user_id) DO NOTHING;
  
  RETURN QUERY
  SELECT 
    prefs.id,
    prefs.user_id,
    prefs.favorite_template_ids,
    prefs.custom_templates,
    prefs.template_usage_history,
    prefs.show_template_suggestions,
    prefs.auto_detect_situation,
    prefs.preferred_tone,
    prefs.created_at,
    prefs.updated_at
  FROM user_template_preferences prefs
  WHERE prefs.user_id = p_user_id;
END;
$$;

-- Function to record template usage (for smart suggestions)
CREATE OR REPLACE FUNCTION record_template_usage(
  p_user_id UUID,
  p_template_id TEXT,
  p_situation_type TEXT
)
RETURNS VOID
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
DECLARE
  v_usage_entry JSONB;
BEGIN
  -- Check authorization
  IF auth.uid() != p_user_id THEN
    RAISE EXCEPTION 'Access denied';
  END IF;
  
  -- Create usage entry
  v_usage_entry := jsonb_build_object(
    'template_id', p_template_id,
    'situation_type', p_situation_type,
    'used_at', EXTRACT(EPOCH FROM NOW())::INTEGER
  );
  
  -- Ensure preferences exist
  INSERT INTO user_template_preferences (user_id)
  VALUES (p_user_id)
  ON CONFLICT (user_id) DO NOTHING;
  
  -- Append to usage history (keep last 100 entries)
  UPDATE user_template_preferences
  SET 
    template_usage_history = (
      SELECT jsonb_agg(entry)
      FROM (
        SELECT entry
        FROM jsonb_array_elements(
          template_usage_history || v_usage_entry
        ) entry
        ORDER BY (entry->>'used_at')::INTEGER DESC
        LIMIT 100
      ) recent
    ),
    updated_at = NOW()
  WHERE user_id = p_user_id;
END;
$$;

-- Comments for documentation
COMMENT ON TABLE user_template_preferences IS 'User preferences for response templates and message formatting';
COMMENT ON FUNCTION get_user_template_preferences(UUID) IS 'Gets or creates user template preferences';
COMMENT ON FUNCTION record_template_usage(UUID, TEXT, TEXT) IS 'Records template usage for smart suggestions';

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT ALL ON user_template_preferences TO authenticated;
GRANT EXECUTE ON FUNCTION get_user_template_preferences(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION record_template_usage(UUID, TEXT, TEXT) TO authenticated;
</file>

<file path="backend/supabase/migrations/20260102_000001_context_system.sql">
-- ============================================================
-- SMART INBOX CONTEXT SYSTEM - Phase 3
-- Adds conversation context, relationship profiles, and semantic search
-- ============================================================

-- Enable pgvector extension for semantic search
CREATE EXTENSION IF NOT EXISTS vector;

-- Message embeddings for semantic search
CREATE TABLE IF NOT EXISTS message_embeddings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  message_id UUID NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- OpenAI embedding (1536 dimensions for text-embedding-ada-002)
  embedding vector(1536) NOT NULL,
  
  -- Metadata for search optimization
  message_length INTEGER NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(message_id)
);

-- Index for fast similarity search
CREATE INDEX IF NOT EXISTS idx_message_embeddings_vector ON message_embeddings 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

CREATE INDEX IF NOT EXISTS idx_message_embeddings_user ON message_embeddings(user_id);
CREATE INDEX IF NOT EXISTS idx_message_embeddings_message ON message_embeddings(message_id);

-- Relationship profiles
CREATE TABLE IF NOT EXISTS relationship_profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  
  -- Profile data
  participant_name TEXT NOT NULL,
  participant_user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  
  -- Relationship metadata
  relationship_type TEXT, -- boss, colleague, friend, family, client, other
  relationship_notes TEXT, -- User-added notes
  
  -- Auto-generated context
  conversation_summary TEXT, -- AI-generated summary
  safe_topics JSONB DEFAULT '[]'::jsonb, -- Topics that went well
  topics_to_avoid JSONB DEFAULT '[]'::jsonb, -- Topics that caused issues
  communication_style TEXT, -- How they prefer to communicate
  typical_response_time INTEGER, -- Average response time in seconds
  
  -- Stats
  total_messages INTEGER DEFAULT 0,
  first_message_at TIMESTAMPTZ,
  last_message_at TIMESTAMPTZ,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(user_id, conversation_id)
);

CREATE INDEX IF NOT EXISTS idx_relationship_profiles_user ON relationship_profiles(user_id);
CREATE INDEX IF NOT EXISTS idx_relationship_profiles_conversation ON relationship_profiles(conversation_id);

-- Conversation context cache
CREATE TABLE IF NOT EXISTS conversation_context_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  
  -- Cached context
  last_discussed TEXT, -- "Last talked about project deadline"
  key_points JSONB DEFAULT '[]'::jsonb, -- Important points from recent messages
  pending_questions JSONB DEFAULT '[]'::jsonb, -- Unanswered questions
  
  -- Cache metadata
  generated_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL,
  
  UNIQUE(user_id, conversation_id)
);

CREATE INDEX IF NOT EXISTS idx_context_cache_user ON conversation_context_cache(user_id);
CREATE INDEX IF NOT EXISTS idx_context_cache_expires ON conversation_context_cache(expires_at);

-- Safe topics tracking
CREATE TABLE IF NOT EXISTS safe_topics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  
  -- Topic data
  topic_name TEXT NOT NULL, -- "work projects", "weekend plans", etc.
  topic_keywords JSONB DEFAULT '[]'::jsonb, -- Related keywords
  
  -- Engagement metrics
  message_count INTEGER DEFAULT 1,
  avg_response_time INTEGER, -- How fast user responds to this topic (seconds)
  positive_tone_rate REAL, -- % of messages with positive tone
  
  -- Status
  is_safe BOOLEAN DEFAULT true, -- Safe to discuss
  last_discussed TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(user_id, conversation_id, topic_name)
);

CREATE INDEX IF NOT EXISTS idx_safe_topics_user ON safe_topics(user_id);
CREATE INDEX IF NOT EXISTS idx_safe_topics_conversation ON safe_topics(conversation_id);
CREATE INDEX IF NOT EXISTS idx_safe_topics_discussed ON safe_topics(last_discussed);

-- ============================================================
-- RLS POLICIES
-- ============================================================

ALTER TABLE message_embeddings ENABLE ROW LEVEL SECURITY;
ALTER TABLE relationship_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversation_context_cache ENABLE ROW LEVEL SECURITY;
ALTER TABLE safe_topics ENABLE ROW LEVEL SECURITY;

-- Message embeddings: users can only access their own
CREATE POLICY "Users can view their own message embeddings"
  ON message_embeddings FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own message embeddings"
  ON message_embeddings FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Relationship profiles: users can manage their own
CREATE POLICY "Users can view their own relationship profiles"
  ON relationship_profiles FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own relationship profiles"
  ON relationship_profiles FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own relationship profiles"
  ON relationship_profiles FOR UPDATE
  USING (auth.uid() = user_id);

-- Context cache: users can access their own
CREATE POLICY "Users can view their own context cache"
  ON conversation_context_cache FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their own context cache"
  ON conversation_context_cache FOR ALL
  USING (auth.uid() = user_id);

-- Safe topics: users can manage their own
CREATE POLICY "Users can manage their own safe topics"
  ON safe_topics FOR ALL
  USING (auth.uid() = user_id);

-- ============================================================
-- RPC FUNCTIONS
-- ============================================================

-- Semantic search for similar messages
CREATE OR REPLACE FUNCTION search_similar_messages(
  p_user_id UUID,
  p_query_embedding vector(1536),
  p_limit INTEGER DEFAULT 5,
  p_conversation_id UUID DEFAULT NULL
)
RETURNS TABLE (
  message_id UUID,
  similarity REAL,
  message_body TEXT,
  created_at TIMESTAMPTZ
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verify user access
  IF auth.uid() != p_user_id THEN
    RAISE EXCEPTION 'Access denied';
  END IF;

  RETURN QUERY
  SELECT 
    m.id AS message_id,
    1 - (me.embedding <=> p_query_embedding) AS similarity,
    m.body AS message_body,
    m.created_at
  FROM message_embeddings me
  JOIN messages m ON me.message_id = m.id
  WHERE me.user_id = p_user_id
    AND (p_conversation_id IS NULL OR m.conversation_id = p_conversation_id)
  ORDER BY me.embedding <=> p_query_embedding
  LIMIT p_limit;
END;
$$;

-- Get relationship profile
CREATE OR REPLACE FUNCTION get_relationship_profile(
  p_user_id UUID,
  p_conversation_id UUID
)
RETURNS TABLE (
  profile_id UUID,
  participant_name TEXT,
  relationship_type TEXT,
  conversation_summary TEXT,
  safe_topics JSONB,
  topics_to_avoid JSONB,
  communication_style TEXT,
  typical_response_time INTEGER,
  total_messages INTEGER
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verify user access
  IF auth.uid() != p_user_id THEN
    RAISE EXCEPTION 'Access denied';
  END IF;

  -- Verify user is participant
  IF NOT EXISTS (
    SELECT 1 FROM conversation_participants
    WHERE conversation_id = p_conversation_id AND user_id = p_user_id
  ) THEN
    RAISE EXCEPTION 'Access denied to conversation';
  END IF;

  RETURN QUERY
  SELECT 
    rp.id AS profile_id,
    rp.participant_name,
    rp.relationship_type,
    rp.conversation_summary,
    rp.safe_topics,
    rp.topics_to_avoid,
    rp.communication_style,
    rp.typical_response_time,
    rp.total_messages
  FROM relationship_profiles rp
  WHERE rp.user_id = p_user_id
    AND rp.conversation_id = p_conversation_id
  LIMIT 1;
END;
$$;

-- Get cached conversation context
CREATE OR REPLACE FUNCTION get_conversation_context(
  p_user_id UUID,
  p_conversation_id UUID
)
RETURNS TABLE (
  last_discussed TEXT,
  key_points JSONB,
  pending_questions JSONB,
  cache_age INTEGER
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
DECLARE
  v_now TIMESTAMPTZ;
BEGIN
  v_now := NOW();

  -- Verify access
  IF auth.uid() != p_user_id THEN
    RAISE EXCEPTION 'Access denied';
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM conversation_participants
    WHERE conversation_id = p_conversation_id AND user_id = p_user_id
  ) THEN
    RAISE EXCEPTION 'Access denied to conversation';
  END IF;

  RETURN QUERY
  SELECT 
    ccc.last_discussed,
    ccc.key_points,
    ccc.pending_questions,
    EXTRACT(EPOCH FROM (v_now - ccc.generated_at))::INTEGER AS cache_age
  FROM conversation_context_cache ccc
  WHERE ccc.user_id = p_user_id
    AND ccc.conversation_id = p_conversation_id
    AND ccc.expires_at > v_now
  LIMIT 1;
END;
$$;

-- Get safe topics for conversation
CREATE OR REPLACE FUNCTION get_safe_topics(
  p_user_id UUID,
  p_conversation_id UUID
)
RETURNS TABLE (
  topic_name TEXT,
  message_count INTEGER,
  positive_tone_rate REAL,
  last_discussed TIMESTAMPTZ
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verify access
  IF auth.uid() != p_user_id THEN
    RAISE EXCEPTION 'Access denied';
  END IF;

  RETURN QUERY
  SELECT 
    st.topic_name,
    st.message_count,
    st.positive_tone_rate,
    st.last_discussed
  FROM safe_topics st
  WHERE st.user_id = p_user_id
    AND st.conversation_id = p_conversation_id
    AND st.is_safe = true
  ORDER BY st.positive_tone_rate DESC, st.message_count DESC
  LIMIT 10;
END;
$$;

-- Comments
COMMENT ON TABLE message_embeddings IS 'Vector embeddings for semantic search of messages';
COMMENT ON TABLE relationship_profiles IS 'AI-generated relationship profiles for conversations';
COMMENT ON TABLE conversation_context_cache IS 'Cached conversation context for quick loading';
COMMENT ON TABLE safe_topics IS 'Topics that have led to positive engagement';

-- Grant permissions
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT ALL ON message_embeddings TO authenticated;
GRANT ALL ON relationship_profiles TO authenticated;
GRANT ALL ON conversation_context_cache TO authenticated;
GRANT ALL ON safe_topics TO authenticated;
GRANT EXECUTE ON FUNCTION search_similar_messages(UUID, vector, INTEGER, UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION get_relationship_profile(UUID, UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION get_conversation_context(UUID, UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION get_safe_topics(UUID, UUID) TO authenticated;
</file>

<file path="backend/supabase/migrations/20260103_000001_followup_system.sql">
-- ============================================================
-- SMART FOLLOW-UP SYSTEM
-- ============================================================

-- Follow-up items (things that need response)
CREATE TABLE follow_up_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  message_id UUID REFERENCES messages(id) ON DELETE CASCADE,
  
  -- Item details
  item_type TEXT NOT NULL CHECK (item_type IN (
    'action_item',      -- "I'll send you..."
    'unanswered_question', -- Question without response
    'pending_response',    -- Conversation waiting for reply
    'scheduled_followup'   -- User-scheduled reminder
  )),
  
  title TEXT NOT NULL,
  description TEXT,
  extracted_text TEXT, -- Original text that triggered this
  
  -- Status
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
    'pending',
    'completed',
    'dismissed',
    'snoozed'
  )),
  
  -- Priority
  priority INTEGER DEFAULT 50 CHECK (priority >= 0 AND priority <= 100),
  
  -- Timing
  detected_at INTEGER NOT NULL,
  due_at INTEGER, -- When action should be completed
  remind_at INTEGER, -- When to remind user
  snoozed_until INTEGER, -- If snoozed
  completed_at INTEGER,
  
  -- Context triggers
  triggers JSONB, -- { "app": "email", "calendar_event": "meeting", "location": "office" }
  
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  
  UNIQUE(user_id, message_id, item_type)
);

CREATE INDEX idx_followup_items_user ON follow_up_items(user_id);
CREATE INDEX idx_followup_items_status ON follow_up_items(status);
CREATE INDEX idx_followup_items_remind_at ON follow_up_items(remind_at);
CREATE INDEX idx_followup_items_conversation ON follow_up_items(conversation_id);

-- Action items (specific commitments)
CREATE TABLE action_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  follow_up_item_id UUID NOT NULL REFERENCES follow_up_items(id) ON DELETE CASCADE,
  
  -- Action details
  action_type TEXT NOT NULL, -- send, call, meet, review, decide, etc.
  action_target TEXT, -- What/who is the action about
  commitment_text TEXT NOT NULL, -- Original promise
  
  -- Extracted details
  mentioned_deadline TEXT, -- "this afternoon", "by Friday"
  extracted_deadline INTEGER, -- Parsed timestamp
  
  created_at INTEGER NOT NULL
);

CREATE INDEX idx_action_items_followup ON action_items(follow_up_item_id);

-- Unanswered questions
CREATE TABLE unanswered_questions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  follow_up_item_id UUID NOT NULL REFERENCES follow_up_items(id) ON DELETE CASCADE,
  message_id UUID NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
  
  -- Question details
  question_text TEXT NOT NULL,
  question_type TEXT, -- when, where, what, who, why, how, yes/no
  context TEXT, -- Surrounding context
  
  -- Timing
  asked_at INTEGER NOT NULL,
  time_since_asked INTEGER, -- In seconds
  
  created_at INTEGER NOT NULL
);

CREATE INDEX idx_unanswered_questions_followup ON unanswered_questions(follow_up_item_id);
CREATE INDEX idx_unanswered_questions_message ON unanswered_questions(message_id);

-- Context triggers (app usage, calendar, location)
CREATE TABLE context_triggers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  follow_up_item_id UUID NOT NULL REFERENCES follow_up_items(id) ON DELETE CASCADE,
  
  -- Trigger details
  trigger_type TEXT NOT NULL CHECK (trigger_type IN (
    'app_opened',       -- When user opens specific app
    'calendar_event',   -- Before/during calendar event
    'location',         -- When at specific location
    'time_of_day',      -- Specific time
    'day_of_week'       -- Specific day
  )),
  
  trigger_config JSONB NOT NULL, -- Configuration for trigger
  
  -- Status
  is_active BOOLEAN DEFAULT true,
  last_triggered INTEGER,
  trigger_count INTEGER DEFAULT 0,
  
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

CREATE INDEX idx_context_triggers_user ON context_triggers(user_id);
CREATE INDEX idx_context_triggers_active ON context_triggers(is_active);
CREATE INDEX idx_context_triggers_followup ON context_triggers(follow_up_item_id);

-- ============================================================
-- RPC FUNCTIONS
-- ============================================================

-- Get pending follow-ups for user
CREATE OR REPLACE FUNCTION get_pending_followups(
  p_user_id UUID,
  p_limit INTEGER DEFAULT 50
)
RETURNS TABLE (
  item_id UUID,
  conversation_id UUID,
  item_type TEXT,
  title TEXT,
  description TEXT,
  priority INTEGER,
  detected_at INTEGER,
  remind_at INTEGER,
  triggers JSONB
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    fi.id AS item_id,
    fi.conversation_id,
    fi.item_type,
    fi.title,
    fi.description,
    fi.priority,
    fi.detected_at,
    fi.remind_at,
    fi.triggers
  FROM follow_up_items fi
  WHERE fi.user_id = p_user_id
    AND fi.status = 'pending'
    AND (fi.snoozed_until IS NULL OR fi.snoozed_until < EXTRACT(EPOCH FROM NOW())::INTEGER)
  ORDER BY fi.priority DESC, fi.detected_at ASC
  LIMIT p_limit;
END;
$$;

-- Get follow-ups for specific conversation
CREATE OR REPLACE FUNCTION get_conversation_followups(
  p_user_id UUID,
  p_conversation_id UUID
)
RETURNS TABLE (
  item_id UUID,
  item_type TEXT,
  title TEXT,
  description TEXT,
  priority INTEGER,
  status TEXT
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    fi.id AS item_id,
    fi.item_type,
    fi.title,
    fi.description,
    fi.priority,
    fi.status
  FROM follow_up_items fi
  WHERE fi.user_id = p_user_id
    AND fi.conversation_id = p_conversation_id
    AND fi.status IN ('pending', 'snoozed')
  ORDER BY fi.priority DESC, fi.detected_at DESC;
END;
$$;

-- Mark follow-up as completed
CREATE OR REPLACE FUNCTION complete_followup(
  p_user_id UUID,
  p_item_id UUID
)
RETURNS VOID
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
DECLARE
  v_now INTEGER;
BEGIN
  v_now := EXTRACT(EPOCH FROM NOW())::INTEGER;
  
  UPDATE follow_up_items
  SET 
    status = 'completed',
    completed_at = v_now,
    updated_at = v_now
  WHERE id = p_item_id AND user_id = p_user_id;
END;
$$;

-- Snooze follow-up
CREATE OR REPLACE FUNCTION snooze_followup(
  p_user_id UUID,
  p_item_id UUID,
  p_snooze_duration INTEGER -- In seconds
)
RETURNS VOID
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
DECLARE
  v_now INTEGER;
BEGIN
  v_now := EXTRACT(EPOCH FROM NOW())::INTEGER;
  
  UPDATE follow_up_items
  SET 
    status = 'snoozed',
    snoozed_until = v_now + p_snooze_duration,
    updated_at = v_now
  WHERE id = p_item_id AND user_id = p_user_id;
END;
$$;
</file>

<file path="frontend/firebase.json">
{"flutter":{"platforms":{"android":{"default":{"projectId":"messageai-e2e9e","appId":"1:397483513751:android:bb838799a2cd3f7f1c56d2","fileOutput":"android/app/google-services.json"}},"dart":{"lib/firebase_options.dart":{"projectId":"messageai-e2e9e","configurations":{"android":"1:397483513751:android:bb838799a2cd3f7f1c56d2","web":"1:397483513751:web:3121cbb846ddd8381c56d2","windows":"1:397483513751:web:ba73c764d577f4f51c56d2"}}}}}}
</file>

<file path="frontend/integration_test/ai_flow_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/app.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('AI Analysis Integration Flow', () {
    testWidgets('app structure loads correctly', (tester) async {
      // Verify the app widget exists
      const app = MessageAIApp();
      
      // Basic structure test
      expect(app, isA<MessageAIApp>());
    });
    
    testWidgets('complete AI analysis flow - TODO', (tester) async {
      // This is a placeholder for a full integration test
      // To implement when backend is fully configured:
      // 
      // 1. Initialize Supabase with test credentials
      // 2. Login with test user
      // 3. Navigate to a test conversation
      // 4. Send a message: "Hello, how are you doing today?"
      // 5. Wait for AI analysis to complete (may take 3-5 seconds)
      // 6. Verify ToneBadge appears on the message bubble
      // 7. Tap the badge to open ToneDetailSheet
      // 8. Verify sheet shows: tone, urgency level, intent, confidence
      // 9. Close sheet and pull down the message panel
      // 10. Verify AIInsightsPanel shows conversation-level insights
      // 
      // Requirements:
      // - Supabase running with test database
      // - OpenAI API key configured in ai_analyze_tone Edge Function
      // - Test user account in auth.users table
      // - Test conversation and participants in database
      
      // TODO: Implement full flow when authentication is configured
      expect(true, isTrue); // Placeholder assertion
    });
  });
}
</file>

<file path="frontend/integration_test/context_system_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/main.dart' as app;

/// Integration tests for Phase 3: Context System
///
/// These tests verify the complete flow of:
/// 1. Loading conversation context
/// 2. Displaying context preview card
/// 3. Opening relationship profiles
/// 4. Viewing safe topics and communication patterns
///
/// Prerequisites:
/// - Test Supabase instance with sample data
/// - Authenticated user session
/// - At least one conversation with messages
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Context System Integration Tests', () {
    testWidgets('Full context preview flow', (tester) async {
      // Start the app
      app.main();
      await tester.pumpAndSettle();

      // Wait for authentication/home screen
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to a conversation (adjust selector based on your UI)
      // This is a template - adjust based on your actual navigation
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Verify context preview card appears
        expect(find.text('Last Conversation'), findsOneWidget,
            reason: 'Context preview card should appear at top of messages');

        // Verify key points are displayed if available
        final recentTopicsFinder = find.text('Recent topics:');
        if (recentTopicsFinder.evaluate().isNotEmpty) {
          expect(recentTopicsFinder, findsOneWidget,
              reason: 'Recent topics section should be visible');
        }
      }
    });

    testWidgets('Relationship profile flow', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to a conversation
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Find and tap "Who is this?" button
        final whoIsThisButton = find.byTooltip('Who is this?');
        if (whoIsThisButton.evaluate().isNotEmpty) {
          await tester.tap(whoIsThisButton);
          await tester.pumpAndSettle();

          // Verify relationship sheet opens
          // Look for common elements that should be in the sheet
          await tester.pumpAndSettle(const Duration(seconds: 2));

          // Close the sheet
          final closeButton = find.byIcon(Icons.close);
          if (closeButton.evaluate().isNotEmpty) {
            await tester.tap(closeButton);
            await tester.pumpAndSettle();
          }
        }
      }
    });

    testWidgets('Context caching behavior', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Open a conversation
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Wait for context to load
        await tester.pumpAndSettle(const Duration(seconds: 2));

        // Go back
        final backButton = find.byTooltip('Back');
        if (backButton.evaluate().isNotEmpty) {
          await tester.tap(backButton);
          await tester.pumpAndSettle();

          // Open same conversation again
          await tester.tap(conversationFinder);
          await tester.pumpAndSettle();

          // Second load should be faster (cached)
          // Look for 'cached' indicator
          final cachedIndicator = find.text('cached');
          // Note: This may not always appear depending on timing
          await tester.pumpAndSettle();
        }
      }
    });

    testWidgets('Pending questions display', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to conversation with pending questions
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Look for pending questions badge
        final pendingQuestionsFinder = find.byIcon(Icons.help_outline);
        if (pendingQuestionsFinder.evaluate().isNotEmpty) {
          expect(pendingQuestionsFinder, findsOneWidget,
              reason: 'Pending questions indicator should be visible');

          // Verify text format
          final questionTextFinder = find.textContaining('unanswered question');
          expect(questionTextFinder, findsOneWidget,
              reason: 'Pending questions count should be displayed');
        }
      }
    });

    testWidgets('Safe topics display in relationship profile', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to conversation
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Open relationship profile
        final whoIsThisButton = find.byTooltip('Who is this?');
        if (whoIsThisButton.evaluate().isNotEmpty) {
          await tester.tap(whoIsThisButton);
          await tester.pumpAndSettle(const Duration(seconds: 2));

          // Look for safe topics section
          final safeTopicsFinder = find.text('Safe Topics');
          if (safeTopicsFinder.evaluate().isNotEmpty) {
            expect(safeTopicsFinder, findsOneWidget,
                reason: 'Safe topics section should be visible');
          }

          // Look for topics to avoid section
          final avoidTopicsFinder = find.text('Topics to Avoid');
          if (avoidTopicsFinder.evaluate().isNotEmpty) {
            expect(avoidTopicsFinder, findsOneWidget,
                reason: 'Topics to avoid section should be visible');
          }

          // Close the sheet
          final closeButton = find.byIcon(Icons.close);
          if (closeButton.evaluate().isNotEmpty) {
            await tester.tap(closeButton);
            await tester.pumpAndSettle();
          }
        }
      }
    });

    testWidgets('Context updates after sending message', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to conversation
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Note initial context
        await tester.pumpAndSettle(const Duration(seconds: 2));

        // Send a message
        final messageField = find.byType(TextField);
        if (messageField.evaluate().isNotEmpty) {
          await tester.enterText(messageField.first, 'Test message for context');
          await tester.testTextInput.receiveAction(TextInputAction.send);
          await tester.pumpAndSettle();

          // Context should eventually update
          // Note: In real scenario, this depends on backend processing
          await tester.pumpAndSettle(const Duration(seconds: 3));
        }
      }
    });
  });

  group('Error Handling Tests', () {
    testWidgets('Handles missing context gracefully', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to a new conversation with no context
      // Should not crash or show errors
      final conversationFinder = find.text('New Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Should show messages without context card
        expect(tester.takeException(), isNull,
            reason: 'Should handle missing context without crashing');
      }
    });

    testWidgets('Handles missing relationship profile', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      final conversationFinder = find.text('New Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Try to open relationship profile
        final whoIsThisButton = find.byTooltip('Who is this?');
        if (whoIsThisButton.evaluate().isNotEmpty) {
          await tester.tap(whoIsThisButton);
          await tester.pumpAndSettle(const Duration(seconds: 2));

          // Should show "No profile available" message
          final noProfileFinder = find.text('No profile available');
          if (noProfileFinder.evaluate().isNotEmpty) {
            expect(noProfileFinder, findsOneWidget);
          }

          // Close if needed
          final closeButton = find.byIcon(Icons.close);
          if (closeButton.evaluate().isNotEmpty) {
            await tester.tap(closeButton);
            await tester.pumpAndSettle();
          }
        }
      }
    });
  });
}
</file>

<file path="frontend/integration_test/enhanced_tone_analysis_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/features/messages/widgets/tone_detail_sheet.dart';
import 'package:flutter/material.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Enhanced Tone Analysis Integration Tests', () {
    testWidgets('Full flow: Parse analysis -> Display badge -> Show detail sheet',
        (tester) async {
      // Simulate API response with enhanced fields
      final apiResponse = {
        'id': 'analysis-123',
        'message_id': 'msg-456',
        'tone': 'Overwhelmed',
        'urgency_level': 'High',
        'intent': 'expressing severe stress about deadline',
        'confidence_score': 0.95,
        'analysis_timestamp': DateTime.now().millisecondsSinceEpoch ~/ 1000,
        'intensity': 'very_high',
        'secondary_tones': ['Frustrated', 'Concerned'],
        'context_flags': {
          'tone_indicator_present': true,
          'sarcasm_detected': false,
          'ambiguous': false,
        },
        'anxiety_assessment': {
          'risk_level': 'high',
          'mitigation_suggestions': [
            'Urgent tone detected. Consider asking for a specific timeline.',
            'Take a moment before responding to reduce pressure.',
          ],
        },
      };

      // 1. Parse the analysis
      final analysis = AIAnalysis.fromJson(apiResponse);
      expect(analysis.tone, 'Overwhelmed');
      expect(analysis.intensity, 'very_high');
      expect(analysis.contextFlags?['tone_indicator_present'], true);
      expect(analysis.anxietyAssessment?['risk_level'], 'high');

      // 2. Display in ToneBadge
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(
              analysis: analysis,
              onTap: () {},
            ),
          ),
        ),
      );

      expect(find.text('😵'), findsOneWidget, reason: 'Overwhelmed emoji');
      expect(find.text('Overwhelmed'), findsOneWidget);
      
      // Should have intensity and urgency dots
      final containers = tester.widgetList<Container>(find.byType(Container)).toList();
      final circleDots = containers.where((c) {
        final d = c.decoration;
        return d is BoxDecoration && d.shape == BoxShape.circle;
      }).length;
      expect(circleDots, greaterThanOrEqualTo(2));

      // 3. Show detail sheet
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: Builder(
              builder: (context) => ElevatedButton(
                onPressed: () {
                  ToneDetailSheet.show(
                    context,
                    analysis,
                    "I'm SO stressed about this deadline /srs",
                  );
                },
                child: const Text('Show Details'),
              ),
            ),
          ),
        ),
      );

      await tester.tap(find.text('Show Details'));
      await tester.pumpAndSettle();

      // Verify detail sheet content
      expect(find.text('AI Analysis'), findsOneWidget);
      expect(find.text('Overwhelmed'), findsOneWidget);
      expect(find.text('High'), findsOneWidget, reason: 'Urgency level');
      expect(find.text('Very High'), findsOneWidget, reason: 'Intensity formatted');
      
      // Check for anxiety assessment
      expect(find.textContaining('Response Anxiety'), findsOneWidget);
      expect(find.textContaining('HIGH'), findsOneWidget);
    });

    testWidgets('Playful tone with tone indicator /j', (tester) async {
      final apiResponse = {
        'id': 'analysis-789',
        'message_id': 'msg-012',
        'tone': 'Playful',
        'urgency_level': 'Low',
        'intent': 'joking about suggestion',
        'confidence_score': 0.92,
        'analysis_timestamp': DateTime.now().millisecondsSinceEpoch ~/ 1000,
        'intensity': 'medium',
        'context_flags': {
          'tone_indicator_present': true,
          'sarcasm_detected': false,
        },
        'anxiety_assessment': {
          'risk_level': 'low',
          'mitigation_suggestions': [],
        },
      };

      final analysis = AIAnalysis.fromJson(apiResponse);

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      expect(find.text('😜'), findsOneWidget, reason: 'Playful emoji');
      expect(find.text('Playful'), findsOneWidget);
    });

    testWidgets('Sarcastic tone detection', (tester) async {
      final apiResponse = {
        'id': 'analysis-sarcasm',
        'message_id': 'msg-sarcasm',
        'tone': 'Sarcastic',
        'urgency_level': 'Low',
        'intent': 'expressing frustration sarcastically',
        'confidence_score': 0.88,
        'analysis_timestamp': DateTime.now().millisecondsSinceEpoch ~/ 1000,
        'intensity': 'high',
        'context_flags': {
          'sarcasm_detected': true,
          'tone_indicator_present': true,
        },
        'anxiety_assessment': {
          'risk_level': 'medium',
          'mitigation_suggestions': [
            'Sarcasm detected. Literal meaning may differ.',
          ],
        },
      };

      final analysis = AIAnalysis.fromJson(apiResponse);

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      expect(find.text('🙄'), findsOneWidget, reason: 'Sarcastic emoji');
      expect(analysis.contextFlags?['sarcasm_detected'], true);
      expect(analysis.anxietyAssessment?['risk_level'], 'medium');
    });

    testWidgets('All 5 intensity levels display correctly', (tester) async {
      final intensities = ['very_low', 'low', 'medium', 'high', 'very_high'];

      for (final intensity in intensities) {
        final analysis = AIAnalysis(
          id: 'test-$intensity',
          messageId: 'msg-$intensity',
          tone: 'Friendly',
          intensity: intensity,
          analysisTimestamp: DateTime.now().millisecondsSinceEpoch ~/ 1000,
        );

        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: ToneBadge(analysis: analysis),
            ),
          ),
        );

        // Should display intensity dot
        final containers = tester.widgetList<Container>(find.byType(Container));
        final hasIntensityDot = containers.any((c) {
          final d = c.decoration;
          return d is BoxDecoration && d.shape == BoxShape.circle;
        });
        
        expect(hasIntensityDot, true, reason: 'Intensity dot for $intensity');
      }
    });

    testWidgets('Backward compatibility: Analysis without enhanced fields', (tester) async {
      // Old API response without enhanced fields
      final oldApiResponse = {
        'id': 'old-analysis',
        'message_id': 'old-msg',
        'tone': 'Friendly',
        'urgency_level': 'Low',
        'intent': 'greeting',
        'confidence_score': 0.85,
        'analysis_timestamp': DateTime.now().millisecondsSinceEpoch ~/ 1000,
      };

      final analysis = AIAnalysis.fromJson(oldApiResponse);
      expect(analysis.intensity, null);
      expect(analysis.contextFlags, null);

      // Should still display correctly
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      expect(find.text('😊'), findsOneWidget);
      expect(find.text('Friendly'), findsOneWidget);
    });
  });
}
</file>

<file path="frontend/lib/core/errors/app_error.dart">
/// Application error types and models
/// Provides structured error handling across the app

/// Error categories for classification
enum ErrorCategory {
  auth,
  network,
  database,
  messaging,
  storage,
  permission,
  validation,
  unknown,
}

/// Error severity levels
enum ErrorSeverity {
  info,     // Informational, no action required
  warning,  // Warning, user should be aware
  error,    // Error, user action may help
  critical, // Critical, likely requires app restart or support
}

/// Structured application error
class AppError implements Exception {
  final ErrorCategory category;
  final ErrorSeverity severity;
  final String code;
  final String message;
  final String? userMessage;
  final dynamic originalError;
  final StackTrace? stackTrace;
  final Map<String, dynamic>? context;
  final bool isRetryable;

  const AppError({
    required this.category,
    required this.severity,
    required this.code,
    required this.message,
    this.userMessage,
    this.originalError,
    this.stackTrace,
    this.context,
    this.isRetryable = false,
  });

  /// Get user-friendly error message
  String get displayMessage => userMessage ?? message;

  /// Check if error requires user action
  bool get requiresUserAction => 
      severity == ErrorSeverity.error || 
      severity == ErrorSeverity.critical;

  @override
  String toString() {
    return 'AppError($category.$code): $message';
  }

  /// Copy with modifications
  AppError copyWith({
    ErrorCategory? category,
    ErrorSeverity? severity,
    String? code,
    String? message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    Map<String, dynamic>? context,
    bool? isRetryable,
  }) {
    return AppError(
      category: category ?? this.category,
      severity: severity ?? this.severity,
      code: code ?? this.code,
      message: message ?? this.message,
      userMessage: userMessage ?? this.userMessage,
      originalError: originalError ?? this.originalError,
      stackTrace: stackTrace ?? this.stackTrace,
      context: context ?? this.context,
      isRetryable: isRetryable ?? this.isRetryable,
    );
  }
}

/// Authentication errors
class AuthError extends AppError {
  AuthError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = false,
  }) : super(
          category: ErrorCategory.auth,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory AuthError.invalidCredentials() => AuthError(
        code: 'AUTH001',
        message: 'Invalid email or password',
        userMessage: 'The email or password you entered is incorrect. Please try again.',
      );

  factory AuthError.emailAlreadyExists() => AuthError(
        code: 'AUTH002',
        message: 'Email already registered',
        userMessage: 'An account with this email already exists. Try signing in instead.',
      );

  factory AuthError.weakPassword() => AuthError(
        code: 'AUTH003',
        message: 'Password too weak',
        userMessage: 'Please choose a stronger password (at least 6 characters).',
      );

  factory AuthError.invalidEmail() => AuthError(
        code: 'AUTH004',
        message: 'Invalid email format',
        userMessage: 'Please enter a valid email address.',
      );

  factory AuthError.sessionExpired() => AuthError(
        code: 'AUTH005',
        message: 'Session expired',
        userMessage: 'Your session has expired. Please sign in again.',
      );

  factory AuthError.networkError() => AuthError(
        code: 'AUTH006',
        message: 'Network error during authentication',
        userMessage: 'Unable to connect. Please check your internet connection and try again.',
        isRetryable: true,
      );

  factory AuthError.unknown(dynamic error) => AuthError(
        code: 'AUTH999',
        message: 'Unknown authentication error',
        userMessage: 'Something went wrong during authentication. Please try again.',
        originalError: error,
        isRetryable: true,
      );
}

/// Network errors
class NetworkError extends AppError {
  NetworkError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
  }) : super(
          category: ErrorCategory.network,
          severity: ErrorSeverity.warning,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: true,
        );

  factory NetworkError.noConnection() => NetworkError(
        code: 'NET001',
        message: 'No internet connection',
        userMessage: 'No internet connection. Please check your network settings.',
      );

  factory NetworkError.timeout() => NetworkError(
        code: 'NET002',
        message: 'Request timeout',
        userMessage: 'The request took too long. Please try again.',
      );

  factory NetworkError.serverError() => NetworkError(
        code: 'NET003',
        message: 'Server error',
        userMessage: 'Server is temporarily unavailable. Please try again later.',
      );
}

/// Message sending errors
class MessageError extends AppError {
  MessageError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = true,
  }) : super(
          category: ErrorCategory.messaging,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory MessageError.sendFailed() => MessageError(
        code: 'MSG001',
        message: 'Failed to send message',
        userMessage: 'Unable to send message. Please try again.',
      );

  factory MessageError.networkError() => MessageError(
        code: 'MSG002',
        message: 'Network error while sending message',
        userMessage: 'Message saved offline. It will send when you\'re back online.',
      );

  factory MessageError.unauthorized() => MessageError(
        code: 'MSG003',
        message: 'Not authorized to send message',
        userMessage: 'You don\'t have permission to send messages to this conversation.',
        isRetryable: false,
      );

  factory MessageError.conversationNotFound() => MessageError(
        code: 'MSG004',
        message: 'Conversation not found',
        userMessage: 'This conversation no longer exists.',
        isRetryable: false,
      );

  factory MessageError.mediaTooLarge() => MessageError(
        code: 'MSG005',
        message: 'Media file too large',
        userMessage: 'The image is too large. Please choose a smaller file.',
        isRetryable: false,
      );

  factory MessageError.mediaUploadFailed() => MessageError(
        code: 'MSG006',
        message: 'Failed to upload media',
        userMessage: 'Unable to upload image. Please try again.',
      );
}

/// Storage errors
class StorageError extends AppError {
  StorageError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = true,
  }) : super(
          category: ErrorCategory.storage,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory StorageError.uploadFailed() => StorageError(
        code: 'STR001',
        message: 'Upload failed',
        userMessage: 'Unable to upload file. Please try again.',
      );

  factory StorageError.fileTooLarge() => StorageError(
        code: 'STR002',
        message: 'File too large',
        userMessage: 'The file is too large. Maximum size is 10MB.',
        isRetryable: false,
      );

  factory StorageError.unsupportedFormat() => StorageError(
        code: 'STR003',
        message: 'Unsupported file format',
        userMessage: 'This file type is not supported. Please use JPG, PNG, or GIF.',
        isRetryable: false,
      );
}

/// Database errors
class DatabaseError extends AppError {
  DatabaseError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = true,
  }) : super(
          category: ErrorCategory.database,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory DatabaseError.queryFailed() => DatabaseError(
        code: 'DB001',
        message: 'Database query failed',
        userMessage: 'Unable to fetch data. Please try again.',
      );

  factory DatabaseError.syncFailed() => DatabaseError(
        code: 'DB002',
        message: 'Sync failed',
        userMessage: 'Unable to sync data. Your changes are saved locally.',
      );
}

/// Permission errors
class PermissionError extends AppError {
  PermissionError({
    required String code,
    required String message,
    String? userMessage,
    bool isRetryable = false,
  }) : super(
          category: ErrorCategory.permission,
          severity: ErrorSeverity.warning,
          code: code,
          message: message,
          userMessage: userMessage,
          isRetryable: isRetryable,
        );

  factory PermissionError.cameraNotGranted() => PermissionError(
        code: 'PERM001',
        message: 'Camera permission not granted',
        userMessage: 'Camera access is required. Please enable it in Settings.',
      );

  factory PermissionError.storageNotGranted() => PermissionError(
        code: 'PERM002',
        message: 'Storage permission not granted',
        userMessage: 'Storage access is required. Please enable it in Settings.',
      );

  factory PermissionError.notificationsNotGranted() => PermissionError(
        code: 'PERM003',
        message: 'Notification permission not granted',
        userMessage: 'Enable notifications to receive message alerts.',
      );
}
</file>

<file path="frontend/lib/core/errors/error_handler.dart">
import 'package:messageai/core/errors/app_error.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

/// Global error handler service
class ErrorHandler {
  static final ErrorHandler _instance = ErrorHandler._internal();

  factory ErrorHandler() {
    return _instance;
  }

  ErrorHandler._internal();

  /// Convert any error to AppError
  AppError handleError(dynamic error, {StackTrace? stackTrace, String? context}) {
    AppError appError;

    if (error is AppError) {
      appError = error;
    } else if (error is AuthException) {
      appError = _handleAuthException(error);
    } else if (error is PostgrestException) {
      appError = _handlePostgrestException(error);
    } else if (error is StorageException) {
      appError = _handleStorageException(error);
    } else if (error is String) {
      appError = _handleStringError(error);
    } else {
      appError = _handleUnknownError(error);
    }

    // Log error
    _logError(appError, stackTrace, context);

    return appError;
  }

  /// Handle Supabase Auth exceptions
  AppError _handleAuthException(AuthException error) {
    final message = error.message.toLowerCase();

    if (message.contains('invalid login credentials') ||
        message.contains('invalid email or password')) {
      return AuthError.invalidCredentials();
    } else if (message.contains('already registered') ||
               message.contains('already been registered')) {
      return AuthError.emailAlreadyExists();
    } else if (message.contains('password') && message.contains('weak')) {
      return AuthError.weakPassword();
    } else if (message.contains('invalid email')) {
      return AuthError.invalidEmail();
    } else if (message.contains('session') && 
               (message.contains('expired') || message.contains('invalid'))) {
      return AuthError.sessionExpired();
    } else if (message.contains('network') || 
               message.contains('connection') ||
               message.contains('timeout')) {
      return AuthError.networkError();
    } else {
      return AuthError.unknown(error);
    }
  }

  /// Handle Supabase Postgrest (database) exceptions
  AppError _handlePostgrestException(PostgrestException error) {
    final message = error.message.toLowerCase();
    final code = error.code ?? '';

    // RLS policy violations
    if (code.contains('42501') || message.contains('permission denied')) {
      return MessageError.unauthorized();
    }

    // Foreign key violations
    if (code.contains('23503') || message.contains('foreign key')) {
      return MessageError.conversationNotFound();
    }

    // Network errors
    if (message.contains('network') || 
        message.contains('timeout') ||
        message.contains('connection')) {
      return NetworkError.noConnection();
    }

    // Server errors
    if (code.startsWith('5')) {
      return NetworkError.serverError();
    }

    // Generic database error
    return DatabaseError.queryFailed();
  }

  /// Handle Supabase Storage exceptions
  AppError _handleStorageException(StorageException error) {
    final message = error.message.toLowerCase();

    if (message.contains('size') || message.contains('too large')) {
      return StorageError.fileTooLarge();
    } else if (message.contains('format') || 
               message.contains('type') ||
               message.contains('invalid file')) {
      return StorageError.unsupportedFormat();
    } else {
      return StorageError.uploadFailed();
    }
  }

  /// Handle string errors (thrown as strings)
  AppError _handleStringError(String error) {
    final message = error.toLowerCase();

    // Auth errors
    if (message.contains('sign in') || message.contains('sign up')) {
      if (message.contains('failed')) {
        return AuthError.unknown(error);
      }
    }

    // Message errors
    if (message.contains('message')) {
      if (message.contains('failed') || message.contains('error')) {
        return MessageError.sendFailed();
      }
    }

    // Network errors
    if (message.contains('network') || 
        message.contains('connection') ||
        message.contains('offline') ||
        message.contains('internet')) {
      return NetworkError.noConnection();
    }

    // Generic error
    return AppError(
      category: ErrorCategory.unknown,
      severity: ErrorSeverity.error,
      code: 'UNK001',
      message: error,
      userMessage: 'Something went wrong. Please try again.',
      isRetryable: true,
    );
  }

  /// Handle unknown errors
  AppError _handleUnknownError(dynamic error) {
    return AppError(
      category: ErrorCategory.unknown,
      severity: ErrorSeverity.error,
      code: 'UNK999',
      message: error.toString(),
      userMessage: 'An unexpected error occurred. Please try again.',
      originalError: error,
      isRetryable: true,
    );
  }

  /// Log error for debugging
  void _logError(AppError error, StackTrace? stackTrace, String? context) {
    // Only log critical errors and non-retryable errors
    if (error.severity == ErrorSeverity.critical || !error.isRetryable) {
      final emoji = _getEmojiForSeverity(error.severity);
      print('$emoji ${error.code}: ${error.userMessage ?? error.message}');
    }
  }

  /// Get emoji for severity level
  String _getEmojiForSeverity(ErrorSeverity severity) {
    switch (severity) {
      case ErrorSeverity.info:
        return 'ℹ️';
      case ErrorSeverity.warning:
        return '⚠️';
      case ErrorSeverity.error:
        return '❌';
      case ErrorSeverity.critical:
        return '🚨';
    }
  }

  /// Check if error is network-related
  bool isNetworkError(AppError error) {
    return error.category == ErrorCategory.network ||
           (error.category == ErrorCategory.auth && error.code == 'AUTH006') ||
           (error.category == ErrorCategory.messaging && error.code == 'MSG002');
  }

  /// Check if error should trigger offline mode
  bool shouldGoOffline(AppError error) {
    return error.category == ErrorCategory.network &&
           error.code == 'NET001';
  }

  /// Get retry delay based on attempt number (exponential backoff)
  Duration getRetryDelay(int attemptNumber) {
    // Exponential backoff: 1s, 2s, 4s, 8s, 16s
    final delaySeconds = (1 << (attemptNumber - 1)).clamp(1, 16);
    return Duration(seconds: delaySeconds);
  }

  /// Check if should retry based on attempt count
  bool shouldRetry(AppError error, int attemptNumber, {int maxAttempts = 3}) {
    return error.isRetryable && attemptNumber < maxAttempts;
  }
}

/// Extension to add error handling to Future
extension FutureErrorHandler<T> on Future<T> {
  /// Handle errors and convert to AppError
  Future<T> handleAppError({String? context}) async {
    try {
      return await this;
    } catch (error, stackTrace) {
      throw ErrorHandler().handleError(error, stackTrace: stackTrace, context: context);
    }
  }
}
</file>

<file path="frontend/lib/core/errors/error_ui.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/errors/app_error.dart';

/// UI utilities for displaying errors to users
class ErrorUI {
  /// Show error as snackbar (for non-critical errors)
  static void showErrorSnackbar(
    BuildContext context,
    AppError error, {
    VoidCallback? onRetry,
  }) {
    final snackBar = SnackBar(
      content: Row(
        children: [
          Icon(
            _getIconForError(error),
            color: Colors.white,
            size: 20,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              error.displayMessage,
              style: const TextStyle(fontSize: 14),
            ),
          ),
        ],
      ),
      backgroundColor: _getColorForSeverity(error.severity),
      behavior: SnackBarBehavior.floating,
      action: error.isRetryable && onRetry != null
          ? SnackBarAction(
              label: 'Retry',
              textColor: Colors.white,
              onPressed: onRetry,
            )
          : null,
      duration: Duration(
        seconds: error.severity == ErrorSeverity.critical ? 6 : 4,
      ),
    );

    ScaffoldMessenger.of(context)
      ..hideCurrentSnackBar()
      ..showSnackBar(snackBar);
  }

  /// Show error as dialog (for critical errors or when user action required)
  static Future<bool?> showErrorDialog(
    BuildContext context,
    AppError error, {
    VoidCallback? onRetry,
    String? actionLabel,
  }) {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        icon: Icon(
          _getIconForError(error),
          color: _getColorForSeverity(error.severity),
          size: 48,
        ),
        title: Text(_getTitleForError(error)),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(error.displayMessage),
            if (error.code.isNotEmpty) ...[
              const SizedBox(height: 16),
              Text(
                'Error Code: ${error.code}',
                style: TextStyle(
                  fontSize: 12,
                  color: Colors.grey[600],
                ),
              ),
            ],
          ],
        ),
        actions: [
          if (!error.requiresUserAction)
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Dismiss'),
            ),
          if (error.isRetryable && onRetry != null)
            FilledButton(
              onPressed: () {
                Navigator.of(context).pop(true);
                onRetry();
              },
              child: Text(actionLabel ?? 'Retry'),
            ),
          if (!error.isRetryable || onRetry == null)
            FilledButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('OK'),
            ),
        ],
      ),
    );
  }

  /// Show permission error with option to open settings
  static Future<void> showPermissionError(
    BuildContext context,
    PermissionError error,
  ) {
    return showDialog(
      context: context,
      builder: (context) => AlertDialog(
        icon: const Icon(
          Icons.security,
          color: Colors.orange,
          size: 48,
        ),
        title: const Text('Permission Required'),
        content: Text(error.displayMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              Navigator.of(context).pop();
              // TODO: Open app settings
              // OpenSettings.openAppSettings();
            },
            child: const Text('Open Settings'),
          ),
        ],
      ),
    );
  }

  /// Show loading indicator with cancellation
  static Future<T?> showLoadingDialog<T>(
    BuildContext context, {
    required Future<T> Function() action,
    String message = 'Loading...',
  }) async {
    // Show loading dialog
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        content: Row(
          children: [
            const CircularProgressIndicator(),
            const SizedBox(width: 24),
            Text(message),
          ],
        ),
      ),
    );

    try {
      final result = await action();
      if (context.mounted) {
        Navigator.of(context).pop();
      }
      return result;
    } catch (error) {
      if (context.mounted) {
        Navigator.of(context).pop();
        if (error is AppError) {
          showErrorDialog(context, error);
        }
      }
      return null;
    }
  }

  /// Get icon for error
  static IconData _getIconForError(AppError error) {
    switch (error.category) {
      case ErrorCategory.auth:
        return Icons.lock_outline;
      case ErrorCategory.network:
        return Icons.wifi_off;
      case ErrorCategory.database:
        return Icons.storage_outlined;
      case ErrorCategory.messaging:
        return Icons.message_outlined;
      case ErrorCategory.storage:
        return Icons.cloud_upload_outlined;
      case ErrorCategory.permission:
        return Icons.security;
      case ErrorCategory.validation:
        return Icons.error_outline;
      case ErrorCategory.unknown:
        return Icons.warning_amber;
    }
  }

  /// Get color for severity
  static Color _getColorForSeverity(ErrorSeverity severity) {
    switch (severity) {
      case ErrorSeverity.info:
        return Colors.blue;
      case ErrorSeverity.warning:
        return Colors.orange;
      case ErrorSeverity.error:
        return Colors.red;
      case ErrorSeverity.critical:
        return Colors.red.shade900;
    }
  }

  /// Get title for error dialog
  static String _getTitleForError(AppError error) {
    switch (error.category) {
      case ErrorCategory.auth:
        return 'Authentication Error';
      case ErrorCategory.network:
        return 'Connection Problem';
      case ErrorCategory.database:
        return 'Data Error';
      case ErrorCategory.messaging:
        return 'Message Error';
      case ErrorCategory.storage:
        return 'Upload Error';
      case ErrorCategory.permission:
        return 'Permission Required';
      case ErrorCategory.validation:
        return 'Invalid Input';
      case ErrorCategory.unknown:
        return 'Error';
    }
  }
}

/// Mixin for widgets that need error handling
mixin ErrorHandlerMixin<T extends StatefulWidget> on State<T> {
  /// Show error to user
  void showError(AppError error, {VoidCallback? onRetry}) {
    if (!mounted) return;

    if (error.severity == ErrorSeverity.critical || error.requiresUserAction) {
      ErrorUI.showErrorDialog(context, error, onRetry: onRetry);
    } else {
      ErrorUI.showErrorSnackbar(context, error, onRetry: onRetry);
    }
  }

  /// Handle error from async operation
  Future<T?> handleAsyncError<T>(
    Future<T> Function() operation, {
    String? context,
    VoidCallback? onRetry,
  }) async {
    try {
      return await operation();
    } on AppError catch (error) {
      showError(error, onRetry: onRetry);
      return null;
    } catch (error) {
      final appError = AppError(
        category: ErrorCategory.unknown,
        severity: ErrorSeverity.error,
        code: 'UNK001',
        message: error.toString(),
        userMessage: 'An unexpected error occurred.',
      );
      showError(appError, onRetry: onRetry);
      return null;
    }
  }
}
</file>

<file path="frontend/lib/core/theme/app_theme.dart">
import 'package:flutter/material.dart';

/// MessageAI Theme System
/// Monochrome black/white/gray palette for clean, accessible design
class AppTheme {
  // Prevent instantiation
  AppTheme._();

  // ============================================================================
  // COLORS - Grayscale System
  // ============================================================================
  
  /// Pure colors
  static const Color white = Color(0xFFFFFFFF);
  static const Color black = Color(0xFF000000);
  
  /// Gray scale (Light Mode)
  static const Color gray50 = Color(0xFFFAFAFA);   // Almost white
  static const Color gray100 = Color(0xFFF5F5F5);  // Off white
  static const Color gray200 = Color(0xFFEEEEEE);  // Very light gray
  static const Color gray300 = Color(0xFFE0E0E0);  // Light gray
  static const Color gray400 = Color(0xFFBDBDBD);  // Light-medium gray
  static const Color gray500 = Color(0xFF9E9E9E);  // Medium gray
  static const Color gray600 = Color(0xFF757575);  // Medium-dark gray
  static const Color gray700 = Color(0xFF616161);  // Dark gray
  static const Color gray800 = Color(0xFF424242);  // Very dark gray
  static const Color gray900 = Color(0xFF212121);  // Almost black
  
  /// Dark mode grays
  static const Color darkGray100 = Color(0xFF1A1A1A);  // Near black surface
  static const Color darkGray200 = Color(0xFF242424);  // Dark surface
  static const Color darkGray300 = Color(0xFF2E2E2E);  // Medium dark
  static const Color darkGray400 = Color(0xFF3A3A3A);  // Lighter dark
  
  /// Accent colors (minimal use only)
  static const Color accentBlue = Color(0xFF000000);     // Actions, links
  static const Color accentGreen = Color(0xFF4CAF50);    // Online, success
  static const Color accentRed = Color(0xFFF44336);      // Error, urgent
  static const Color accentOrange = Color(0xFFFF9800);   // Warning
  
  // ============================================================================
  // TYPOGRAPHY
  // ============================================================================
  
  /// Font sizes
  static const double fontSizeXXL = 32.0;  // Page titles
  static const double fontSizeXL = 24.0;   // Section headers
  static const double fontSizeL = 20.0;    // Card titles
  static const double fontSizeM = 16.0;    // Body text (BASE)
  static const double fontSizeS = 14.0;    // Captions
  static const double fontSizeXS = 12.0;   // Timestamps
  static const double fontSizeXXS = 10.0;  // Micro-copy
  
  /// Font weights
  static const FontWeight fontWeightLight = FontWeight.w300;
  static const FontWeight fontWeightRegular = FontWeight.w400;
  static const FontWeight fontWeightMedium = FontWeight.w500;
  static const FontWeight fontWeightSemibold = FontWeight.w600;
  static const FontWeight fontWeightBold = FontWeight.w700;
  
  /// Line heights
  static const double lineHeightTight = 1.2;
  static const double lineHeightNormal = 1.5;
  static const double lineHeightRelaxed = 1.75;
  
  // ============================================================================
  // SPACING
  // ============================================================================
  
  /// Base unit: 4px - all spacing uses multiples of this
  static const double spacingXXS = 4.0;
  static const double spacingXS = 8.0;
  static const double spacingS = 12.0;
  static const double spacingM = 16.0;   // Standard spacing (BASE)
  static const double spacingL = 24.0;
  static const double spacingXL = 32.0;
  static const double spacingXXL = 48.0;
  static const double spacingXXXL = 64.0;
  
  // ============================================================================
  // BORDER RADIUS
  // ============================================================================
  
  static const double radiusNone = 0.0;
  static const double radiusXS = 2.0;
  static const double radiusS = 4.0;
  static const double radiusM = 8.0;    // Standard radius (BASE)
  static const double radiusL = 12.0;
  static const double radiusXL = 16.0;
  static const double radiusXXL = 24.0;
  static const double radiusPill = 9999.0;
  
  // ============================================================================
  // SHADOWS
  // ============================================================================
  
  /// Light mode shadows
  static List<BoxShadow> get shadow1Light => [
    BoxShadow(
      color: black.withOpacity(0.12),
      blurRadius: 3,
      offset: const Offset(0, 1),
    ),
    BoxShadow(
      color: black.withOpacity(0.08),
      blurRadius: 2,
      offset: const Offset(0, 1),
    ),
  ];
  
  static List<BoxShadow> get shadow2Light => [
    BoxShadow(
      color: black.withOpacity(0.12),
      blurRadius: 6,
      offset: const Offset(0, 2),
    ),
    BoxShadow(
      color: black.withOpacity(0.08),
      blurRadius: 4,
      offset: const Offset(0, 2),
    ),
  ];
  
  static List<BoxShadow> get shadow3Light => [
    BoxShadow(
      color: black.withOpacity(0.15),
      blurRadius: 12,
      offset: const Offset(0, 4),
    ),
    BoxShadow(
      color: black.withOpacity(0.10),
      blurRadius: 6,
      offset: const Offset(0, 2),
    ),
  ];
  
  /// Dark mode shadows (more subtle)
  static List<BoxShadow> get shadow1Dark => [
    BoxShadow(
      color: black.withOpacity(0.30),
      blurRadius: 3,
      offset: const Offset(0, 1),
    ),
    BoxShadow(
      color: black.withOpacity(0.20),
      blurRadius: 2,
      offset: const Offset(0, 1),
    ),
  ];
  
  static List<BoxShadow> get shadow2Dark => [
    BoxShadow(
      color: black.withOpacity(0.35),
      blurRadius: 6,
      offset: const Offset(0, 2),
    ),
    BoxShadow(
      color: black.withOpacity(0.25),
      blurRadius: 4,
      offset: const Offset(0, 2),
    ),
  ];
  
  // ============================================================================
  // THEME DATA
  // ============================================================================
  
  /// Light theme configuration
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      
      // Color scheme
      colorScheme: const ColorScheme.light(
        primary: accentBlue,
        onPrimary: white,
        secondary: gray900,
        onSecondary: white,
        surface: white,
        onSurface: black,
        surfaceContainerHighest: gray100,
        error: accentRed,
        onError: white,
      ),
      
      // Scaffold
      scaffoldBackgroundColor: white,
      
      // App bar
      appBarTheme: const AppBarTheme(
        backgroundColor: white,
        foregroundColor: black,
        elevation: 0,
        centerTitle: false,
        titleTextStyle: TextStyle(
          color: black,
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
        ),
        iconTheme: IconThemeData(
          color: black,
          size: 24,
        ),
      ),
      
      // Cards
      cardTheme: CardThemeData(
        color: white,
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radiusM),
          side: const BorderSide(color: gray300, width: 1),
        ),
        margin: const EdgeInsets.all(spacingS),
      ),
      
      // Text theme
      textTheme: const TextTheme(
        displayLarge: TextStyle(
          fontSize: fontSizeXXL,
          fontWeight: fontWeightBold,
          color: black,
          height: lineHeightTight,
        ),
        displayMedium: TextStyle(
          fontSize: fontSizeXL,
          fontWeight: fontWeightBold,
          color: black,
          height: lineHeightTight,
        ),
        displaySmall: TextStyle(
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
          color: black,
          height: lineHeightTight,
        ),
        bodyLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightRegular,
          color: black,
          height: lineHeightNormal,
        ),
        bodyMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightRegular,
          color: gray800,
          height: lineHeightNormal,
        ),
        bodySmall: TextStyle(
          fontSize: fontSizeXS,
          fontWeight: fontWeightRegular,
          color: gray600,
          height: lineHeightNormal,
        ),
        labelLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightSemibold,
          color: black,
        ),
        labelMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightMedium,
          color: black,
        ),
      ),
      
      // Buttons
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: accentBlue,
          foregroundColor: white,
          elevation: 0,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingL,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: accentBlue,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingM,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      // FAB
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: black,
        foregroundColor: white,
        elevation: 4,
        shape: CircleBorder(),
      ),
      
      // Input decoration
      inputDecorationTheme: InputDecorationTheme(
        filled: false,
        fillColor: white,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: gray300, width: 1),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: gray300, width: 1),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentBlue, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentRed, width: 1),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: spacingM,
          vertical: spacingS,
        ),
        hintStyle: const TextStyle(color: gray500),
      ),
      
      // Divider
      dividerTheme: const DividerThemeData(
        color: gray300,
        thickness: 1,
        space: 1,
      ),
      
      // Icon theme
      iconTheme: const IconThemeData(
        color: black,
        size: 24,
      ),
    );
  }
  
  /// Dark theme configuration
  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      
      // Color scheme
      colorScheme: const ColorScheme.dark(
        primary: accentBlue,
        onPrimary: black,
        secondary: white,
        onSecondary: black,
        surface: black,
        onSurface: white,
        surfaceContainerHighest: darkGray100,
        error: accentRed,
        onError: black,
      ),
      
      // Scaffold
      scaffoldBackgroundColor: black,
      
      // App bar
      appBarTheme: const AppBarTheme(
        backgroundColor: black,
        foregroundColor: white,
        elevation: 0,
        centerTitle: false,
        titleTextStyle: TextStyle(
          color: white,
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
        ),
        iconTheme: IconThemeData(
          color: white,
          size: 24,
        ),
      ),
      
      // Cards
      cardTheme: CardThemeData(
        color: darkGray100,
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radiusM),
          side: const BorderSide(color: darkGray300, width: 1),
        ),
        margin: const EdgeInsets.all(spacingS),
      ),
      
      // Text theme
      textTheme: const TextTheme(
        displayLarge: TextStyle(
          fontSize: fontSizeXXL,
          fontWeight: fontWeightBold,
          color: white,
          height: lineHeightTight,
        ),
        displayMedium: TextStyle(
          fontSize: fontSizeXL,
          fontWeight: fontWeightBold,
          color: white,
          height: lineHeightTight,
        ),
        displaySmall: TextStyle(
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
          color: white,
          height: lineHeightTight,
        ),
        bodyLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightRegular,
          color: white,
          height: lineHeightNormal,
        ),
        bodyMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightRegular,
          color: gray400,
          height: lineHeightNormal,
        ),
        bodySmall: TextStyle(
          fontSize: fontSizeXS,
          fontWeight: fontWeightRegular,
          color: gray500,
          height: lineHeightNormal,
        ),
        labelLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightSemibold,
          color: white,
        ),
        labelMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightMedium,
          color: white,
        ),
      ),
      
      // Buttons
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: white,
          foregroundColor: black,
          elevation: 0,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingL,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: accentBlue,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingM,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      // FAB
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: white,
        foregroundColor: black,
        elevation: 4,
        shape: CircleBorder(),
      ),
      
      // Input decoration
      inputDecorationTheme: InputDecorationTheme(
        filled: false,
        fillColor: darkGray100,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: darkGray300, width: 1),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: darkGray300, width: 1),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentBlue, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentRed, width: 1),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: spacingM,
          vertical: spacingS,
        ),
        hintStyle: const TextStyle(color: gray600),
      ),
      
      // Divider
      dividerTheme: const DividerThemeData(
        color: darkGray300,
        thickness: 1,
        space: 1,
      ),
      
      // Icon theme
      iconTheme: const IconThemeData(
        color: white,
        size: 24,
      ),
    );
  }
}
</file>

<file path="frontend/lib/data/drift/daos/ai_analysis_dao_cached.dart.backup">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'ai_analysis_dao.g.dart';

/// Data Access Object for AI Analysis operations
@DriftAccessor(tables: [AiAnalysis])
class AIAnalysisDao extends DatabaseAccessor<AppDb> with _$AIAnalysisDaoMixin {
  AIAnalysisDao(AppDb db) : super(db);

  /// Get all AI analyses
  Future<List<AiAnalysi>> getAllAnalyses() {
    return select(aiAnalysis).get();
  }

  /// Get analysis by ID
  Future<AiAnalysi?> getAnalysisById(String id) {
    return (select(aiAnalysis)..where((a) => a.id.equals(id))).getSingleOrNull();
  }

  /// Get analysis for a specific message
  Future<AiAnalysi?> getAnalysisByMessageId(String messageId) {
    return (select(aiAnalysis)..where((a) => a.messageId.equals(messageId)))
        .getSingleOrNull();
  }

  /// Get all analyses for multiple messages
  Future<List<AiAnalysi>> getAnalysesByMessageIds(List<String> messageIds) {
    return (select(aiAnalysis)..where((a) => a.messageId.isIn(messageIds))).get();
  }

  /// Get analyses for a conversation (requires joining with messages)
  /// Note: This is a simple version. For better performance, you might want to
  /// pass in message IDs from the conversation
  Future<List<AiAnalysi>> getAnalysesForConversation(List<String> messageIds) {
    return (select(aiAnalysis)
          ..where((a) => a.messageId.isIn(messageIds))
          ..orderBy([(a) => OrderingTerm.desc(a.analysisTimestamp)]))
        .get();
  }

  /// Add a new analysis
  Future<int> addAnalysis(AiAnalysisCompanion analysis) {
    return into(aiAnalysis).insert(analysis);
  }

  /// Add or update analysis
  Future<void> upsertAnalysis(AiAnalysisCompanion analysis) {
    return into(aiAnalysis).insertOnConflictUpdate(analysis);
  }

  /// Update analysis
  Future<bool> updateAnalysis(AiAnalysi analysis) {
    return update(aiAnalysis).replace(analysis);
  }

  /// Delete analysis
  Future<int> deleteAnalysis(String id) {
    return (delete(aiAnalysis)..where((a) => a.id.equals(id))).go();
  }

  /// Delete analysis by message ID
  Future<int> deleteAnalysisByMessageId(String messageId) {
    return (delete(aiAnalysis)..where((a) => a.messageId.equals(messageId))).go();
  }

  /// Mark analysis as synced
  Future<void> markAsSynced(String id) {
    return (update(aiAnalysis)..where((a) => a.id.equals(id)))
        .write(const AiAnalysisCompanion(isSynced: Value(1)));
  }

  /// Get unsynced analyses
  Future<List<AiAnalysi>> getUnsyncedAnalyses() {
    return (select(aiAnalysis)..where((a) => a.isSynced.equals(0))).get();
  }

  /// Get analyses with specific tone
  Future<List<AiAnalysi>> getAnalysesByTone(String tone) {
    return (select(aiAnalysis)..where((a) => a.tone.equals(tone))).get();
  }

  /// Get analyses with specific urgency level
  Future<List<AiAnalysi>> getAnalysesByUrgencyLevel(String urgencyLevel) {
    return (select(aiAnalysis)
          ..where((a) => a.urgencyLevel.equals(urgencyLevel)))
        .get();
  }

  /// Get analyses with high confidence (> threshold)
  Future<List<AiAnalysi>> getHighConfidenceAnalyses({double threshold = 0.8}) {
    return (select(aiAnalysis)
          ..where((a) => a.confidenceScore.isBiggerOrEqualValue(threshold)))
        .get();
  }

  /// Get recent analyses (within last N seconds)
  Future<List<AiAnalysi>> getRecentAnalyses({int seconds = 3600}) {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final cutoff = now - seconds;
    return (select(aiAnalysis)
          ..where((a) => a.analysisTimestamp.isBiggerOrEqualValue(cutoff))
          ..orderBy([(a) => OrderingTerm.desc(a.analysisTimestamp)]))
        .get();
  }

  /// Delete old analyses (older than N days)
  Future<int> deleteOldAnalyses({int days = 30}) {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final cutoff = now - (days * 24 * 60 * 60);
    return (delete(aiAnalysis)
          ..where((a) => a.analysisTimestamp.isSmallerThanValue(cutoff)))
        .go();
  }

  /// Clear all analyses
  Future<int> clearAllAnalyses() {
    return delete(aiAnalysis).go();
  }

  /// Get analysis count
  Future<int> getAnalysisCount() async {
    final count = countAll();
    final query = selectOnly(aiAnalysis)..addColumns([count]);
    final result = await query.getSingle();
    return result.read(count) ?? 0;
  }

  /// Get analysis count by tone
  Future<Map<String, int>> getAnalysisCountByTone() async {
    final query = selectOnly(aiAnalysis)
      ..addColumns([aiAnalysis.tone, countAll()])
      ..groupBy([aiAnalysis.tone]);

    final results = await query.get();
    return Map.fromEntries(
      results.map((row) {
        final tone = row.read(aiAnalysis.tone) ?? 'Unknown';
        final count = row.read(countAll()) ?? 0;
        return MapEntry(tone, count);
      }),
    );
  }

  /// Stream of all analyses
  Stream<List<AiAnalysi>> watchAllAnalyses() {
    return select(aiAnalysis).watch();
  }

  /// Stream analysis for a specific message
  Stream<AiAnalysi?> watchAnalysisForMessage(String messageId) {
    return (select(aiAnalysis)..where((a) => a.messageId.equals(messageId)))
        .watchSingleOrNull();
  }
}
</file>

<file path="frontend/lib/data/drift/entities/ai_analysis_cached.drift.backup">
-- AI Analysis table for local caching of tone and intent analysis
CREATE TABLE ai_analysis (
  id TEXT PRIMARY KEY NOT NULL,
  message_id TEXT NOT NULL,
  tone TEXT NOT NULL,
  urgency_level TEXT,
  intent TEXT,
  confidence_score REAL,
  analysis_timestamp INTEGER NOT NULL,
  is_synced INTEGER NOT NULL DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

-- Index for efficient lookups by message
CREATE INDEX IF NOT EXISTS idx_ai_analysis_message_id ON ai_analysis(message_id);

-- Index for timestamp queries
CREATE INDEX IF NOT EXISTS idx_ai_analysis_timestamp ON ai_analysis(analysis_timestamp DESC);
</file>

<file path="frontend/lib/features/conversations/widgets/context_preview_card.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/conversation_context.dart';

/// Shows conversation context before opening
class ContextPreviewCard extends StatelessWidget {
  final ConversationContext context;
  final VoidCallback? onTap;

  const ContextPreviewCard({
    Key? key,
    required this.context,
    this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      elevation: 2,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(12),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  const Icon(
                    Icons.history,
                    size: 18,
                    color: Colors.blue,
                  ),
                  const SizedBox(width: 8),
                  const Text(
                    'Last Conversation',
                    style: TextStyle(
                      fontSize: 13,
                      fontWeight: FontWeight.bold,
                      color: Colors.blue,
                    ),
                  ),
                  const Spacer(),
                  if (this.context.fromCache)
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 6,
                        vertical: 2,
                      ),
                      decoration: BoxDecoration(
                        color: Colors.grey.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: const Text(
                        'cached',
                        style: TextStyle(
                          fontSize: 10,
                          color: Colors.grey,
                        ),
                      ),
                    ),
                ],
              ),
              const SizedBox(height: 8),

              // Last discussed
              Text(
                this.context.lastDiscussed,
                style: const TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                ),
              ),

              // Key points
              if (this.context.keyPoints.isNotEmpty) ...[
                const SizedBox(height: 12),
                const Text(
                  'Recent topics:',
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                    color: Colors.grey,
                  ),
                ),
                const SizedBox(height: 6),
                ...this.context.keyPoints.take(3).map((point) => Padding(
                      padding: const EdgeInsets.only(bottom: 4),
                      child: Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            '• ',
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.grey,
                            ),
                          ),
                          Expanded(
                            child: Text(
                              point.text,
                              style: TextStyle(
                                fontSize: 12,
                                color: Colors.grey,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                          const SizedBox(width: 4),
                          Text(
                            point.getTimeAgo(),
                            style: TextStyle(
                              fontSize: 10,
                              color: Colors.grey,
                            ),
                          ),
                        ],
                      ),
                    )),
              ],

              // Pending questions
              if (this.context.pendingQuestions.isNotEmpty) ...[
                const SizedBox(height: 12),
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.orange.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(6),
                  ),
                  child: Row(
                    children: [
                      const Icon(
                        Icons.help_outline,
                        size: 16,
                        color: Colors.orange,
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          '${this.context.pendingQuestions.length} unanswered question${this.context.pendingQuestions.length > 1 ? "s" : ""}',
                          style: const TextStyle(
                            fontSize: 12,
                            color: Colors.orange,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/conversations/widgets/relationship_summary_sheet.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/models/relationship_profile.dart';
import 'package:messageai/models/safe_topic.dart';
import 'package:messageai/services/relationship_service.dart';

/// Bottom sheet showing relationship profile
class RelationshipSummarySheet extends ConsumerStatefulWidget {
  final String conversationId;

  const RelationshipSummarySheet({
    Key? key,
    required this.conversationId,
  }) : super(key: key);

  @override
  ConsumerState<RelationshipSummarySheet> createState() =>
      _RelationshipSummarySheetState();
}

class _RelationshipSummarySheetState
    extends ConsumerState<RelationshipSummarySheet> {
  final relationshipService = RelationshipService();

  RelationshipProfile? profile;
  List<SafeTopic>? safeTopics;
  bool isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadProfile();
  }

  Future<void> _loadProfile() async {
    setState(() => isLoading = true);

    try {
      final results = await Future.wait([
        relationshipService.getProfile(widget.conversationId),
        relationshipService.getSafeTopics(widget.conversationId),
      ]);

      setState(() {
        profile = results[0] as RelationshipProfile?;
        safeTopics = results[1] as List<SafeTopic>?;
        isLoading = false;
      });
    } catch (e) {
      setState(() => isLoading = false);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error loading profile: $e')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
      ),
      child: isLoading
          ? const Center(child: CircularProgressIndicator())
          : profile == null
              ? const Center(child: Text('No profile available'))
              : SingleChildScrollView(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // Header
                      Row(
                        children: [
                          Text(
                            profile!.getRelationshipEmoji(),
                            style: const TextStyle(fontSize: 32),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  profile!.participantName,
                                  style: const TextStyle(
                                    fontSize: 20,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                                if (profile!.relationshipType != null)
                                  Text(
                                    profile!.relationshipType!,
                                    style: TextStyle(
                                      fontSize: 14,
                                      color: Colors.grey,
                                    ),
                                  ),
                              ],
                            ),
                          ),
                          IconButton(
                            icon: const Icon(Icons.close),
                            onPressed: () => Navigator.pop(context),
                          ),
                        ],
                      ),
                      const SizedBox(height: 16),

                      // Summary
                      if (profile!.conversationSummary != null) ...[
                        _buildSection('About This Relationship', [
                          Text(
                            profile!.conversationSummary!,
                            style: const TextStyle(fontSize: 14),
                          ),
                        ]),
                        const SizedBox(height: 16),
                      ],

                      // Communication style
                      if (profile!.communicationStyle != null) ...[
                        _buildSection('Communication Style', [
                          Text(
                            profile!.communicationStyle!,
                            style: const TextStyle(fontSize: 14),
                          ),
                        ]),
                        const SizedBox(height: 16),
                      ],

                      // Response time
                      if (profile!.typicalResponseTime != null) ...[
                        _buildSection('Typical Response Time', [
                          Row(
                            children: [
                              const Icon(Icons.schedule, size: 20),
                              const SizedBox(width: 8),
                              Text(
                                profile!.formatResponseTime(),
                                style: const TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ],
                          ),
                        ]),
                        const SizedBox(height: 16),
                      ],

                      // Safe topics
                      if (profile!.safeTopics.isNotEmpty) ...[
                        _buildSection('Safe Topics', [
                          Wrap(
                            spacing: 8,
                            runSpacing: 8,
                            children: profile!.safeTopics.map((topic) {
                              return Chip(
                                label: Text(
                                  topic,
                                  style: const TextStyle(fontSize: 12),
                                ),
                                backgroundColor: Colors.green.withOpacity(0.1),
                                side: BorderSide(
                                  color: Colors.green.withOpacity(0.3),
                                ),
                              );
                            }).toList(),
                          ),
                        ]),
                        const SizedBox(height: 16),
                      ],

                      // Topics to avoid
                      if (profile!.topicsToAvoid.isNotEmpty) ...[
                        _buildSection('Topics to Avoid', [
                          Wrap(
                            spacing: 8,
                            runSpacing: 8,
                            children: profile!.topicsToAvoid.map((topic) {
                              return Chip(
                                label: Text(
                                  topic,
                                  style: const TextStyle(fontSize: 12),
                                ),
                                backgroundColor: Colors.red.withOpacity(0.1),
                                side: BorderSide(
                                  color: Colors.red.withOpacity(0.3),
                                ),
                              );
                            }).toList(),
                          ),
                        ]),
                        const SizedBox(height: 16),
                      ],

                      // Detailed safe topics
                      if (safeTopics != null && safeTopics!.isNotEmpty) ...[
                        _buildSection('Topic Engagement', [
                          ...safeTopics!.map((topic) => Padding(
                                padding: const EdgeInsets.only(bottom: 8),
                                child: Row(
                                  children: [
                                    Container(
                                      width: 8,
                                      height: 8,
                                      decoration: BoxDecoration(
                                        color: topic.getTopicColor(),
                                        shape: BoxShape.circle,
                                      ),
                                    ),
                                    const SizedBox(width: 8),
                                    Expanded(
                                      child: Text(
                                        topic.topicName,
                                        style: const TextStyle(fontSize: 13),
                                      ),
                                    ),
                                    Text(
                                      topic.getEngagementLabel(),
                                      style: TextStyle(
                                        fontSize: 11,
                                        color: topic.getTopicColor(),
                                        fontWeight: FontWeight.w500,
                                      ),
                                    ),
                                  ],
                                ),
                              )),
                        ]),
                      ],

                      // Stats
                      const SizedBox(height: 16),
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.grey.withOpacity(0.1),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.spaceAround,
                          children: [
                            _buildStat(
                              '${profile!.totalMessages}',
                              'messages',
                            ),
                            if (profile!.firstMessageAt != null)
                              _buildStat(
                                _getTimeSince(profile!.firstMessageAt!),
                                'talking',
                              ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
    );
  }

  Widget _buildSection(String title, List<Widget> children) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.bold,
            color: Colors.grey,
          ),
        ),
        const SizedBox(height: 8),
        ...children,
      ],
    );
  }

  Widget _buildStat(String value, String label) {
    return Column(
      children: [
        Text(
          value,
          style: const TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
        ),
        Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: Colors.grey,
          ),
        ),
      ],
    );
  }

  String _getTimeSince(int timestamp) {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final diff = now - timestamp;

    final days = diff ~/ 86400;
    if (days < 30) return '${days}d';

    final months = days ~/ 30;
    if (months < 12) return '${months}mo';

    final years = months ~/ 12;
    return '${years}yr';
  }
}

/// Show relationship summary sheet
void showRelationshipSummary(BuildContext context, String conversationId) {
  showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    builder: (context) => SizedBox(
      height: MediaQuery.of(context).size.height * 0.8,
      child: RelationshipSummarySheet(conversationId: conversationId),
    ),
  );
}
</file>

<file path="frontend/lib/features/conversations/widgets/who_is_this_button.dart">
import 'package:flutter/material.dart';
import 'package:messageai/features/conversations/widgets/relationship_summary_sheet.dart';

/// Quick access button to see who someone is
class WhoIsThisButton extends StatelessWidget {
  final String conversationId;
  final bool compact;

  const WhoIsThisButton({
    Key? key,
    required this.conversationId,
    this.compact = false,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return compact
        ? IconButton(
            icon: const Icon(Icons.info_outline),
            tooltip: 'Who is this?',
            onPressed: () => _showSummary(context),
          )
        : OutlinedButton.icon(
            icon: const Icon(Icons.info_outline, size: 18),
            label: const Text('Who is this?'),
            onPressed: () => _showSummary(context),
            style: OutlinedButton.styleFrom(
              foregroundColor: Colors.blue,
            ),
          );
  }

  void _showSummary(BuildContext context) {
    showRelationshipSummary(context, conversationId);
  }
}
</file>

<file path="frontend/lib/features/followups/screens/follow_up_dashboard_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/models/follow_up_item.dart';
import 'package:messageai/services/follow_up_service.dart';
import 'package:messageai/features/followups/widgets/follow_up_card.dart';

/// Dashboard showing all pending follow-ups
class FollowUpDashboardScreen extends ConsumerStatefulWidget {
  const FollowUpDashboardScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<FollowUpDashboardScreen> createState() => 
      _FollowUpDashboardScreenState();
}

class _FollowUpDashboardScreenState extends ConsumerState<FollowUpDashboardScreen> {
  final followUpService = FollowUpService();
  
  List<FollowUpItem>? followUps;
  bool isLoading = true;
  String? errorMessage;

  @override
  void initState() {
    super.initState();
    _loadFollowUps();
  }

  Future<void> _loadFollowUps() async {
    setState(() {
      isLoading = true;
      errorMessage = null;
    });

    try {
      final items = await followUpService.getPendingFollowUps();
      setState(() {
        followUps = items;
        isLoading = false;
      });
    } catch (e) {
      setState(() {
        errorMessage = e.toString();
        isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Follow-ups'),
        actions: [
          if (followUps != null && followUps!.isNotEmpty)
            Padding(
              padding: const EdgeInsets.all(16),
              child: Center(
                child: Text(
                  '${followUps!.length}',
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _loadFollowUps,
          ),
        ],
      ),
      body: isLoading
          ? const Center(child: CircularProgressIndicator())
          : errorMessage != null
              ? Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Icon(Icons.error_outline, size: 64, color: Colors.red),
                      const SizedBox(height: 16),
                      Text('Error: $errorMessage'),
                      const SizedBox(height: 16),
                      ElevatedButton(
                        onPressed: _loadFollowUps,
                        child: const Text('Retry'),
                      ),
                    ],
                  ),
                )
              : followUps == null || followUps!.isEmpty
                  ? _buildEmptyState()
                  : _buildFollowUpsList(),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(
            Icons.check_circle_outline,
            size: 80,
            color: Colors.green,
          ),
          const SizedBox(height: 16),
          const Text(
            'All caught up!',
            style: TextStyle(
              fontSize: 24,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'No pending follow-ups',
            style: TextStyle(
              fontSize: 16,
              color: Colors.grey.shade600,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFollowUpsList() {
    // Group by type
    final actionItems = followUps!
        .where((f) => f.itemType == FollowUpItemType.actionItem)
        .toList();
    final questions = followUps!
        .where((f) => f.itemType == FollowUpItemType.unansweredQuestion)
        .toList();
    final pending = followUps!
        .where((f) => f.itemType == FollowUpItemType.pendingResponse)
        .toList();

    return RefreshIndicator(
      onRefresh: _loadFollowUps,
      child: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // Summary stats
          _buildSummaryCard(),
          const SizedBox(height: 16),

          // Overdue items first
          ...followUps!.where((f) => f.isOverdue).map((item) => Padding(
            padding: const EdgeInsets.only(bottom: 12),
            child: FollowUpCard(
              item: item,
              onComplete: () => _handleComplete(item),
              onSnooze: () => _handleSnooze(item),
              onDismiss: () => _handleDismiss(item),
            ),
          )),

          // Due soon
          if (followUps!.any((f) => f.isDueSoon && !f.isOverdue)) ...[
            const SizedBox(height: 8),
            _buildSectionHeader('Due Soon'),
            ...followUps!
                .where((f) => f.isDueSoon && !f.isOverdue)
                .map((item) => Padding(
                  padding: const EdgeInsets.only(bottom: 12),
                  child: FollowUpCard(
                    item: item,
                    onComplete: () => _handleComplete(item),
                    onSnooze: () => _handleSnooze(item),
                    onDismiss: () => _handleDismiss(item),
                  ),
                )),
          ],

          // Action items
          if (actionItems.isNotEmpty) ...[
            const SizedBox(height: 8),
            _buildSectionHeader('Action Items (${actionItems.length})'),
            ...actionItems.map((item) => Padding(
              padding: const EdgeInsets.only(bottom: 12),
              child: FollowUpCard(
                item: item,
                onComplete: () => _handleComplete(item),
                onSnooze: () => _handleSnooze(item),
                onDismiss: () => _handleDismiss(item),
              ),
            )),
          ],

          // Unanswered questions
          if (questions.isNotEmpty) ...[
            const SizedBox(height: 8),
            _buildSectionHeader('Unanswered Questions (${questions.length})'),
            ...questions.map((item) => Padding(
              padding: const EdgeInsets.only(bottom: 12),
              child: FollowUpCard(
                item: item,
                onComplete: () => _handleComplete(item),
                onSnooze: () => _handleSnooze(item),
                onDismiss: () => _handleDismiss(item),
              ),
            )),
          ],

          // Other pending
          if (pending.isNotEmpty) ...[
            const SizedBox(height: 8),
            _buildSectionHeader('Pending Responses (${pending.length})'),
            ...pending.map((item) => Padding(
              padding: const EdgeInsets.only(bottom: 12),
              child: FollowUpCard(
                item: item,
                onComplete: () => _handleComplete(item),
                onSnooze: () => _handleSnooze(item),
                onDismiss: () => _handleDismiss(item),
              ),
            )),
          ],
        ],
      ),
    );
  }

  Widget _buildSummaryCard() {
    final overdueCount = followUps!.where((f) => f.isOverdue).length;
    final dueSoonCount = followUps!.where((f) => f.isDueSoon && !f.isOverdue).length;

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            _buildStat(
              '${followUps!.length}',
              'Total',
              Colors.blue,
            ),
            if (overdueCount > 0)
              _buildStat(
                '$overdueCount',
                'Overdue',
                Colors.red,
              ),
            if (dueSoonCount > 0)
              _buildStat(
                '$dueSoonCount',
                'Due Soon',
                Colors.orange,
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildStat(String value, String label, Color color) {
    return Column(
      children: [
        Text(
          value,
          style: TextStyle(
            fontSize: 24,
            fontWeight: FontWeight.bold,
            color: color,
          ),
        ),
        Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: Colors.grey.shade600,
          ),
        ),
      ],
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Text(
        title,
        style: TextStyle(
          fontSize: 16,
          fontWeight: FontWeight.bold,
          color: Colors.grey.shade700,
        ),
      ),
    );
  }

  Future<void> _handleComplete(FollowUpItem item) async {
    try {
      await followUpService.completeFollowUp(item.id);
      _loadFollowUps();
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Marked as complete')),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    }
  }

  Future<void> _handleSnooze(FollowUpItem item) async {
    final duration = await _showSnoozeDurationPicker();
    if (duration == null) return;

    try {
      await followUpService.snoozeFollowUp(item.id, duration);
      _loadFollowUps();
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Snoozed for ${duration.inHours}h')),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    }
  }

  Future<void> _handleDismiss(FollowUpItem item) async {
    try {
      await followUpService.dismissFollowUp(item.id);
      _loadFollowUps();
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Dismissed')),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    }
  }

  Future<Duration?> _showSnoozeDurationPicker() async {
    return showDialog<Duration>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Snooze for how long?'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              title: const Text('1 hour'),
              onTap: () => Navigator.pop(context, const Duration(hours: 1)),
            ),
            ListTile(
              title: const Text('3 hours'),
              onTap: () => Navigator.pop(context, const Duration(hours: 3)),
            ),
            ListTile(
              title: const Text('Tomorrow'),
              onTap: () => Navigator.pop(context, const Duration(days: 1)),
            ),
            ListTile(
              title: const Text('Next week'),
              onTap: () => Navigator.pop(context, const Duration(days: 7)),
            ),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/followups/widgets/action_item_badge.dart">
import 'package:flutter/material.dart';

/// Badge showing follow-up count in conversations
class ActionItemBadge extends StatelessWidget {
  final int count;
  final VoidCallback? onTap;

  const ActionItemBadge({
    Key? key,
    required this.count,
    this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    if (count == 0) return const SizedBox.shrink();

    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: Colors.orange.withOpacity(0.1),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.orange, width: 1),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(
              Icons.notification_important,
              size: 14,
              color: Colors.orange,
            ),
            const SizedBox(width: 4),
            Text(
              '$count follow-up${count > 1 ? "s" : ""}',
              style: const TextStyle(
                fontSize: 11,
                color: Colors.orange,
                fontWeight: FontWeight.w600,
              ),
            ),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/followups/widgets/follow_up_card.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/follow_up_item.dart';

/// Card displaying a follow-up item
class FollowUpCard extends StatelessWidget {
  final FollowUpItem item;
  final VoidCallback onComplete;
  final VoidCallback onSnooze;
  final VoidCallback onDismiss;

  const FollowUpCard({
    Key? key,
    required this.item,
    required this.onComplete,
    required this.onSnooze,
    required this.onDismiss,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final color = item.itemType.getColor();
    final isOverdue = item.isOverdue;

    return Card(
      elevation: isOverdue ? 4 : 2,
      color: isOverdue ? Colors.red.shade50 : null,
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header
            Row(
              children: [
                Icon(
                  item.itemType.icon,
                  size: 20,
                  color: color,
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    item.title,
                    style: const TextStyle(
                      fontSize: 15,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
                if (item.dueAt != null)
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: isOverdue
                          ? Colors.red.withOpacity(0.2)
                          : item.isDueSoon
                              ? Colors.orange.withOpacity(0.2)
                              : Colors.grey.withOpacity(0.2),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      item.getTimeUntilDue(),
                      style: TextStyle(
                        fontSize: 11,
                        fontWeight: FontWeight.bold,
                        color: isOverdue
                            ? Colors.red
                            : item.isDueSoon
                                ? Colors.orange
                                : Colors.grey,
                      ),
                    ),
                  ),
              ],
            ),

            // Description
            if (item.description != null) ...[
              const SizedBox(height: 8),
              Text(
                item.description!,
                style: TextStyle(
                  fontSize: 13,
                  color: Colors.grey.shade700,
                ),
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
            ],

            // Original text (if action item)
            if (item.extractedText != null &&
                item.itemType == FollowUpItemType.actionItem) ...[
              const SizedBox(height: 8),
              Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: Colors.blue.withOpacity(0.05),
                  borderRadius: BorderRadius.circular(6),
                  border: Border.all(
                    color: Colors.blue.withOpacity(0.2),
                  ),
                ),
                child: Row(
                  children: [
                    const Icon(Icons.format_quote, size: 14, color: Colors.blue),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        item.extractedText!,
                        style: const TextStyle(
                          fontSize: 12,
                          fontStyle: FontStyle.italic,
                        ),
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ),
            ],

            // Metadata
            const SizedBox(height: 8),
            Row(
              children: [
                Icon(Icons.priority_high, size: 14, color: Colors.grey.shade600),
                const SizedBox(width: 4),
                Text(
                  'Priority: ${item.priority}',
                  style: TextStyle(
                    fontSize: 11,
                    color: Colors.grey.shade600,
                  ),
                ),
                const SizedBox(width: 12),
                Icon(Icons.access_time, size: 14, color: Colors.grey.shade600),
                const SizedBox(width: 4),
                Text(
                  item.getTimeSinceDetected(),
                  style: TextStyle(
                    fontSize: 11,
                    color: Colors.grey.shade600,
                  ),
                ),
              ],
            ),

            // Actions
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    icon: const Icon(Icons.check, size: 16),
                    label: const Text('Done', style: TextStyle(fontSize: 12)),
                    onPressed: onComplete,
                    style: OutlinedButton.styleFrom(
                      foregroundColor: Colors.green,
                      padding: const EdgeInsets.symmetric(vertical: 8),
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: OutlinedButton.icon(
                    icon: const Icon(Icons.schedule, size: 16),
                    label: const Text('Snooze', style: TextStyle(fontSize: 12)),
                    onPressed: onSnooze,
                    style: OutlinedButton.styleFrom(
                      foregroundColor: Colors.orange,
                      padding: const EdgeInsets.symmetric(vertical: 8),
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                IconButton(
                  icon: const Icon(Icons.close, size: 20),
                  onPressed: onDismiss,
                  color: Colors.grey,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/ai_insights_background.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';

/// Background panel for AI insights that appears behind the sliding message panel
/// Users can swipe down the message panel to reveal this content
class AIInsightsBackground extends StatelessWidget {
  final String conversationId;
  final double panelPosition;

  const AIInsightsBackground({
    Key? key,
    required this.conversationId,
    this.panelPosition = 0.0,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    // Calculate opacity based on panel position
    // When panel is fully up (position = 1.0), fade out insights
    // When panel is down (position = 0.0), show insights fully
    final opacity = 1.0 - panelPosition;
    
    return Container(
      color: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
      padding: const EdgeInsets.all(AppTheme.spacingL),
      child: SafeArea(
        child: Opacity(
          opacity: opacity.clamp(0.3, 1.0), // Keep minimum visibility
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  Icon(
                    Icons.auto_awesome,
                    size: 28,
                    color: isDark ? AppTheme.white : AppTheme.black,
                  ),
                  const SizedBox(width: AppTheme.spacingS),
                  Text(
                    'AI Insights',
                    style: theme.textTheme.displaySmall?.copyWith(
                      fontWeight: AppTheme.fontWeightBold,
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: AppTheme.spacingXL),
              
              // Placeholder content
              _buildPlaceholderCard(
                context,
                icon: Icons.insights,
                title: 'Tone Analysis',
                description: 'Pull down to see how messages are being interpreted',
                isDark: isDark,
              ),
              
              const SizedBox(height: AppTheme.spacingM),
              
              _buildPlaceholderCard(
                context,
                icon: Icons.lightbulb_outline,
                title: 'Smart Suggestions',
                description: 'AI-powered response recommendations coming soon',
                isDark: isDark,
              ),
              
              const SizedBox(height: AppTheme.spacingM),
              
              _buildPlaceholderCard(
                context,
                icon: Icons.analytics_outlined,
                title: 'Conversation Health',
                description: 'Monitor communication patterns and insights',
                isDark: isDark,
              ),
              
              const Spacer(),
              
              // Hint text
              Center(
                child: Column(
                  children: [
                    Icon(
                      Icons.keyboard_arrow_down,
                      size: 32,
                      color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                    ),
                    const SizedBox(height: AppTheme.spacingXS),
                    Text(
                      'Pull down messages to view insights',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: isDark ? AppTheme.gray600 : AppTheme.gray500,
                      ),
                    ),
                  ],
                ),
              ),
              
              const SizedBox(height: AppTheme.spacingXXL),
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildPlaceholderCard(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String description,
    required bool isDark,
  }) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingS),
            decoration: BoxDecoration(
              color: isDark 
                ? AppTheme.darkGray300 
                : AppTheme.gray100,
              borderRadius: BorderRadius.circular(AppTheme.radiusS),
            ),
            child: Icon(
              icon,
              size: 24,
              color: isDark ? AppTheme.white : AppTheme.black,
            ),
          ),
          const SizedBox(width: AppTheme.spacingM),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: theme.textTheme.labelLarge?.copyWith(
                    fontWeight: AppTheme.fontWeightSemibold,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  description,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/ai_insights_panel.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/state/ai_providers.dart';

/// Enhanced AI insights panel that displays conversation-level analysis
/// Replaces the placeholder background when user pulls down the message panel
class AIInsightsPanel extends ConsumerWidget {
  final String conversationId;
  final List<Message> messages;
  final double panelPosition;

  const AIInsightsPanel({
    Key? key,
    required this.conversationId,
    required this.messages,
    this.panelPosition = 0.0,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    // Calculate opacity based on panel position
    final opacity = 1.0 - panelPosition;
    
    // Fetch analyses for the conversation
    final analysisAsync = ref.watch(
      conversationAnalysisProvider(conversationId),
    );

    return Container(
      color: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
      padding: const EdgeInsets.all(AppTheme.spacingL),
      child: SafeArea(
        child: Opacity(
          opacity: opacity.clamp(0.3, 1.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  Icon(
                    Icons.auto_awesome,
                    size: 28,
                    color: isDark ? AppTheme.white : AppTheme.black,
                  ),
                  const SizedBox(width: AppTheme.spacingS),
                  Text(
                    'AI Insights',
                    style: theme.textTheme.displaySmall?.copyWith(
                      fontWeight: AppTheme.fontWeightBold,
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: AppTheme.spacingXL),
              
              // Analysis content
              Expanded(
                child: analysisAsync.when(
                  data: (analyses) {
                    if (analyses.isEmpty) {
                      return _buildEmptyState(context, isDark);
                    }
                    return _buildAnalysisCards(context, analyses, isDark);
                  },
                  loading: () => _buildLoadingState(context, isDark),
                  error: (error, stack) => _buildErrorState(context, error, isDark),
                ),
              ),
              
              // Hint text
              if (panelPosition > 0.5)
                Center(
                  child: Column(
                    children: [
                      Icon(
                        Icons.keyboard_arrow_down,
                        size: 32,
                        color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                      ),
                      const SizedBox(height: AppTheme.spacingXS),
                      Text(
                        'Pull down to view insights',
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: isDark ? AppTheme.gray600 : AppTheme.gray500,
                        ),
                      ),
                    ],
                  ),
                ),
              
              const SizedBox(height: AppTheme.spacingL),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildAnalysisCards(
    BuildContext context,
    Map<String, AIAnalysis> analyses,
    bool isDark,
  ) {
    final theme = Theme.of(context);
    
    // Calculate summary statistics
    final toneDistribution = <String, int>{};
    int urgentCount = 0;
    double avgConfidence = 0.0;
    
    for (final analysis in analyses.values) {
      toneDistribution[analysis.tone] = (toneDistribution[analysis.tone] ?? 0) + 1;
      if (analysis.urgencyLevel == 'High' || analysis.urgencyLevel == 'Critical') {
        urgentCount++;
      }
      avgConfidence += analysis.confidenceScore ?? 0.0;
    }
    
    if (analyses.isNotEmpty) {
      avgConfidence /= analyses.length;
    }
    
    final mostCommonTone = toneDistribution.entries
        .reduce((a, b) => a.value > b.value ? a : b)
        .key;

    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Overall tone card
          _buildInsightCard(
            context,
            icon: Icons.psychology,
            title: 'Overall Tone',
            value: mostCommonTone,
            description: '${analyses.length} messages analyzed',
            color: AppTheme.accentBlue,
            isDark: isDark,
          ),
          
          const SizedBox(height: AppTheme.spacingM),
          
          // Urgency indicator card
          if (urgentCount > 0)
            _buildInsightCard(
              context,
              icon: Icons.warning_amber,
              title: 'Urgent Messages',
              value: urgentCount.toString(),
              description: 'Requires attention',
              color: AppTheme.accentOrange,
              isDark: isDark,
            ),
          
          if (urgentCount > 0) const SizedBox(height: AppTheme.spacingM),
          
          // Confidence indicator
          _buildInsightCard(
            context,
            icon: Icons.thumb_up_outlined,
            title: 'Analysis Quality',
            value: '${(avgConfidence * 100).round()}%',
            description: 'Average confidence',
            color: avgConfidence > 0.8
                ? AppTheme.accentGreen
                : avgConfidence > 0.6
                    ? AppTheme.accentBlue
                    : AppTheme.accentOrange,
            isDark: isDark,
          ),
          
          const SizedBox(height: AppTheme.spacingM),
          
          // Recent analysis
          if (analyses.isNotEmpty) ...[
            Text(
              'Recent Analysis',
              style: theme.textTheme.labelLarge?.copyWith(
                fontWeight: AppTheme.fontWeightBold,
              ),
            ),
            const SizedBox(height: AppTheme.spacingS),
            ...analyses.entries.take(3).map(
              (entry) => Padding(
                padding: const EdgeInsets.only(bottom: AppTheme.spacingS),
                child: _buildRecentAnalysisItem(
                  context,
                  entry.value,
                  isDark,
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildInsightCard(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String value,
    required String description,
    required Color color,
    required bool isDark,
  }) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingM),
            decoration: BoxDecoration(
              color: color.withOpacity(0.1),
              borderRadius: BorderRadius.circular(AppTheme.radiusS),
            ),
            child: Icon(
              icon,
              size: 24,
              color: color,
            ),
          ),
          const SizedBox(width: AppTheme.spacingM),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  value,
                  style: theme.textTheme.displaySmall?.copyWith(
                    fontWeight: AppTheme.fontWeightBold,
                    color: color,
                  ),
                ),
                Text(
                  description,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray600 : AppTheme.gray500,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildRecentAnalysisItem(
    BuildContext context,
    AIAnalysis analysis,
    bool isDark,
  ) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingS),
      decoration: BoxDecoration(
        color: (isDark ? AppTheme.darkGray100 : AppTheme.white).withOpacity(0.5),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(
          color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Text(
            _getToneEmoji(analysis.tone),
            style: const TextStyle(fontSize: 20),
          ),
          const SizedBox(width: AppTheme.spacingS),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  analysis.tone,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    fontWeight: AppTheme.fontWeightSemibold,
                  ),
                ),
                if (analysis.intent != null)
                  Text(
                    analysis.intent!,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: isDark ? AppTheme.gray600 : AppTheme.gray500,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyState(BuildContext context, bool isDark) {
    final theme = Theme.of(context);
    
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.auto_awesome_outlined,
            size: 64,
            color: isDark ? AppTheme.gray600 : AppTheme.gray400,
          ),
          const SizedBox(height: AppTheme.spacingM),
          Text(
            'No AI analysis yet',
            style: theme.textTheme.titleLarge?.copyWith(
              fontWeight: AppTheme.fontWeightSemibold,
            ),
          ),
          const SizedBox(height: AppTheme.spacingS),
          Text(
            'Send messages to see AI-powered insights',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: isDark ? AppTheme.gray500 : AppTheme.gray600,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildLoadingState(BuildContext context, bool isDark) {
    return const Center(
      child: CircularProgressIndicator(),
    );
  }

  Widget _buildErrorState(BuildContext context, Object error, bool isDark) {
    final theme = Theme.of(context);
    
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.error_outline,
            size: 64,
            color: AppTheme.accentRed,
          ),
          const SizedBox(height: AppTheme.spacingM),
          Text(
            'Error loading insights',
            style: theme.textTheme.titleLarge,
          ),
          const SizedBox(height: AppTheme.spacingS),
          Text(
            error.toString(),
            style: theme.textTheme.bodySmall,
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  String _getToneEmoji(String tone) {
    switch (tone.toLowerCase()) {
      case 'friendly':
        return '😊';
      case 'professional':
        return '💼';
      case 'urgent':
        return '⚡';
      case 'casual':
        return '😎';
      case 'formal':
        return '👔';
      case 'concerned':
        return '😟';
      case 'excited':
        return '🎉';
      case 'neutral':
      default:
        return '💬';
    }
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/draft_feedback_panel.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/draft_analysis.dart';
import 'package:messageai/features/messages/widgets/template_picker.dart';
import 'package:messageai/features/messages/widgets/message_formatter_panel.dart';

/// Collapsible feedback panel for draft message analysis
/// Shows confidence score prominently with progressive disclosure
class DraftFeedbackPanel extends StatefulWidget {
  final DraftAnalysis? analysis;
  final bool isLoading;
  final String? draftMessage; // NEW: For formatting long messages
  final Function(String)? onApplySuggestion;
  final Function(String)? onTemplateSelected; // NEW: For templates
  final VoidCallback? onClose;

  const DraftFeedbackPanel({
    Key? key,
    required this.analysis,
    this.isLoading = false,
    this.draftMessage,
    this.onApplySuggestion,
    this.onTemplateSelected,
    this.onClose,
  }) : super(key: key);

  @override
  State<DraftFeedbackPanel> createState() => _DraftFeedbackPanelState();
}

class _DraftFeedbackPanelState extends State<DraftFeedbackPanel> {
  bool _isExpanded = true;

  @override
  Widget build(BuildContext context) {
    if (widget.isLoading) {
      return _buildLoadingState(context);
    }

    if (widget.analysis == null) {
      return const SizedBox.shrink();
    }

    if (!_isExpanded) {
      return _buildCollapsedState(context, widget.analysis!);
    }

    return _buildExpandedState(context, widget.analysis!);
  }

  Widget _buildLoadingState(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: (isDark ? AppTheme.darkGray200 : AppTheme.gray100),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          const SizedBox(
            width: 20,
            height: 20,
            child: CircularProgressIndicator(strokeWidth: 2),
          ),
          const SizedBox(width: AppTheme.spacingS),
          Text(
            'Checking message...',
            style: theme.textTheme.bodyMedium?.copyWith(
              fontWeight: AppTheme.fontWeightMedium,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCollapsedState(BuildContext context, DraftAnalysis analysis) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final confidenceColor = analysis.getConfidenceColor();

    return GestureDetector(
      onTap: () => setState(() => _isExpanded = true),
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: AppTheme.spacingM,
          vertical: AppTheme.spacingS,
        ),
        decoration: BoxDecoration(
          color: confidenceColor.withOpacity(0.1),
          borderRadius: BorderRadius.circular(AppTheme.radiusM),
          border: Border.all(color: confidenceColor.withOpacity(0.3)),
        ),
        child: Row(
          children: [
            Icon(
              analysis.getAppropriatenessIcon(),
              color: confidenceColor,
              size: 20,
            ),
            const SizedBox(width: AppTheme.spacingS),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    '${analysis.confidenceScore}% Confidence',
                    style: theme.textTheme.titleSmall?.copyWith(
                      color: confidenceColor,
                      fontWeight: AppTheme.fontWeightBold,
                    ),
                  ),
                  Text(
                    analysis.getStatusMessage(),
                    style: theme.textTheme.bodySmall,
                  ),
                ],
              ),
            ),
            Icon(
              Icons.expand_more,
              color: isDark ? AppTheme.gray500 : AppTheme.gray600,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildExpandedState(BuildContext context, DraftAnalysis analysis) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final confidenceColor = analysis.getConfidenceColor();

    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: confidenceColor.withOpacity(0.1),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(color: confidenceColor.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          // Header with confidence score and collapse button
          Row(
            children: [
              Icon(
                analysis.getAppropriatenessIcon(),
                color: confidenceColor,
                size: 24,
              ),
              const SizedBox(width: AppTheme.spacingS),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      '${analysis.confidenceScore}% Confidence',
                      style: theme.textTheme.titleMedium?.copyWith(
                        color: confidenceColor,
                        fontWeight: AppTheme.fontWeightBold,
                      ),
                    ),
                    Text(
                      '${analysis.tone} • ${analysis.appropriateness.displayName}',
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                      ),
                    ),
                  ],
                ),
              ),
              IconButton(
                icon: const Icon(Icons.expand_less, size: 20),
                onPressed: () => setState(() => _isExpanded = false),
                tooltip: 'Minimize',
              ),
              if (widget.onClose != null)
                IconButton(
                  icon: const Icon(Icons.close, size: 20),
                  onPressed: widget.onClose,
                  tooltip: 'Close',
                ),
            ],
          ),

          const SizedBox(height: AppTheme.spacingM),

          // Strengths (always show if present)
          if (analysis.strengths.isNotEmpty) ...[
            _buildSection(
              context,
              '✅ Strengths',
              analysis.strengths,
              Colors.green,
              showApplyButton: false,
            ),
            const SizedBox(height: AppTheme.spacingS),
          ],

          // Warnings (show if present)
          if (analysis.warnings.isNotEmpty) ...[
            _buildSection(
              context,
              '⚠️ Watch Out',
              analysis.warnings,
              Colors.orange,
              showApplyButton: false,
            ),
            const SizedBox(height: AppTheme.spacingS),
          ],

          // Suggestions with Apply buttons
          if (analysis.suggestions.isNotEmpty) ...[
            _buildSection(
              context,
              '💡 Suggestions',
              analysis.suggestions,
              Colors.blue,
              showApplyButton: widget.onApplySuggestion != null,
            ),
            const SizedBox(height: AppTheme.spacingS),
          ],

          // ✅ NEW: Situation Detection
          if (analysis.situationDetection != null) ...[
            _buildSituationSection(context, analysis),
            const SizedBox(height: AppTheme.spacingS),
          ],

          // ✅ NEW: Suggested Templates
          if (analysis.suggestedTemplates != null &&
              analysis.suggestedTemplates!.isNotEmpty) ...[
            _buildTemplatesSection(context, analysis),
            const SizedBox(height: AppTheme.spacingS),
          ],

          // ✅ NEW: Message Too Long Warning
          if (widget.draftMessage != null && widget.draftMessage!.length > 500) ...[
            _buildFormattingSection(context),
            const SizedBox(height: AppTheme.spacingS),
          ],

          // Reasoning (collapsible)
          if (analysis.reasoning != null && analysis.reasoning!.isNotEmpty) ...[
            Theme(
              data: Theme.of(context).copyWith(dividerColor: Colors.transparent),
              child: ExpansionTile(
                tilePadding: EdgeInsets.zero,
                title: Text(
                  'Why this score?',
                  style: theme.textTheme.labelMedium?.copyWith(
                    fontWeight: AppTheme.fontWeightMedium,
                    color: isDark ? AppTheme.gray400 : AppTheme.gray700,
                  ),
                ),
                children: [
                  Padding(
                    padding: const EdgeInsets.only(bottom: AppTheme.spacingS),
                    child: Text(
                      analysis.reasoning!,
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildSection(
    BuildContext context,
    String title,
    List<String> items,
    Color color, {
    required bool showApplyButton,
  }) {
    final theme = Theme.of(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: theme.textTheme.labelMedium?.copyWith(
            color: color,
            fontWeight: AppTheme.fontWeightBold,
          ),
        ),
        const SizedBox(height: AppTheme.spacingXS),
        ...items.map((item) => Padding(
              padding: const EdgeInsets.only(top: AppTheme.spacingXXS),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Padding(
                    padding: const EdgeInsets.only(top: 2),
                    child: Text(
                      '• ',
                      style: TextStyle(
                        color: color,
                        fontSize: AppTheme.fontSizeS,
                      ),
                    ),
                  ),
                  Expanded(
                    child: Text(
                      item,
                      style: theme.textTheme.bodySmall,
                    ),
                  ),
                  if (showApplyButton && widget.onApplySuggestion != null) ...[
                    const SizedBox(width: AppTheme.spacingXS),
                    TextButton(
                      onPressed: () => widget.onApplySuggestion!(item),
                      style: TextButton.styleFrom(
                        padding: const EdgeInsets.symmetric(
                          horizontal: AppTheme.spacingS,
                          vertical: AppTheme.spacingXXS,
                        ),
                        minimumSize: Size.zero,
                        tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                      ),
                      child: Text(
                        'Apply',
                        style: TextStyle(
                          fontSize: AppTheme.fontSizeXS,
                          color: color,
                        ),
                      ),
                    ),
                  ],
                ],
              ),
            )),
      ],
    );
  }

  // ✅ NEW: Build situation detection section
  Widget _buildSituationSection(BuildContext context, DraftAnalysis analysis) {
    final detection = analysis.situationDetection!;
    final color = detection.situationType.getColor();
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingS),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(detection.situationType.icon, size: 18, color: color),
              const SizedBox(width: AppTheme.spacingXS),
              Text(
                'Detected: ${detection.situationType.displayName}',
                style: theme.textTheme.labelMedium?.copyWith(
                  fontWeight: AppTheme.fontWeightBold,
                  color: color,
                ),
              ),
              const Spacer(),
              Text(
                '${(detection.confidence * 100).toInt()}%',
                style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey),
              ),
            ],
          ),
          const SizedBox(height: AppTheme.spacingXXS),
          Text(
            detection.reasoning,
            style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey),
          ),
        ],
      ),
    );
  }

  // ✅ NEW: Build templates section
  Widget _buildTemplatesSection(BuildContext context, DraftAnalysis analysis) {
    final theme = Theme.of(context);
    final templates = analysis.suggestedTemplates!.take(3).toList();

    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingS),
      decoration: BoxDecoration(
        color: Colors.blue.withOpacity(0.05),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(color: Colors.blue.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const Icon(Icons.lightbulb, size: 18, color: Colors.blue),
              const SizedBox(width: AppTheme.spacingXS),
              Text(
                'Suggested Templates',
                style: theme.textTheme.labelMedium?.copyWith(
                  fontWeight: AppTheme.fontWeightBold,
                  color: Colors.blue,
                ),
              ),
            ],
          ),
          const SizedBox(height: AppTheme.spacingXS),
          ...templates.map((template) => Padding(
            padding: const EdgeInsets.only(top: AppTheme.spacingXXS),
            child: InkWell(
              onTap: () {
                showTemplatePicker(
                  context,
                  analysis.situationDetection?.situationType,
                  (selectedText) {
                    if (widget.onTemplateSelected != null) {
                      widget.onTemplateSelected!(selectedText);
                    }
                  },
                );
              },
              child: Row(
                children: [
                  const Icon(Icons.arrow_forward, size: 14, color: Colors.blue),
                  const SizedBox(width: AppTheme.spacingXXS),
                  Expanded(
                    child: Text(
                      template.name,
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: Colors.blue,
                        decoration: TextDecoration.underline,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          )),
          const SizedBox(height: AppTheme.spacingS),
          SizedBox(
            width: double.infinity,
            child: OutlinedButton(
              onPressed: () {
                showTemplatePicker(
                  context,
                  analysis.situationDetection?.situationType,
                  (selectedText) {
                    if (widget.onTemplateSelected != null) {
                      widget.onTemplateSelected!(selectedText);
                    }
                  },
                );
              },
              style: OutlinedButton.styleFrom(
                padding: const EdgeInsets.symmetric(
                  vertical: AppTheme.spacingXS,
                ),
                side: const BorderSide(color: Colors.blue),
              ),
              child: const Text(
                'Browse All Templates',
                style: TextStyle(fontSize: AppTheme.fontSizeXS),
              ),
            ),
          ),
        ],
      ),
    );
  }

  // ✅ NEW: Build formatting warning section
  Widget _buildFormattingSection(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingS),
      decoration: BoxDecoration(
        color: Colors.orange.withOpacity(0.1),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(color: Colors.orange.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const Icon(Icons.warning_amber, size: 18, color: Colors.orange),
              const SizedBox(width: AppTheme.spacingXS),
              Text(
                'Long Message Detected',
                style: theme.textTheme.labelMedium?.copyWith(
                  fontWeight: AppTheme.fontWeightBold,
                  color: Colors.orange,
                ),
              ),
            ],
          ),
          const SizedBox(height: AppTheme.spacingXXS),
          Text(
            'This message might be overwhelming. Consider formatting it.',
            style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey),
          ),
          const SizedBox(height: AppTheme.spacingS),
          SizedBox(
            width: double.infinity,
            child: OutlinedButton(
              onPressed: () {
                showDialog(
                  context: context,
                  builder: (context) => Dialog(
                    child: MessageFormatterPanel(
                      originalMessage: widget.draftMessage!,
                      onFormatted: (formatted) {
                        if (widget.onTemplateSelected != null) {
                          widget.onTemplateSelected!(formatted);
                        }
                        Navigator.pop(context);
                      },
                    ),
                  ),
                );
              },
              style: OutlinedButton.styleFrom(
                padding: const EdgeInsets.symmetric(
                  vertical: AppTheme.spacingXS,
                ),
                side: const BorderSide(color: Colors.orange),
              ),
              child: const Text(
                'Format Message',
                style: TextStyle(fontSize: AppTheme.fontSizeXS),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/evidence_viewer.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Widget showing evidence that supports the tone analysis
class EvidenceViewer extends StatefulWidget {
  final List<Evidence> evidence;

  const EvidenceViewer({super.key, required this.evidence});

  @override
  State<EvidenceViewer> createState() => _EvidenceViewerState();
}

class _EvidenceViewerState extends State<EvidenceViewer> {
  bool _expanded = false;

  @override
  Widget build(BuildContext context) {
    if (widget.evidence.isEmpty) {
      return Container(
        padding: const EdgeInsets.all(10),
        decoration: BoxDecoration(
          color: Colors.grey.withOpacity(0.1),
          borderRadius: BorderRadius.circular(6),
        ),
        child: const Row(
          children: [
            Icon(Icons.info_outline, size: 16, color: Colors.grey),
            SizedBox(width: 8),
            Expanded(
              child: Text(
                'No specific evidence found in message',
                style: TextStyle(fontSize: 12, color: Colors.grey),
              ),
            ),
          ],
        ),
      );
    }

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.teal.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.teal.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          InkWell(
            onTap: () => setState(() => _expanded = !_expanded),
            child: Row(
              children: [
                const Icon(Icons.search, color: Colors.teal, size: 20),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    'Evidence (${widget.evidence.length})',
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      color: Colors.teal,
                    ),
                  ),
                ),
                Icon(
                  _expanded ? Icons.expand_less : Icons.expand_more,
                  color: Colors.teal,
                ),
              ],
            ),
          ),
          if (_expanded) ...[
            const SizedBox(height: 12),
            const Text(
              'Specific evidence supporting this analysis:',
              style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic),
            ),
            const SizedBox(height: 8),
            
            // Evidence items
            ...widget.evidence.map((evidence) => Padding(
              padding: const EdgeInsets.only(bottom: 8),
              child: _EvidenceItem(evidence: evidence),
            )),
          ],
        ],
      ),
    );
  }
}

class _EvidenceItem extends StatelessWidget {
  final Evidence evidence;

  const _EvidenceItem({required this.evidence});

  @override
  Widget build(BuildContext context) {
    final typeColor = _getTypeColor(evidence.type);
    final typeIcon = _getTypeIcon(evidence.type);

    return Container(
      padding: const EdgeInsets.all(10),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(6),
        border: Border.all(color: typeColor.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Type and quote
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Icon(typeIcon, size: 16, color: typeColor),
              const SizedBox(width: 8),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                      decoration: BoxDecoration(
                        color: typeColor.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(3),
                      ),
                      child: Text(
                        evidence.type.toUpperCase(),
                        style: TextStyle(
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                          color: typeColor,
                        ),
                      ),
                    ),
                    const SizedBox(height: 6),
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      decoration: BoxDecoration(
                        color: Colors.grey.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(4),
                      ),
                      child: Text(
                        '"${evidence.quote}"',
                        style: const TextStyle(
                          fontSize: 13,
                          fontWeight: FontWeight.w600,
                          fontFamily: 'monospace',
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          
          // What it supports
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Icon(Icons.arrow_forward, size: 14, color: Colors.grey),
              const SizedBox(width: 6),
              Expanded(
                child: Text(
                  'Supports: ${evidence.supports}',
                  style: const TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                    color: Colors.black87,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 4),
          
          // Reasoning
          Padding(
            padding: const EdgeInsets.only(left: 20),
            child: Text(
              evidence.reasoning,
              style: const TextStyle(
                fontSize: 11,
                color: Colors.black54,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Color _getTypeColor(String type) {
    switch (type) {
      case 'keyword':
        return Colors.blue;
      case 'punctuation':
        return Colors.orange;
      case 'emoji':
        return Colors.pink;
      case 'length':
        return Colors.purple;
      case 'pattern':
        return Colors.teal;
      case 'timing':
        return Colors.amber;
      default:
        return Colors.grey;
    }
  }

  IconData _getTypeIcon(String type) {
    switch (type) {
      case 'keyword':
        return Icons.text_fields;
      case 'punctuation':
        return Icons.format_quote;
      case 'emoji':
        return Icons.emoji_emotions;
      case 'length':
        return Icons.straighten;
      case 'pattern':
        return Icons.pattern;
      case 'timing':
        return Icons.access_time;
      default:
        return Icons.info;
    }
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/interpretation_options.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Widget showing alternative interpretations for ambiguous messages
class InterpretationOptions extends StatefulWidget {
  final List<MessageInterpretation> interpretations;

  const InterpretationOptions({super.key, required this.interpretations});

  @override
  State<InterpretationOptions> createState() => _InterpretationOptionsState();
}

class _InterpretationOptionsState extends State<InterpretationOptions> {
  bool _expanded = false;

  @override
  Widget build(BuildContext context) {
    if (widget.interpretations.isEmpty) return const SizedBox.shrink();

    // Sort by likelihood (highest first)
    final sorted = List<MessageInterpretation>.from(widget.interpretations)
      ..sort((a, b) => b.likelihood.compareTo(a.likelihood));

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.purple.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.purple.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          InkWell(
            onTap: () => setState(() => _expanded = !_expanded),
            child: Row(
              children: [
                const Icon(Icons.lightbulb_outline, color: Colors.purple, size: 20),
                const SizedBox(width: 8),
                const Expanded(
                  child: Text(
                    'Alternative Interpretations',
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                      color: Colors.purple,
                    ),
                  ),
                ),
                Icon(
                  _expanded ? Icons.expand_less : Icons.expand_more,
                  color: Colors.purple,
                ),
              ],
            ),
          ),
          if (_expanded) ...[
            const SizedBox(height: 12),
            const Text(
              'This message could be interpreted in multiple ways:',
              style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic),
            ),
            const SizedBox(height: 8),
            
            // Interpretations
            ...sorted.asMap().entries.map((entry) {
              final index = entry.key;
              final interp = entry.value;
              return Padding(
                padding: const EdgeInsets.only(bottom: 12),
                child: _InterpretationCard(
                  interpretation: interp,
                  rank: index + 1,
                ),
              );
            }),
          ],
        ],
      ),
    );
  }
}

class _InterpretationCard extends StatelessWidget {
  final MessageInterpretation interpretation;
  final int rank;

  const _InterpretationCard({
    required this.interpretation,
    required this.rank,
  });

  @override
  Widget build(BuildContext context) {
    Color likelihoodColor;
    if (interpretation.isLikely) {
      likelihoodColor = Colors.green;
    } else if (interpretation.isPossible) {
      likelihoodColor = Colors.orange;
    } else {
      likelihoodColor = Colors.grey;
    }

    return Container(
      padding: const EdgeInsets.all(10),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(6),
        border: Border.all(color: likelihoodColor.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Rank and likelihood
          Row(
            children: [
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: likelihoodColor.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Text(
                  '#$rank',
                  style: TextStyle(
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                    color: likelihoodColor,
                  ),
                ),
              ),
              const SizedBox(width: 8),
              Text(
                '${interpretation.likelihood}% likely',
                style: TextStyle(
                  fontSize: 12,
                  fontWeight: FontWeight.w600,
                  color: likelihoodColor,
                ),
              ),
              const Spacer(),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                decoration: BoxDecoration(
                  color: Colors.grey.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Text(
                  interpretation.tone,
                  style: const TextStyle(
                    fontSize: 11,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          
          // Interpretation text
          Text(
            interpretation.interpretation,
            style: const TextStyle(
              fontSize: 13,
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 6),
          
          // Reasoning
          Text(
            interpretation.reasoning,
            style: const TextStyle(
              fontSize: 12,
              color: Colors.black87,
            ),
          ),
          
          // Context clues
          if (interpretation.contextClues.isNotEmpty) ...[
            const SizedBox(height: 6),
            Wrap(
              spacing: 4,
              runSpacing: 4,
              children: interpretation.contextClues.map((clue) {
                return Container(
                  padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                  decoration: BoxDecoration(
                    color: Colors.blue.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(3),
                  ),
                  child: Text(
                    clue,
                    style: const TextStyle(
                      fontSize: 10,
                      color: Colors.blue,
                    ),
                  ),
                );
              }).toList(),
            ),
          ],
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/message_formatter_panel.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/services/message_formatter_service.dart';
import 'package:messageai/models/formatted_message.dart';

/// Panel for formatting long messages
class MessageFormatterPanel extends ConsumerStatefulWidget {
  final String originalMessage;
  final Function(String) onFormatted;

  const MessageFormatterPanel({
    super.key,
    required this.originalMessage,
    required this.onFormatted,
  });

  @override
  ConsumerState<MessageFormatterPanel> createState() => 
      _MessageFormatterPanelState();
}

class _MessageFormatterPanelState extends ConsumerState<MessageFormatterPanel> {
  late final MessageFormatterService formatterService;
  
  bool condense = false;
  bool chunk = false;
  bool addTldr = false;
  bool addStructure = false;
  
  FormattedMessage? formattedResult;
  bool isFormatting = false;

  @override
  void initState() {
    super.initState();
    formatterService = MessageFormatterService(Supabase.instance.client);
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      constraints: const BoxConstraints(maxHeight: 600),
      child: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header
            Row(
              children: [
                const Icon(Icons.auto_fix_high, color: Colors.purple, size: 20),
                const SizedBox(width: 8),
                const Text(
                  'Message Formatter',
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 16,
                  ),
                ),
                const Spacer(),
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () => Navigator.pop(context),
                ),
              ],
            ),
            Text(
              'Original: ${widget.originalMessage.length} characters',
              style: const TextStyle(
                fontSize: 12,
                color: Colors.grey,
              ),
            ),
            const SizedBox(height: 4),
            const Text(
              'Make your message more digestible',
              style: TextStyle(
                fontSize: 13,
                color: Colors.grey,
              ),
            ),
            const SizedBox(height: 16),

            // Formatting options
            CheckboxListTile(
              title: const Text('Condense', style: TextStyle(fontSize: 14)),
              subtitle: const Text(
                'Reduce length while keeping key points (50-70% shorter)',
                style: TextStyle(fontSize: 11),
              ),
              value: condense,
              dense: true,
              onChanged: (value) => setState(() => condense = value!),
            ),
            CheckboxListTile(
              title: const Text('Break into Chunks', style: TextStyle(fontSize: 14)),
              subtitle: const Text(
                'Add sections with headers for easier reading',
                style: TextStyle(fontSize: 11),
              ),
              value: chunk,
              dense: true,
              onChanged: (value) => setState(() => chunk = value!),
            ),
            CheckboxListTile(
              title: const Text('Add TL;DR', style: TextStyle(fontSize: 14)),
              subtitle: const Text(
                'Brief 1-2 sentence summary at the top',
                style: TextStyle(fontSize: 11),
              ),
              value: addTldr,
              dense: true,
              onChanged: (value) => setState(() => addTldr = value!),
            ),
            CheckboxListTile(
              title: const Text('Add Structure', style: TextStyle(fontSize: 14)),
              subtitle: const Text(
                'Headings, bullets, and emphasis for clarity',
                style: TextStyle(fontSize: 11),
              ),
              value: addStructure,
              dense: true,
              onChanged: (value) => setState(() => addStructure = value!),
            ),

            const SizedBox(height: 16),

            // Format button
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: isFormatting ? null : _formatMessage,
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.purple,
                ),
                child: isFormatting
                    ? const SizedBox(
                        width: 16,
                        height: 16,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          color: Colors.white,
                        ),
                      )
                    : const Text('Format Message'),
              ),
            ),

            // Result preview
            if (formattedResult != null) ...[
              const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.green.shade50,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.green.shade300),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        const Text(
                          'Formatted Result',
                          style: TextStyle(
                            fontSize: 13,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const Spacer(),
                        Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 8,
                            vertical: 4,
                          ),
                          decoration: BoxDecoration(
                            color: Colors.green,
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Text(
                            '-${formattedResult!.getSavingsPercentage().toStringAsFixed(0)}% shorter',
                            style: const TextStyle(
                              fontSize: 10,
                              fontWeight: FontWeight.bold,
                              color: Colors.white,
                            ),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Text(
                      '${formattedResult!.characterCount} chars • ${formattedResult!.estimatedReadTime}',
                      style: const TextStyle(
                        fontSize: 11,
                        color: Colors.grey,
                      ),
                    ),
                    const SizedBox(height: 8),
                    ConstrainedBox(
                      constraints: const BoxConstraints(maxHeight: 150),
                      child: SingleChildScrollView(
                        child: Text(
                          formattedResult!.formattedMessage,
                          style: const TextStyle(fontSize: 12),
                        ),
                      ),
                    ),
                    const SizedBox(height: 12),
                    Row(
                      children: [
                        Expanded(
                          child: OutlinedButton(
                            onPressed: () {
                              // Show full preview
                              showDialog(
                                context: context,
                                builder: (context) => AlertDialog(
                                  title: const Text('Formatted Message'),
                                  content: SingleChildScrollView(
                                    child: Text(formattedResult!.formattedMessage),
                                  ),
                                  actions: [
                                    TextButton(
                                      onPressed: () => Navigator.pop(context),
                                      child: const Text('Close'),
                                    ),
                                  ],
                                ),
                              );
                            },
                            child: const Text('Preview Full', style: TextStyle(fontSize: 12)),
                          ),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: ElevatedButton(
                            onPressed: () {
                              widget.onFormatted(formattedResult!.formattedMessage);
                              Navigator.pop(context);
                            },
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.purple,
                            ),
                            child: const Text('Use This', style: TextStyle(fontSize: 12)),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Future<void> _formatMessage() async {
    if (!condense && !chunk && !addTldr && !addStructure) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Select at least one formatting option')),
      );
      return;
    }

    setState(() => isFormatting = true);

    try {
      final result = await formatterService.formatMessage(
        message: widget.originalMessage,
        condense: condense,
        chunk: chunk,
        addTldr: addTldr,
        addStructure: addStructure,
      );

      if (mounted) {
        setState(() {
          formattedResult = result;
          isFormatting = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() => isFormatting = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error formatting message: $e')),
        );
      }
    }
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/message_list_panel.dart">
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/features/messages/widgets/tone_detail_sheet.dart';
import 'package:messageai/state/ai_providers.dart';
import 'package:messageai/widgets/user_avatar.dart';

/// Panel containing the message list and compose bar
/// This widget slides up and down over the AI insights background
class MessageListPanel extends ConsumerWidget {
  final List<Message> messages;
  final String? currentUserId;
  final Map<String, List<Receipt>> receiptsCache;
  final Set<String> typingUsers;
  final Set<String> onlineUsers;
  final TextEditingController messageController;
  final bool isSending;
  final bool isUploadingImage;
  final XFile? selectedImage;
  final VoidCallback onSendMessage;
  final VoidCallback onPickImage;
  final VoidCallback onClearImage;

  const MessageListPanel({
    Key? key,
    required this.messages,
    required this.currentUserId,
    required this.receiptsCache,
    required this.typingUsers,
    required this.onlineUsers,
    required this.messageController,
    required this.isSending,
    required this.isUploadingImage,
    required this.selectedImage,
    required this.onSendMessage,
    required this.onPickImage,
    required this.onClearImage,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    return Column(
      children: [
        // Message list
        Expanded(
          child: messages.isEmpty
              ? Center(
                  child: Text(
                    'No messages yet. Start the conversation!',
                    style: theme.textTheme.bodyMedium,
                  ),
                )
              : ListView.builder(
                  reverse: true,
                  padding: const EdgeInsets.symmetric(
                    vertical: AppTheme.spacingS,
                    horizontal: AppTheme.spacingXS,
                  ),
                  itemCount: messages.length + (typingUsers.isNotEmpty ? 1 : 0),
                  itemBuilder: (context, index) {
                    // Show typing indicator as first item (at bottom)
                    if (index == 0 && typingUsers.isNotEmpty) {
                      return _buildTypingIndicator(context, isDark);
                    }
                    
                    // Adjust index if typing indicator is showing
                    final messageIndex = typingUsers.isNotEmpty ? index - 1 : index;
                    final message = messages[messages.length - 1 - messageIndex];
                    final isOwn = message.senderId == currentUserId;
                    final isOnline = onlineUsers.contains(message.senderId);

                    return _buildMessageBubble(
                      context,
                      ref,
                      message,
                      isOwn,
                      isOnline,
                      isDark,
                    );
                  },
                ),
        ),
        
        // Compose bar
        _buildComposeBar(context, isDark),
      ],
    );
  }
  
  Widget _buildMessageBubble(
    BuildContext context,
    WidgetRef ref,
    Message message,
    bool isOwn,
    bool isOnline,
    bool isDark,
  ) {
    // Fetch AI analysis for this message
    final analysisAsync = ref.watch(messageAnalysisProvider(message.id));
    return Align(
      alignment: isOwn ? Alignment.centerRight : Alignment.centerLeft,
      child: Row(
        mainAxisAlignment: isOwn ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          // Show avatar for other users' messages (left side)
          if (!isOwn) ...[
            Padding(
              padding: const EdgeInsets.only(
                left: AppTheme.spacingS,
                right: AppTheme.spacingXXS,
                bottom: AppTheme.spacingXXS,
              ),
              child: Stack(
                children: [
                  UserAvatar(
                    userId: message.senderId,
                    fallbackText: message.senderId.substring(0, 1).toUpperCase(),
                    radius: 16,
                  ),
                  Positioned(
                    right: 0,
                    bottom: 0,
                    child: Container(
                      width: 12,
                      height: 12,
                      decoration: BoxDecoration(
                        color: isOnline ? AppTheme.accentGreen : AppTheme.gray500,
                        shape: BoxShape.circle,
                        border: Border.all(
                          color: isDark ? AppTheme.black : AppTheme.white,
                          width: 2,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
          
          // Message bubble
          Container(
            constraints: BoxConstraints(
              maxWidth: MediaQuery.of(context).size.width * 0.65,
            ),
            margin: EdgeInsets.only(
              left: isOwn ? 64 : 0,
              right: isOwn ? AppTheme.spacingS : 64,
              top: AppTheme.spacingXXS,
              bottom: AppTheme.spacingXXS,
            ),
            padding: const EdgeInsets.symmetric(
              horizontal: AppTheme.spacingS,
              vertical: AppTheme.spacingS,
            ),
            decoration: BoxDecoration(
              color: isOwn
                  ? (isDark ? AppTheme.darkGray300 : AppTheme.gray200)
                  : (isDark ? AppTheme.darkGray100 : AppTheme.white),
              borderRadius: BorderRadius.only(
                topLeft: const Radius.circular(AppTheme.radiusXL),
                topRight: const Radius.circular(AppTheme.radiusXL),
                bottomLeft: Radius.circular(isOwn ? AppTheme.radiusXL : AppTheme.radiusXS),
                bottomRight: Radius.circular(isOwn ? AppTheme.radiusXS : AppTheme.radiusXL),
              ),
              border: !isOwn
                  ? Border.all(
                      color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                      width: 1,
                    )
                  : null,
            ),
            child: Column(
              crossAxisAlignment: isOwn ? CrossAxisAlignment.end : CrossAxisAlignment.start,
              children: [
                // Show image if present
                if (message.mediaUrl != null && message.mediaUrl!.isNotEmpty) ...[
                  ClipRRect(
                    borderRadius: BorderRadius.circular(AppTheme.radiusS),
                    child: Image.network(
                      message.mediaUrl!,
                      width: 250,
                      fit: BoxFit.cover,
                      loadingBuilder: (context, child, loadingProgress) {
                        if (loadingProgress == null) return child;
                        return Container(
                          width: 250,
                          height: 250,
                          color: isDark ? AppTheme.darkGray200 : AppTheme.gray200,
                          child: Center(
                            child: CircularProgressIndicator(
                              value: loadingProgress.expectedTotalBytes != null
                                  ? loadingProgress.cumulativeBytesLoaded /
                                      loadingProgress.expectedTotalBytes!
                                  : null,
                            ),
                          ),
                        );
                      },
                      errorBuilder: (context, error, stackTrace) {
                        return Container(
                          width: 250,
                          height: 250,
                          color: isDark ? AppTheme.darkGray200 : AppTheme.gray200,
                          child: const Icon(Icons.broken_image, size: 50),
                        );
                      },
                    ),
                  ),
                  const SizedBox(height: AppTheme.spacingXXS),
                ],
                
                // Message text
                Text(
                  message.body,
                  style: TextStyle(
                    color: isDark ? AppTheme.white : AppTheme.black,
                    fontSize: AppTheme.fontSizeM,
                    height: AppTheme.lineHeightNormal,
                  ),
                ),
                
                const SizedBox(height: AppTheme.spacingXXS),
                
                // Timestamp and delivery indicator
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      _formatTime(message.createdAt),
                      style: TextStyle(
                        fontSize: AppTheme.fontSizeXS,
                        color: isDark ? AppTheme.gray600 : AppTheme.gray600,
                      ),
                    ),
                    if (isOwn) ...[
                      const SizedBox(width: AppTheme.spacingXXS),
                      _buildDeliveryIndicator(message),
                    ],
                  ],
                ),
                
                // AI Analysis Badge (shows tone analysis if available)
                analysisAsync.when(
                  data: (analysis) {
                    if (analysis == null) return const SizedBox.shrink();
                    return Padding(
                      padding: const EdgeInsets.only(top: 8),
                      child: ToneBadge(
                        analysis: analysis,
                        onTap: () => ToneDetailSheet.show(
                          context,
                          analysis,
                          message.body,
                        ),
                      ),
                    );
                  },
                  loading: () => const SizedBox.shrink(),
                  error: (_, __) => const SizedBox.shrink(),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildTypingIndicator(BuildContext context, bool isDark) {
    final count = typingUsers.length;
    final text = count == 1 
        ? 'Someone is typing...' 
        : '$count people are typing...';
    
    return Padding(
      padding: const EdgeInsets.symmetric(
        horizontal: AppTheme.spacingM,
        vertical: AppTheme.spacingS,
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.symmetric(
              horizontal: AppTheme.spacingS,
              vertical: AppTheme.spacingS,
            ),
            decoration: BoxDecoration(
              color: isDark ? AppTheme.darkGray100 : AppTheme.white,
              borderRadius: BorderRadius.circular(AppTheme.radiusM),
              border: Border.all(
                color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                width: 1,
              ),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  text,
                  style: TextStyle(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                    fontSize: AppTheme.fontSizeS,
                    fontStyle: FontStyle.italic,
                  ),
                ),
                const SizedBox(width: AppTheme.spacingS),
                SizedBox(
                  width: 20,
                  height: 20,
                  child: _TypingAnimation(isDark: isDark),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildComposeBar(BuildContext context, bool isDark) {
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingS),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        border: Border(
          top: BorderSide(
            color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
            width: 1,
          ),
        ),
      ),
      child: SafeArea(
        top: false,
        child: Column(
          children: [
            // Show selected image preview
            if (selectedImage != null) ...[
              Container(
                padding: const EdgeInsets.all(AppTheme.spacingS),
                child: Stack(
                  children: [
                    ClipRRect(
                      borderRadius: BorderRadius.circular(AppTheme.radiusS),
                      child: Image.file(
                        File(selectedImage!.path),
                        height: 150,
                        width: 150,
                        fit: BoxFit.cover,
                      ),
                    ),
                    Positioned(
                      top: AppTheme.spacingXXS,
                      right: AppTheme.spacingXXS,
                      child: GestureDetector(
                        onTap: onClearImage,
                        child: Container(
                          decoration: BoxDecoration(
                            color: AppTheme.black.withOpacity(0.6),
                            shape: BoxShape.circle,
                          ),
                          padding: const EdgeInsets.all(AppTheme.spacingXXS),
                          child: const Icon(
                            Icons.close,
                            color: AppTheme.white,
                            size: 20,
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
            
            // Input row
            Row(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                // Image picker button
                IconButton(
                  onPressed: isUploadingImage || isSending ? null : onPickImage,
                  icon: Icon(
                    Icons.image,
                    color: isUploadingImage || isSending
                        ? (isDark ? AppTheme.gray600 : AppTheme.gray400)
                        : AppTheme.accentBlue,
                  ),
                  padding: const EdgeInsets.all(AppTheme.spacingS),
                ),
                
                const SizedBox(width: AppTheme.spacingXXS),
                
                // Text input
                Expanded(
                  child: Container(
                    decoration: BoxDecoration(
                      color: isDark ? AppTheme.darkGray200 : AppTheme.gray100,
                      borderRadius: BorderRadius.circular(AppTheme.radiusXL),
                      border: Border.all(
                        color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                        width: 1,
                      ),
                    ),
                    padding: const EdgeInsets.symmetric(
                      horizontal: AppTheme.spacingM,
                    ),
                    child: TextField(
                      controller: messageController,
                      enabled: !isSending && !isUploadingImage,
                      decoration: const InputDecoration(
                        hintText: 'Message',
                        border: InputBorder.none,
                        contentPadding: EdgeInsets.symmetric(
                          vertical: AppTheme.spacingS,
                        ),
                      ),
                      maxLines: 5,
                      minLines: 1,
                      textCapitalization: TextCapitalization.sentences,
                      style: TextStyle(
                        color: isDark ? AppTheme.white : AppTheme.black,
                      ),
                    ),
                  ),
                ),
                
                const SizedBox(width: AppTheme.spacingS),
                
                // Send button
                Container(
                  decoration: BoxDecoration(
                    color: isDark ? AppTheme.white : AppTheme.black,
                    shape: BoxShape.circle,
                  ),
                  child: IconButton(
                    onPressed: (isSending || isUploadingImage) ? null : onSendMessage,
                    icon: (isSending || isUploadingImage)
                        ? SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              color: isDark ? AppTheme.black : AppTheme.white,
                            ),
                          )
                        : Icon(
                            Icons.send,
                            size: 20,
                            color: isDark ? AppTheme.black : AppTheme.white,
                          ),
                    padding: const EdgeInsets.all(AppTheme.spacingS),
                    constraints: const BoxConstraints(),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildDeliveryIndicator(Message message) {
    final receipts = receiptsCache[message.id] ?? [];
    
    // Filter out own receipts (shouldn't exist for sent messages, but just in case)
    final otherReceipts = receipts.where((r) => r.userId != currentUserId).toList();
    
    final hasDelivered = otherReceipts.any((r) => r.status == 'delivered' || r.status == 'read');
    final hasRead = otherReceipts.any((r) => r.status == 'read');

    IconData icon;
    Color color;

    if (hasRead) {
      icon = Icons.done_all;
      color = AppTheme.accentBlue;
    } else if (hasDelivered) {
      icon = Icons.done_all;
      color = AppTheme.gray600;
    } else {
      icon = Icons.done;
      color = AppTheme.gray600;
    }

    return Icon(
      icon,
      size: 14,
      color: color,
    );
  }
  
  String _formatTime(int timestamp) {
    final dateTime = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);
    final hour = dateTime.hour.toString().padLeft(2, '0');
    final minute = dateTime.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }
}

/// Animated typing indicator dots
class _TypingAnimation extends StatefulWidget {
  final bool isDark;
  
  const _TypingAnimation({required this.isDark});

  @override
  State<_TypingAnimation> createState() => _TypingAnimationState();
}

class _TypingAnimationState extends State<_TypingAnimation>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1000),
    )..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return Row(
          mainAxisSize: MainAxisSize.min,
          children: List.generate(3, (index) {
            final delay = index * 0.2;
            final value = (_controller.value - delay) % 1.0;
            final opacity = value < 0.5 ? value * 2 : (1 - value) * 2;
            
            return Container(
              width: 4,
              height: 4,
              margin: const EdgeInsets.symmetric(horizontal: 1),
              decoration: BoxDecoration(
                color: (widget.isDark ? AppTheme.gray600 : AppTheme.gray600)
                    .withOpacity(opacity),
                shape: BoxShape.circle,
              ),
            );
          }),
        );
      },
    );
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/relationship_type_selector.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/draft_analysis.dart';

/// Simple dialog for selecting relationship type
class RelationshipTypeSelector extends StatelessWidget {
  final RelationshipType currentType;
  final Function(RelationshipType) onSelected;

  const RelationshipTypeSelector({
    Key? key,
    required this.currentType,
    required this.onSelected,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AlertDialog(
      title: const Text('Set Relationship Type'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: RelationshipType.values.map((type) {
          final isSelected = type == currentType;
          return ListTile(
            leading: Icon(
              type.icon,
              color: isSelected ? AppTheme.accentBlue : null,
            ),
            title: Text(
              type.displayName,
              style: isSelected
                  ? TextStyle(
                      color: AppTheme.accentBlue,
                      fontWeight: AppTheme.fontWeightBold,
                    )
                  : null,
            ),
            trailing: isSelected
                ? const Icon(Icons.check, color: AppTheme.accentBlue)
                : null,
            onTap: () {
              onSelected(type);
              Navigator.pop(context);
            },
          );
        }).toList(),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Cancel'),
        ),
      ],
    );
  }

  static Future<void> show(
    BuildContext context,
    RelationshipType currentType,
    Function(RelationshipType) onSelected,
  ) {
    return showDialog(
      context: context,
      builder: (context) => RelationshipTypeSelector(
        currentType: currentType,
        onSelected: onSelected,
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/rsd_alert_card.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Alert card for RSD triggers
class RSDAlertCard extends StatelessWidget {
  final List<RSDTrigger> triggers;

  const RSDAlertCard({super.key, required this.triggers});

  @override
  Widget build(BuildContext context) {
    if (triggers.isEmpty) return const SizedBox.shrink();

    final highSeverity = triggers.any((t) => t.isHighSeverity);

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: highSeverity 
            ? Colors.orange.withOpacity(0.1)
            : Colors.blue.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: highSeverity 
              ? Colors.orange.withOpacity(0.5)
              : Colors.blue.withOpacity(0.5),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Row(
            children: [
              Icon(
                highSeverity ? Icons.warning_amber : Icons.info_outline,
                color: highSeverity ? Colors.orange : Colors.blue,
                size: 20,
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  'RSD Alert: This might not be what it seems',
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                    color: highSeverity ? Colors.orange : Colors.blue,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          
          // Triggers
          ...triggers.map((trigger) => Padding(
            padding: const EdgeInsets.only(bottom: 8),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  '📌 "${trigger.pattern}"',
                  style: const TextStyle(
                    fontWeight: FontWeight.w600,
                    fontSize: 13,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  '⚠️ ${trigger.explanation}',
                  style: const TextStyle(fontSize: 12),
                ),
                const SizedBox(height: 4),
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.green.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Row(
                    children: [
                      const Icon(Icons.check_circle, size: 16, color: Colors.green),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          trigger.reassurance,
                          style: const TextStyle(
                            fontSize: 12,
                            color: Colors.green,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          )),
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/template_picker.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/models/response_template.dart';
import 'package:messageai/models/situation_type.dart';
import 'package:messageai/services/response_template_service.dart';

/// Widget for picking and using response templates
class TemplatePicker extends ConsumerStatefulWidget {
  final SituationType? detectedSituation;
  final Function(String) onTemplateSelected;

  const TemplatePicker({
    super.key,
    this.detectedSituation,
    required this.onTemplateSelected,
  });

  @override
  ConsumerState<TemplatePicker> createState() => _TemplatePickerState();
}

class _TemplatePickerState extends ConsumerState<TemplatePicker> {
  final templateService = ResponseTemplateService();
  ResponseTemplate? selectedTemplate;
  final Map<String, TextEditingController> _fieldControllers = {};

  @override
  void initState() {
    super.initState();
    templateService.loadTemplates();
  }

  @override
  void dispose() {
    // Dispose all controllers
    for (final controller in _fieldControllers.values) {
      controller.dispose();
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final templates = widget.detectedSituation != null
        ? templateService.getTemplatesForSituation(widget.detectedSituation!)
        : templateService.getAllTemplates();

    if (templates.isEmpty) {
      return const SizedBox.shrink();
    }

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).scaffoldBackgroundColor,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 10,
            offset: const Offset(0, -2),
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Row(
            children: [
              Icon(
                widget.detectedSituation?.icon ?? Icons.lightbulb,
                color: widget.detectedSituation?.getColor() ?? Colors.blue,
              ),
              const SizedBox(width: 8),
              const Expanded(
                child: Text(
                  'Response Templates',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              IconButton(
                icon: const Icon(Icons.close),
                onPressed: () => Navigator.pop(context),
              ),
            ],
          ),
          
          if (widget.detectedSituation != null) ...[
            const SizedBox(height: 8),
            Text(
              'Detected: ${widget.detectedSituation!.displayName}',
              style: const TextStyle(
                fontSize: 13,
                color: Colors.grey,
              ),
            ),
          ],
          
          const SizedBox(height: 16),

          // Template list
          Expanded(
            child: ListView.builder(
              itemCount: templates.length,
              itemBuilder: (context, index) {
                final template = templates[index];
                final isSelected = selectedTemplate?.id == template.id;

                return Card(
                  margin: const EdgeInsets.only(bottom: 8),
                  elevation: isSelected ? 4 : 1,
                  color: isSelected ? Colors.blue.shade50 : null,
                  child: ListTile(
                    title: Text(
                      template.name,
                      style: TextStyle(
                        fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                      ),
                    ),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const SizedBox(height: 4),
                        Text(
                          template.situation,
                          style: const TextStyle(fontSize: 12),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          template.template,
                          style: const TextStyle(
                            fontSize: 11,
                            fontStyle: FontStyle.italic,
                            color: Colors.grey,
                          ),
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ],
                    ),
                    trailing: Icon(
                      isSelected ? Icons.check_circle : Icons.chevron_right,
                      color: isSelected ? Colors.blue : null,
                    ),
                    onTap: () {
                      setState(() {
                        selectedTemplate = template;
                        // Initialize controllers for this template's fields
                        _fieldControllers.clear();
                        if (template.customizableFields != null) {
                          for (final field in template.customizableFields!) {
                            _fieldControllers[field] = TextEditingController();
                          }
                        }
                      });
                    },
                  ),
                );
              },
            ),
          ),

          // Customization section (if template selected with fields)
          if (selectedTemplate != null &&
              selectedTemplate!.customizableFields != null &&
              selectedTemplate!.customizableFields!.isNotEmpty) ...[
            const SizedBox(height: 16),
            const Text(
              'Fill in the blanks:',
              style: TextStyle(
                fontSize: 14,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            ...selectedTemplate!.customizableFields!.map((field) {
              return Padding(
                padding: const EdgeInsets.only(bottom: 8),
                child: TextField(
                  controller: _fieldControllers[field],
                  decoration: InputDecoration(
                    labelText: field.replaceAll('_', ' ').toUpperCase(),
                    border: const OutlineInputBorder(),
                    isDense: true,
                  ),
                  onChanged: (_) => setState(() {}),
                ),
              );
            }),
          ],

          // Preview and use button
          if (selectedTemplate != null) ...[
            const SizedBox(height: 16),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.grey.shade200,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Preview:',
                    style: TextStyle(
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    _getPreviewText(),
                    style: const TextStyle(fontSize: 13),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () {
                  final filledTemplate = _getPreviewText();
                  widget.onTemplateSelected(filledTemplate);
                  Navigator.pop(context);
                },
                child: const Text('Use This Template'),
              ),
            ),
          ],
        ],
      ),
    );
  }

  String _getPreviewText() {
    if (selectedTemplate == null) return '';
    
    final values = <String, String>{};
    for (final entry in _fieldControllers.entries) {
      values[entry.key] = entry.value.text;
    }
    
    return selectedTemplate!.fillTemplate(values);
  }
}

/// Show template picker as bottom sheet
void showTemplatePicker(
  BuildContext context,
  SituationType? detectedSituation,
  Function(String) onTemplateSelected,
) {
  showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    builder: (context) => SizedBox(
      height: MediaQuery.of(context).size.height * 0.7,
      child: TemplatePicker(
        detectedSituation: detectedSituation,
        onTemplateSelected: onTemplateSelected,
      ),
    ),
  );
}
</file>

<file path="frontend/lib/features/messages/widgets/tone_badge.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/ai_analysis.dart';

/// A small badge widget that displays tone analysis for a message
/// Appears at the bottom-right of message bubbles
class ToneBadge extends StatelessWidget {
  final AIAnalysis analysis;
  final VoidCallback? onTap;

  const ToneBadge({
    Key? key,
    required this.analysis,
    this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    final toneInfo = _getToneInfo(analysis.tone);
    final urgencyColor = _getUrgencyColor(analysis.urgencyLevel);

    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: AppTheme.spacingXS,
          vertical: AppTheme.spacingXXS,
        ),
        decoration: BoxDecoration(
          color: (isDark ? AppTheme.darkGray200 : AppTheme.gray100)
              .withOpacity(0.9),
          borderRadius: BorderRadius.circular(AppTheme.radiusS),
          border: Border.all(
            color: urgencyColor.withOpacity(0.3),
            width: 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              toneInfo.emoji,
              style: const TextStyle(fontSize: 12),
            ),
            const SizedBox(width: AppTheme.spacingXXS),
            Text(
              toneInfo.label,
              style: TextStyle(
                fontSize: AppTheme.fontSizeXXS,
                fontWeight: AppTheme.fontWeightMedium,
                color: isDark ? AppTheme.white : AppTheme.black,
              ),
            ),
            // ✅ NEW: Show intensity dot
            if (analysis.intensity != null) ...[
              const SizedBox(width: AppTheme.spacingXXS),
              Container(
                width: 6,
                height: 6,
                decoration: BoxDecoration(
                  color: _getIntensityColor(analysis.intensity!),
                  shape: BoxShape.circle,
                ),
              ),
            ],
            // Existing urgency dot
            if (analysis.urgencyLevel != null && analysis.urgencyLevel != 'Low') ...[
              const SizedBox(width: AppTheme.spacingXXS),
              Container(
                width: 6,
                height: 6,
                decoration: BoxDecoration(
                  color: urgencyColor,
                  shape: BoxShape.circle,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  ToneInfo _getToneInfo(String tone) {
    switch (tone.toLowerCase()) {
      // Original 8
      case 'friendly':
        return ToneInfo(emoji: '😊', label: 'Friendly');
      case 'professional':
        return ToneInfo(emoji: '💼', label: 'Professional');
      case 'urgent':
        return ToneInfo(emoji: '⚠️', label: 'Urgent');
      case 'casual':
        return ToneInfo(emoji: '😎', label: 'Casual');
      case 'formal':
        return ToneInfo(emoji: '🎩', label: 'Formal');
      case 'concerned':
        return ToneInfo(emoji: '😟', label: 'Concerned');
      case 'excited':
        return ToneInfo(emoji: '🎉', label: 'Excited');
      case 'neutral':
        return ToneInfo(emoji: '😐', label: 'Neutral');
      
      // ✅ NEW: 15 additional tones
      case 'apologetic':
        return ToneInfo(emoji: '🙏', label: 'Apologetic');
      case 'appreciative':
        return ToneInfo(emoji: '🙌', label: 'Appreciative');
      case 'frustrated':
        return ToneInfo(emoji: '😤', label: 'Frustrated');
      case 'playful':
        return ToneInfo(emoji: '😜', label: 'Playful');
      case 'sarcastic':
        return ToneInfo(emoji: '🙄', label: 'Sarcastic');
      case 'empathetic':
        return ToneInfo(emoji: '🤗', label: 'Empathetic');
      case 'inquisitive':
        return ToneInfo(emoji: '🤔', label: 'Inquisitive');
      case 'assertive':
        return ToneInfo(emoji: '💪', label: 'Assertive');
      case 'tentative':
        return ToneInfo(emoji: '😬', label: 'Tentative');
      case 'defensive':
        return ToneInfo(emoji: '🛡️', label: 'Defensive');
      case 'encouraging':
        return ToneInfo(emoji: '💚', label: 'Encouraging');
      case 'disappointed':
        return ToneInfo(emoji: '😞', label: 'Disappointed');
      case 'overwhelmed':
        return ToneInfo(emoji: '😵', label: 'Overwhelmed');
      case 'relieved':
        return ToneInfo(emoji: '😌', label: 'Relieved');
      case 'confused':
        return ToneInfo(emoji: '😕', label: 'Confused');
      
      default:
        return ToneInfo(emoji: '💬', label: 'Neutral');
    }
  }

  Color _getUrgencyColor(String? urgencyLevel) {
    if (urgencyLevel == null) return AppTheme.gray500;
    
    switch (urgencyLevel.toLowerCase()) {
      case 'critical':
        return AppTheme.accentRed;
      case 'high':
        return AppTheme.accentOrange;
      case 'medium':
        return AppTheme.accentBlue;
      case 'low':
      default:
        return AppTheme.accentGreen;
    }
  }

  // ✅ NEW: Helper for intensity colors
  Color _getIntensityColor(String intensity) {
    switch (intensity.toLowerCase()) {
      case 'very_high':
        return Colors.red;
      case 'high':
        return Colors.orange;
      case 'medium':
        return Colors.blue;
      case 'low':
        return Colors.green;
      case 'very_low':
        return Colors.grey;
      default:
        return Colors.grey;
    }
  }
}

class ToneInfo {
  final String emoji;
  final String label;

  ToneInfo({required this.emoji, required this.label});
}
</file>

<file path="frontend/lib/features/messages/widgets/tone_detail_sheet.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/features/messages/widgets/rsd_alert_card.dart';
import 'package:messageai/features/messages/widgets/interpretation_options.dart';
import 'package:messageai/features/messages/widgets/evidence_viewer.dart';

/// Bottom sheet showing detailed tone analysis
class ToneDetailSheet extends StatelessWidget {
  final AIAnalysis analysis;
  final String messageBody;

  const ToneDetailSheet({
    Key? key,
    required this.analysis,
    required this.messageBody,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingL),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(AppTheme.radiusXL),
          topRight: Radius.circular(AppTheme.radiusXL),
        ),
      ),
      child: SafeArea(
        top: false,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Handle bar
            Center(
              child: Container(
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                  borderRadius: BorderRadius.circular(AppTheme.radiusPill),
                ),
              ),
            ),
            
            const SizedBox(height: AppTheme.spacingL),
            
            // Header
            Row(
              children: [
                Icon(
                  Icons.psychology,
                  size: 28,
                  color: isDark ? AppTheme.white : AppTheme.black,
                ),
                const SizedBox(width: AppTheme.spacingS),
                Text(
                  'AI Analysis',
                  style: theme.textTheme.displaySmall?.copyWith(
                    fontWeight: AppTheme.fontWeightBold,
                  ),
                ),
              ],
            ),
            
            const SizedBox(height: AppTheme.spacingL),
            
            // Message preview
            _buildSection(
              context,
              'Message',
              messageBody.length > 100
                  ? '${messageBody.substring(0, 100)}...'
                  : messageBody,
              Icons.chat_bubble_outline,
              isDark,
            ),
            
            const SizedBox(height: AppTheme.spacingM),
            
            // ✅ PHASE 1: RSD Alert
            if (analysis.rsdTriggers != null && analysis.rsdTriggers!.isNotEmpty) ...[
              RSDAlertCard(triggers: analysis.rsdTriggers!),
              const SizedBox(height: AppTheme.spacingM),
            ],
            
            // Tone
            _buildSection(
              context,
              'Tone',
              analysis.tone,
              Icons.sentiment_satisfied,
              isDark,
              highlight: true,
            ),
            
            const SizedBox(height: AppTheme.spacingM),
            
            // Urgency
            if (analysis.urgencyLevel != null)
              _buildSection(
                context,
                'Urgency Level',
                analysis.urgencyLevel!,
                Icons.priority_high,
                isDark,
                color: _getUrgencyColor(analysis.urgencyLevel),
              ),
            
            if (analysis.urgencyLevel != null)
              const SizedBox(height: AppTheme.spacingM),
            
            // Intent
            if (analysis.intent != null)
              _buildSection(
                context,
                'Intent',
                analysis.intent!,
                Icons.lightbulb_outline,
                isDark,
              ),
            
            if (analysis.intent != null)
              const SizedBox(height: AppTheme.spacingM),
            
            // Confidence
            if (analysis.confidenceScore != null) ...[
              _buildConfidenceBar(
                context,
                analysis.confidenceScore!,
                isDark,
              ),
              const SizedBox(height: AppTheme.spacingM),
            ],
            
            // ✅ NEW: Intensity section
            if (analysis.intensity != null) ...[
              _buildSection(
                context,
                'Intensity',
                _formatIntensity(analysis.intensity!),
                Icons.trending_up,
                isDark,
              ),
              const SizedBox(height: AppTheme.spacingM),
            ],
            
            // ✅ NEW: Context flags
            if (analysis.contextFlags != null && analysis.contextFlags!.isNotEmpty) ...[
              _buildContextFlags(context, analysis.contextFlags!, isDark),
              const SizedBox(height: AppTheme.spacingM),
            ],
            
            // ✅ NEW: Anxiety assessment
            if (analysis.anxietyAssessment != null) ...[
              _buildAnxietyAssessment(context, analysis.anxietyAssessment!, isDark),
              const SizedBox(height: AppTheme.spacingM),
            ],
            
            // ✅ PHASE 1: Alternative Interpretations
            if (analysis.alternativeInterpretations != null && 
                analysis.alternativeInterpretations!.isNotEmpty) ...[
              InterpretationOptions(interpretations: analysis.alternativeInterpretations!),
              const SizedBox(height: AppTheme.spacingM),
            ],
            
            // ✅ PHASE 1: Evidence
            if (analysis.evidence != null) ...[
              EvidenceViewer(evidence: analysis.evidence!),
              const SizedBox(height: AppTheme.spacingL),
            ],
            
            // Feedback section
            _buildFeedbackSection(context, isDark),
            
            const SizedBox(height: AppTheme.spacingM),
            
            // Close button
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () => Navigator.pop(context),
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(
                    vertical: AppTheme.spacingM,
                  ),
                ),
                child: const Text('Close'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSection(
    BuildContext context,
    String label,
    String value,
    IconData icon,
    bool isDark, {
    bool highlight = false,
    Color? color,
  }) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: highlight
            ? (isDark ? AppTheme.darkGray200 : AppTheme.gray100)
            : (isDark ? AppTheme.darkGray200.withOpacity(0.5) : AppTheme.gray50),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: color ?? (isDark ? AppTheme.darkGray300 : AppTheme.gray300),
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingS),
            decoration: BoxDecoration(
              color: (color ?? (isDark ? AppTheme.darkGray300 : AppTheme.gray200))
                  .withOpacity(0.3),
              borderRadius: BorderRadius.circular(AppTheme.radiusS),
            ),
            child: Icon(
              icon,
              size: 20,
              color: color ?? (isDark ? AppTheme.white : AppTheme.black),
            ),
          ),
          const SizedBox(width: AppTheme.spacingM),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  label,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                    fontWeight: AppTheme.fontWeightMedium,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  value,
                  style: theme.textTheme.bodyLarge?.copyWith(
                    fontWeight: AppTheme.fontWeightSemibold,
                    color: color,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildConfidenceBar(
    BuildContext context,
    double confidence,
    bool isDark,
  ) {
    final theme = Theme.of(context);
    final percentage = (confidence * 100).round();
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Confidence',
              style: theme.textTheme.bodySmall?.copyWith(
                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                fontWeight: AppTheme.fontWeightMedium,
              ),
            ),
            Text(
              '$percentage%',
              style: theme.textTheme.bodySmall?.copyWith(
                fontWeight: AppTheme.fontWeightBold,
              ),
            ),
          ],
        ),
        const SizedBox(height: AppTheme.spacingXS),
        ClipRRect(
          borderRadius: BorderRadius.circular(AppTheme.radiusPill),
          child: LinearProgressIndicator(
            value: confidence,
            minHeight: 8,
            backgroundColor: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
            valueColor: AlwaysStoppedAnimation<Color>(
              confidence > 0.8
                  ? AppTheme.accentGreen
                  : confidence > 0.6
                      ? AppTheme.accentBlue
                      : AppTheme.accentOrange,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildFeedbackSection(BuildContext context, bool isDark) {
    final theme = Theme.of(context);
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Was this analysis helpful?',
          style: theme.textTheme.bodySmall?.copyWith(
            color: isDark ? AppTheme.gray500 : AppTheme.gray600,
            fontWeight: AppTheme.fontWeightMedium,
          ),
        ),
        const SizedBox(height: AppTheme.spacingXS),
        Row(
          children: [
            OutlinedButton.icon(
              onPressed: () {
                // TODO: Implement feedback logic
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Thanks for your feedback!')),
                );
              },
              icon: const Icon(Icons.thumb_up_outlined, size: 18),
              label: const Text('Helpful'),
              style: OutlinedButton.styleFrom(
                side: BorderSide(
                  color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                ),
              ),
            ),
            const SizedBox(width: AppTheme.spacingS),
            OutlinedButton.icon(
              onPressed: () {
                // TODO: Implement feedback logic
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Thanks for your feedback!')),
                );
              },
              icon: const Icon(Icons.thumb_down_outlined, size: 18),
              label: const Text('Not helpful'),
              style: OutlinedButton.styleFrom(
                side: BorderSide(
                  color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                ),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Color _getUrgencyColor(String? urgencyLevel) {
    if (urgencyLevel == null) return AppTheme.gray500;
    
    switch (urgencyLevel.toLowerCase()) {
      case 'critical':
        return AppTheme.accentRed;
      case 'high':
        return AppTheme.accentOrange;
      case 'medium':
        return AppTheme.accentBlue;
      case 'low':
      default:
        return AppTheme.accentGreen;
    }
  }

  // ✅ NEW: Helper methods for enhanced fields
  String _formatIntensity(String intensity) {
    return intensity.replaceAll('_', ' ').split(' ').map((word) => 
      word[0].toUpperCase() + word.substring(1)
    ).join(' ');
  }

  Widget _buildContextFlags(BuildContext context, Map<String, dynamic> flags, bool isDark) {
    final activeFlags = flags.entries
        .where((e) => e.value == true)
        .map((e) => _formatFlag(e.key))
        .toList();
    
    if (activeFlags.isEmpty) return const SizedBox.shrink();
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: Colors.blue.withOpacity(0.1),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: Colors.blue.withOpacity(0.3),
        ),
      ),
      child: Row(
        children: [
          Icon(
            Icons.info_outline,
            size: 20,
            color: Colors.blue,
          ),
          const SizedBox(width: AppTheme.spacingS),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Context Flags',
                  style: TextStyle(
                    fontSize: AppTheme.fontSizeXS,
                    fontWeight: AppTheme.fontWeightBold,
                    color: Colors.blue,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  activeFlags.join(', '),
                  style: TextStyle(fontSize: AppTheme.fontSizeXS),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  String _formatFlag(String flag) {
    return flag.replaceAll('_', ' ').split(' ').map((word) => 
      word[0].toUpperCase() + word.substring(1)
    ).join(' ');
  }

  Widget _buildAnxietyAssessment(BuildContext context, Map<String, dynamic> assessment, bool isDark) {
    final riskLevel = assessment['risk_level'] as String?;
    final suggestions = (assessment['mitigation_suggestions'] as List<dynamic>?)
        ?.map((e) => e as String)
        .toList() ?? [];
    
    if (riskLevel == null) return const SizedBox.shrink();
    
    final riskColor = _getRiskColor(riskLevel);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: riskColor.withOpacity(0.1),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(color: riskColor),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.psychology, size: 20, color: riskColor),
              const SizedBox(width: AppTheme.spacingS),
              Text(
                'Response Anxiety: ${riskLevel.toUpperCase()}',
                style: TextStyle(
                  fontWeight: AppTheme.fontWeightBold,
                  color: riskColor,
                ),
              ),
            ],
          ),
          if (suggestions.isNotEmpty) ...[
            const SizedBox(height: AppTheme.spacingS),
            ...suggestions.map((s) => Padding(
              padding: const EdgeInsets.only(top: AppTheme.spacingXXS),
              child: Text(
                '• $s',
                style: TextStyle(fontSize: AppTheme.fontSizeXS),
              ),
            )),
          ],
        ],
      ),
    );
  }

  Color _getRiskColor(String level) {
    switch (level.toLowerCase()) {
      case 'high':
        return Colors.red;
      case 'medium':
        return Colors.orange;
      case 'low':
        return Colors.green;
      default:
        return Colors.grey;
    }
  }

  static void show(
    BuildContext context,
    AIAnalysis analysis,
    String messageBody,
  ) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => ToneDetailSheet(
        analysis: analysis,
        messageBody: messageBody,
      ),
    );
  }
}
</file>

<file path="frontend/lib/models/action_item.dart">
/// Model for action item details
class ActionItem {
  final String id;
  final String followUpItemId;
  final String actionType;
  final String? actionTarget;
  final String commitmentText;
  final String? mentionedDeadline;
  final int? extractedDeadline;

  ActionItem({
    required this.id,
    required this.followUpItemId,
    required this.actionType,
    this.actionTarget,
    required this.commitmentText,
    this.mentionedDeadline,
    this.extractedDeadline,
  });

  factory ActionItem.fromJson(Map<String, dynamic> json) {
    return ActionItem(
      id: json['id'] as String,
      followUpItemId: json['follow_up_item_id'] as String,
      actionType: json['action_type'] as String,
      actionTarget: json['action_target'] as String?,
      commitmentText: json['commitment_text'] as String,
      mentionedDeadline: json['mentioned_deadline'] as String?,
      extractedDeadline: json['extracted_deadline'] as int?,
    );
  }

  String getActionEmoji() {
    switch (actionType.toLowerCase()) {
      case 'send':
        return '📤';
      case 'call':
        return '📞';
      case 'meet':
        return '🤝';
      case 'review':
        return '📋';
      case 'decide':
        return '🤔';
      case 'follow_up':
        return '🔄';
      case 'check':
        return '✅';
      case 'schedule':
        return '📅';
      default:
        return '📌';
    }
  }
}
</file>

<file path="frontend/lib/models/ai_analysis.dart">
/// Simple AI Analysis model - no Drift dependency
/// Fetched directly from Supabase with in-memory session caching
class AIAnalysis {
  final String id;
  final String messageId;
  final String tone;
  final String? urgencyLevel;
  final String? intent;
  final double? confidenceScore;
  final int analysisTimestamp;
  
  // ✅ NEW ENHANCED FIELDS
  final String? intensity;
  final List<String>? secondaryTones;
  final Map<String, dynamic>? contextFlags;
  final Map<String, dynamic>? anxietyAssessment;
  
  // ✅ PHASE 1: Smart Message Interpreter fields
  final List<RSDTrigger>? rsdTriggers;
  final List<MessageInterpretation>? alternativeInterpretations;
  final List<Evidence>? evidence;
  
  const AIAnalysis({
    required this.id,
    required this.messageId,
    required this.tone,
    this.urgencyLevel,
    this.intent,
    this.confidenceScore,
    required this.analysisTimestamp,
    // ✅ NEW
    this.intensity,
    this.secondaryTones,
    this.contextFlags,
    this.anxietyAssessment,
    // ✅ PHASE 1
    this.rsdTriggers,
    this.alternativeInterpretations,
    this.evidence,
  });
  
  /// Create from Supabase JSON response
  factory AIAnalysis.fromJson(Map<String, dynamic> json) {
    try {
      // Handle both direct table columns and RPC function results
      final id = json['id'] as String? ?? json['analysis_id'] as String?;
      final messageId = json['message_id'] as String?;
      final tone = json['tone'] as String?;
      
      if (id == null || messageId == null || tone == null) {
        throw FormatException(
          'Missing required fields in AI analysis JSON: '
          'id=$id, message_id=$messageId, tone=$tone. '
          'Full JSON: $json'
        );
      }
      
      return AIAnalysis(
        id: id,
        messageId: messageId,
        tone: tone,
        urgencyLevel: json['urgency_level'] as String?,
        intent: json['intent'] as String?,
        confidenceScore: (json['confidence_score'] as num?)?.toDouble(),
        analysisTimestamp: (json['analysis_timestamp'] as num?)?.toInt() ?? 
                           DateTime.now().millisecondsSinceEpoch ~/ 1000,
        // ✅ Parse new fields
        intensity: json['intensity'] as String?,
        secondaryTones: (json['secondary_tones'] as List<dynamic>?)
            ?.map((e) => e as String)
            .toList(),
        contextFlags: json['context_flags'] as Map<String, dynamic>?,
        anxietyAssessment: json['anxiety_assessment'] as Map<String, dynamic>?,
        // ✅ PHASE 1: Parse RSD, interpretations, evidence
        rsdTriggers: (json['rsd_triggers'] as List<dynamic>?)
            ?.map((e) => RSDTrigger.fromJson(e as Map<String, dynamic>))
            .toList(),
        alternativeInterpretations: (json['alternative_interpretations'] as List<dynamic>?)
            ?.map((e) => MessageInterpretation.fromJson(e as Map<String, dynamic>))
            .toList(),
        evidence: (json['evidence'] as List<dynamic>?)
            ?.map((e) => Evidence.fromJson(e as Map<String, dynamic>))
            .toList(),
      );
    } catch (e) {
      throw FormatException('Failed to parse AIAnalysis from JSON: $e\nJSON: $json');
    }
  }
  
  /// Convert to JSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'message_id': messageId,
      'tone': tone,
      'urgency_level': urgencyLevel,
      'intent': intent,
      'confidence_score': confidenceScore,
      'analysis_timestamp': analysisTimestamp,
      // ✅ Include new fields
      if (intensity != null) 'intensity': intensity,
      if (secondaryTones != null) 'secondary_tones': secondaryTones,
      if (contextFlags != null) 'context_flags': contextFlags,
      if (anxietyAssessment != null) 'anxiety_assessment': anxietyAssessment,
      // ✅ PHASE 1 fields
      if (rsdTriggers != null) 'rsd_triggers': rsdTriggers!.map((e) => e.toJson()).toList(),
      if (alternativeInterpretations != null) 'alternative_interpretations': 
          alternativeInterpretations!.map((e) => e.toJson()).toList(),
      if (evidence != null) 'evidence': evidence!.map((e) => e.toJson()).toList(),
    };
  }
  
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AIAnalysis &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          messageId == other.messageId;
  
  @override
  int get hashCode => id.hashCode ^ messageId.hashCode;
  
  @override
  String toString() {
    return 'AIAnalysis(id: $id, messageId: $messageId, tone: $tone, '
           'urgency: $urgencyLevel, intensity: $intensity, intent: $intent, confidence: $confidenceScore)';
  }
}

// ============================================================================
// PHASE 1: Smart Message Interpreter - Helper Classes
// ============================================================================

/// RSD Trigger model
class RSDTrigger {
  final String pattern;
  final String severity; // high, medium, low
  final String explanation;
  final String reassurance;

  const RSDTrigger({
    required this.pattern,
    required this.severity,
    required this.explanation,
    required this.reassurance,
  });

  factory RSDTrigger.fromJson(Map<String, dynamic> json) {
    return RSDTrigger(
      pattern: json['pattern'] as String,
      severity: json['severity'] as String,
      explanation: json['explanation'] as String,
      reassurance: json['reassurance'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'pattern': pattern,
      'severity': severity,
      'explanation': explanation,
      'reassurance': reassurance,
    };
  }

  bool get isHighSeverity => severity == 'high';
  bool get isMediumSeverity => severity == 'medium';
  bool get isLowSeverity => severity == 'low';
}

/// Alternative Interpretation model
class MessageInterpretation {
  final String interpretation;
  final String tone;
  final int likelihood; // 0-100
  final String reasoning;
  final List<String> contextClues;

  const MessageInterpretation({
    required this.interpretation,
    required this.tone,
    required this.likelihood,
    required this.reasoning,
    required this.contextClues,
  });

  factory MessageInterpretation.fromJson(Map<String, dynamic> json) {
    return MessageInterpretation(
      interpretation: json['interpretation'] as String,
      tone: json['tone'] as String,
      likelihood: json['likelihood'] as int,
      reasoning: json['reasoning'] as String,
      contextClues: (json['context_clues'] as List<dynamic>)
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'interpretation': interpretation,
      'tone': tone,
      'likelihood': likelihood,
      'reasoning': reasoning,
      'context_clues': contextClues,
    };
  }

  bool get isLikely => likelihood >= 60;
  bool get isPossible => likelihood >= 30 && likelihood < 60;
  bool get isUnlikely => likelihood < 30;
}

/// Evidence model
class Evidence {
  final String type; // keyword, punctuation, emoji, etc.
  final String quote;
  final String supports;
  final String reasoning;

  const Evidence({
    required this.type,
    required this.quote,
    required this.supports,
    required this.reasoning,
  });

  factory Evidence.fromJson(Map<String, dynamic> json) {
    return Evidence(
      type: json['type'] as String,
      quote: json['quote'] as String,
      supports: json['supports'] as String,
      reasoning: json['reasoning'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'type': type,
      'quote': quote,
      'supports': supports,
      'reasoning': reasoning,
    };
  }

  bool get isKeywordEvidence => type == 'keyword';
  bool get isPunctuationEvidence => type == 'punctuation';
  bool get isEmojiEvidence => type == 'emoji';
}
</file>

<file path="frontend/lib/models/context_trigger.dart">
/// Model for context triggers
class ContextTrigger {
  final String id;
  final String userId;
  final String followUpItemId;
  final String triggerType;
  final Map<String, dynamic> triggerConfig;
  final bool isActive;
  final int? lastTriggered;
  final int triggerCount;
  final int createdAt;
  final int updatedAt;

  ContextTrigger({
    required this.id,
    required this.userId,
    required this.followUpItemId,
    required this.triggerType,
    required this.triggerConfig,
    required this.isActive,
    this.lastTriggered,
    required this.triggerCount,
    required this.createdAt,
    required this.updatedAt,
  });

  factory ContextTrigger.fromJson(Map<String, dynamic> json) {
    return ContextTrigger(
      id: json['id'] as String,
      userId: json['user_id'] as String,
      followUpItemId: json['follow_up_item_id'] as String,
      triggerType: json['trigger_type'] as String,
      triggerConfig: json['trigger_config'] as Map<String, dynamic>,
      isActive: json['is_active'] as bool? ?? true,
      lastTriggered: json['last_triggered'] as int?,
      triggerCount: json['trigger_count'] as int? ?? 0,
      createdAt: json['created_at'] as int,
      updatedAt: json['updated_at'] as int,
    );
  }

  String getTriggerLabel() {
    switch (triggerType) {
      case 'app_opened':
        final app = triggerConfig['app'] as String?;
        return 'When you open ${app ?? "the app"}';
      case 'calendar_event':
        final event = triggerConfig['event'] as String?;
        return 'Before ${event ?? "calendar event"}';
      case 'location':
        final location = triggerConfig['location'] as String?;
        return 'At ${location ?? "this location"}';
      case 'time_of_day':
        final time = triggerConfig['time'] as String?;
        return 'At $time';
      case 'day_of_week':
        final day = triggerConfig['day'] as String?;
        return 'Every $day';
      default:
        return 'Context trigger';
    }
  }

  String getTriggerEmoji() {
    switch (triggerType) {
      case 'app_opened':
        return '📱';
      case 'calendar_event':
        return '📅';
      case 'location':
        return '📍';
      case 'time_of_day':
        return '⏰';
      case 'day_of_week':
        return '📆';
      default:
        return '🔔';
    }
  }
}
</file>

<file path="frontend/lib/models/conversation_context.dart">
/// Model for conversation context
class ConversationContext {
  final String conversationId;
  final String lastDiscussed;
  final List<KeyPoint> keyPoints;
  final List<String> pendingQuestions;
  final bool fromCache;
  final int? cacheAge;

  ConversationContext({
    required this.conversationId,
    required this.lastDiscussed,
    required this.keyPoints,
    required this.pendingQuestions,
    this.fromCache = false,
    this.cacheAge,
  });

  factory ConversationContext.fromJson(Map<String, dynamic> json) {
    return ConversationContext(
      conversationId: json['conversation_id'] as String? ?? '',
      lastDiscussed: json['last_discussed'] as String,
      keyPoints: (json['key_points'] as List<dynamic>)
          .map((e) => KeyPoint.fromJson(e as Map<String, dynamic>))
          .toList(),
      pendingQuestions: (json['pending_questions'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ??
          [],
      fromCache: json['from_cache'] as bool? ?? false,
      cacheAge: json['cache_age'] as int?,
    );
  }
}

/// Key point from conversation
class KeyPoint {
  final String text;
  final int timestamp;

  KeyPoint({
    required this.text,
    required this.timestamp,
  });

  factory KeyPoint.fromJson(Map<String, dynamic> json) {
    return KeyPoint(
      text: json['text'] as String,
      timestamp: json['timestamp'] as int,
    );
  }

  String getTimeAgo() {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final diff = now - timestamp;

    if (diff < 60) return 'just now';
    if (diff < 3600) return '${diff ~/ 60}m ago';
    if (diff < 86400) return '${diff ~/ 3600}h ago';
    if (diff < 604800) return '${diff ~/ 86400}d ago';
    return '${diff ~/ 604800}w ago';
  }
}
</file>

<file path="frontend/lib/models/draft_analysis.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/situation_type.dart';
import 'package:messageai/models/response_template.dart';

/// Model for draft message analysis results
/// Extends tone analysis with confidence scoring and suggestions
class DraftAnalysis {
  // Tone analysis fields
  final String tone;
  final String? intensity;
  final String? urgencyLevel;
  final String? intent;
  final Map<String, dynamic>? contextFlags;
  final String? reasoning;
  
  // Draft-specific fields
  final int confidenceScore; // 0-100
  final AppropriatenessLevel appropriateness;
  final List<String> suggestions;
  final List<String> warnings;
  final List<String> strengths;
  
  // ✅ NEW: Phase 2 fields
  final SituationDetection? situationDetection;
  final List<ResponseTemplate>? suggestedTemplates;

  const DraftAnalysis({
    required this.tone,
    this.intensity,
    this.urgencyLevel,
    this.intent,
    this.contextFlags,
    this.reasoning,
    required this.confidenceScore,
    required this.appropriateness,
    required this.suggestions,
    required this.warnings,
    required this.strengths,
    // NEW
    this.situationDetection,
    this.suggestedTemplates,
  });

  factory DraftAnalysis.fromJson(Map<String, dynamic> json) {
    return DraftAnalysis(
      // Tone fields
      tone: json['tone'] as String,
      intensity: json['intensity'] as String?,
      urgencyLevel: json['urgency_level'] as String?,
      intent: json['intent'] as String?,
      contextFlags: json['context_flags'] as Map<String, dynamic>?,
      reasoning: json['reasoning'] as String?,
      
      // Draft fields
      confidenceScore: json['confidence_score'] as int,
      appropriateness: AppropriatenessLevel.fromString(
        json['appropriateness'] as String,
      ),
      suggestions: (json['suggestions'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ?? [],
      warnings: (json['warnings'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ?? [],
      strengths: (json['strengths'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ?? [],
      
      // NEW: Phase 2 fields
      situationDetection: json['situation_detection'] != null
          ? SituationDetection.fromJson(json['situation_detection'] as Map<String, dynamic>)
          : null,
      suggestedTemplates: (json['suggested_templates'] as List<dynamic>?)
          ?.map((e) => ResponseTemplate.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  /// Get color based on confidence score
  Color getConfidenceColor() {
    if (confidenceScore >= 90) return Colors.green;
    if (confidenceScore >= 75) return Colors.lightGreen;
    if (confidenceScore >= 60) return Colors.orange;
    return Colors.red;
  }

  /// Get icon based on appropriateness
  IconData getAppropriatenessIcon() {
    switch (appropriateness) {
      case AppropriatenessLevel.excellent:
        return Icons.check_circle;
      case AppropriatenessLevel.good:
        return Icons.thumb_up;
      case AppropriatenessLevel.okay:
        return Icons.info;
      case AppropriatenessLevel.needsWork:
        return Icons.warning;
    }
  }

  /// Get brief status message
  String getStatusMessage() {
    if (confidenceScore >= 90) return 'Ready to send!';
    if (confidenceScore >= 75) return 'Looking good';
    if (confidenceScore >= 60) return 'Could be improved';
    return 'Needs revision';
  }
}

enum AppropriatenessLevel {
  excellent('excellent'),
  good('good'),
  okay('okay'),
  needsWork('needs_work');

  final String value;
  const AppropriatenessLevel(this.value);

  static AppropriatenessLevel fromString(String value) {
    return AppropriatenessLevel.values.firstWhere(
      (e) => e.value == value,
      orElse: () => AppropriatenessLevel.okay,
    );
  }

  String get displayName {
    switch (this) {
      case AppropriatenessLevel.excellent:
        return 'Excellent';
      case AppropriatenessLevel.good:
        return 'Good';
      case AppropriatenessLevel.okay:
        return 'Okay';
      case AppropriatenessLevel.needsWork:
        return 'Needs Work';
    }
  }
}

enum RelationshipType {
  boss('boss', 'Boss/Manager'),
  colleague('colleague', 'Colleague'),
  friend('friend', 'Friend'),
  family('family', 'Family'),
  client('client', 'Client'),
  none('none', 'Not specified');

  final String value;
  final String displayName;
  const RelationshipType(this.value, this.displayName);

  static RelationshipType fromString(String? value) {
    if (value == null) return RelationshipType.none;
    return RelationshipType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => RelationshipType.none,
    );
  }

  IconData get icon {
    switch (this) {
      case RelationshipType.boss:
        return Icons.business;
      case RelationshipType.colleague:
        return Icons.people;
      case RelationshipType.friend:
        return Icons.emoji_people;
      case RelationshipType.family:
        return Icons.family_restroom;
      case RelationshipType.client:
        return Icons.handshake;
      case RelationshipType.none:
        return Icons.help_outline;
    }
  }
}
</file>

<file path="frontend/lib/models/follow_up_item.dart">
import 'package:flutter/material.dart';

/// Follow-up item types
enum FollowUpItemType {
  actionItem('action_item', 'Action Item', Icons.task_alt),
  unansweredQuestion('unanswered_question', 'Unanswered Question', Icons.help_outline),
  pendingResponse('pending_response', 'Pending Response', Icons.pending),
  scheduledFollowup('scheduled_followup', 'Scheduled', Icons.schedule);

  final String value;
  final String displayName;
  final IconData icon;

  const FollowUpItemType(this.value, this.displayName, this.icon);

  static FollowUpItemType fromString(String value) {
    return FollowUpItemType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => FollowUpItemType.pendingResponse,
    );
  }

  Color getColor() {
    switch (this) {
      case FollowUpItemType.actionItem:
        return Colors.orange;
      case FollowUpItemType.unansweredQuestion:
        return Colors.blue;
      case FollowUpItemType.pendingResponse:
        return Colors.purple;
      case FollowUpItemType.scheduledFollowup:
        return Colors.green;
    }
  }
}

/// Follow-up item status
enum FollowUpStatus {
  pending('pending'),
  completed('completed'),
  dismissed('dismissed'),
  snoozed('snoozed');

  final String value;
  const FollowUpStatus(this.value);

  static FollowUpStatus fromString(String value) {
    return FollowUpStatus.values.firstWhere(
      (e) => e.value == value,
      orElse: () => FollowUpStatus.pending,
    );
  }
}

/// Model for follow-up item
class FollowUpItem {
  final String id;
  final String userId;
  final String conversationId;
  final String? messageId;
  final FollowUpItemType itemType;
  final String title;
  final String? description;
  final String? extractedText;
  final FollowUpStatus status;
  final int priority;
  final int detectedAt;
  final int? dueAt;
  final int? remindAt;
  final int? snoozedUntil;
  final int? completedAt;
  final Map<String, dynamic>? triggers;

  FollowUpItem({
    required this.id,
    required this.userId,
    required this.conversationId,
    this.messageId,
    required this.itemType,
    required this.title,
    this.description,
    this.extractedText,
    required this.status,
    required this.priority,
    required this.detectedAt,
    this.dueAt,
    this.remindAt,
    this.snoozedUntil,
    this.completedAt,
    this.triggers,
  });

  factory FollowUpItem.fromJson(Map<String, dynamic> json) {
    return FollowUpItem(
      id: json['item_id'] as String? ?? json['id'] as String,
      userId: json['user_id'] as String,
      conversationId: json['conversation_id'] as String,
      messageId: json['message_id'] as String?,
      itemType: FollowUpItemType.fromString(json['item_type'] as String),
      title: json['title'] as String,
      description: json['description'] as String?,
      extractedText: json['extracted_text'] as String?,
      status: FollowUpStatus.fromString(json['status'] as String? ?? 'pending'),
      priority: json['priority'] as int,
      detectedAt: json['detected_at'] as int,
      dueAt: json['due_at'] as int?,
      remindAt: json['remind_at'] as int?,
      snoozedUntil: json['snoozed_until'] as int?,
      completedAt: json['completed_at'] as int?,
      triggers: json['triggers'] as Map<String, dynamic>?,
    );
  }

  bool get isOverdue {
    if (dueAt == null) return false;
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    return now > dueAt!;
  }

  bool get isDueSoon {
    if (dueAt == null) return false;
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final hoursUntilDue = (dueAt! - now) / 3600;
    return hoursUntilDue > 0 && hoursUntilDue <= 24;
  }

  String getTimeUntilDue() {
    if (dueAt == null) return '';
    
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final diff = dueAt! - now;
    
    if (diff < 0) return 'Overdue';
    if (diff < 3600) return '${diff ~/ 60}m';
    if (diff < 86400) return '${diff ~/ 3600}h';
    return '${diff ~/ 86400}d';
  }

  String getTimeSinceDetected() {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final diff = now - detectedAt;
    
    if (diff < 3600) return '${diff ~/ 60}m ago';
    if (diff < 86400) return '${diff ~/ 3600}h ago';
    return '${diff ~/ 86400}d ago';
  }
}
</file>

<file path="frontend/lib/models/formatted_message.dart">
/// Result of message formatting
class FormattedMessage {
  final int originalLength;
  final String formattedMessage;
  final List<String> formattingApplied;
  final int characterCount;
  final String estimatedReadTime;

  FormattedMessage({
    required this.originalLength,
    required this.formattedMessage,
    required this.formattingApplied,
    required this.characterCount,
    required this.estimatedReadTime,
  });

  factory FormattedMessage.fromJson(Map<String, dynamic> json) {
    return FormattedMessage(
      originalLength: json['original_length'] as int,
      formattedMessage: json['formatted_message'] as String,
      formattingApplied: (json['formatting_applied'] as List<dynamic>)
          .map((e) => e as String)
          .toList(),
      characterCount: json['character_count'] as int,
      estimatedReadTime: json['estimated_read_time'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'original_length': originalLength,
      'formatted_message': formattedMessage,
      'formatting_applied': formattingApplied,
      'character_count': characterCount,
      'estimated_read_time': estimatedReadTime,
    };
  }

  double getSavingsPercentage() {
    if (originalLength == 0) return 0;
    return ((originalLength - characterCount) / originalLength) * 100;
  }

  @override
  String toString() {
    return 'FormattedMessage(original: $originalLength chars, formatted: $characterCount chars, saved: ${getSavingsPercentage().toStringAsFixed(0)}%)';
  }
}
</file>

<file path="frontend/lib/models/relationship_profile.dart">
/// Model for relationship profile
class RelationshipProfile {
  final String id;
  final String userId;
  final String conversationId;
  final String participantName;
  final String? participantUserId;
  final String? relationshipType;
  final String? relationshipNotes;
  final String? conversationSummary;
  final List<String> safeTopics;
  final List<String> topicsToAvoid;
  final String? communicationStyle;
  final int? typicalResponseTime;
  final int totalMessages;
  final int? firstMessageAt;
  final int? lastMessageAt;

  RelationshipProfile({
    required this.id,
    required this.userId,
    required this.conversationId,
    required this.participantName,
    this.participantUserId,
    this.relationshipType,
    this.relationshipNotes,
    this.conversationSummary,
    this.safeTopics = const [],
    this.topicsToAvoid = const [],
    this.communicationStyle,
    this.typicalResponseTime,
    this.totalMessages = 0,
    this.firstMessageAt,
    this.lastMessageAt,
  });

  factory RelationshipProfile.fromJson(Map<String, dynamic> json) {
    return RelationshipProfile(
      id: json['profile_id'] as String? ?? json['id'] as String,
      userId: json['user_id'] as String,
      conversationId: json['conversation_id'] as String,
      participantName: json['participant_name'] as String,
      participantUserId: json['participant_user_id'] as String?,
      relationshipType: json['relationship_type'] as String?,
      relationshipNotes: json['relationship_notes'] as String?,
      conversationSummary: json['conversation_summary'] as String?,
      safeTopics: (json['safe_topics'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ??
          [],
      topicsToAvoid: (json['topics_to_avoid'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ??
          [],
      communicationStyle: json['communication_style'] as String?,
      typicalResponseTime: json['typical_response_time'] as int?,
      totalMessages: json['total_messages'] as int? ?? 0,
      firstMessageAt: json['first_message_at'] as int?,
      lastMessageAt: json['last_message_at'] as int?,
    );
  }

  String getRelationshipEmoji() {
    switch (relationshipType?.toLowerCase()) {
      case 'boss':
        return '👔';
      case 'colleague':
        return '🤝';
      case 'friend':
        return '😊';
      case 'family':
        return '👨‍👩‍👧‍👦';
      case 'client':
        return '💼';
      default:
        return '👤';
    }
  }

  String formatResponseTime() {
    if (typicalResponseTime == null) return 'Unknown';

    final minutes = typicalResponseTime! ~/ 60;
    if (minutes < 60) return '$minutes min';

    final hours = minutes ~/ 60;
    if (hours < 24) return '$hours hr';

    final days = hours ~/ 24;
    return '$days days';
  }
}
</file>

<file path="frontend/lib/models/response_template.dart">
/// Model for response templates
class ResponseTemplate {
  final String id;
  final String name;
  final String situation;
  final String template;
  final String tone; // polite, casual, direct, apologetic
  final List<String> context;
  final bool neurodivergentFriendly;
  final List<String>? customizableFields;

  ResponseTemplate({
    required this.id,
    required this.name,
    required this.situation,
    required this.template,
    required this.tone,
    required this.context,
    required this.neurodivergentFriendly,
    this.customizableFields,
  });

  factory ResponseTemplate.fromJson(Map<String, dynamic> json) {
    return ResponseTemplate(
      id: json['id'] as String,
      name: json['name'] as String,
      situation: json['situation'] as String,
      template: json['template'] as String,
      tone: json['tone'] as String,
      context: (json['context'] as List<dynamic>).map((e) => e as String).toList(),
      neurodivergentFriendly: json['neurodivergent_friendly'] as bool,
      customizableFields: (json['customizable_fields'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'situation': situation,
      'template': template,
      'tone': tone,
      'context': context,
      'neurodivergent_friendly': neurodivergentFriendly,
      if (customizableFields != null) 'customizable_fields': customizableFields,
    };
  }

  /// Fill in customizable fields in the template
  String fillTemplate(Map<String, String> values) {
    String result = template;
    if (customizableFields != null) {
      for (final field in customizableFields!) {
        final value = values[field] ?? '{$field}';
        result = result.replaceAll('{$field}', value);
      }
    }
    return result;
  }

  /// Check if template has unfilled fields
  bool hasUnfilledFields(String text) {
    return text.contains(RegExp(r'\{[^}]+\}'));
  }

  @override
  String toString() {
    return 'ResponseTemplate(id: $id, name: $name, tone: $tone)';
  }
}
</file>

<file path="frontend/lib/models/safe_topic.dart">
import 'package:flutter/material.dart';

/// Model for safe topics
class SafeTopic {
  final String id;
  final String topicName;
  final List<String> keywords;
  final int messageCount;
  final int? avgResponseTime;
  final double? positiveToneRate;
  final bool isSafe;
  final int? lastDiscussed;

  SafeTopic({
    required this.id,
    required this.topicName,
    required this.keywords,
    required this.messageCount,
    this.avgResponseTime,
    this.positiveToneRate,
    this.isSafe = true,
    this.lastDiscussed,
  });

  factory SafeTopic.fromJson(Map<String, dynamic> json) {
    return SafeTopic(
      id: json['id'] as String,
      topicName: json['topic_name'] as String,
      keywords: (json['topic_keywords'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ??
          [],
      messageCount: json['message_count'] as int,
      avgResponseTime: json['avg_response_time'] as int?,
      positiveToneRate: (json['positive_tone_rate'] as num?)?.toDouble(),
      isSafe: json['is_safe'] as bool? ?? true,
      lastDiscussed: json['last_discussed'] as int?,
    );
  }

  Color getTopicColor() {
    if (positiveToneRate == null) return Colors.grey;
    if (positiveToneRate! >= 0.8) return Colors.green;
    if (positiveToneRate! >= 0.6) return Colors.blue;
    return Colors.orange;
  }

  String getEngagementLabel() {
    if (positiveToneRate == null) return 'Unknown';
    if (positiveToneRate! >= 0.8) return 'Great topic!';
    if (positiveToneRate! >= 0.6) return 'Good topic';
    return 'Neutral';
  }
}
</file>

<file path="frontend/lib/models/situation_type.dart">
import 'package:flutter/material.dart';

/// Types of situations for response templates
enum SituationType {
  declining('declining', 'Saying No', Icons.cancel),
  boundarySetting('boundary_setting', 'Setting Boundary', Icons.shield),
  infoDumping('info_dumping', 'Sharing Info', Icons.lightbulb),
  apologizing('apologizing', 'Apologizing', Icons.handshake),
  clarifying('clarifying', 'Clarifying', Icons.help_outline),
  casualChat('casual_chat', 'Casual Chat', Icons.chat),
  workProfessional('work_professional', 'Professional', Icons.work),
  emotionalSupport('emotional_support', 'Support', Icons.favorite),
  unknown('unknown', 'Unknown', Icons.question_mark);

  final String value;
  final String displayName;
  final IconData icon;

  const SituationType(this.value, this.displayName, this.icon);

  static SituationType fromString(String value) {
    return SituationType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => SituationType.unknown,
    );
  }

  Color getColor() {
    switch (this) {
      case SituationType.declining:
        return Colors.red;
      case SituationType.boundarySetting:
        return Colors.orange;
      case SituationType.infoDumping:
        return Colors.purple;
      case SituationType.apologizing:
        return Colors.blue;
      case SituationType.clarifying:
        return Colors.teal;
      case SituationType.casualChat:
        return Colors.green;
      case SituationType.workProfessional:
        return Colors.indigo;
      case SituationType.emotionalSupport:
        return Colors.pink;
      case SituationType.unknown:
        return Colors.grey;
    }
  }
}

/// Situation detection result
class SituationDetection {
  final SituationType situationType;
  final double confidence;
  final String reasoning;
  final List<String> suggestedTemplateIds;

  SituationDetection({
    required this.situationType,
    required this.confidence,
    required this.reasoning,
    required this.suggestedTemplateIds,
  });

  factory SituationDetection.fromJson(Map<String, dynamic> json) {
    return SituationDetection(
      situationType: SituationType.fromString(json['situation_type'] as String),
      confidence: (json['confidence'] as num).toDouble(),
      reasoning: json['reasoning'] as String,
      suggestedTemplateIds: (json['suggested_templates'] as List<dynamic>)
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'situation_type': situationType.value,
      'confidence': confidence,
      'reasoning': reasoning,
      'suggested_templates': suggestedTemplateIds,
    };
  }

  @override
  String toString() {
    return 'SituationDetection(type: ${situationType.displayName}, confidence: ${(confidence * 100).toInt()}%)';
  }
}
</file>

<file path="frontend/lib/services/ai_analysis_service_cached.dart.backup">
import 'dart:async';
import 'dart:convert';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/ai_analysis_dao.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:uuid/uuid.dart';

/// Service for managing AI message analysis (tone, intent, urgency)
class AIAnalysisService {
  final _analysisDao = AppDb.instance.aiAnalysisDao;
  final _supabase = SupabaseClientProvider.client;
  final _uuid = const Uuid();

  // Debouncing: Track pending analysis requests to avoid duplicates
  final Map<String, Timer> _pendingRequests = {};
  final Duration _debounceDelay = const Duration(milliseconds: 500);

  /// Request AI analysis for a message
  /// Debounces requests to avoid spamming the API
  Future<AiAnalysi?> requestAnalysis(
    String messageId,
    String messageBody, {
    List<String>? conversationContext,
    bool forceRefresh = false,
  }) async {
    // Cancel any pending request for this message
    _pendingRequests[messageId]?.cancel();

    // Check if we already have cached analysis
    if (!forceRefresh) {
      final cached = await _analysisDao.getAnalysisByMessageId(messageId);
      if (cached != null) {
        print('📊 Using cached analysis for message ${messageId.substring(0, 8)}');
        return cached;
      }
    }

    // Create a debounced request
    final completer = Completer<AiAnalysi?>();
    
    _pendingRequests[messageId] = Timer(_debounceDelay, () async {
      try {
        print('🤖 Requesting AI analysis for message ${messageId.substring(0, 8)}...');
        
        final analysis = await _callAnalysisAPI(
          messageId,
          messageBody,
          conversationContext,
        );
        
        if (!completer.isCompleted) {
          completer.complete(analysis);
        }
      } catch (e) {
        print('❌ Analysis request failed: $e');
        if (!completer.isCompleted) {
          completer.completeError(e);
        }
      } finally {
        _pendingRequests.remove(messageId);
      }
    });

    return completer.future;
  }

  /// Call the AI analysis Edge Function
  Future<AiAnalysi> _callAnalysisAPI(
    String messageId,
    String messageBody,
    List<String>? conversationContext,
  ) async {
    try {
      final response = await _supabase.functions.invoke(
        'ai_analyze_tone',
        body: {
          'message_id': messageId,
          'message_body': messageBody,
          if (conversationContext != null)
            'conversation_context': conversationContext,
        },
      );

      if (response.status != 200) {
        throw Exception('API returned status ${response.status}');
      }

      final data = response.data;
      if (data == null || !data['success']) {
        throw Exception(data?['error'] ?? 'Unknown error');
      }

      final analysisData = data['analysis'];
      
      // Store in local database
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final analysis = AiAnalysisCompanion.insert(
        id: analysisData['id'] as String,
        messageId: messageId,
        tone: analysisData['tone'] as String,
        urgencyLevel: Value(analysisData['urgency_level'] as String?),
        intent: Value(analysisData['intent'] as String?),
        confidenceScore: Value(
          (analysisData['confidence_score'] as num?)?.toDouble(),
        ),
        analysisTimestamp: analysisData['analysis_timestamp'] as int? ?? now,
        isSynced: const Value(true),
        createdAt: now,
        updatedAt: now,
      );

      await _analysisDao.upsertAnalysis(analysis);
      
      print('✅ Analysis complete: ${analysisData['tone']} (${analysisData['urgency_level']})');
      
      // Return the stored analysis
      return (await _analysisDao.getAnalysisByMessageId(messageId))!;
    } catch (e) {
      print('❌ Failed to call analysis API: $e');
      rethrow;
    }
  }

  /// Get analysis for a specific message
  Future<AiAnalysi?> getAnalysis(String messageId) async {
    return _analysisDao.getAnalysisByMessageId(messageId);
  }

  /// Get analyses for multiple messages
  Future<Map<String, AiAnalysi>> getAnalysesForMessages(
    List<String> messageIds,
  ) async {
    final analyses = await _analysisDao.getAnalysesByMessageIds(messageIds);
    return Map.fromEntries(
      analyses.map((a) => MapEntry(a.messageId, a)),
    );
  }

  /// Get analyses for a conversation
  Future<Map<String, AiAnalysi>> getConversationAnalysis(
    String conversationId,
    List<String> messageIds,
  ) async {
    final analyses = await _analysisDao.getAnalysesForConversation(messageIds);
    return Map.fromEntries(
      analyses.map((a) => MapEntry(a.messageId, a)),
    );
  }

  /// Sync analysis from backend for a message
  Future<AiAnalysi?> syncAnalysisFromBackend(String messageId) async {
    try {
      print('🔄 Syncing analysis for message ${messageId.substring(0, 8)} from backend...');
      
      final response = await _supabase.rpc(
        'get_message_ai_analysis',
        params: {'p_message_id': messageId},
      );

      if (response == null || (response as List).isEmpty) {
        print('ℹ️ No analysis found on backend');
        return null;
      }

      final data = (response as List).first;
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      
      final analysis = AiAnalysisCompanion.insert(
        id: data['id'] as String,
        messageId: messageId,
        tone: data['tone'] as String,
        urgencyLevel: Value(data['urgency_level'] as String?),
        intent: Value(data['intent'] as String?),
        confidenceScore: Value((data['confidence_score'] as num?)?.toDouble()),
        analysisTimestamp: data['analysis_timestamp'] as int? ?? now,
        isSynced: const Value(true),
        createdAt: now,
        updatedAt: now,
      );

      await _analysisDao.upsertAnalysis(analysis);
      
      return _analysisDao.getAnalysisByMessageId(messageId);
    } catch (e) {
      print('❌ Failed to sync analysis from backend: $e');
      return null;
    }
  }

  /// Sync analyses for a conversation from backend
  Future<void> syncConversationAnalysesFromBackend(
    String conversationId,
  ) async {
    try {
      print('🔄 Syncing analyses for conversation ${conversationId.substring(0, 8)}...');
      
      final response = await _supabase.rpc(
        'get_conversation_ai_analysis',
        params: {'p_conversation_id': conversationId},
      );

      if (response == null || (response as List).isEmpty) {
        print('ℹ️ No analyses found on backend');
        return;
      }

      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final analyses = (response as List).cast<Map<String, dynamic>>();
      
      for (final data in analyses) {
        final analysis = AiAnalysisCompanion.insert(
          id: _uuid.v4(),
          messageId: data['message_id'] as String,
          tone: data['tone'] as String,
          urgencyLevel: Value(data['urgency_level'] as String?),
          intent: Value(data['intent'] as String?),
          confidenceScore: Value((data['confidence_score'] as num?)?.toDouble()),
          analysisTimestamp: data['analysis_timestamp'] as int? ?? now,
          isSynced: const Value(true),
          createdAt: now,
          updatedAt: now,
        );

        await _analysisDao.upsertAnalysis(analysis);
      }
      
      print('✅ Synced ${analyses.length} analyses from backend');
    } catch (e) {
      print('❌ Failed to sync conversation analyses: $e');
    }
  }

  /// Delete analysis for a message
  Future<void> deleteAnalysis(String messageId) async {
    await _analysisDao.deleteAnalysisByMessageId(messageId);
  }

  /// Clear old analyses (older than N days)
  Future<void> cleanupOldAnalyses({int days = 30}) async {
    final deleted = await _analysisDao.deleteOldAnalyses(days: days);
    print('🧹 Cleaned up $deleted old analyses');
  }

  /// Get analysis statistics
  Future<Map<String, dynamic>> getAnalysisStats() async {
    final count = await _analysisDao.getAnalysisCount();
    final byTone = await _analysisDao.getAnalysisCountByTone();
    
    return {
      'total_count': count,
      'by_tone': byTone,
    };
  }

  /// Stream analysis for a message
  Stream<AiAnalysi?> watchAnalysis(String messageId) {
    return _analysisDao.watchAnalysisForMessage(messageId);
  }

  /// Cancel pending analysis request
  void cancelPendingRequest(String messageId) {
    _pendingRequests[messageId]?.cancel();
    _pendingRequests.remove(messageId);
  }

  /// Cancel all pending requests
  void cancelAllPendingRequests() {
    for (final timer in _pendingRequests.values) {
      timer.cancel();
    }
    _pendingRequests.clear();
  }

  /// Dispose resources
  void dispose() {
    cancelAllPendingRequests();
  }
}
</file>

<file path="frontend/lib/services/ai_analysis_service.dart">
import 'dart:async';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Simple AI Analysis Service - Supabase only, no local persistence
/// Uses in-memory cache for current session to reduce API calls
class AIAnalysisService {
  final _supabase = SupabaseClientProvider.client;
  
  /// In-memory cache (cleared on app restart)
  final Map<String, AIAnalysis> _sessionCache = {};
  
  /// Pending requests to avoid duplicate API calls
  final Map<String, Future<AIAnalysis?>> _pendingRequests = {};
  
  /// Request AI analysis for a message
  /// Returns cached result if available, otherwise calls Edge Function
  Future<AIAnalysis?> requestAnalysis(
    String messageId,
    String messageBody, {
    List<String>? conversationContext,
  }) async {
    // Check session cache first
    if (_sessionCache.containsKey(messageId)) {
      print('📊 Using cached analysis for $messageId');
      return _sessionCache[messageId];
    }
    
    // Check if request is already in progress
    if (_pendingRequests.containsKey(messageId)) {
      print('⏳ Analysis already in progress for $messageId');
      return _pendingRequests[messageId];
    }
    
    // Make new request
    print('🤖 Requesting new analysis for $messageId');
    final future = _callAnalysisAPI(messageId, messageBody, conversationContext);
    _pendingRequests[messageId] = future;
    
    try {
      final result = await future;
      if (result != null) {
        _sessionCache[messageId] = result;
      }
      return result;
    } finally {
      _pendingRequests.remove(messageId);
    }
  }
  
  /// Call the Edge Function to analyze a message
  Future<AIAnalysis?> _callAnalysisAPI(
    String messageId,
    String messageBody,
    List<String>? conversationContext,
  ) async {
    try {
      final response = await _supabase.functions.invoke(
        'ai_analyze_tone',
        body: {
          'message_id': messageId,
          'message_body': messageBody,
          if (conversationContext != null)
            'conversation_context': conversationContext,
        },
      );
      
      if (response.status != 200) {
        throw Exception('API returned status ${response.status}');
      }
      
      final data = response.data;
      if (data == null || !data['success']) {
        throw Exception(data?['error'] ?? 'Unknown error');
      }
      
      return AIAnalysis.fromJson(data['analysis']);
    } catch (e) {
      print('❌ Analysis request failed: $e');
      return null;
    }
  }
  
  /// Fetch existing analysis from Supabase
  Future<AIAnalysis?> getAnalysis(String messageId) async {
    // Check cache
    if (_sessionCache.containsKey(messageId)) {
      return _sessionCache[messageId];
    }
    
    try {
      final response = await _supabase.rpc(
        'get_message_ai_analysis',
        params: {'p_message_id': messageId},
      );
      
      if (response == null || (response as List).isEmpty) {
        return null;
      }
      
      final analysis = AIAnalysis.fromJson(response[0]);
      _sessionCache[messageId] = analysis;
      return analysis;
    } catch (e) {
      print('❌ Failed to fetch analysis: $e');
      return null;
    }
  }
  
  /// Fetch all analyses for a conversation
  Future<Map<String, AIAnalysis>> getConversationAnalyses(
    String conversationId,
  ) async {
    try {
      final response = await _supabase.rpc(
        'get_conversation_ai_analysis',
        params: {'p_conversation_id': conversationId},
      );
      
      if (response == null || (response as List).isEmpty) {
        return {};
      }
      
      final Map<String, AIAnalysis> analyses = {};
      for (final item in response) {
        final analysis = AIAnalysis.fromJson(item);
        analyses[analysis.messageId] = analysis;
        _sessionCache[analysis.messageId] = analysis; // Cache it
      }
      
      return analyses;
    } catch (e) {
      print('❌ Failed to fetch conversation analyses: $e');
      return {};
    }
  }
  
  /// Clear the session cache
  void clearCache() {
    _sessionCache.clear();
    print('🧹 Analysis cache cleared');
  }
  
  /// Get cache statistics
  Map<String, dynamic> getCacheStats() {
    return {
      'cached_count': _sessionCache.length,
      'pending_count': _pendingRequests.length,
    };
  }
}
</file>

<file path="frontend/lib/services/avatar_service.dart">
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:image_picker/image_picker.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_handler.dart';

/// Service for handling avatar uploads and management
class AvatarService {
  static final AvatarService _instance = AvatarService._internal();

  factory AvatarService() {
    return _instance;
  }

  AvatarService._internal();

  final _supabase = SupabaseClientProvider.client;
  final _errorHandler = ErrorHandler();
  final _imagePicker = ImagePicker();

  /// Pick an image from gallery
  Future<XFile?> pickImage() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 512,
        maxHeight: 512,
        imageQuality: 85,
      );
      return image;
    } catch (error, stackTrace) {
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Pick Image',
      );
    }
  }

  /// Pick an image from camera
  Future<XFile?> pickImageFromCamera() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.camera,
        maxWidth: 512,
        maxHeight: 512,
        imageQuality: 85,
      );
      return image;
    } catch (error, stackTrace) {
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Take Photo',
      );
    }
  }

  /// Upload avatar to Supabase Storage and update profile
  Future<String> uploadAvatar(XFile imageFile) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      print('📤 Uploading avatar for user: ${currentUser.id}');

      // Generate unique filename
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final extension = imageFile.path.split('.').last;
      final fileName = '${currentUser.id}/avatar_$timestamp.$extension';

      // Read file bytes
      final Uint8List fileBytes;
      if (kIsWeb) {
        fileBytes = await imageFile.readAsBytes();
      } else {
        fileBytes = await File(imageFile.path).readAsBytes();
      }

      print('📁 File size: ${fileBytes.length} bytes');
      print('📁 File name: $fileName');

      // Delete old avatar if exists
      await _deleteOldAvatar(currentUser.id);

      // Upload to Supabase Storage
      final uploadPath = await _supabase.storage
          .from('avatars')
          .uploadBinary(fileName, fileBytes);

      print('✅ Avatar uploaded: $uploadPath');

      // Get public URL
      final publicUrl = _supabase.storage
          .from('avatars')
          .getPublicUrl(fileName);

      print('🔗 Public URL: $publicUrl');

      // Update profile with new avatar URL
      await _updateProfileAvatar(currentUser.id, publicUrl);

      return publicUrl;
    } catch (error, stackTrace) {
      print('❌ Error uploading avatar: $error');
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Upload Avatar',
      );
    }
  }

  /// Delete old avatar files for a user
  Future<void> _deleteOldAvatar(String userId) async {
    try {
      // List all files in user's folder
      final files = await _supabase.storage
          .from('avatars')
          .list(path: userId);

      // Delete each file
      for (final file in files) {
        final filePath = '$userId/${file.name}';
        await _supabase.storage
            .from('avatars')
            .remove([filePath]);
        print('🗑️  Deleted old avatar: $filePath');
      }
    } catch (e) {
      print('⚠️  Error deleting old avatar (non-critical): $e');
      // Don't throw - old avatar deletion is non-critical
    }
  }

  /// Update profile table with new avatar URL
  Future<void> _updateProfileAvatar(String userId, String avatarUrl) async {
    try {
      await _supabase
          .from('profiles')
          .update({'avatar_url': avatarUrl, 'updated_at': DateTime.now().toIso8601String()})
          .eq('user_id', userId);

      print('✅ Profile updated with new avatar URL');
    } catch (error, stackTrace) {
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Update Profile Avatar',
      );
    }
  }

  /// Get avatar URL for a user
  Future<String?> getAvatarUrl(String userId) async {
    try {
      final response = await _supabase
          .from('profiles')
          .select('avatar_url')
          .eq('user_id', userId)
          .maybeSingle();

      if (response != null && response['avatar_url'] != null) {
        return response['avatar_url'] as String;
      }
      return null;
    } catch (error, stackTrace) {
      print('⚠️  Error fetching avatar URL: $error');
      // Return null instead of throwing - missing avatar is not critical
      return null;
    }
  }

  /// Delete avatar for current user
  Future<void> deleteAvatar() async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      print('🗑️  Deleting avatar for user: ${currentUser.id}');

      // Delete from storage
      await _deleteOldAvatar(currentUser.id);

      // Update profile to remove avatar URL
      await _supabase
          .from('profiles')
          .update({'avatar_url': null, 'updated_at': DateTime.now().toIso8601String()})
          .eq('user_id', currentUser.id);

      print('✅ Avatar deleted successfully');
    } catch (error, stackTrace) {
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Delete Avatar',
      );
    }
  }

  /// Get current user's avatar URL
  Future<String?> getCurrentUserAvatar() async {
    final currentUser = _supabase.auth.currentUser;
    if (currentUser == null) {
      return null;
    }
    return getAvatarUrl(currentUser.id);
  }
}
</file>

<file path="frontend/lib/services/context_preloader_service.dart">
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/models/conversation_context.dart';

/// Service for loading conversation context
class ContextPreloaderService {
  static final ContextPreloaderService _instance =
      ContextPreloaderService._internal();
  factory ContextPreloaderService() => _instance;
  ContextPreloaderService._internal();

  static String get baseUrl {
    final supabaseUrl = SupabaseClientProvider.client.supabaseUrl;
    return '$supabaseUrl/functions/v1';
  }

  // In-memory cache
  final Map<String, ConversationContext> _cache = {};

  /// Load context for a conversation
  Future<ConversationContext> loadContext(String conversationId) async {
    // Check in-memory cache first
    if (_cache.containsKey(conversationId)) {
      final cached = _cache[conversationId]!;
      // Return if less than 5 minutes old
      if (cached.cacheAge != null && cached.cacheAge! < 300) {
        return cached;
      }
    }

    try {
      final token =
          SupabaseClientProvider.client.auth.currentSession?.accessToken;
      if (token == null) {
        throw Exception('Not authenticated');
      }

      final response = await http.post(
        Uri.parse('$baseUrl/ai-context-preloader'),
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
        body: jsonEncode({
          'conversation_id': conversationId,
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true) {
          final context = ConversationContext.fromJson({
            'conversation_id': conversationId,
            ...data['context'],
            'from_cache': data['from_cache'],
          });

          // Update in-memory cache
          _cache[conversationId] = context;

          return context;
        } else {
          throw Exception(data['error'] ?? 'Failed to load context');
        }
      } else {
        throw Exception('HTTP ${response.statusCode}: ${response.body}');
      }
    } catch (e) {
      print('Error loading context: $e');
      rethrow;
    }
  }

  /// Preload context for multiple conversations
  Future<void> preloadContexts(List<String> conversationIds) async {
    // Load in parallel with rate limiting
    final futures = conversationIds.take(5).map((id) => loadContext(id));
    await Future.wait(futures, eagerError: false);
  }

  /// Clear cache
  void clearCache() {
    _cache.clear();
  }
}
</file>

<file path="frontend/lib/services/device_registration_service.dart">
import 'dart:io' show Platform;
import 'package:messageai/data/remote/supabase_client.dart';

/// Service for registering and managing device tokens with the backend
class DeviceRegistrationService {
  /// Register or update device token in Supabase
  Future<void> registerDeviceToken(String token) async {
    try {
      final supabase = SupabaseClientProvider.client;
      final userId = supabase.auth.currentUser?.id;
      
      if (userId == null) {
        print('⚠️ Cannot register device: user not authenticated');
        throw Exception('User not authenticated');
      }
      
      // Determine platform
      String platform;
      if (Platform.isIOS) {
        platform = 'ios';
      } else if (Platform.isAndroid) {
        platform = 'android';
      } else {
        platform = 'web';
      }
      
      print('📱 Registering device token...');
      print('   User ID: $userId');
      print('   Platform: $platform');
      print('   Token: ${token.substring(0, 20)}...');
      
      // Upsert device (insert or update if token already exists)
      // This handles both new registrations and token refreshes
      await supabase.from('profile_devices').upsert({
        'user_id': userId,
        'fcm_token': token,
        'platform': platform,
        'last_seen': DateTime.now().toIso8601String(),
      }, onConflict: 'fcm_token');
      
      print('✅ Device token registered successfully!');
    } catch (e) {
      print('❌ Failed to register device token: $e');
      rethrow;
    }
  }
  
  /// Unregister device token (e.g., on logout)
  Future<void> unregisterDeviceToken(String token) async {
    try {
      final supabase = SupabaseClientProvider.client;
      
      print('🗑️ Unregistering device token...');
      
      await supabase
          .from('profile_devices')
          .delete()
          .eq('fcm_token', token);
      
      print('✅ Device token unregistered');
    } catch (e) {
      print('❌ Failed to unregister device token: $e');
      rethrow;
    }
  }
  
  /// Update last seen timestamp for device
  Future<void> updateDeviceLastSeen(String token) async {
    try {
      final supabase = SupabaseClientProvider.client;
      
      print('🔄 Updating last_seen for token: ${token.substring(0, 20)}...');
      
      final response = await supabase
          .from('profile_devices')
          .update({
            'last_seen': DateTime.now().toIso8601String(),
          })
          .eq('fcm_token', token)
          .select();
      
      if (response.isEmpty) {
        print('⚠️ No device found with that token - device may not be registered');
      } else {
        print('✅ Device last_seen updated successfully');
      }
    } catch (e) {
      print('❌ Failed to update device last_seen: $e');
      // Don't rethrow - this is not critical
    }
  }
}
</file>

<file path="frontend/lib/services/draft_analysis_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/models/draft_analysis.dart';

/// Service for analyzing draft messages on-demand
/// User manually requests analysis via button press
class DraftAnalysisService {
  final SupabaseClient _supabase;

  DraftAnalysisService(this._supabase);

  /// Analyze a draft message (called when user clicks "Check" button)
  Future<DraftAnalysis> analyzeDraft({
    required String draftMessage,
    String? conversationId,
    RelationshipType? relationshipType,
    List<String>? conversationHistory,
  }) async {
    try {
      print('🔍 Analyzing draft message...');
      
      final response = await _supabase.functions.invoke(
        'ai_analyze_draft',
        body: {
          'draft_message': draftMessage,
          if (conversationId != null) 'conversation_id': conversationId,
          if (relationshipType != null && relationshipType != RelationshipType.none)
            'relationship_type': relationshipType.value,
          if (conversationHistory != null && conversationHistory.isNotEmpty)
            'conversation_history': conversationHistory,
        },
      );

      if (response.data == null) {
        throw Exception('No response from draft analysis service');
      }

      final data = response.data as Map<String, dynamic>;
      
      if (data['success'] != true) {
        throw Exception(data['error'] ?? 'Analysis failed');
      }

      final analysis = DraftAnalysis.fromJson(data['analysis'] as Map<String, dynamic>);
      
      print('✅ Draft analysis complete: ${analysis.confidenceScore}% confidence');
      
      return analysis;
    } catch (e) {
      print('❌ Error analyzing draft: $e');
      rethrow;
    }
  }

  /// Get recent messages from conversation for context
  Future<List<String>> getConversationContext(String conversationId, {int limit = 3}) async {
    try {
      final response = await _supabase
          .from('messages')
          .select('body')
          .eq('conversation_id', conversationId)
          .order('created_at', ascending: false)
          .limit(limit);

      return (response as List).map((m) => m['body'] as String).toList();
    } catch (e) {
      print('Warning: Could not fetch conversation context: $e');
      return [];
    }
  }

  /// Get or detect relationship type for conversation
  Future<RelationshipType> getRelationshipType(String conversationId) async {
    try {
      final response = await _supabase
          .from('conversations')
          .select('relationship_type')
          .eq('id', conversationId)
          .single();

      return RelationshipType.fromString(response['relationship_type'] as String?);
    } catch (e) {
      print('Warning: Could not fetch relationship type: $e');
      return RelationshipType.none;
    }
  }

  /// Update relationship type for conversation
  Future<void> setRelationshipType(String conversationId, RelationshipType type) async {
    try {
      await _supabase
          .from('conversations')
          .update({'relationship_type': type.value})
          .eq('id', conversationId);
      
      print('✅ Relationship type updated to: ${type.displayName}');
    } catch (e) {
      print('❌ Error updating relationship type: $e');
      rethrow;
    }
  }
}
</file>

<file path="frontend/lib/services/follow_up_service.dart">
// ignore_for_file: avoid_print

import 'package:http/http.dart' as http;
import 'dart:convert';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/models/follow_up_item.dart';

/// Service for managing follow-up items
class FollowUpService {
  static final FollowUpService _instance = FollowUpService._internal();
  factory FollowUpService() => _instance;
  FollowUpService._internal();

  final _supabase = SupabaseClientProvider.client;

  String get _baseUrl {
    final supabaseUrl = _supabase.supabaseUrl;
    return '$supabaseUrl/functions/v1';
  }

  /// Extract follow-ups from conversation
  Future<void> extractFollowUps(String conversationId, {bool scanAll = false}) async {
    try {
      final token = _supabase.auth.currentSession?.accessToken;
      if (token == null) throw Exception('Not authenticated');

      await http.post(
        Uri.parse('$_baseUrl/ai-extract-followups'),
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
        body: jsonEncode({
          'conversation_id': conversationId,
          'scan_recent_messages': scanAll,
        }),
      );
    } catch (e) {
      print('Error extracting follow-ups: $e');
      rethrow;
    }
  }

  /// Get all pending follow-ups for user
  Future<List<FollowUpItem>> getPendingFollowUps() async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return [];

      final response = await _supabase.rpc('get_pending_followups', params: {
        'p_user_id': userId,
        'p_limit': 50,
      });

      if (response == null) return [];

      return (response as List)
          .map((data) => FollowUpItem.fromJson({
                'user_id': userId,
                ...data as Map<String, dynamic>,
              }))
          .toList();
    } catch (e) {
      print('Error getting pending follow-ups: $e');
      return [];
    }
  }

  /// Get follow-ups for specific conversation
  Future<List<FollowUpItem>> getConversationFollowUps(String conversationId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return [];

      final response = await _supabase.rpc('get_conversation_followups', params: {
        'p_user_id': userId,
        'p_conversation_id': conversationId,
      });

      if (response == null) return [];

      return (response as List)
          .map((data) => FollowUpItem.fromJson({
                'user_id': userId,
                'conversation_id': conversationId,
                ...data as Map<String, dynamic>,
              }))
          .toList();
    } catch (e) {
      print('Error getting conversation follow-ups: $e');
      return [];
    }
  }

  /// Mark follow-up as completed
  Future<void> completeFollowUp(String itemId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      await _supabase.rpc('complete_followup', params: {
        'p_user_id': userId,
        'p_item_id': itemId,
      });
    } catch (e) {
      print('Error completing follow-up: $e');
      rethrow;
    }
  }

  /// Snooze follow-up
  Future<void> snoozeFollowUp(String itemId, Duration duration) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      await _supabase.rpc('snooze_followup', params: {
        'p_user_id': userId,
        'p_item_id': itemId,
        'p_snooze_duration': duration.inSeconds,
      });
    } catch (e) {
      print('Error snoozing follow-up: $e');
      rethrow;
    }
  }

  /// Dismiss follow-up
  Future<void> dismissFollowUp(String itemId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;

      await _supabase.from('follow_up_items').update({
        'status': 'dismissed',
        'updated_at': now,
      }).eq('id', itemId).eq('user_id', userId);
    } catch (e) {
      print('Error dismissing follow-up: $e');
      rethrow;
    }
  }
}
</file>

<file path="frontend/lib/services/message_formatter_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/models/formatted_message.dart';

/// Service for formatting messages
class MessageFormatterService {
  final SupabaseClient _supabase;

  MessageFormatterService(this._supabase);

  /// Format a message with specified options
  Future<FormattedMessage> formatMessage({
    required String message,
    bool condense = false,
    bool chunk = false,
    bool addTldr = false,
    bool addStructure = false,
  }) async {
    try {
      print('🎨 Formatting message...');
      
      final response = await _supabase.functions.invoke(
        'ai-format-message',
        body: {
          'message': message,
          'options': {
            'condense': condense,
            'chunk': chunk,
            'add_tldr': addTldr,
            'add_structure': addStructure,
          },
        },
      );

      if (response.data == null) {
        throw Exception('No response from message formatting service');
      }

      final data = response.data as Map<String, dynamic>;
      
      if (data['success'] != true) {
        throw Exception(data['error'] ?? 'Formatting failed');
      }

      final formatted = FormattedMessage.fromJson(
        data['formatted'] as Map<String, dynamic>,
      );
      
      print('✅ Message formatted: ${formatted.originalLength} → ${formatted.characterCount} chars');
      
      return formatted;
    } catch (e) {
      print('❌ Error formatting message: $e');
      rethrow;
    }
  }

  /// Quick format: condense only
  Future<FormattedMessage> condenseMessage(String message) {
    return formatMessage(message: message, condense: true);
  }

  /// Quick format: add structure
  Future<FormattedMessage> structureMessage(String message) {
    return formatMessage(message: message, addStructure: true, chunk: true);
  }

  /// Quick format: full formatting (all options)
  Future<FormattedMessage> fullFormat(String message) {
    return formatMessage(
      message: message,
      condense: true,
      chunk: true,
      addTldr: true,
      addStructure: true,
    );
  }
}
</file>

<file path="frontend/lib/services/network_connectivity_service.dart">
import 'dart:async';
import 'package:flutter/foundation.dart';

/// Network connectivity states
enum ConnectivityStatus {
  online,
  offline,
  unknown,
}

/// Service for monitoring network connectivity
/// Note: For production, consider using connectivity_plus package
class NetworkConnectivityService {
  static final NetworkConnectivityService _instance =
      NetworkConnectivityService._internal();

  factory NetworkConnectivityService() {
    return _instance;
  }

  NetworkConnectivityService._internal();

  final _statusController = StreamController<ConnectivityStatus>.broadcast();
  ConnectivityStatus _currentStatus = ConnectivityStatus.unknown;
  Timer? _pingTimer;
  bool _isMonitoring = false;

  /// Get current connectivity status
  ConnectivityStatus get currentStatus => _currentStatus;

  /// Stream of connectivity status changes
  Stream<ConnectivityStatus> get onStatusChange => _statusController.stream;

  /// Check if currently online
  bool get isOnline => _currentStatus == ConnectivityStatus.online;

  /// Check if currently offline
  bool get isOffline => _currentStatus == ConnectivityStatus.offline;

  /// Start monitoring connectivity
  void startMonitoring({Duration checkInterval = const Duration(seconds: 10)}) {
    if (_isMonitoring) {
      print('⚠️  Connectivity monitoring already started');
      return;
    }

    _isMonitoring = true;
    print('🌐 Starting connectivity monitoring (every ${checkInterval.inSeconds}s)');

    // Check immediately
    _checkConnectivity();

    // Then check periodically
    _pingTimer = Timer.periodic(checkInterval, (_) {
      _checkConnectivity();
    });
  }

  /// Stop monitoring connectivity
  void stopMonitoring() {
    _pingTimer?.cancel();
    _pingTimer = null;
    _isMonitoring = false;
    print('🌐 Stopped connectivity monitoring');
  }

  /// Check connectivity status
  Future<void> _checkConnectivity() async {
    try {
      // Simple connectivity check
      // In production, use connectivity_plus package for better detection
      final previousStatus = _currentStatus;
      final newStatus = await _performConnectivityCheck();

      if (newStatus != previousStatus) {
        _currentStatus = newStatus;
        _statusController.add(_currentStatus);
        _logStatusChange(previousStatus, newStatus);
      }
    } catch (e) {
      print('❌ Error checking connectivity: $e');
    }
  }

  /// Perform actual connectivity check
  /// Override this method to use connectivity_plus or other packages
  Future<ConnectivityStatus> _performConnectivityCheck() async {
    try {
      // For now, we assume online unless explicitly set offline
      // In production, use connectivity_plus to check actual network state
      
      // You can enhance this by:
      // 1. Using connectivity_plus package
      // 2. Pinging a known endpoint
      // 3. Checking platform-specific APIs
      
      return ConnectivityStatus.online;
    } catch (e) {
      return ConnectivityStatus.offline;
    }
  }

  /// Manually set connectivity status (useful for testing)
  void setStatus(ConnectivityStatus status) {
    if (_currentStatus != status) {
      final previousStatus = _currentStatus;
      _currentStatus = status;
      _statusController.add(_currentStatus);
      _logStatusChange(previousStatus, status);
    }
  }

  /// Force a connectivity check now
  Future<ConnectivityStatus> checkNow() async {
    final status = await _performConnectivityCheck();
    if (status != _currentStatus) {
      final previousStatus = _currentStatus;
      _currentStatus = status;
      _statusController.add(_currentStatus);
      _logStatusChange(previousStatus, status);
    }
    return _currentStatus;
  }

  /// Log status changes
  void _logStatusChange(
    ConnectivityStatus previous,
    ConnectivityStatus current,
  ) {
    final emoji = current == ConnectivityStatus.online ? '✅' : '📴';
    print('$emoji Connectivity: ${previous.name} → ${current.name}');
  }

  /// Dispose resources
  void dispose() {
    stopMonitoring();
    _statusController.close();
  }
}

/// Extension for convenience methods
extension ConnectivityStatusExtension on ConnectivityStatus {
  bool get isOnline => this == ConnectivityStatus.online;
  bool get isOffline => this == ConnectivityStatus.offline;
  bool get isUnknown => this == ConnectivityStatus.unknown;
}
</file>

<file path="frontend/lib/services/offline_queue_service.dart">
import 'dart:async';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/services/network_connectivity_service.dart';
import 'package:messageai/services/retry_service.dart';
import 'package:messageai/core/errors/app_error.dart';

/// Service for managing offline message queue and auto-sync
class OfflineQueueService {
  static final OfflineQueueService _instance =
      OfflineQueueService._internal();

  factory OfflineQueueService() {
    return _instance;
  }

  OfflineQueueService._internal();

  final _db = AppDb.instance;
  final _supabase = SupabaseClientProvider.client;
  final _connectivityService = NetworkConnectivityService();
  final _retryService = RetryService();

  StreamSubscription<ConnectivityStatus>? _connectivitySubscription;
  Timer? _syncTimer;
  bool _isSyncing = false;
  bool _isMonitoring = false;

  /// Start monitoring and auto-syncing
  void startMonitoring() {
    if (_isMonitoring) {
      return;
    }

    _isMonitoring = true;

    // Listen for connectivity changes - only sync when coming back online
    _connectivitySubscription = _connectivityService.onStatusChange.listen((status) {
      if (status == ConnectivityStatus.online) {
        syncPendingMessages();
      }
    });

    // No periodic polling - sync only happens:
    // 1. When connectivity is restored
    // 2. When explicitly requested (e.g., after sending a message)
  }

  /// Stop monitoring
  void stopMonitoring() {
    _connectivitySubscription?.cancel();
    _connectivitySubscription = null;
    _syncTimer?.cancel();
    _syncTimer = null;
    _isMonitoring = false;
    print('📦 Stopped offline queue monitoring');
  }

  /// Get count of pending messages
  Future<int> getPendingMessageCount() async {
    try {
      final messages = await _db.messageDao.getUnsyncedMessages();
      return messages.length;
    } catch (e) {
      print('❌ Error getting pending message count: $e');
      return 0;
    }
  }

  /// Sync all pending messages
  Future<SyncResult> syncPendingMessages() async {
    if (_isSyncing) {
      return SyncResult.alreadyRunning();
    }

    if (_connectivityService.isOffline) {
      return SyncResult.offline();
    }

    _isSyncing = true;
    int successCount = 0;
    int failureCount = 0;
    final List<String> failedMessageIds = [];

    try {
      final pendingMessages = await _db.messageDao.getUnsyncedMessages();

      if (pendingMessages.isEmpty) {
        return SyncResult.noMessages();
      }

      for (final message in pendingMessages) {
        final result = await _syncSingleMessage(message);
        if (result) {
          successCount++;
        } else {
          failureCount++;
          failedMessageIds.add(message.id);
        }
      }

      if (failureCount > 0) {
        print('⚠️ Sync: $successCount succeeded, $failureCount failed');
      }

      return SyncResult(
        totalMessages: pendingMessages.length,
        successCount: successCount,
        failureCount: failureCount,
        failedMessageIds: failedMessageIds,
      );
    } catch (e) {
      print('❌ Error syncing: $e');
      return SyncResult.error(e.toString());
    } finally {
      _isSyncing = false;
    }
  }

  /// Sync a single message with retry
  Future<bool> _syncSingleMessage(Message message) async {
    try {
      final result = await _retryService.execute(
        operation: () => _sendMessageToBackend(message),
        operationName: 'Sync Message ${message.id.substring(0, 8)}',
        config: RetryConfig.defaultConfig,
      );

      if (result.succeeded) {
        await _db.messageDao.markMessageAsSynced(message.id);
        return true;
      } else {
        final error = result.error;
        
        // If error is non-retryable, delete the message from queue
        if (error != null && !error.isRetryable) {
          print('🗑️ Removed invalid message: ${error.code}');
          await _db.messageDao.deleteMessage(message.id);
          return true;
        }
        
        return false;
      }
    } catch (e) {
      return false;
    }
  }

  /// Send message to backend
  Future<void> _sendMessageToBackend(Message message) async {
    final payload = {
      'id': message.id,
      'conversation_id': message.conversationId,
      'sender_id': message.senderId,
      'body': message.body,
      'media_url': message.mediaUrl,
      'created_at': DateTime.fromMillisecondsSinceEpoch(message.createdAt * 1000)
          .toIso8601String(),
      'updated_at': DateTime.fromMillisecondsSinceEpoch(message.updatedAt * 1000)
          .toIso8601String(),
    };

    await _supabase.from('messages').insert(payload);
    
    // Send push notification (don't wait for it)
    _sendPushNotification(message).catchError((e) {
      // Silently fail - push notifications are not critical
    });
  }

  /// Send push notification for message
  Future<void> _sendPushNotification(Message message) async {
    try {
      // Get sender profile (use maybeSingle to handle missing profile)
      final profile = await _supabase
          .from('profiles')
          .select('username, email')
          .eq('user_id', message.senderId)
          .maybeSingle();

      final senderName = profile?['username'] as String? ?? 
                         profile?['email'] as String? ?? 
                         'Someone';

      // Call push notification edge function with auth header
      final accessToken = _supabase.auth.currentSession?.accessToken;
      if (accessToken == null) return;
      
      await _supabase.functions.invoke(
        'push_notify',
        body: {
          'message_id': message.id,
          'conversation_id': message.conversationId,
          'sender_id': message.senderId,
          'sender_name': senderName,
          'title': senderName,
          'body': message.body,
        },
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      );
    } catch (e) {
      // Ignore errors
    }
  }

  /// Force sync now (called by user action)
  Future<SyncResult> forceSyncNow() async {
    print('🔄 Force sync requested');
    return await syncPendingMessages();
  }

  /// Check if any messages are pending
  Future<bool> hasPendingMessages() async {
    final count = await getPendingMessageCount();
    return count > 0;
  }

  /// Dispose resources
  void dispose() {
    stopMonitoring();
  }
}

/// Result of sync operation
class SyncResult {
  final int totalMessages;
  final int successCount;
  final int failureCount;
  final List<String> failedMessageIds;
  final String? errorMessage;
  final SyncStatus status;

  SyncResult({
    required this.totalMessages,
    required this.successCount,
    required this.failureCount,
    this.failedMessageIds = const [],
    this.errorMessage,
    this.status = SyncStatus.completed,
  });

  SyncResult.noMessages()
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          status: SyncStatus.noMessages,
        );

  SyncResult.offline()
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          status: SyncStatus.offline,
        );

  SyncResult.alreadyRunning()
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          status: SyncStatus.alreadyRunning,
        );

  SyncResult.error(String message)
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          errorMessage: message,
          status: SyncStatus.error,
        );

  bool get hasErrors => failureCount > 0 || errorMessage != null;
  bool get isSuccess => failureCount == 0 && errorMessage == null;
  bool get isPartialSuccess => successCount > 0 && failureCount > 0;
}

/// Status of sync operation
enum SyncStatus {
  completed,
  noMessages,
  offline,
  alreadyRunning,
  error,
}
</file>

<file path="frontend/lib/services/realtime_diagnostic_service.dart">
import 'dart:async';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Diagnostic information about a Realtime channel
class RealtimeChannelDiagnostics {
  final String channelName;
  final String status;
  final DateTime subscribedAt;
  final DateTime? lastMessageAt;
  final int messagesReceived;
  final List<String> errors;
  final Duration? latency;

  RealtimeChannelDiagnostics({
    required this.channelName,
    required this.status,
    required this.subscribedAt,
    this.lastMessageAt,
    this.messagesReceived = 0,
    this.errors = const [],
    this.latency,
  });

  bool get isHealthy => status == 'SUBSCRIBED' && errors.isEmpty;
  
  Duration get timeSinceLastMessage => 
      lastMessageAt != null 
          ? DateTime.now().difference(lastMessageAt!)
          : Duration.zero;
}

/// Service for diagnosing and monitoring Realtime connections
class RealtimeDiagnosticService {
  static final RealtimeDiagnosticService _instance =
      RealtimeDiagnosticService._internal();

  factory RealtimeDiagnosticService() {
    return _instance;
  }

  RealtimeDiagnosticService._internal();

  final _supabase = SupabaseClientProvider.client;
  final Map<String, RealtimeChannelDiagnostics> _channelDiagnostics = {};
  final Map<String, DateTime> _messageTimestamps = {};
  Timer? _healthCheckTimer;
  bool _isMonitoring = false;

  /// Start monitoring Realtime health
  void startMonitoring({Duration checkInterval = const Duration(seconds: 5)}) {
    if (_isMonitoring) {
      return;
    }

    _isMonitoring = true;
    _healthCheckTimer = Timer.periodic(checkInterval, (_) {
      _performHealthCheck();
    });
  }

  /// Stop monitoring
  void stopMonitoring() {
    _healthCheckTimer?.cancel();
    _healthCheckTimer = null;
    _isMonitoring = false;
  }

  /// Register a channel for monitoring
  void registerChannel(String channelName, RealtimeChannel channel) {
    _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
      channelName: channelName,
      status: 'SUBSCRIBING',
      subscribedAt: DateTime.now(),
    );
  }

  /// Update channel status
  void updateChannelStatus(String channelName, String status) {
    final current = _channelDiagnostics[channelName];
    if (current != null) {
      _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
        channelName: channelName,
        status: status,
        subscribedAt: current.subscribedAt,
        lastMessageAt: current.lastMessageAt,
        messagesReceived: current.messagesReceived,
        errors: current.errors,
        latency: current.latency,
      );
    }
  }

  /// Record message received
  void recordMessageReceived(String channelName) {
    final current = _channelDiagnostics[channelName];
    if (current != null) {
      final now = DateTime.now();
      
      // Calculate latency if we have a timestamp
      Duration? latency;
      if (_messageTimestamps.containsKey(channelName)) {
        latency = now.difference(_messageTimestamps[channelName]!);
      }

      _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
        channelName: channelName,
        status: current.status,
        subscribedAt: current.subscribedAt,
        lastMessageAt: now,
        messagesReceived: current.messagesReceived + 1,
        errors: current.errors,
        latency: latency,
      );
    }
  }

  /// Record error
  void recordError(String channelName, String error) {
    final current = _channelDiagnostics[channelName];
    if (current != null) {
      final newErrors = List<String>.from(current.errors)..add(error);
      
      _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
        channelName: channelName,
        status: current.status,
        subscribedAt: current.subscribedAt,
        lastMessageAt: current.lastMessageAt,
        messagesReceived: current.messagesReceived,
        errors: newErrors,
        latency: current.latency,
      );

      print('❌ Error on $channelName: $error');
    }
  }

  /// Mark message send timestamp (for latency calculation)
  void markMessageSent(String channelName) {
    _messageTimestamps[channelName] = DateTime.now();
  }

  /// Perform health check on all channels
  void _performHealthCheck() {
    print('🏥 Realtime Health Check');
    print('━' * 60);

    if (_channelDiagnostics.isEmpty) {
      print('   No active channels');
      return;
    }

    for (final entry in _channelDiagnostics.entries) {
      final channel = entry.key;
      final diag = entry.value;

      final healthEmoji = diag.isHealthy ? '✅' : '⚠️';
      final statusEmoji = _getStatusEmoji(diag.status);

      print('$healthEmoji $channel');
      print('   $statusEmoji Status: ${diag.status}');
      print('   📊 Messages: ${diag.messagesReceived}');
      
      if (diag.lastMessageAt != null) {
        final timeSince = DateTime.now().difference(diag.lastMessageAt!);
        print('   ⏱️  Last message: ${timeSince.inSeconds}s ago');
      }

      if (diag.latency != null) {
        print('   🚀 Latency: ${diag.latency!.inMilliseconds}ms');
      }

      if (diag.errors.isNotEmpty) {
        print('   ❌ Errors: ${diag.errors.length}');
        for (final error in diag.errors.take(3)) {
          print('      - $error');
        }
      }

      final uptime = DateTime.now().difference(diag.subscribedAt);
      print('   ⏰ Uptime: ${_formatDuration(uptime)}');
      print('');
    }

    print('━' * 60);
  }

  /// Get emoji for status
  String _getStatusEmoji(String status) {
    switch (status) {
      case 'SUBSCRIBED':
        return '✅';
      case 'SUBSCRIBING':
        return '🔄';
      case 'CLOSED':
        return '⏸️';
      case 'CHANNEL_ERROR':
        return '❌';
      case 'TIMED_OUT':
        return '⏰';
      default:
        return '❓';
    }
  }

  /// Format duration nicely
  String _formatDuration(Duration duration) {
    if (duration.inSeconds < 60) {
      return '${duration.inSeconds}s';
    } else if (duration.inMinutes < 60) {
      return '${duration.inMinutes}m ${duration.inSeconds % 60}s';
    } else {
      return '${duration.inHours}h ${duration.inMinutes % 60}m';
    }
  }

  /// Get diagnostics for a channel
  RealtimeChannelDiagnostics? getDiagnostics(String channelName) {
    return _channelDiagnostics[channelName];
  }

  /// Get all diagnostics
  Map<String, RealtimeChannelDiagnostics> getAllDiagnostics() {
    return Map.from(_channelDiagnostics);
  }

  /// Test Realtime connection
  Future<RealtimeTestResult> testConnection() async {
    print('🧪 Testing Realtime connection...');
    
    final startTime = DateTime.now();
    final testChannel = _supabase.realtime.channel('test_${startTime.millisecondsSinceEpoch}');
    
    try {
      final completer = Completer<RealtimeTestResult>();
      var subscribeStatus = 'UNKNOWN';

      testChannel.subscribe(
        (status, [error]) {
          subscribeStatus = status;
          
          if (status == 'SUBSCRIBED') {
            final latency = DateTime.now().difference(startTime);
            completer.complete(RealtimeTestResult(
              success: true,
              latency: latency,
              status: status,
            ));
          } else if (status == 'CHANNEL_ERROR' || status == 'TIMED_OUT') {
            completer.complete(RealtimeTestResult(
            success: false,
            status: status,
            error: error?.toString(),
          ));
        }
      },
      const Duration(seconds: 30), // Test with 30s timeout
      );

      // Timeout after 10 seconds
      final result = await completer.future.timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          return RealtimeTestResult(
            success: false,
            status: 'TIMEOUT',
            error: 'Connection test timed out after 10 seconds',
          );
        },
      );

      // Clean up
      await testChannel.unsubscribe();

      return result;
    } catch (e) {
      return RealtimeTestResult(
        success: false,
        status: 'ERROR',
        error: e.toString(),
      );
    }
  }

  /// Generate diagnostic report
  String generateReport() {
    final buffer = StringBuffer();
    
    buffer.writeln('═' * 60);
    buffer.writeln('REALTIME DIAGNOSTICS REPORT');
    buffer.writeln('Generated: ${DateTime.now()}');
    buffer.writeln('═' * 60);
    buffer.writeln();

    if (_channelDiagnostics.isEmpty) {
      buffer.writeln('No active channels');
      return buffer.toString();
    }

    for (final entry in _channelDiagnostics.entries) {
      final diag = entry.value;
      
      buffer.writeln('Channel: ${diag.channelName}');
      buffer.writeln('  Status: ${diag.status} ${diag.isHealthy ? '✓' : '✗'}');
      buffer.writeln('  Messages Received: ${diag.messagesReceived}');
      buffer.writeln('  Subscribed At: ${diag.subscribedAt}');
      
      if (diag.lastMessageAt != null) {
        buffer.writeln('  Last Message: ${diag.lastMessageAt}');
        buffer.writeln('  Time Since Last: ${diag.timeSinceLastMessage.inSeconds}s');
      }
      
      if (diag.latency != null) {
        buffer.writeln('  Latency: ${diag.latency!.inMilliseconds}ms');
      }
      
      if (diag.errors.isNotEmpty) {
        buffer.writeln('  Errors: ${diag.errors.length}');
        for (final error in diag.errors) {
          buffer.writeln('    - $error');
        }
      }
      
      buffer.writeln();
    }

    buffer.writeln('═' * 60);
    return buffer.toString();
  }

  /// Dispose resources
  void dispose() {
    stopMonitoring();
    _channelDiagnostics.clear();
    _messageTimestamps.clear();
  }
}

/// Result of Realtime connection test
class RealtimeTestResult {
  final bool success;
  final Duration? latency;
  final String status;
  final String? error;

  RealtimeTestResult({
    required this.success,
    this.latency,
    required this.status,
    this.error,
  });

  @override
  String toString() {
    if (success) {
      return 'SUCCESS: Connected in ${latency?.inMilliseconds}ms (Status: $status)';
    } else {
      return 'FAILED: $status${error != null ? ' - $error' : ''}';
    }
  }
}
</file>

<file path="frontend/lib/services/relationship_service.dart">
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/models/relationship_profile.dart';
import 'package:messageai/models/safe_topic.dart';

/// Service for managing relationship profiles
class RelationshipService {
  static final RelationshipService _instance = RelationshipService._internal();
  factory RelationshipService() => _instance;
  RelationshipService._internal();

  final _supabase = SupabaseClientProvider.client;

  /// Get relationship profile for a conversation
  Future<RelationshipProfile?> getProfile(String conversationId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return null;

      final response = await _supabase.rpc('get_relationship_profile', params: {
        'p_user_id': userId,
        'p_conversation_id': conversationId,
      });

      if (response == null || response.isEmpty) return null;

      return RelationshipProfile.fromJson({
        'user_id': userId,
        'conversation_id': conversationId,
        ...response as Map<String, dynamic>,
      });
    } catch (e) {
      print('Error getting relationship profile: $e');
      return null;
    }
  }

  /// Get safe topics for a conversation
  Future<List<SafeTopic>> getSafeTopics(String conversationId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return [];

      final response = await _supabase.rpc('get_safe_topics', params: {
        'p_user_id': userId,
        'p_conversation_id': conversationId,
      });

      if (response == null) return [];

      return (response as List)
          .map((data) => SafeTopic.fromJson(data as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('Error getting safe topics: $e');
      return [];
    }
  }

  /// Update relationship notes
  Future<void> updateNotes(String conversationId, String notes) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      await _supabase
          .from('relationship_profiles')
          .update({'relationship_notes': notes})
          .eq('user_id', userId)
          .eq('conversation_id', conversationId);
    } catch (e) {
      print('Error updating notes: $e');
      rethrow;
    }
  }

  /// Update relationship type
  Future<void> updateRelationshipType(
    String conversationId,
    String relationshipType,
  ) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      await _supabase
          .from('relationship_profiles')
          .update({'relationship_type': relationshipType})
          .eq('user_id', userId)
          .eq('conversation_id', conversationId);
    } catch (e) {
      print('Error updating relationship type: $e');
      rethrow;
    }
  }
}
</file>

<file path="frontend/lib/services/response_template_service.dart">
import 'package:messageai/models/response_template.dart';
import 'package:messageai/models/situation_type.dart';

/// Service for managing response templates
class ResponseTemplateService {
  static final ResponseTemplateService _instance = 
      ResponseTemplateService._internal();
  factory ResponseTemplateService() => _instance;
  ResponseTemplateService._internal();

  // In-memory template storage (loaded from backend)
  final Map<String, ResponseTemplate> _templates = {};
  final Map<SituationType, List<String>> _templatesBySituation = {};
  bool _initialized = false;

  /// Initialize templates (call on app start)
  Future<void> loadTemplates() async {
    if (_initialized) return;
    
    // TODO: Load from backend or local storage
    // For now, using hardcoded templates
    _initializeHardcodedTemplates();
    _initialized = true;
  }

  /// Get template by ID
  ResponseTemplate? getTemplate(String id) {
    return _templates[id];
  }

  /// Get templates for a situation type
  List<ResponseTemplate> getTemplatesForSituation(SituationType situation) {
    final templateIds = _templatesBySituation[situation] ?? [];
    return templateIds
        .map((id) => _templates[id])
        .whereType<ResponseTemplate>()
        .toList();
  }

  /// Get all templates
  List<ResponseTemplate> getAllTemplates() {
    return _templates.values.toList();
  }

  /// Search templates by keywords
  List<ResponseTemplate> searchTemplates(String query) {
    final lowerQuery = query.toLowerCase();
    return _templates.values.where((template) {
      return template.name.toLowerCase().contains(lowerQuery) ||
             template.situation.toLowerCase().contains(lowerQuery) ||
             template.context.any((c) => c.toLowerCase().contains(lowerQuery));
    }).toList();
  }

  void _initializeHardcodedTemplates() {
    // Declining templates
    final decliningTemplates = [
      ResponseTemplate(
        id: 'decline_polite',
        name: 'Polite Decline',
        situation: 'When you need to say no professionally',
        template: "Thank you for thinking of me! Unfortunately, I won't be able to {activity} {timeframe}. I appreciate your understanding.",
        tone: 'polite',
        context: ['can you', 'would you', 'invitation'],
        neurodivergentFriendly: true,
        customizableFields: ['activity', 'timeframe'],
      ),
      ResponseTemplate(
        id: 'decline_no_explanation',
        name: 'Direct Decline',
        situation: "When you don't owe an explanation",
        template: "Thanks for the invite, but I'm not able to join this time.",
        tone: 'direct',
        context: ['party', 'event', 'hangout'],
        neurodivergentFriendly: true,
      ),
      ResponseTemplate(
        id: 'decline_with_alternative',
        name: 'Decline with Counter-Offer',
        situation: 'When you want to participate but need different terms',
        template: "I can't {original_request}, but I could {alternative}. Would that work?",
        tone: 'casual',
        context: ['meeting', 'call', 'hangout'],
        neurodivergentFriendly: true,
        customizableFields: ['original_request', 'alternative'],
      ),
      ResponseTemplate(
        id: 'decline_capacity',
        name: 'At Capacity (Mental Health)',
        situation: 'When you need to protect your energy',
        template: "I really appreciate you thinking of me, but I need to be mindful of my capacity right now. I'll have to pass on this one.",
        tone: 'apologetic',
        context: ['favor', 'help', 'support'],
        neurodivergentFriendly: true,
      ),
    ];

    // Boundary templates
    final boundaryTemplates = [
      ResponseTemplate(
        id: 'boundary_time',
        name: 'Time Boundary',
        situation: 'When someone expects 24/7 availability',
        template: "I'm available to discuss this during {your_hours}. Can we schedule a time within those hours?",
        tone: 'direct',
        context: ['urgent', 'right now', 'immediately'],
        neurodivergentFriendly: true,
        customizableFields: ['your_hours'],
      ),
      ResponseTemplate(
        id: 'boundary_communication',
        name: 'Communication Preference',
        situation: "When someone uses a communication method that doesn't work for you",
        template: "I process information better through {preferred_method}. Could we switch to that for this conversation?",
        tone: 'direct',
        context: ['call', 'video', 'meeting'],
        neurodivergentFriendly: true,
        customizableFields: ['preferred_method'],
      ),
      ResponseTemplate(
        id: 'boundary_topic',
        name: 'Topic Boundary',
        situation: "When someone brings up something you don't want to discuss",
        template: "I'm not comfortable discussing {topic}. Let's talk about something else.",
        tone: 'direct',
        context: ['personal', 'private', 'politics'],
        neurodivergentFriendly: true,
        customizableFields: ['topic'],
      ),
    ];

    // Info-dump templates
    final infoDumpTemplates = [
      ResponseTemplate(
        id: 'infodump_intro',
        name: 'Info-Dump with Warning',
        situation: 'When you want to share a lot about something you love',
        template: "I'm really excited about {topic}! Fair warning: I could talk about this for hours 😊 Are you interested in hearing more?",
        tone: 'casual',
        context: ['excited', 'interesting', 'found'],
        neurodivergentFriendly: true,
        customizableFields: ['topic'],
      ),
      ResponseTemplate(
        id: 'infodump_chunked',
        name: 'Info-Dump in Chunks',
        situation: 'When you want to share but keep it digestible',
        template: "Quick version: {short_summary}\n\nWant the details? I can break it down into:\n1. {aspect_1}\n2. {aspect_2}\n3. {aspect_3}\n\nLet me know what interests you!",
        tone: 'casual',
        context: ['explain', 'tell', 'share'],
        neurodivergentFriendly: true,
        customizableFields: ['short_summary', 'aspect_1', 'aspect_2', 'aspect_3'],
      ),
    ];

    // Apologizing templates
    final apologizingTemplates = [
      ResponseTemplate(
        id: 'apology_genuine',
        name: 'Genuine Apology',
        situation: 'When you actually did something wrong',
        template: "I'm sorry for {what_you_did}. I understand that {impact}. Going forward, I'll {corrective_action}.",
        tone: 'apologetic',
        context: ['mistake', 'wrong', 'messed up'],
        neurodivergentFriendly: true,
        customizableFields: ['what_you_did', 'impact', 'corrective_action'],
      ),
      ResponseTemplate(
        id: 'apology_no_need',
        name: 'Replace Unnecessary Apology',
        situation: "When you're apologizing out of habit",
        template: "Thank you for {what_they_did}. I appreciate {specific_thing}.",
        tone: 'polite',
        context: ['sorry for', 'apologies for'],
        neurodivergentFriendly: true,
        customizableFields: ['what_they_did', 'specific_thing'],
      ),
    ];

    // Clarifying templates
    final clarifyingTemplates = [
      ResponseTemplate(
        id: 'clarify_misunderstand',
        name: 'Admit Confusion',
        situation: "When you don't understand something",
        template: "I want to make sure I understand correctly. Are you saying {your_interpretation}?",
        tone: 'direct',
        context: ['confused', 'unclear', 'not sure'],
        neurodivergentFriendly: true,
        customizableFields: ['your_interpretation'],
      ),
      ResponseTemplate(
        id: 'clarify_literal',
        name: 'Ask for Literal Meaning',
        situation: 'When you need things stated directly',
        template: "I'm having trouble reading between the lines. Could you tell me directly what you need from me?",
        tone: 'direct',
        context: ['ambiguous', 'vague', 'hint'],
        neurodivergentFriendly: true,
      ),
    ];

    // Store templates
    final allTemplates = [
      ...decliningTemplates,
      ...boundaryTemplates,
      ...infoDumpTemplates,
      ...apologizingTemplates,
      ...clarifyingTemplates,
    ];
    
    for (final template in allTemplates) {
      _templates[template.id] = template;
    }

    // Index by situation
    _templatesBySituation[SituationType.declining] = 
        decliningTemplates.map((t) => t.id).toList();
    _templatesBySituation[SituationType.boundarySetting] = 
        boundaryTemplates.map((t) => t.id).toList();
    _templatesBySituation[SituationType.infoDumping] = 
        infoDumpTemplates.map((t) => t.id).toList();
    _templatesBySituation[SituationType.apologizing] = 
        apologizingTemplates.map((t) => t.id).toList();
    _templatesBySituation[SituationType.clarifying] = 
        clarifyingTemplates.map((t) => t.id).toList();
  }
}
</file>

<file path="frontend/lib/services/retry_service.dart">
import 'dart:async';
import 'dart:math';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_handler.dart';

/// Configuration for retry behavior
class RetryConfig {
  final int maxAttempts;
  final Duration initialDelay;
  final Duration maxDelay;
  final double backoffMultiplier;
  final bool useJitter;

  const RetryConfig({
    this.maxAttempts = 3,
    this.initialDelay = const Duration(seconds: 1),
    this.maxDelay = const Duration(seconds: 30),
    this.backoffMultiplier = 2.0,
    this.useJitter = true,
  });

  /// Aggressive retry (more attempts, faster)
  static const aggressive = RetryConfig(
    maxAttempts: 5,
    initialDelay: Duration(milliseconds: 500),
    maxDelay: Duration(seconds: 15),
  );

  /// Conservative retry (fewer attempts, slower)
  static const conservative = RetryConfig(
    maxAttempts: 2,
    initialDelay: Duration(seconds: 2),
    maxDelay: Duration(seconds: 60),
  );

  /// Default retry configuration
  static const defaultConfig = RetryConfig();
}

/// Result of a retry operation
class RetryResult<T> {
  final T? data;
  final AppError? error;
  final int attempts;
  final bool succeeded;

  RetryResult({
    this.data,
    this.error,
    required this.attempts,
    required this.succeeded,
  });

  RetryResult.success(T data, int attempts)
      : this(
          data: data,
          succeeded: true,
          attempts: attempts,
        );

  RetryResult.failure(AppError error, int attempts)
      : this(
          error: error,
          succeeded: false,
          attempts: attempts,
        );
}

/// Service for handling retries with exponential backoff
class RetryService {
  static final RetryService _instance = RetryService._internal();

  factory RetryService() {
    return _instance;
  }

  RetryService._internal();

  final _errorHandler = ErrorHandler();
  final _random = Random();

  /// Execute operation with retry logic
  Future<RetryResult<T>> execute<T>({
    required Future<T> Function() operation,
    required String operationName,
    RetryConfig config = RetryConfig.defaultConfig,
    bool Function(AppError)? shouldRetry,
  }) async {
    int attemptNumber = 0;
    AppError? lastError;

    while (attemptNumber < config.maxAttempts) {
      attemptNumber++;

      try {
        final result = await operation();
        return RetryResult.success(result, attemptNumber);
      } catch (error, stackTrace) {
        // Convert to AppError
        final appError = error is AppError
            ? error
            : _errorHandler.handleError(
                error,
                stackTrace: stackTrace,
                context: operationName,
              );

        lastError = appError;

        // Check if we should retry
        final shouldRetryThis = shouldRetry?.call(appError) ??
            _errorHandler.shouldRetry(appError, attemptNumber, maxAttempts: config.maxAttempts);

        if (!shouldRetryThis) {
          return RetryResult.failure(appError, attemptNumber);
        }

        // Calculate delay before next attempt
        if (attemptNumber < config.maxAttempts) {
          final delay = _calculateDelay(
            attemptNumber,
            config: config,
          );
          await Future.delayed(delay);
        }
      }
    }

    return RetryResult.failure(
      lastError ?? AppError(
        category: ErrorCategory.unknown,
        severity: ErrorSeverity.error,
        code: 'RETRY001',
        message: 'Max retry attempts exceeded',
        userMessage: 'Operation failed after multiple attempts',
      ),
      attemptNumber,
    );
  }

  /// Calculate delay for next retry attempt (exponential backoff with jitter)
  Duration _calculateDelay(int attemptNumber, {required RetryConfig config}) {
    // Calculate base delay: initialDelay * (backoffMultiplier ^ attemptNumber)
    final exponentialDelay = config.initialDelay.inMilliseconds *
        pow(config.backoffMultiplier, attemptNumber - 1);

    // Cap at max delay
    final cappedDelay = min(exponentialDelay, config.maxDelay.inMilliseconds.toDouble());

    // Add jitter to avoid thundering herd
    final delayWithJitter = config.useJitter
        ? _addJitter(cappedDelay.toDouble())
        : cappedDelay.toDouble();

    return Duration(milliseconds: delayWithJitter.round());
  }

  /// Add random jitter to delay (±25%)
  double _addJitter(double delay) {
    final jitterRange = delay * 0.25; // ±25%
    final jitter = (_random.nextDouble() * 2 - 1) * jitterRange;
    return delay + jitter;
  }

  /// Execute with simple retry (no configuration)
  Future<T> executeSimple<T>({
    required Future<T> Function() operation,
    int maxAttempts = 3,
  }) async {
    final result = await execute(
      operation: operation,
      operationName: 'Operation',
      config: RetryConfig(maxAttempts: maxAttempts),
    );

    if (result.succeeded) {
      return result.data as T;
    } else {
      throw result.error!;
    }
  }

  /// Execute with timeout and retry
  Future<RetryResult<T>> executeWithTimeout<T>({
    required Future<T> Function() operation,
    required String operationName,
    Duration timeout = const Duration(seconds: 30),
    RetryConfig config = RetryConfig.defaultConfig,
  }) async {
    return execute<T>(
      operation: () async {
        return await operation().timeout(
          timeout,
          onTimeout: () {
            throw AppError(
              category: ErrorCategory.network,
              severity: ErrorSeverity.warning,
              code: 'NET002',
              message: 'Operation timeout',
              userMessage: 'The operation took too long. Please try again.',
              isRetryable: true,
            );
          },
        );
      },
      operationName: operationName,
      config: config,
    );
  }
}

/// Extension to add retry capability to Future
extension RetryExtension<T> on Future<T> {
  /// Retry this future with exponential backoff
  Future<T> withRetry({
    String operationName = 'Operation',
    int maxAttempts = 3,
  }) async {
    final retryService = RetryService();
    return retryService.executeSimple(
      operation: () => this,
      maxAttempts: maxAttempts,
    );
  }

  /// Retry with full configuration
  Future<RetryResult<T>> withRetryConfig({
    required String operationName,
    RetryConfig config = RetryConfig.defaultConfig,
  }) async {
    final retryService = RetryService();
    return retryService.execute(
      operation: () => this,
      operationName: operationName,
      config: config,
    );
  }
}
</file>

<file path="frontend/lib/state/ai_providers_cached.dart.backup">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/services/ai_analysis_service.dart';

/// Provider for the AI Analysis Service singleton
final aiAnalysisServiceProvider = Provider<AIAnalysisService>((ref) {
  return AIAnalysisService();
});

/// Provider for getting analysis for a specific message
final messageAnalysisProvider = FutureProvider.family<AiAnalysi?, String>(
  (ref, messageId) async {
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getAnalysis(messageId);
  },
);

/// Stream provider for watching analysis changes for a message
final messageAnalysisStreamProvider = StreamProvider.family<AiAnalysi?, String>(
  (ref, messageId) {
    final service = ref.watch(aiAnalysisServiceProvider);
    return service.watchAnalysis(messageId);
  },
);

/// Provider for getting analyses for a conversation
final conversationAnalysisProvider = FutureProvider.family<Map<String, AiAnalysi>, ConversationAnalysisParams>(
  (ref, params) async {
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getConversationAnalysis(
      params.conversationId,
      params.messageIds,
    );
  },
);

/// Provider for analysis statistics
final analysisStatsProvider = FutureProvider<Map<String, dynamic>>(
  (ref) async {
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getAnalysisStats();
  },
);

/// Provider for requesting analysis (returns the service method)
/// Use this to trigger analysis requests from UI
final requestAnalysisProvider = Provider<Future<AiAnalysi?> Function(String, String)>((ref) {
  final service = ref.watch(aiAnalysisServiceProvider);
  return (messageId, messageBody) => service.requestAnalysis(messageId, messageBody);
});

/// Parameters for conversation analysis provider
class ConversationAnalysisParams {
  final String conversationId;
  final List<String> messageIds;

  ConversationAnalysisParams({
    required this.conversationId,
    required this.messageIds,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConversationAnalysisParams &&
          runtimeType == other.runtimeType &&
          conversationId == other.conversationId &&
          _listEquals(messageIds, other.messageIds);

  @override
  int get hashCode => conversationId.hashCode ^ messageIds.hashCode;

  bool _listEquals(List<String> a, List<String> b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }
}
</file>

<file path="frontend/lib/state/ai_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart' hide Provider;
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/models/draft_analysis.dart';
import 'package:messageai/services/ai_analysis_service.dart';
import 'package:messageai/services/draft_analysis_service.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Provider for AI Analysis Service singleton
final aiAnalysisServiceProvider = Provider<AIAnalysisService>((ref) {
  return AIAnalysisService();
});

/// StateNotifier to track when to refresh analysis
class AnalysisRefreshNotifier extends StateNotifier<int> {
  AnalysisRefreshNotifier() : super(0);
  
  void refresh() {
    state++;
  }
}

final analysisRefreshProvider = StateNotifierProvider<AnalysisRefreshNotifier, int>((ref) {
  final notifier = AnalysisRefreshNotifier();
  
  // Listen to realtime updates on message_ai_analysis table
  final supabase = SupabaseClientProvider.client;
  final channel = supabase.realtime.channel('ai_analysis_updates');
  
  channel.on(
    RealtimeListenTypes.postgresChanges,
    ChannelFilter(
      event: 'INSERT',
      schema: 'public',
      table: 'message_ai_analysis',
    ),
    (payload, [ref]) {
      print('🔄 AI analysis updated, refreshing providers...');
      notifier.refresh();
    },
  );
  
  channel.subscribe(
    (status, [error]) {
      if (status == 'SUBSCRIBED') {
        print('✅ AI analysis realtime listener subscribed');
      } else if (error != null) {
        print('❌ AI analysis realtime error: $error');
      }
    },
  );
  
  ref.onDispose(() {
    channel.unsubscribe();
  });
  
  return notifier;
});

/// Fetch analysis for a single message (auto-refreshes on realtime updates)
final messageAnalysisProvider = FutureProvider.family<AIAnalysis?, String>(
  (ref, messageId) async {
    // Watch the refresh notifier to trigger rebuilds
    ref.watch(analysisRefreshProvider);
    
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getAnalysis(messageId);
  },
);

/// Fetch all analyses for a conversation (auto-refreshes on realtime updates)
final conversationAnalysisProvider = FutureProvider.family<Map<String, AIAnalysis>, String>(
  (ref, conversationId) async {
    // Watch the refresh notifier to trigger rebuilds
    ref.watch(analysisRefreshProvider);
    
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getConversationAnalyses(conversationId);
  },
);

/// Provider for triggering analysis requests
final requestAnalysisProvider = Provider((ref) {
  final service = ref.watch(aiAnalysisServiceProvider);
  return (String messageId, String messageBody) => 
      service.requestAnalysis(messageId, messageBody);
});

// =============================================================================
// DRAFT ANALYSIS PROVIDERS (for outgoing messages)
// =============================================================================

/// Provider for Draft Analysis Service
final draftAnalysisServiceProvider = Provider<DraftAnalysisService>((ref) {
  final supabase = SupabaseClientProvider.client;
  return DraftAnalysisService(supabase);
});

/// State notifier for managing draft analysis state (manual trigger)
class DraftAnalysisNotifier extends StateNotifier<AsyncValue<DraftAnalysis?>> {
  final DraftAnalysisService _service;

  DraftAnalysisNotifier(this._service) : super(const AsyncValue.data(null));

  /// Analyze a draft (called when user clicks "Check Message" button)
  Future<void> analyzeDraft({
    required String draftMessage,
    String? conversationId,
    RelationshipType? relationshipType,
    List<String>? conversationHistory,
  }) async {
    // Clear if draft is empty
    if (draftMessage.trim().isEmpty) {
      state = const AsyncValue.data(null);
      return;
    }

    // Set loading state
    state = const AsyncValue.loading();

    try {
      final analysis = await _service.analyzeDraft(
        draftMessage: draftMessage,
        conversationId: conversationId,
        relationshipType: relationshipType,
        conversationHistory: conversationHistory,
      );
      state = AsyncValue.data(analysis);
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  /// Clear current analysis
  void clear() {
    state = const AsyncValue.data(null);
  }
}

/// Provider for draft analysis state (manual trigger)
final draftAnalysisProvider =
    StateNotifierProvider<DraftAnalysisNotifier, AsyncValue<DraftAnalysis?>>(
  (ref) {
    final service = ref.watch(draftAnalysisServiceProvider);
    return DraftAnalysisNotifier(service);
  },
);
</file>

<file path="frontend/lib/widgets/network_status_banner.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/network_connectivity_service.dart';
import 'package:messageai/services/offline_queue_service.dart';

/// Banner that shows network status and pending message count
class NetworkStatusBanner extends StatefulWidget {
  const NetworkStatusBanner({Key? key}) : super(key: key);

  @override
  State<NetworkStatusBanner> createState() => _NetworkStatusBannerState();
}

class _NetworkStatusBannerState extends State<NetworkStatusBanner> {
  final _connectivityService = NetworkConnectivityService();
  final _offlineQueueService = OfflineQueueService();
  
  ConnectivityStatus _status = ConnectivityStatus.unknown;
  int _pendingMessages = 0;

  @override
  void initState() {
    super.initState();
    _status = _connectivityService.currentStatus;
    _loadPendingCount();
    
    // Listen to connectivity changes
    _connectivityService.onStatusChange.listen((status) {
      if (mounted) {
        setState(() => _status = status);
        _loadPendingCount();
      }
    });
  }

  Future<void> _loadPendingCount() async {
    final count = await _offlineQueueService.getPendingMessageCount();
    if (mounted) {
      setState(() => _pendingMessages = count);
    }
  }

  Future<void> _handleSyncTap() async {
    // Show loading
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Row(
          children: [
            SizedBox(
              width: 16,
              height: 16,
              child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),
            ),
            SizedBox(width: 12),
            Text('Syncing pending messages...'),
          ],
        ),
        duration: Duration(seconds: 2),
      ),
    );

    final result = await _offlineQueueService.forceSyncNow();
    
    if (!mounted) return;

    ScaffoldMessenger.of(context).hideCurrentSnackBar();
    
    if (result.isSuccess) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.check_circle, color: Colors.white),
              const SizedBox(width: 12),
              Text('${result.successCount} messages synced'),
            ],
          ),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 2),
        ),
      );
      _loadPendingCount();
    } else if (result.status == SyncStatus.noMessages) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Row(
            children: [
              Icon(Icons.check_circle, color: Colors.white),
              SizedBox(width: 12),
              Text('All messages are synced'),
            ],
          ),
          backgroundColor: Colors.blue,
          duration: Duration(seconds: 2),
        ),
      );
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.error, color: Colors.white),
              const SizedBox(width: 12),
              Text('Failed to sync: ${result.errorMessage ?? "Unknown error"}'),
            ],
          ),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    // Only show banner when offline or has pending messages
    if (_status == ConnectivityStatus.online && _pendingMessages == 0) {
      return const SizedBox.shrink();
    }

    return Material(
      color: _getBannerColor(),
      child: InkWell(
        onTap: _status == ConnectivityStatus.online && _pendingMessages > 0
            ? _handleSyncTap
            : null,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: Row(
            children: [
              Icon(
                _getBannerIcon(),
                size: 20,
                color: Colors.white,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  _getBannerText(),
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 14,
                  ),
                ),
              ),
              if (_status == ConnectivityStatus.online && _pendingMessages > 0)
                const Icon(
                  Icons.sync,
                  size: 20,
                  color: Colors.white,
                ),
            ],
          ),
        ),
      ),
    );
  }

  Color _getBannerColor() {
    if (_status == ConnectivityStatus.offline) {
      return Colors.red.shade700;
    } else if (_pendingMessages > 0) {
      return Colors.orange.shade700;
    }
    return Colors.blue;
  }

  IconData _getBannerIcon() {
    if (_status == ConnectivityStatus.offline) {
      return Icons.cloud_off;
    } else if (_pendingMessages > 0) {
      return Icons.cloud_sync;
    }
    return Icons.cloud_done;
  }

  String _getBannerText() {
    if (_status == ConnectivityStatus.offline) {
      if (_pendingMessages > 0) {
        return 'Offline • $_pendingMessages message${_pendingMessages == 1 ? '' : 's'} pending';
      }
      return 'You are offline';
    } else if (_pendingMessages > 0) {
      return 'Syncing $_pendingMessages message${_pendingMessages == 1 ? '' : 's'} • Tap to sync now';
    }
    return 'All messages synced';
  }
}

/// Small inline network indicator
class NetworkStatusIndicator extends StatefulWidget {
  final bool showLabel;

  const NetworkStatusIndicator({
    Key? key,
    this.showLabel = true,
  }) : super(key: key);

  @override
  State<NetworkStatusIndicator> createState() => _NetworkStatusIndicatorState();
}

class _NetworkStatusIndicatorState extends State<NetworkStatusIndicator> {
  final _connectivityService = NetworkConnectivityService();
  ConnectivityStatus _status = ConnectivityStatus.unknown;

  @override
  void initState() {
    super.initState();
    _status = _connectivityService.currentStatus;
    
    _connectivityService.onStatusChange.listen((status) {
      if (mounted) {
        setState(() => _status = status);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          width: 8,
          height: 8,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: _getStatusColor(),
          ),
        ),
        if (widget.showLabel) ...[
          const SizedBox(width: 6),
          Text(
            _getStatusLabel(),
            style: TextStyle(
              fontSize: 12,
              color: Colors.grey[600],
            ),
          ),
        ],
      ],
    );
  }

  Color _getStatusColor() {
    switch (_status) {
      case ConnectivityStatus.online:
        return Colors.green;
      case ConnectivityStatus.offline:
        return Colors.red;
      case ConnectivityStatus.unknown:
        return Colors.grey;
    }
  }

  String _getStatusLabel() {
    switch (_status) {
      case ConnectivityStatus.online:
        return 'Online';
      case ConnectivityStatus.offline:
        return 'Offline';
      case ConnectivityStatus.unknown:
        return 'Unknown';
    }
  }
}
</file>

<file path="frontend/lib/widgets/sliding_panel.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';

/// A sliding panel widget that can be dragged up and down
/// Used for the message screen to slide over AI insights
class SlidingPanel extends StatefulWidget {
  /// The content to display in the sliding panel
  final Widget child;
  
  /// Called when the panel position changes (0.0 = collapsed, 1.0 = fully expanded)
  final ValueChanged<double>? onSlide;
  
  /// Minimum height as a fraction of screen (0.0 - 1.0)
  final double minHeight;
  
  /// Maximum height as a fraction of screen (0.0 - 1.0)
  final double maxHeight;
  
  /// Initial height as a fraction of screen (0.0 - 1.0)
  final double initialHeight;
  
  /// Snap positions for the panel (as fractions of screen height)
  final List<double> snapSizes;
  
  /// Background color of the panel
  final Color? backgroundColor;
  
  /// Border radius for the top corners
  final double borderRadius;
  
  /// Whether to show the drag handle
  final bool showDragHandle;

  const SlidingPanel({
    Key? key,
    required this.child,
    this.onSlide,
    this.minHeight = 0.2,
    this.maxHeight = 0.95,
    this.initialHeight = 0.8,
    this.snapSizes = const [0.2, 0.5, 0.8, 0.95],
    this.backgroundColor,
    this.borderRadius = 16.0,
    this.showDragHandle = true,
  }) : super(key: key);

  @override
  State<SlidingPanel> createState() => _SlidingPanelState();
}

class _SlidingPanelState extends State<SlidingPanel> {
  final DraggableScrollableController _controller = DraggableScrollableController();
  
  @override
  void initState() {
    super.initState();
    // Add listener to track position changes
    _controller.addListener(_onPositionChanged);
  }
  
  @override
  void dispose() {
    _controller.removeListener(_onPositionChanged);
    _controller.dispose();
    super.dispose();
  }
  
  void _onPositionChanged() {
    if (_controller.isAttached) {
      final size = _controller.size;
      // Normalize the size to 0.0 - 1.0 range
      final normalizedPosition = (size - widget.minHeight) / (widget.maxHeight - widget.minHeight);
      widget.onSlide?.call(normalizedPosition.clamp(0.0, 1.0));
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final bgColor = widget.backgroundColor ?? 
                    (isDark ? AppTheme.black : AppTheme.white);
    
    return DraggableScrollableSheet(
      controller: _controller,
      initialChildSize: widget.initialHeight,
      minChildSize: widget.minHeight,
      maxChildSize: widget.maxHeight,
      snap: true,
      snapSizes: widget.snapSizes,
      builder: (BuildContext context, ScrollController scrollController) {
        return Container(
          decoration: BoxDecoration(
            color: bgColor,
            borderRadius: BorderRadius.only(
              topLeft: Radius.circular(widget.borderRadius),
              topRight: Radius.circular(widget.borderRadius),
            ),
            boxShadow: isDark ? AppTheme.shadow2Dark : AppTheme.shadow3Light,
          ),
          child: Column(
            children: [
              // Drag handle area
              if (widget.showDragHandle)
                GestureDetector(
                  onTap: () => _snapToNextPosition(),
                  child: Container(
                    width: double.infinity,
                    padding: const EdgeInsets.symmetric(
                      vertical: AppTheme.spacingS,
                    ),
                    child: Center(
                      child: Container(
                        width: 40,
                        height: 4,
                        decoration: BoxDecoration(
                          color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                          borderRadius: BorderRadius.circular(AppTheme.radiusPill),
                        ),
                      ),
                    ),
                  ),
                ),
              
              // Panel content
              Expanded(
                child: widget.child,
              ),
            ],
          ),
        );
      },
    );
  }
  
  /// Snaps the panel to the next position in the snapSizes list
  void _snapToNextPosition() {
    if (!_controller.isAttached) return;
    
    final currentSize = _controller.size;
    final sortedSnaps = List<double>.from(widget.snapSizes)..sort();
    
    // Find the next snap position
    final nextSnap = sortedSnaps.firstWhere(
      (snap) => snap > currentSize + 0.05, // Add small buffer for floating point
      orElse: () => sortedSnaps.first, // Wrap around to first
    );
    
    _controller.animateTo(
      nextSnap,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
  }
}

/// Extension to provide convenience methods for sliding panel
extension SlidingPanelController on DraggableScrollableController {
  /// Animate to a specific size
  Future<void> animateToSize(
    double size, {
    Duration duration = const Duration(milliseconds: 300),
    Curve curve = Curves.easeInOut,
  }) {
    return animateTo(
      size,
      duration: duration,
      curve: curve,
    );
  }
  
  /// Jump to a specific size without animation
  void jumpToSize(double size) {
    jumpTo(size);
  }
  
  /// Get current size
  double get currentSize => isAttached ? size : 0.0;
}
</file>

<file path="frontend/lib/widgets/user_avatar.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/avatar_service.dart';

/// Reusable widget for displaying user avatars
/// Fetches avatar from backend or shows fallback initial
class UserAvatar extends StatefulWidget {
  final String? userId;
  final String? avatarUrl;
  final String fallbackText;
  final double radius;
  final bool isGroup;

  const UserAvatar({
    Key? key,
    this.userId,
    this.avatarUrl,
    required this.fallbackText,
    this.radius = 20,
    this.isGroup = false,
  }) : super(key: key);

  @override
  State<UserAvatar> createState() => _UserAvatarState();
}

class _UserAvatarState extends State<UserAvatar> {
  final _avatarService = AvatarService();
  String? _fetchedAvatarUrl;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _loadAvatar();
  }

  @override
  void didUpdateWidget(UserAvatar oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Reload if userId changed
    if (oldWidget.userId != widget.userId || oldWidget.avatarUrl != widget.avatarUrl) {
      _loadAvatar();
    }
  }

  Future<void> _loadAvatar() async {
    // If avatarUrl is directly provided, use it
    if (widget.avatarUrl != null) {
      setState(() {
        _fetchedAvatarUrl = widget.avatarUrl;
      });
      return;
    }

    // If userId provided, fetch avatar
    if (widget.userId != null) {
      setState(() => _isLoading = true);
      
      try {
        final url = await _avatarService.getAvatarUrl(widget.userId!);
        if (mounted) {
          setState(() {
            _fetchedAvatarUrl = url;
            _isLoading = false;
          });
        }
      } catch (e) {
        if (mounted) {
          setState(() => _isLoading = false);
        }
        // Silently fail - fallback will be shown
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    // Show loading indicator
    if (_isLoading) {
      return CircleAvatar(
        radius: widget.radius,
        backgroundColor: theme.colorScheme.primary.withOpacity(0.2),
        child: SizedBox(
          width: widget.radius,
          height: widget.radius,
          child: const CircularProgressIndicator(strokeWidth: 2),
        ),
      );
    }

    // Show avatar image if available
    if (_fetchedAvatarUrl != null && _fetchedAvatarUrl!.isNotEmpty) {
      return CircleAvatar(
        radius: widget.radius,
        backgroundColor: theme.colorScheme.primary,
        backgroundImage: NetworkImage(_fetchedAvatarUrl!),
        // Error handling: show fallback if image fails to load
        onBackgroundImageError: (exception, stackTrace) {
          print('Error loading avatar: $exception');
        },
        child: Container(), // Empty container as placeholder
      );
    }

    // Fallback: Show initial or group icon
    return CircleAvatar(
      radius: widget.radius,
      backgroundColor: theme.colorScheme.primary,
      child: widget.isGroup
          ? Icon(
              Icons.group,
              color: Colors.white,
              size: widget.radius * 1.2,
            )
          : Text(
              _getInitial(widget.fallbackText),
              style: TextStyle(
                fontSize: widget.radius * 0.9,
                fontWeight: FontWeight.bold,
                color: Colors.white,
              ),
            ),
    );
  }

  /// Get first letter of name for fallback
  String _getInitial(String text) {
    if (text.isEmpty) return '?';
    return text[0].toUpperCase();
  }
}
</file>

<file path="frontend/repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
.metadata
analysis_options.yaml
android/.gitignore
android/app/build.gradle.kts
android/app/src/debug/AndroidManifest.xml
android/app/src/main/AndroidManifest.xml
android/app/src/main/kotlin/com/example/messageai/MainActivity.kt
android/app/src/main/res/drawable-v21/launch_background.xml
android/app/src/main/res/drawable/launch_background.xml
android/app/src/main/res/mipmap-hdpi/ic_launcher.png
android/app/src/main/res/mipmap-mdpi/ic_launcher.png
android/app/src/main/res/mipmap-xhdpi/ic_launcher.png
android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png
android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
android/app/src/main/res/values-night/styles.xml
android/app/src/main/res/values/styles.xml
android/build.gradle.kts
android/gradle.properties
android/settings.gradle.kts
devtools_options.yaml
firebase.json
integration_test/ai_flow_test.dart
lib/app.dart
lib/core/env.dart
lib/core/errors/app_error.dart
lib/core/errors/error_handler.dart
lib/core/errors/error_ui.dart
lib/core/theme/app_theme.dart
lib/data/drift/app_db.dart
lib/data/drift/daos/ai_analysis_dao_cached.dart.backup
lib/data/drift/daos/conversation_dao.dart
lib/data/drift/daos/message_dao.dart
lib/data/drift/daos/participant_dao.dart
lib/data/drift/daos/pending_outbox_dao.dart
lib/data/drift/daos/receipt_dao.dart
lib/data/drift/entities/ai_analysis_cached.drift.backup
lib/data/drift/entities/conversation.drift
lib/data/remote/supabase_client.dart
lib/data/repositories/group_repository.dart
lib/data/repositories/message_repository.dart
lib/data/repositories/receipt_repository.dart
lib/features/auth/screens/auth_screen.dart
lib/features/conversations/screens/conversations_list_screen.dart
lib/features/conversations/widgets/message_bubble.dart
lib/features/messages/screens/message_screen.dart
lib/features/messages/widgets/ai_insights_background.dart
lib/features/messages/widgets/ai_insights_panel.dart
lib/features/messages/widgets/message_list_panel.dart
lib/features/messages/widgets/tone_badge.dart
lib/features/messages/widgets/tone_detail_sheet.dart
lib/features/notifications/widgets/notification_widgets.dart
lib/features/settings/screens/settings_screen.dart
lib/firebase_options.dart
lib/gen/api/api.dart
lib/gen/api/clients/messages_api.dart
lib/gen/api/clients/receipts_api.dart
lib/gen/api/models/message_payload.dart
lib/gen/api/models/receipt_payload.dart
lib/main.dart
lib/models/ai_analysis.dart
lib/services/ai_analysis_service_cached.dart.backup
lib/services/ai_analysis_service.dart
lib/services/auth_service.dart
lib/services/avatar_service.dart
lib/services/conversation_service.dart
lib/services/deep_link_handler.dart
lib/services/device_registration_service.dart
lib/services/local_notification_service.dart
lib/services/media_service.dart
lib/services/message_service.dart
lib/services/network_connectivity_service.dart
lib/services/notification_service.dart
lib/services/offline_queue_service.dart
lib/services/presence_service.dart
lib/services/realtime_diagnostic_service.dart
lib/services/realtime_message_service.dart
lib/services/retry_service.dart
lib/services/typing_indicator_service.dart
lib/state/ai_providers_cached.dart.backup
lib/state/ai_providers.dart
lib/state/database_provider.dart
lib/state/notification_providers.dart
lib/state/presence_providers.dart
lib/state/providers.dart
lib/state/realtime_providers.dart
lib/state/repository_providers.dart
lib/state/send_queue.dart
lib/state/typing_providers.dart
lib/widgets/network_status_banner.dart
lib/widgets/sliding_panel.dart
lib/widgets/user_avatar.dart
Makefile
pubspec.yaml
test/models/ai_analysis_test.dart
test/offline_queue_test.dart
test/realtime_diagnostic_test.dart
test/services/ai_analysis_service_test.dart
test/widget_test.dart
test/widgets/tone_badge_test.dart
web/favicon.png
web/icons/Icon-192.png
web/icons/Icon-512.png
web/icons/Icon-maskable-192.png
web/icons/Icon-maskable-512.png
web/index.html
web/manifest.json
windows/.gitignore
windows/CMakeLists.txt
windows/flutter/CMakeLists.txt
windows/runner/CMakeLists.txt
windows/runner/flutter_window.cpp
windows/runner/flutter_window.h
windows/runner/main.cpp
windows/runner/resource.h
windows/runner/resources/app_icon.ico
windows/runner/runner.exe.manifest
windows/runner/Runner.rc
windows/runner/utils.cpp
windows/runner/utils.h
windows/runner/win32_window.cpp
windows/runner/win32_window.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.packages
.pub-cache/
.pub/
/build/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release

# iOS/macOS
**/ios/**/*.mode1v3
**/ios/**/*.mode2v3
**/ios/**/*.moved-aside
**/ios/**/*.pbxuser
**/ios/**/*.perspectivev3
**/ios/**/*sync/
**/ios/**/.sconsign.dblite
**/ios/**/.tags*
**/ios/**/.vscode/*
!**/ios/**/.vscode/extensions.json
**/ios/**/DerivedData/
**/ios/**/Flutter/Flutter.framework/*
**/ios/**/Flutter/Flutter.podspec
**/ios/**/Flutter/Generated.xcconfig
**/ios/**/Flutter/ephemeral/
**/ios/**/Flutter/app.flx
**/ios/**/Flutter/app.zip
**/ios/**/Flutter/flutter_assets/
**/ios/**/Flutter/flutter_export_environment.sh
**/ios/**/GoogleService-Info.plist
**/ios/**/ServiceAccount.json
**/ios/**/.symlinks/
**/ios/**/.vagrant
**/ios/**/Flutter/Flutter.framework
**/ios/**/Flutter/Flutter.podspec
**/ios/Podfile
**/ios/Podfile.lock

# Web
lib/generated_plugin_registrant.dart

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
**/android/app/debug
**/android/app/profile
**/android/app/release
**/android/app/outputs
**/android/.gradle
**/android/captures/
**/android/gradlew
**/android/gradlew.bat
**/android/gradle/wrapper/gradle-wrapper.jar
**/android/gradle/wrapper/gradle-wrapper.properties

# Firebase
google-services.json
GoogleService-Info.plist
**/android/app/google-services.json
**/ios/GoogleService-Info.plist

# Exceptions to above rules.
!/packages/flutter_tools/test/data/dart_dependencies_test/**/.packages

# Environment files
.env
.env.local
.env.*.local
.env.dev.json
.env.prod.json

# Generated code
*.g.dart
*.config.dart
*.freezed.dart
*.chopper.dart

# Drift related
.dart_tool/build
lib/data/drift/**/*.g.dart

# Coverage
coverage/
.coverage

# Exceptions to above rules.
!/packages/flutter_tools/test/data/dart_dependencies_test/**/.packages

# Xcode related
*.xcarchive
*.xcworkspace
xcuser.xcuserdatad

# Compiled output
*.app/
*.framework/
*.so
.symbols/

# Obfuscation
app.*.map.json

# macOS
.DS_Store
.AppleDouble
.LSOverride
*.mode1v3
*.mode2v3
*.moved-aside
*.pbxuser
*.perspectivev3
**/*.sconsign.dblite
.sconsign.dblite
dsa_cert.certSigningRequest
profile
DerivedData/
build/
Generated.xcconfig
GeneratedPluginRegistrant.swift

# iOS
**/ios/.symlinks/
**/ios/.vagrant
**/ios/**/Flutter/Flutter.framework
**/ios/**/Flutter/Flutter.podspec
**/ios/**/Flutter/Generated.xcconfig
**/ios/**/Flutter/generated_plugin_registrant.m
**/ios/**/Flutter/ephemeral/
**/ios/**/GoogleService-Info.plist
**/ios/**/ServiceAccount.json
**/ios/**/.sconsign.dblite
**/ios/**/.tags
**/ios/**/.vscode/*
!**/ios/**/.vscode/extensions.json
**/ios/**/Flutter/.last_build_id
**/ios/**/Flutter/app.flx
**/ios/**/Flutter/app.zip
**/ios/**/Flutter/flutter_assets/
**/ios/**/Flutter/flutter_export_environment.sh

# Android
**/android/app/debug
**/android/app/profile
**/android/app/release
**/android/app/outputs/
**/android/.gradle
**/android/captures/
**/android/gradle-app.setting
**/android/gradlew
**/android/gradlew.bat
**/android/gradle/wrapper/gradle-wrapper.jar
**/android/gradle/wrapper/gradle-wrapper.properties
**/android/local.properties

# Web
lib/generated_plugin_registrant.dart

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
**/android/**/gradle-wrapper.jar
**/android/gradle
**/android/gradlew
**/android/gradlew.bat
**/android/local.properties
**/android/**/GeneratedPluginRegistrant.java

# iOS/macOS
**/ios/**/*.mode1v3
**/ios/**/*.mode2v3
**/ios/**/.vscode/*
!**/ios/**/.vscode/extensions.json
**/ios/**/DerivedData/
**/ios/**/Flutter/Flutter.framework
**/ios/**/Flutter/Flutter.podspec
**/ios/**/Flutter/Generated.xcconfig
**/ios/**/Flutter/ephemeral/
**/ios/**/Flutter/app.flx
**/ios/**/Flutter/app.zip
**/ios/**/Flutter/flutter_assets/
**/ios/**/Flutter/flutter_export_environment.sh
**/ios/**/GoogleService-Info.plist
**/ios/**/ServiceAccount.json
**/ios/**/.symlinks/
**/ios/**/.vagrant
**/macos/Flutter/Flutter-Debug.xcconfig
**/macos/Flutter/Flutter-Release.xcconfig
**/macos/Flutter/GeneratedPluginRegistrant.swift

# Windows
windows/flutter/generated_plugin_registrant.cc
windows/flutter/generated_plugin_registrant.h
windows/flutter/generated_plugins.cmake

# Linux
linux/flutter/generated_plugin_registrant.cc
linux/flutter/generated_plugin_registrant.h
linux/flutter/generated_plugins.cmake

# Coverage
coverage/

# Symbols
app.*.symbols

# Local env files
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# VS Code settings
.vscode/*
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json

# misc
*.deb
*.dsc
*.buildinfo
*.changes
*.orig.*
/.dart_tool
/.flutter-plugins
/.flutter-plugins-dependencies
/.packages
/.pub-cache
/pubspec.lock
/build
/linux/flutter/generated_plugin_registrant.cc
/linux/flutter/generated_plugin_registrant.h
/linux/flutter/generated_plugins.cmake
/macos/Flutter/GeneratedPluginRegistrant.swift
/web/plugins.json
/windows/flutter/generated_plugin_registrant.cc
/windows/flutter/generated_plugin_registrant.h
/windows/flutter/generated_plugins.cmake

# Firebase & Google Services
**/GoogleService-Info.plist
**/google-services.json
**/ServiceAccount.json

# Temporary files
*.tmp
*.swp
*.swo
*~
.~*

# System
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
</file>

<file path=".metadata">
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "9f455d2486bcb28cad87b062475f42edc959f636"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: 9f455d2486bcb28cad87b062475f42edc959f636
      base_revision: 9f455d2486bcb28cad87b062475f42edc959f636
    - platform: windows
      create_revision: 9f455d2486bcb28cad87b062475f42edc959f636
      base_revision: 9f455d2486bcb28cad87b062475f42edc959f636

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'
</file>

<file path="analysis_options.yaml">
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options
</file>

<file path="android/.gitignore">
gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java
.cxx/

# Remember to never publicly share your keystore.
# See https://flutter.dev/to/reference-keystore
key.properties
**/*.keystore
**/*.jks
</file>

<file path="android/app/build.gradle.kts">
plugins {
    id("com.android.application")
    // START: FlutterFire Configuration
    id("com.google.gms.google-services")
    // END: FlutterFire Configuration
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.messageai"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
        isCoreLibraryDesugaringEnabled = true
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_11.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.example.messageai"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
        multiDexEnabled = true
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}

dependencies {
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.1.4")
    
    // Exclude sign_in_with_apple which uses deprecated Flutter APIs
    configurations.all {
        exclude(group = "com.aboutyou.dart_packages", module = "sign_in_with_apple")
    }
}
</file>

<file path="android/app/src/debug/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
</file>

<file path="android/app/src/main/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="messageai"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>
</file>

<file path="android/app/src/main/kotlin/com/example/messageai/MainActivity.kt">
package com.example.messageai

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()
</file>

<file path="android/app/src/main/res/drawable-v21/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
</file>

<file path="android/app/src/main/res/drawable/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
</file>

<file path="android/app/src/main/res/values-night/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="android/app/src/main/res/values/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="android/build.gradle.kts">
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}
</file>

<file path="android/gradle.properties">
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
android.enableJetifier=true
</file>

<file path="android/settings.gradle.kts">
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.9.1" apply false
    // START: FlutterFire Configuration
    id("com.google.gms.google-services") version("4.3.15") apply false
    // END: FlutterFire Configuration
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
}

include(":app")
</file>

<file path="devtools_options.yaml">
description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:
</file>

<file path="firebase.json">
{"flutter":{"platforms":{"android":{"default":{"projectId":"messageai-e2e9e","appId":"1:397483513751:android:bb838799a2cd3f7f1c56d2","fileOutput":"android/app/google-services.json"}},"dart":{"lib/firebase_options.dart":{"projectId":"messageai-e2e9e","configurations":{"android":"1:397483513751:android:bb838799a2cd3f7f1c56d2","web":"1:397483513751:web:3121cbb846ddd8381c56d2","windows":"1:397483513751:web:ba73c764d577f4f51c56d2"}}}}}}
</file>

<file path="integration_test/ai_flow_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/app.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('AI Analysis Integration Flow', () {
    testWidgets('app structure loads correctly', (tester) async {
      // Verify the app widget exists
      const app = MessageAIApp();
      
      // Basic structure test
      expect(app, isA<MessageAIApp>());
    });
    
    testWidgets('complete AI analysis flow - TODO', (tester) async {
      // This is a placeholder for a full integration test
      // To implement when backend is fully configured:
      // 
      // 1. Initialize Supabase with test credentials
      // 2. Login with test user
      // 3. Navigate to a test conversation
      // 4. Send a message: "Hello, how are you doing today?"
      // 5. Wait for AI analysis to complete (may take 3-5 seconds)
      // 6. Verify ToneBadge appears on the message bubble
      // 7. Tap the badge to open ToneDetailSheet
      // 8. Verify sheet shows: tone, urgency level, intent, confidence
      // 9. Close sheet and pull down the message panel
      // 10. Verify AIInsightsPanel shows conversation-level insights
      // 
      // Requirements:
      // - Supabase running with test database
      // - OpenAI API key configured in ai_analyze_tone Edge Function
      // - Test user account in auth.users table
      // - Test conversation and participants in database
      
      // TODO: Implement full flow when authentication is configured
      expect(true, isTrue); // Placeholder assertion
    });
  });
}
</file>

<file path="lib/app.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/features/auth/screens/auth_screen.dart';
import 'package:messageai/features/conversations/screens/conversations_list_screen.dart';
import 'package:messageai/features/messages/screens/message_screen.dart';
import 'package:messageai/state/providers.dart';
import 'package:messageai/services/device_registration_service.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

/// Global navigator key for deep linking and navigation from notifications
final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

/// Main application widget with lifecycle monitoring
class MessageAIApp extends ConsumerStatefulWidget {
  const MessageAIApp({Key? key}) : super(key: key);

  @override
  ConsumerState<MessageAIApp> createState() => _MessageAIAppState();
}

class _MessageAIAppState extends ConsumerState<MessageAIApp> with WidgetsBindingObserver {
  final _deviceRegistration = DeviceRegistrationService();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    // Update last_seen on app launch
    _updateLastSeen();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      // App came to foreground - update last_seen
      _updateLastSeen();
    }
  }

  Future<void> _updateLastSeen() async {
    try {
      print('⏰ Updating device last_seen...');
      final token = await FirebaseMessaging.instance.getToken();
      if (token != null) {
        await _deviceRegistration.updateDeviceLastSeen(token);
        print('✅ Device last_seen updated');
      } else {
        print('⚠️ No FCM token available');
      }
    } catch (e) {
      print('❌ Failed to update last_seen: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'MessageAI',
      navigatorKey: navigatorKey,
      theme: AppTheme.lightTheme,
      darkTheme: AppTheme.darkTheme,
      themeMode: ThemeMode.system,
      home: const AuthGate(),
      routes: {
        '/auth': (_) => AuthScreen(onAuthSuccess: () {}),
        '/conversations': (_) => const ConversationsListScreen(),
      },
      // ✅ Handle dynamic routes for deep linking (e.g., /conversation/:id)
      onGenerateRoute: (settings) {
        // Handle conversation deep links
        if (settings.name?.startsWith('/conversation/') ?? false) {
          final conversationId = settings.name!.split('/').last;
          
          print('🔗 Deep link: navigating to conversation $conversationId');
          
          return MaterialPageRoute(
            builder: (_) => MessageScreen(
              conversationId: conversationId,
              conversationTitle: 'Chat', // Will be loaded by screen
            ),
            settings: settings,
          );
        }
        
        // Return null for unknown routes (will show error page)
        return null;
      },
    );
  }
}

/// Widget that routes between auth and main screens based on session
class AuthGate extends ConsumerWidget {
  const AuthGate({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isAuthenticated = ref.watch(isAuthenticatedProvider);

    return isAuthenticated.when(
      data: (authenticated) {
        if (authenticated) {
          return const ConversationsListScreen();
        } else {
          return AuthScreen(
            onAuthSuccess: () {
              // Refresh auth state - this will trigger a rebuild
              ref.refresh(isAuthenticatedProvider);
            },
          );
        }
      },
      loading: () {
        return Scaffold(
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.chat_bubble,
                  size: 64,
                  color: Theme.of(context).colorScheme.primary,
                ),
                const SizedBox(height: 24),
                Text(
                  'MessageAI',
                  style: Theme.of(context).textTheme.headlineSmall,
                ),
                const SizedBox(height: 32),
                const CircularProgressIndicator(),
              ],
            ),
          ),
        );
      },
      error: (error, stackTrace) {
        return Scaffold(
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.error_outline,
                  size: 64,
                  color: Theme.of(context).colorScheme.error,
                ),
                const SizedBox(height: 24),
                Text(
                  'Error',
                  style: Theme.of(context).textTheme.headlineSmall,
                ),
                const SizedBox(height: 16),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 24),
                  child: Text(
                    error.toString(),
                    textAlign: TextAlign.center,
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}
</file>

<file path="lib/core/env.dart">
/// Environment configuration for Supabase connection.
/// 
/// Reads SUPABASE_URL and SUPABASE_ANON_KEY from:
/// 1. Dart defines (via --dart-define-from-file=.env.dev.json)
/// 2. Environment variables as fallback

class Env {
  static const String supabaseUrl = String.fromEnvironment(
    'SUPABASE_URL',
    defaultValue: 'https://your-project.supabase.co',
  );

  static const String supabaseAnonKey = String.fromEnvironment(
    'SUPABASE_ANON_KEY',
    defaultValue: 'your-anon-key',
  );

  // Validate that required config is present
  static void validate() {
    assert(
      supabaseUrl != 'https://your-project.supabase.co',
      'SUPABASE_URL not configured',
    );
    assert(
      supabaseAnonKey != 'your-anon-key',
      'SUPABASE_ANON_KEY not configured',
    );
  }
}
</file>

<file path="lib/core/errors/app_error.dart">
/// Application error types and models
/// Provides structured error handling across the app

/// Error categories for classification
enum ErrorCategory {
  auth,
  network,
  database,
  messaging,
  storage,
  permission,
  validation,
  unknown,
}

/// Error severity levels
enum ErrorSeverity {
  info,     // Informational, no action required
  warning,  // Warning, user should be aware
  error,    // Error, user action may help
  critical, // Critical, likely requires app restart or support
}

/// Structured application error
class AppError implements Exception {
  final ErrorCategory category;
  final ErrorSeverity severity;
  final String code;
  final String message;
  final String? userMessage;
  final dynamic originalError;
  final StackTrace? stackTrace;
  final Map<String, dynamic>? context;
  final bool isRetryable;

  const AppError({
    required this.category,
    required this.severity,
    required this.code,
    required this.message,
    this.userMessage,
    this.originalError,
    this.stackTrace,
    this.context,
    this.isRetryable = false,
  });

  /// Get user-friendly error message
  String get displayMessage => userMessage ?? message;

  /// Check if error requires user action
  bool get requiresUserAction => 
      severity == ErrorSeverity.error || 
      severity == ErrorSeverity.critical;

  @override
  String toString() {
    return 'AppError($category.$code): $message';
  }

  /// Copy with modifications
  AppError copyWith({
    ErrorCategory? category,
    ErrorSeverity? severity,
    String? code,
    String? message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    Map<String, dynamic>? context,
    bool? isRetryable,
  }) {
    return AppError(
      category: category ?? this.category,
      severity: severity ?? this.severity,
      code: code ?? this.code,
      message: message ?? this.message,
      userMessage: userMessage ?? this.userMessage,
      originalError: originalError ?? this.originalError,
      stackTrace: stackTrace ?? this.stackTrace,
      context: context ?? this.context,
      isRetryable: isRetryable ?? this.isRetryable,
    );
  }
}

/// Authentication errors
class AuthError extends AppError {
  AuthError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = false,
  }) : super(
          category: ErrorCategory.auth,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory AuthError.invalidCredentials() => AuthError(
        code: 'AUTH001',
        message: 'Invalid email or password',
        userMessage: 'The email or password you entered is incorrect. Please try again.',
      );

  factory AuthError.emailAlreadyExists() => AuthError(
        code: 'AUTH002',
        message: 'Email already registered',
        userMessage: 'An account with this email already exists. Try signing in instead.',
      );

  factory AuthError.weakPassword() => AuthError(
        code: 'AUTH003',
        message: 'Password too weak',
        userMessage: 'Please choose a stronger password (at least 6 characters).',
      );

  factory AuthError.invalidEmail() => AuthError(
        code: 'AUTH004',
        message: 'Invalid email format',
        userMessage: 'Please enter a valid email address.',
      );

  factory AuthError.sessionExpired() => AuthError(
        code: 'AUTH005',
        message: 'Session expired',
        userMessage: 'Your session has expired. Please sign in again.',
      );

  factory AuthError.networkError() => AuthError(
        code: 'AUTH006',
        message: 'Network error during authentication',
        userMessage: 'Unable to connect. Please check your internet connection and try again.',
        isRetryable: true,
      );

  factory AuthError.unknown(dynamic error) => AuthError(
        code: 'AUTH999',
        message: 'Unknown authentication error',
        userMessage: 'Something went wrong during authentication. Please try again.',
        originalError: error,
        isRetryable: true,
      );
}

/// Network errors
class NetworkError extends AppError {
  NetworkError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
  }) : super(
          category: ErrorCategory.network,
          severity: ErrorSeverity.warning,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: true,
        );

  factory NetworkError.noConnection() => NetworkError(
        code: 'NET001',
        message: 'No internet connection',
        userMessage: 'No internet connection. Please check your network settings.',
      );

  factory NetworkError.timeout() => NetworkError(
        code: 'NET002',
        message: 'Request timeout',
        userMessage: 'The request took too long. Please try again.',
      );

  factory NetworkError.serverError() => NetworkError(
        code: 'NET003',
        message: 'Server error',
        userMessage: 'Server is temporarily unavailable. Please try again later.',
      );
}

/// Message sending errors
class MessageError extends AppError {
  MessageError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = true,
  }) : super(
          category: ErrorCategory.messaging,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory MessageError.sendFailed() => MessageError(
        code: 'MSG001',
        message: 'Failed to send message',
        userMessage: 'Unable to send message. Please try again.',
      );

  factory MessageError.networkError() => MessageError(
        code: 'MSG002',
        message: 'Network error while sending message',
        userMessage: 'Message saved offline. It will send when you\'re back online.',
      );

  factory MessageError.unauthorized() => MessageError(
        code: 'MSG003',
        message: 'Not authorized to send message',
        userMessage: 'You don\'t have permission to send messages to this conversation.',
        isRetryable: false,
      );

  factory MessageError.conversationNotFound() => MessageError(
        code: 'MSG004',
        message: 'Conversation not found',
        userMessage: 'This conversation no longer exists.',
        isRetryable: false,
      );

  factory MessageError.mediaTooLarge() => MessageError(
        code: 'MSG005',
        message: 'Media file too large',
        userMessage: 'The image is too large. Please choose a smaller file.',
        isRetryable: false,
      );

  factory MessageError.mediaUploadFailed() => MessageError(
        code: 'MSG006',
        message: 'Failed to upload media',
        userMessage: 'Unable to upload image. Please try again.',
      );
}

/// Storage errors
class StorageError extends AppError {
  StorageError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = true,
  }) : super(
          category: ErrorCategory.storage,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory StorageError.uploadFailed() => StorageError(
        code: 'STR001',
        message: 'Upload failed',
        userMessage: 'Unable to upload file. Please try again.',
      );

  factory StorageError.fileTooLarge() => StorageError(
        code: 'STR002',
        message: 'File too large',
        userMessage: 'The file is too large. Maximum size is 10MB.',
        isRetryable: false,
      );

  factory StorageError.unsupportedFormat() => StorageError(
        code: 'STR003',
        message: 'Unsupported file format',
        userMessage: 'This file type is not supported. Please use JPG, PNG, or GIF.',
        isRetryable: false,
      );
}

/// Database errors
class DatabaseError extends AppError {
  DatabaseError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = true,
  }) : super(
          category: ErrorCategory.database,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory DatabaseError.queryFailed() => DatabaseError(
        code: 'DB001',
        message: 'Database query failed',
        userMessage: 'Unable to fetch data. Please try again.',
      );

  factory DatabaseError.syncFailed() => DatabaseError(
        code: 'DB002',
        message: 'Sync failed',
        userMessage: 'Unable to sync data. Your changes are saved locally.',
      );
}

/// Permission errors
class PermissionError extends AppError {
  PermissionError({
    required String code,
    required String message,
    String? userMessage,
    bool isRetryable = false,
  }) : super(
          category: ErrorCategory.permission,
          severity: ErrorSeverity.warning,
          code: code,
          message: message,
          userMessage: userMessage,
          isRetryable: isRetryable,
        );

  factory PermissionError.cameraNotGranted() => PermissionError(
        code: 'PERM001',
        message: 'Camera permission not granted',
        userMessage: 'Camera access is required. Please enable it in Settings.',
      );

  factory PermissionError.storageNotGranted() => PermissionError(
        code: 'PERM002',
        message: 'Storage permission not granted',
        userMessage: 'Storage access is required. Please enable it in Settings.',
      );

  factory PermissionError.notificationsNotGranted() => PermissionError(
        code: 'PERM003',
        message: 'Notification permission not granted',
        userMessage: 'Enable notifications to receive message alerts.',
      );
}
</file>

<file path="lib/core/errors/error_handler.dart">
import 'package:messageai/core/errors/app_error.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

/// Global error handler service
class ErrorHandler {
  static final ErrorHandler _instance = ErrorHandler._internal();

  factory ErrorHandler() {
    return _instance;
  }

  ErrorHandler._internal();

  /// Convert any error to AppError
  AppError handleError(dynamic error, {StackTrace? stackTrace, String? context}) {
    AppError appError;

    if (error is AppError) {
      appError = error;
    } else if (error is AuthException) {
      appError = _handleAuthException(error);
    } else if (error is PostgrestException) {
      appError = _handlePostgrestException(error);
    } else if (error is StorageException) {
      appError = _handleStorageException(error);
    } else if (error is String) {
      appError = _handleStringError(error);
    } else {
      appError = _handleUnknownError(error);
    }

    // Log error
    _logError(appError, stackTrace, context);

    return appError;
  }

  /// Handle Supabase Auth exceptions
  AppError _handleAuthException(AuthException error) {
    final message = error.message.toLowerCase();

    if (message.contains('invalid login credentials') ||
        message.contains('invalid email or password')) {
      return AuthError.invalidCredentials();
    } else if (message.contains('already registered') ||
               message.contains('already been registered')) {
      return AuthError.emailAlreadyExists();
    } else if (message.contains('password') && message.contains('weak')) {
      return AuthError.weakPassword();
    } else if (message.contains('invalid email')) {
      return AuthError.invalidEmail();
    } else if (message.contains('session') && 
               (message.contains('expired') || message.contains('invalid'))) {
      return AuthError.sessionExpired();
    } else if (message.contains('network') || 
               message.contains('connection') ||
               message.contains('timeout')) {
      return AuthError.networkError();
    } else {
      return AuthError.unknown(error);
    }
  }

  /// Handle Supabase Postgrest (database) exceptions
  AppError _handlePostgrestException(PostgrestException error) {
    final message = error.message.toLowerCase();
    final code = error.code ?? '';

    // RLS policy violations
    if (code.contains('42501') || message.contains('permission denied')) {
      return MessageError.unauthorized();
    }

    // Foreign key violations
    if (code.contains('23503') || message.contains('foreign key')) {
      return MessageError.conversationNotFound();
    }

    // Network errors
    if (message.contains('network') || 
        message.contains('timeout') ||
        message.contains('connection')) {
      return NetworkError.noConnection();
    }

    // Server errors
    if (code.startsWith('5')) {
      return NetworkError.serverError();
    }

    // Generic database error
    return DatabaseError.queryFailed();
  }

  /// Handle Supabase Storage exceptions
  AppError _handleStorageException(StorageException error) {
    final message = error.message.toLowerCase();

    if (message.contains('size') || message.contains('too large')) {
      return StorageError.fileTooLarge();
    } else if (message.contains('format') || 
               message.contains('type') ||
               message.contains('invalid file')) {
      return StorageError.unsupportedFormat();
    } else {
      return StorageError.uploadFailed();
    }
  }

  /// Handle string errors (thrown as strings)
  AppError _handleStringError(String error) {
    final message = error.toLowerCase();

    // Auth errors
    if (message.contains('sign in') || message.contains('sign up')) {
      if (message.contains('failed')) {
        return AuthError.unknown(error);
      }
    }

    // Message errors
    if (message.contains('message')) {
      if (message.contains('failed') || message.contains('error')) {
        return MessageError.sendFailed();
      }
    }

    // Network errors
    if (message.contains('network') || 
        message.contains('connection') ||
        message.contains('offline') ||
        message.contains('internet')) {
      return NetworkError.noConnection();
    }

    // Generic error
    return AppError(
      category: ErrorCategory.unknown,
      severity: ErrorSeverity.error,
      code: 'UNK001',
      message: error,
      userMessage: 'Something went wrong. Please try again.',
      isRetryable: true,
    );
  }

  /// Handle unknown errors
  AppError _handleUnknownError(dynamic error) {
    return AppError(
      category: ErrorCategory.unknown,
      severity: ErrorSeverity.error,
      code: 'UNK999',
      message: error.toString(),
      userMessage: 'An unexpected error occurred. Please try again.',
      originalError: error,
      isRetryable: true,
    );
  }

  /// Log error for debugging
  void _logError(AppError error, StackTrace? stackTrace, String? context) {
    // Only log critical errors and non-retryable errors
    if (error.severity == ErrorSeverity.critical || !error.isRetryable) {
      final emoji = _getEmojiForSeverity(error.severity);
      print('$emoji ${error.code}: ${error.userMessage ?? error.message}');
    }
  }

  /// Get emoji for severity level
  String _getEmojiForSeverity(ErrorSeverity severity) {
    switch (severity) {
      case ErrorSeverity.info:
        return 'ℹ️';
      case ErrorSeverity.warning:
        return '⚠️';
      case ErrorSeverity.error:
        return '❌';
      case ErrorSeverity.critical:
        return '🚨';
    }
  }

  /// Check if error is network-related
  bool isNetworkError(AppError error) {
    return error.category == ErrorCategory.network ||
           (error.category == ErrorCategory.auth && error.code == 'AUTH006') ||
           (error.category == ErrorCategory.messaging && error.code == 'MSG002');
  }

  /// Check if error should trigger offline mode
  bool shouldGoOffline(AppError error) {
    return error.category == ErrorCategory.network &&
           error.code == 'NET001';
  }

  /// Get retry delay based on attempt number (exponential backoff)
  Duration getRetryDelay(int attemptNumber) {
    // Exponential backoff: 1s, 2s, 4s, 8s, 16s
    final delaySeconds = (1 << (attemptNumber - 1)).clamp(1, 16);
    return Duration(seconds: delaySeconds);
  }

  /// Check if should retry based on attempt count
  bool shouldRetry(AppError error, int attemptNumber, {int maxAttempts = 3}) {
    return error.isRetryable && attemptNumber < maxAttempts;
  }
}

/// Extension to add error handling to Future
extension FutureErrorHandler<T> on Future<T> {
  /// Handle errors and convert to AppError
  Future<T> handleAppError({String? context}) async {
    try {
      return await this;
    } catch (error, stackTrace) {
      throw ErrorHandler().handleError(error, stackTrace: stackTrace, context: context);
    }
  }
}
</file>

<file path="lib/core/errors/error_ui.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/errors/app_error.dart';

/// UI utilities for displaying errors to users
class ErrorUI {
  /// Show error as snackbar (for non-critical errors)
  static void showErrorSnackbar(
    BuildContext context,
    AppError error, {
    VoidCallback? onRetry,
  }) {
    final snackBar = SnackBar(
      content: Row(
        children: [
          Icon(
            _getIconForError(error),
            color: Colors.white,
            size: 20,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              error.displayMessage,
              style: const TextStyle(fontSize: 14),
            ),
          ),
        ],
      ),
      backgroundColor: _getColorForSeverity(error.severity),
      behavior: SnackBarBehavior.floating,
      action: error.isRetryable && onRetry != null
          ? SnackBarAction(
              label: 'Retry',
              textColor: Colors.white,
              onPressed: onRetry,
            )
          : null,
      duration: Duration(
        seconds: error.severity == ErrorSeverity.critical ? 6 : 4,
      ),
    );

    ScaffoldMessenger.of(context)
      ..hideCurrentSnackBar()
      ..showSnackBar(snackBar);
  }

  /// Show error as dialog (for critical errors or when user action required)
  static Future<bool?> showErrorDialog(
    BuildContext context,
    AppError error, {
    VoidCallback? onRetry,
    String? actionLabel,
  }) {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        icon: Icon(
          _getIconForError(error),
          color: _getColorForSeverity(error.severity),
          size: 48,
        ),
        title: Text(_getTitleForError(error)),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(error.displayMessage),
            if (error.code.isNotEmpty) ...[
              const SizedBox(height: 16),
              Text(
                'Error Code: ${error.code}',
                style: TextStyle(
                  fontSize: 12,
                  color: Colors.grey[600],
                ),
              ),
            ],
          ],
        ),
        actions: [
          if (!error.requiresUserAction)
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Dismiss'),
            ),
          if (error.isRetryable && onRetry != null)
            FilledButton(
              onPressed: () {
                Navigator.of(context).pop(true);
                onRetry();
              },
              child: Text(actionLabel ?? 'Retry'),
            ),
          if (!error.isRetryable || onRetry == null)
            FilledButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('OK'),
            ),
        ],
      ),
    );
  }

  /// Show permission error with option to open settings
  static Future<void> showPermissionError(
    BuildContext context,
    PermissionError error,
  ) {
    return showDialog(
      context: context,
      builder: (context) => AlertDialog(
        icon: const Icon(
          Icons.security,
          color: Colors.orange,
          size: 48,
        ),
        title: const Text('Permission Required'),
        content: Text(error.displayMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              Navigator.of(context).pop();
              // TODO: Open app settings
              // OpenSettings.openAppSettings();
            },
            child: const Text('Open Settings'),
          ),
        ],
      ),
    );
  }

  /// Show loading indicator with cancellation
  static Future<T?> showLoadingDialog<T>(
    BuildContext context, {
    required Future<T> Function() action,
    String message = 'Loading...',
  }) async {
    // Show loading dialog
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        content: Row(
          children: [
            const CircularProgressIndicator(),
            const SizedBox(width: 24),
            Text(message),
          ],
        ),
      ),
    );

    try {
      final result = await action();
      if (context.mounted) {
        Navigator.of(context).pop();
      }
      return result;
    } catch (error) {
      if (context.mounted) {
        Navigator.of(context).pop();
        if (error is AppError) {
          showErrorDialog(context, error);
        }
      }
      return null;
    }
  }

  /// Get icon for error
  static IconData _getIconForError(AppError error) {
    switch (error.category) {
      case ErrorCategory.auth:
        return Icons.lock_outline;
      case ErrorCategory.network:
        return Icons.wifi_off;
      case ErrorCategory.database:
        return Icons.storage_outlined;
      case ErrorCategory.messaging:
        return Icons.message_outlined;
      case ErrorCategory.storage:
        return Icons.cloud_upload_outlined;
      case ErrorCategory.permission:
        return Icons.security;
      case ErrorCategory.validation:
        return Icons.error_outline;
      case ErrorCategory.unknown:
        return Icons.warning_amber;
    }
  }

  /// Get color for severity
  static Color _getColorForSeverity(ErrorSeverity severity) {
    switch (severity) {
      case ErrorSeverity.info:
        return Colors.blue;
      case ErrorSeverity.warning:
        return Colors.orange;
      case ErrorSeverity.error:
        return Colors.red;
      case ErrorSeverity.critical:
        return Colors.red.shade900;
    }
  }

  /// Get title for error dialog
  static String _getTitleForError(AppError error) {
    switch (error.category) {
      case ErrorCategory.auth:
        return 'Authentication Error';
      case ErrorCategory.network:
        return 'Connection Problem';
      case ErrorCategory.database:
        return 'Data Error';
      case ErrorCategory.messaging:
        return 'Message Error';
      case ErrorCategory.storage:
        return 'Upload Error';
      case ErrorCategory.permission:
        return 'Permission Required';
      case ErrorCategory.validation:
        return 'Invalid Input';
      case ErrorCategory.unknown:
        return 'Error';
    }
  }
}

/// Mixin for widgets that need error handling
mixin ErrorHandlerMixin<T extends StatefulWidget> on State<T> {
  /// Show error to user
  void showError(AppError error, {VoidCallback? onRetry}) {
    if (!mounted) return;

    if (error.severity == ErrorSeverity.critical || error.requiresUserAction) {
      ErrorUI.showErrorDialog(context, error, onRetry: onRetry);
    } else {
      ErrorUI.showErrorSnackbar(context, error, onRetry: onRetry);
    }
  }

  /// Handle error from async operation
  Future<T?> handleAsyncError<T>(
    Future<T> Function() operation, {
    String? context,
    VoidCallback? onRetry,
  }) async {
    try {
      return await operation();
    } on AppError catch (error) {
      showError(error, onRetry: onRetry);
      return null;
    } catch (error) {
      final appError = AppError(
        category: ErrorCategory.unknown,
        severity: ErrorSeverity.error,
        code: 'UNK001',
        message: error.toString(),
        userMessage: 'An unexpected error occurred.',
      );
      showError(appError, onRetry: onRetry);
      return null;
    }
  }
}
</file>

<file path="lib/core/theme/app_theme.dart">
import 'package:flutter/material.dart';

/// MessageAI Theme System
/// Monochrome black/white/gray palette for clean, accessible design
class AppTheme {
  // Prevent instantiation
  AppTheme._();

  // ============================================================================
  // COLORS - Grayscale System
  // ============================================================================
  
  /// Pure colors
  static const Color white = Color(0xFFFFFFFF);
  static const Color black = Color(0xFF000000);
  
  /// Gray scale (Light Mode)
  static const Color gray50 = Color(0xFFFAFAFA);   // Almost white
  static const Color gray100 = Color(0xFFF5F5F5);  // Off white
  static const Color gray200 = Color(0xFFEEEEEE);  // Very light gray
  static const Color gray300 = Color(0xFFE0E0E0);  // Light gray
  static const Color gray400 = Color(0xFFBDBDBD);  // Light-medium gray
  static const Color gray500 = Color(0xFF9E9E9E);  // Medium gray
  static const Color gray600 = Color(0xFF757575);  // Medium-dark gray
  static const Color gray700 = Color(0xFF616161);  // Dark gray
  static const Color gray800 = Color(0xFF424242);  // Very dark gray
  static const Color gray900 = Color(0xFF212121);  // Almost black
  
  /// Dark mode grays
  static const Color darkGray100 = Color(0xFF1A1A1A);  // Near black surface
  static const Color darkGray200 = Color(0xFF242424);  // Dark surface
  static const Color darkGray300 = Color(0xFF2E2E2E);  // Medium dark
  static const Color darkGray400 = Color(0xFF3A3A3A);  // Lighter dark
  
  /// Accent colors (minimal use only)
  static const Color accentBlue = Color(0xFF000000);     // Actions, links
  static const Color accentGreen = Color(0xFF4CAF50);    // Online, success
  static const Color accentRed = Color(0xFFF44336);      // Error, urgent
  static const Color accentOrange = Color(0xFFFF9800);   // Warning
  
  // ============================================================================
  // TYPOGRAPHY
  // ============================================================================
  
  /// Font sizes
  static const double fontSizeXXL = 32.0;  // Page titles
  static const double fontSizeXL = 24.0;   // Section headers
  static const double fontSizeL = 20.0;    // Card titles
  static const double fontSizeM = 16.0;    // Body text (BASE)
  static const double fontSizeS = 14.0;    // Captions
  static const double fontSizeXS = 12.0;   // Timestamps
  static const double fontSizeXXS = 10.0;  // Micro-copy
  
  /// Font weights
  static const FontWeight fontWeightLight = FontWeight.w300;
  static const FontWeight fontWeightRegular = FontWeight.w400;
  static const FontWeight fontWeightMedium = FontWeight.w500;
  static const FontWeight fontWeightSemibold = FontWeight.w600;
  static const FontWeight fontWeightBold = FontWeight.w700;
  
  /// Line heights
  static const double lineHeightTight = 1.2;
  static const double lineHeightNormal = 1.5;
  static const double lineHeightRelaxed = 1.75;
  
  // ============================================================================
  // SPACING
  // ============================================================================
  
  /// Base unit: 4px - all spacing uses multiples of this
  static const double spacingXXS = 4.0;
  static const double spacingXS = 8.0;
  static const double spacingS = 12.0;
  static const double spacingM = 16.0;   // Standard spacing (BASE)
  static const double spacingL = 24.0;
  static const double spacingXL = 32.0;
  static const double spacingXXL = 48.0;
  static const double spacingXXXL = 64.0;
  
  // ============================================================================
  // BORDER RADIUS
  // ============================================================================
  
  static const double radiusNone = 0.0;
  static const double radiusXS = 2.0;
  static const double radiusS = 4.0;
  static const double radiusM = 8.0;    // Standard radius (BASE)
  static const double radiusL = 12.0;
  static const double radiusXL = 16.0;
  static const double radiusXXL = 24.0;
  static const double radiusPill = 9999.0;
  
  // ============================================================================
  // SHADOWS
  // ============================================================================
  
  /// Light mode shadows
  static List<BoxShadow> get shadow1Light => [
    BoxShadow(
      color: black.withOpacity(0.12),
      blurRadius: 3,
      offset: const Offset(0, 1),
    ),
    BoxShadow(
      color: black.withOpacity(0.08),
      blurRadius: 2,
      offset: const Offset(0, 1),
    ),
  ];
  
  static List<BoxShadow> get shadow2Light => [
    BoxShadow(
      color: black.withOpacity(0.12),
      blurRadius: 6,
      offset: const Offset(0, 2),
    ),
    BoxShadow(
      color: black.withOpacity(0.08),
      blurRadius: 4,
      offset: const Offset(0, 2),
    ),
  ];
  
  static List<BoxShadow> get shadow3Light => [
    BoxShadow(
      color: black.withOpacity(0.15),
      blurRadius: 12,
      offset: const Offset(0, 4),
    ),
    BoxShadow(
      color: black.withOpacity(0.10),
      blurRadius: 6,
      offset: const Offset(0, 2),
    ),
  ];
  
  /// Dark mode shadows (more subtle)
  static List<BoxShadow> get shadow1Dark => [
    BoxShadow(
      color: black.withOpacity(0.30),
      blurRadius: 3,
      offset: const Offset(0, 1),
    ),
    BoxShadow(
      color: black.withOpacity(0.20),
      blurRadius: 2,
      offset: const Offset(0, 1),
    ),
  ];
  
  static List<BoxShadow> get shadow2Dark => [
    BoxShadow(
      color: black.withOpacity(0.35),
      blurRadius: 6,
      offset: const Offset(0, 2),
    ),
    BoxShadow(
      color: black.withOpacity(0.25),
      blurRadius: 4,
      offset: const Offset(0, 2),
    ),
  ];
  
  // ============================================================================
  // THEME DATA
  // ============================================================================
  
  /// Light theme configuration
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      
      // Color scheme
      colorScheme: const ColorScheme.light(
        primary: accentBlue,
        onPrimary: white,
        secondary: gray900,
        onSecondary: white,
        surface: white,
        onSurface: black,
        surfaceContainerHighest: gray100,
        error: accentRed,
        onError: white,
      ),
      
      // Scaffold
      scaffoldBackgroundColor: white,
      
      // App bar
      appBarTheme: const AppBarTheme(
        backgroundColor: white,
        foregroundColor: black,
        elevation: 0,
        centerTitle: false,
        titleTextStyle: TextStyle(
          color: black,
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
        ),
        iconTheme: IconThemeData(
          color: black,
          size: 24,
        ),
      ),
      
      // Cards
      cardTheme: CardThemeData(
        color: white,
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radiusM),
          side: const BorderSide(color: gray300, width: 1),
        ),
        margin: const EdgeInsets.all(spacingS),
      ),
      
      // Text theme
      textTheme: const TextTheme(
        displayLarge: TextStyle(
          fontSize: fontSizeXXL,
          fontWeight: fontWeightBold,
          color: black,
          height: lineHeightTight,
        ),
        displayMedium: TextStyle(
          fontSize: fontSizeXL,
          fontWeight: fontWeightBold,
          color: black,
          height: lineHeightTight,
        ),
        displaySmall: TextStyle(
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
          color: black,
          height: lineHeightTight,
        ),
        bodyLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightRegular,
          color: black,
          height: lineHeightNormal,
        ),
        bodyMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightRegular,
          color: gray800,
          height: lineHeightNormal,
        ),
        bodySmall: TextStyle(
          fontSize: fontSizeXS,
          fontWeight: fontWeightRegular,
          color: gray600,
          height: lineHeightNormal,
        ),
        labelLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightSemibold,
          color: black,
        ),
        labelMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightMedium,
          color: black,
        ),
      ),
      
      // Buttons
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: accentBlue,
          foregroundColor: white,
          elevation: 0,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingL,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: accentBlue,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingM,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      // FAB
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: black,
        foregroundColor: white,
        elevation: 4,
        shape: CircleBorder(),
      ),
      
      // Input decoration
      inputDecorationTheme: InputDecorationTheme(
        filled: false,
        fillColor: white,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: gray300, width: 1),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: gray300, width: 1),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentBlue, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentRed, width: 1),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: spacingM,
          vertical: spacingS,
        ),
        hintStyle: const TextStyle(color: gray500),
      ),
      
      // Divider
      dividerTheme: const DividerThemeData(
        color: gray300,
        thickness: 1,
        space: 1,
      ),
      
      // Icon theme
      iconTheme: const IconThemeData(
        color: black,
        size: 24,
      ),
    );
  }
  
  /// Dark theme configuration
  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      
      // Color scheme
      colorScheme: const ColorScheme.dark(
        primary: accentBlue,
        onPrimary: black,
        secondary: white,
        onSecondary: black,
        surface: black,
        onSurface: white,
        surfaceContainerHighest: darkGray100,
        error: accentRed,
        onError: black,
      ),
      
      // Scaffold
      scaffoldBackgroundColor: black,
      
      // App bar
      appBarTheme: const AppBarTheme(
        backgroundColor: black,
        foregroundColor: white,
        elevation: 0,
        centerTitle: false,
        titleTextStyle: TextStyle(
          color: white,
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
        ),
        iconTheme: IconThemeData(
          color: white,
          size: 24,
        ),
      ),
      
      // Cards
      cardTheme: CardThemeData(
        color: darkGray100,
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radiusM),
          side: const BorderSide(color: darkGray300, width: 1),
        ),
        margin: const EdgeInsets.all(spacingS),
      ),
      
      // Text theme
      textTheme: const TextTheme(
        displayLarge: TextStyle(
          fontSize: fontSizeXXL,
          fontWeight: fontWeightBold,
          color: white,
          height: lineHeightTight,
        ),
        displayMedium: TextStyle(
          fontSize: fontSizeXL,
          fontWeight: fontWeightBold,
          color: white,
          height: lineHeightTight,
        ),
        displaySmall: TextStyle(
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
          color: white,
          height: lineHeightTight,
        ),
        bodyLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightRegular,
          color: white,
          height: lineHeightNormal,
        ),
        bodyMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightRegular,
          color: gray400,
          height: lineHeightNormal,
        ),
        bodySmall: TextStyle(
          fontSize: fontSizeXS,
          fontWeight: fontWeightRegular,
          color: gray500,
          height: lineHeightNormal,
        ),
        labelLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightSemibold,
          color: white,
        ),
        labelMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightMedium,
          color: white,
        ),
      ),
      
      // Buttons
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: white,
          foregroundColor: black,
          elevation: 0,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingL,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: accentBlue,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingM,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      // FAB
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: white,
        foregroundColor: black,
        elevation: 4,
        shape: CircleBorder(),
      ),
      
      // Input decoration
      inputDecorationTheme: InputDecorationTheme(
        filled: false,
        fillColor: darkGray100,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: darkGray300, width: 1),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: darkGray300, width: 1),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentBlue, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentRed, width: 1),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: spacingM,
          vertical: spacingS,
        ),
        hintStyle: const TextStyle(color: gray600),
      ),
      
      // Divider
      dividerTheme: const DividerThemeData(
        color: darkGray300,
        thickness: 1,
        space: 1,
      ),
      
      // Icon theme
      iconTheme: const IconThemeData(
        color: white,
        size: 24,
      ),
    );
  }
}
</file>

<file path="lib/data/drift/app_db.dart">
import 'package:drift/drift.dart';
import 'package:drift_flutter/drift_flutter.dart';
import 'package:messageai/data/drift/daos/conversation_dao.dart';
import 'package:messageai/data/drift/daos/message_dao.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/drift/daos/participant_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';
// AI Analysis DAO commented out (using remote-only approach)
// Uncomment and restore from backup files when scaling to local cache
// import 'package:messageai/data/drift/daos/ai_analysis_dao.dart';

part 'app_db.g.dart';

// Table definitions
class Conversations extends Table {
  TextColumn get id => text()();
  TextColumn get title => text()();
  TextColumn get description => text().nullable()();
  IntColumn get createdAt => integer()(); // Unix timestamp
  IntColumn get updatedAt => integer()();
  BoolColumn get isGroup => boolean().withDefault(const Constant(false))();
  IntColumn get lastMessageAt => integer().nullable()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};
}

class Messages extends Table {
  TextColumn get id => text()();
  TextColumn get conversationId => text()();
  TextColumn get senderId => text()();
  TextColumn get body => text()();
  TextColumn get mediaUrl => text().nullable()();
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    {conversationId, id}
  ];
}

class Participants extends Table {
  TextColumn get id => text()();
  TextColumn get conversationId => text()();
  TextColumn get userId => text()();
  IntColumn get joinedAt => integer()();
  BoolColumn get isAdmin => boolean().withDefault(const Constant(false))();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    {conversationId, userId}
  ];
}

class Receipts extends Table {
  TextColumn get id => text()();
  TextColumn get messageId => text()();
  TextColumn get userId => text()();
  TextColumn get status => text()(); // 'delivered', 'read'
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    {messageId, userId}
  ];
}

class PendingOutbox extends Table {
  TextColumn get id => text()();
  TextColumn get operation => text()(); // 'send_message', 'ack_receipt'
  TextColumn get payload => text()(); // JSON serialized
  TextColumn get conversationId => text().nullable()();
  IntColumn get createdAt => integer()();
  IntColumn get retryCount => integer().withDefault(const Constant(0))();
  TextColumn get lastError => text().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

// AI Analysis table commented out for now (using remote-only approach)
// Uncomment and restore from backup files when scaling to local cache
/*
class AiAnalysis extends Table {
  TextColumn get id => text()();
  TextColumn get messageId => text()();
  TextColumn get tone => text()();
  TextColumn get urgencyLevel => text().nullable()();
  TextColumn get intent => text().nullable()();
  RealColumn get confidenceScore => real().nullable()();
  IntColumn get analysisTimestamp => integer()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();

  @override
  Set<Column> get primaryKey => {id};
}
*/

// Main database class
// Note: AiAnalysis table and AIAnalysisDao commented out (using remote-only approach)
@DriftDatabase(
  tables: [Conversations, Messages, Participants, Receipts, PendingOutbox],
  daos: [ConversationDao, MessageDao, ReceiptDao, ParticipantDao, PendingOutboxDao],
)
class AppDb extends _$AppDb {
  AppDb() : super(_openConnection());

  @override
  int get schemaVersion => 1; // Reverted to 1 (AI table removed)

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) async {
        await m.createAll();
      },
      onUpgrade: (Migrator m, int from, int to) async {
        // AI Analysis migration commented out (using remote-only approach)
        // if (from == 1 && to == 2) {
        //   await m.createTable(aiAnalysis);
        // }
      },
    );
  }

  /// Get the singleton instance of the database
  static AppDb? _instance;

  static AppDb get instance => _instance ??= AppDb();

  /// Close the database connection
  Future<void> close() async {
    await super.close();
    _instance = null;
  }
}

// Connection logic
QueryExecutor _openConnection() {
  return driftDatabase(
    name: 'messageai_db',
  );
}
</file>

<file path="lib/data/drift/daos/ai_analysis_dao_cached.dart.backup">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'ai_analysis_dao.g.dart';

/// Data Access Object for AI Analysis operations
@DriftAccessor(tables: [AiAnalysis])
class AIAnalysisDao extends DatabaseAccessor<AppDb> with _$AIAnalysisDaoMixin {
  AIAnalysisDao(AppDb db) : super(db);

  /// Get all AI analyses
  Future<List<AiAnalysi>> getAllAnalyses() {
    return select(aiAnalysis).get();
  }

  /// Get analysis by ID
  Future<AiAnalysi?> getAnalysisById(String id) {
    return (select(aiAnalysis)..where((a) => a.id.equals(id))).getSingleOrNull();
  }

  /// Get analysis for a specific message
  Future<AiAnalysi?> getAnalysisByMessageId(String messageId) {
    return (select(aiAnalysis)..where((a) => a.messageId.equals(messageId)))
        .getSingleOrNull();
  }

  /// Get all analyses for multiple messages
  Future<List<AiAnalysi>> getAnalysesByMessageIds(List<String> messageIds) {
    return (select(aiAnalysis)..where((a) => a.messageId.isIn(messageIds))).get();
  }

  /// Get analyses for a conversation (requires joining with messages)
  /// Note: This is a simple version. For better performance, you might want to
  /// pass in message IDs from the conversation
  Future<List<AiAnalysi>> getAnalysesForConversation(List<String> messageIds) {
    return (select(aiAnalysis)
          ..where((a) => a.messageId.isIn(messageIds))
          ..orderBy([(a) => OrderingTerm.desc(a.analysisTimestamp)]))
        .get();
  }

  /// Add a new analysis
  Future<int> addAnalysis(AiAnalysisCompanion analysis) {
    return into(aiAnalysis).insert(analysis);
  }

  /// Add or update analysis
  Future<void> upsertAnalysis(AiAnalysisCompanion analysis) {
    return into(aiAnalysis).insertOnConflictUpdate(analysis);
  }

  /// Update analysis
  Future<bool> updateAnalysis(AiAnalysi analysis) {
    return update(aiAnalysis).replace(analysis);
  }

  /// Delete analysis
  Future<int> deleteAnalysis(String id) {
    return (delete(aiAnalysis)..where((a) => a.id.equals(id))).go();
  }

  /// Delete analysis by message ID
  Future<int> deleteAnalysisByMessageId(String messageId) {
    return (delete(aiAnalysis)..where((a) => a.messageId.equals(messageId))).go();
  }

  /// Mark analysis as synced
  Future<void> markAsSynced(String id) {
    return (update(aiAnalysis)..where((a) => a.id.equals(id)))
        .write(const AiAnalysisCompanion(isSynced: Value(1)));
  }

  /// Get unsynced analyses
  Future<List<AiAnalysi>> getUnsyncedAnalyses() {
    return (select(aiAnalysis)..where((a) => a.isSynced.equals(0))).get();
  }

  /// Get analyses with specific tone
  Future<List<AiAnalysi>> getAnalysesByTone(String tone) {
    return (select(aiAnalysis)..where((a) => a.tone.equals(tone))).get();
  }

  /// Get analyses with specific urgency level
  Future<List<AiAnalysi>> getAnalysesByUrgencyLevel(String urgencyLevel) {
    return (select(aiAnalysis)
          ..where((a) => a.urgencyLevel.equals(urgencyLevel)))
        .get();
  }

  /// Get analyses with high confidence (> threshold)
  Future<List<AiAnalysi>> getHighConfidenceAnalyses({double threshold = 0.8}) {
    return (select(aiAnalysis)
          ..where((a) => a.confidenceScore.isBiggerOrEqualValue(threshold)))
        .get();
  }

  /// Get recent analyses (within last N seconds)
  Future<List<AiAnalysi>> getRecentAnalyses({int seconds = 3600}) {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final cutoff = now - seconds;
    return (select(aiAnalysis)
          ..where((a) => a.analysisTimestamp.isBiggerOrEqualValue(cutoff))
          ..orderBy([(a) => OrderingTerm.desc(a.analysisTimestamp)]))
        .get();
  }

  /// Delete old analyses (older than N days)
  Future<int> deleteOldAnalyses({int days = 30}) {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final cutoff = now - (days * 24 * 60 * 60);
    return (delete(aiAnalysis)
          ..where((a) => a.analysisTimestamp.isSmallerThanValue(cutoff)))
        .go();
  }

  /// Clear all analyses
  Future<int> clearAllAnalyses() {
    return delete(aiAnalysis).go();
  }

  /// Get analysis count
  Future<int> getAnalysisCount() async {
    final count = countAll();
    final query = selectOnly(aiAnalysis)..addColumns([count]);
    final result = await query.getSingle();
    return result.read(count) ?? 0;
  }

  /// Get analysis count by tone
  Future<Map<String, int>> getAnalysisCountByTone() async {
    final query = selectOnly(aiAnalysis)
      ..addColumns([aiAnalysis.tone, countAll()])
      ..groupBy([aiAnalysis.tone]);

    final results = await query.get();
    return Map.fromEntries(
      results.map((row) {
        final tone = row.read(aiAnalysis.tone) ?? 'Unknown';
        final count = row.read(countAll()) ?? 0;
        return MapEntry(tone, count);
      }),
    );
  }

  /// Stream of all analyses
  Stream<List<AiAnalysi>> watchAllAnalyses() {
    return select(aiAnalysis).watch();
  }

  /// Stream analysis for a specific message
  Stream<AiAnalysi?> watchAnalysisForMessage(String messageId) {
    return (select(aiAnalysis)..where((a) => a.messageId.equals(messageId)))
        .watchSingleOrNull();
  }
}
</file>

<file path="lib/data/drift/daos/conversation_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'conversation_dao.g.dart';

@DriftAccessor(tables: [Conversations])
class ConversationDao extends DatabaseAccessor<AppDb> with _$ConversationDaoMixin {
  ConversationDao(AppDb db) : super(db);

  /// Get all conversations ordered by last message
  Future<List<Conversation>> getAllConversations() async {
    final query = select(conversations)
      ..orderBy([(c) => OrderingTerm(expression: c.lastMessageAt, mode: OrderingMode.desc)]);
    return query.get();
  }

  /// Get conversation by ID
  Future<Conversation?> getConversationById(String id) async {
    return (select(conversations)..where((c) => c.id.equals(id)))
        .getSingleOrNull();
  }

  /// Insert or update conversation
  Future<void> upsertConversation(Conversation conversation) async {
    await into(conversations).insert(
      conversation,
      onConflict: DoUpdate((_) => conversation),
    );
  }

  /// Batch insert conversations
  Future<void> insertConversations(List<Conversation> convs) async {
    await batch((batch) {
      batch.insertAll(conversations, convs, mode: InsertMode.insertOrReplace);
    });
  }

  /// Delete conversation by ID
  Future<int> deleteConversation(String id) async {
    return (delete(conversations)..where((c) => c.id.equals(id))).go();
  }

  /// Update conversation sync status
  Future<void> markConversationAsSynced(String id) async {
    await (update(conversations)..where((c) => c.id.equals(id)))
        .write(const ConversationsCompanion(isSynced: Value(true)));
  }

  /// Get unsynced conversations
  Future<List<Conversation>> getUnsyncedConversations() async {
    return (select(conversations)..where((c) => c.isSynced.equals(false)))
        .get();
  }

  /// Update last message time
  Future<void> updateLastMessageTime(String conversationId) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    await (update(conversations)..where((c) => c.id.equals(conversationId)))
        .write(ConversationsCompanion(
          updatedAt: Value(now),
          lastMessageAt: Value(now),
        ));
  }

  /// Get recent conversations (for list)
  Future<List<Conversation>> getRecentConversations({int limit = 20}) async {
    return (select(conversations)
          ..orderBy([(c) => OrderingTerm(expression: c.lastMessageAt, mode: OrderingMode.desc)])
          ..limit(limit))
        .get();
  }

  /// Count total conversations
  Future<int> getConversationCount() async {
    final result = await select(conversations).get();
    return result.length;
  }
}
</file>

<file path="lib/data/drift/daos/message_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'message_dao.g.dart';

@DriftAccessor(tables: [Messages])
class MessageDao extends DatabaseAccessor<AppDb> with _$MessageDaoMixin {
  MessageDao(AppDb db) : super(db);

  /// Get all messages for a conversation ordered by creation time (oldest first)
  Future<List<Message>> getMessagesByConversation(String conversationId) async {
    final results = await (select(messages)
          ..where((m) => m.conversationId.equals(conversationId))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.asc)]))
        .get();
    
    // Debug: Print message order
    if (results.isNotEmpty) {
      print('📊 Messages loaded: ${results.length} total');
      final firstBody = results.first.body.length > 20 
          ? '${results.first.body.substring(0, 20)}...' 
          : results.first.body;
      final lastBody = results.last.body.length > 20 
          ? '${results.last.body.substring(0, 20)}...' 
          : results.last.body;
      print('   First message: "$firstBody" at timestamp ${results.first.createdAt}');
      print('   Last message: "$lastBody" at timestamp ${results.last.createdAt}');
    }
    
    return results;
  }

  /// Get recent messages for a conversation
  Future<List<Message>> getRecentMessages(String conversationId, {int limit = 50}) async {
    return (select(messages)
          ..where((m) => m.conversationId.equals(conversationId))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.desc)])
          ..limit(limit))
        .get();
  }

  /// Insert a new message
  Future<void> insertMessage(Message message) async {
    await into(messages).insert(message);
  }

  /// Update message sync status
  Future<void> markMessageAsSynced(String messageId) async {
    await (update(messages)..where((m) => m.id.equals(messageId)))
        .write(const MessagesCompanion(isSynced: Value(true)));
  }

  /// Get unsynced messages
  Future<List<Message>> getUnsyncedMessages() async {
    return (select(messages)..where((m) => m.isSynced.equals(false)))
        .get();
  }

  /// Delete message by ID
  Future<int> deleteMessage(String id) async {
    return (delete(messages)..where((m) => m.id.equals(id))).go();
  }

  /// Get message by ID
  Future<Message?> getMessageById(String id) async {
    return (select(messages)..where((m) => m.id.equals(id)))
        .getSingleOrNull();
  }

  /// Get the most recent message for a conversation
  Future<Message?> getLatestMessageForConversation(String conversationId) async {
    return (select(messages)
          ..where((m) => m.conversationId.equals(conversationId))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.desc)])
          ..limit(1))
        .getSingleOrNull();
  }

  /// Get unsynced message count
  Future<int> getUnsyncedMessageCount() async {
    final result = await (select(messages)..where((m) => m.isSynced.equals(false))).get();
    return result.length;
  }

  /// Search messages in a conversation
  Future<List<Message>> searchMessages(String conversationId, String query) async {
    return (select(messages)
          ..where((m) => m.conversationId.equals(conversationId) & m.body.contains(query))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.desc)]))
        .get();
  }

  /// Insert multiple messages
  Future<void> insertMessages(List<Message> messageList) async {
    await batch((batch) {
      batch.insertAll(messages, messageList);
    });
  }

  /// Upsert a message (insert or update)
  Future<void> upsertMessage(Message message) async {
    await into(messages).insertOnConflictUpdate(message);
  }
}
</file>

<file path="lib/data/drift/daos/participant_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'participant_dao.g.dart';

@DriftAccessor(tables: [Participants])
class ParticipantDao extends DatabaseAccessor<AppDb> with _$ParticipantDaoMixin {
  ParticipantDao(AppDb db) : super(db);

  /// Get all participants in a conversation
  Future<List<Participant>> getParticipantsByConversation(String conversationId) async {
    return (select(participants)
          ..where((p) => p.conversationId.equals(conversationId)))
        .get();
  }

  /// Get participant by ID
  Future<Participant?> getParticipantById(String id) async {
    return (select(participants)..where((p) => p.id.equals(id)))
        .getSingleOrNull();
  }

  /// Get participant by conversation ID and user ID
  Future<Participant?> getParticipant(String conversationId, String userId) async {
    return (select(participants)
          ..where((p) =>
              p.conversationId.equals(conversationId) & p.userId.equals(userId)))
        .getSingleOrNull();
  }

  /// Add participant to conversation (upsert to avoid duplicates)
  Future<void> addParticipant(Participant participant) async {
    await into(participants).insertOnConflictUpdate(participant);
  }

  /// Batch add participants
  Future<void> addParticipants(List<Participant> parts) async {
    await batch((batch) {
      batch.insertAll(participants, parts, mode: InsertMode.insertOrReplace);
    });
  }

  /// Remove participant from conversation
  Future<int> removeParticipant(String conversationId, String userId) async {
    return (delete(participants)
          ..where((p) =>
              p.conversationId.equals(conversationId) & p.userId.equals(userId)))
        .go();
  }

  /// Remove participant by ID
  Future<int> removeParticipantById(String id) async {
    return (delete(participants)..where((p) => p.id.equals(id))).go();
  }

  /// Remove all participants from conversation
  Future<int> removeConversationParticipants(String conversationId) async {
    return (delete(participants)..where((p) => p.conversationId.equals(conversationId)))
        .go();
  }

  /// Promote participant to admin
  Future<void> promoteToAdmin(String id) async {
    await (update(participants)..where((p) => p.id.equals(id)))
        .write(const ParticipantsCompanion(isAdmin: Value(true)));
  }

  /// Demote participant from admin
  Future<void> demoteFromAdmin(String id) async {
    await (update(participants)..where((p) => p.id.equals(id)))
        .write(const ParticipantsCompanion(isAdmin: Value(false)));
  }

  /// Get admin count for conversation
  Future<int> getAdminCount(String conversationId) async {
    final result = await (select(participants)
          ..where((p) =>
              p.conversationId.equals(conversationId) & p.isAdmin.equals(true)))
        .get();
    return result.length;
  }

  /// Get participant count for a conversation
  Future<int> getParticipantCount(String conversationId) async {
    final result = await (select(participants)
          ..where((p) => p.conversationId.equals(conversationId)))
        .get();
    return result.length;
  }

  /// Check if user is participant in conversation
  Future<bool> isParticipant(String conversationId, String userId) async {
    final participant = await getParticipant(conversationId, userId);
    return participant != null;
  }

  /// Check if user is admin in conversation
  Future<bool> isAdmin(String conversationId, String userId) async {
    final participant = await getParticipant(conversationId, userId);
    return participant?.isAdmin ?? false;
  }

  /// Mark participants as synced
  Future<void> markParticipantsAsSynced(List<String> ids) async {
    await batch((batch) {
      for (final id in ids) {
        batch.update(participants, const ParticipantsCompanion(isSynced: Value(true)),
            where: (p) => p.id.equals(id));
      }
    });
  }
}
</file>

<file path="lib/data/drift/daos/pending_outbox_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'pending_outbox_dao.g.dart';

@DriftAccessor(tables: [PendingOutbox])
class PendingOutboxDao extends DatabaseAccessor<AppDb> with _$PendingOutboxDaoMixin {
  PendingOutboxDao(AppDb db) : super(db);

  /// Get all pending operations
  Future<List<PendingOutboxData>> getAllPendingOperations() async {
    return (select(pendingOutbox)
          ..orderBy([(p) => OrderingTerm(expression: p.createdAt)]))
        .get();
  }

  /// Get pending operations for a specific conversation
  Future<List<PendingOutboxData>> getPendingOperationsByConversation(String conversationId) async {
    return (select(pendingOutbox)
          ..where((p) => p.conversationId.equals(conversationId))
          ..orderBy([(p) => OrderingTerm(expression: p.createdAt)]))
        .get();
  }

  /// Add operation to pending outbox
  Future<void> addPendingOperation({
    required String id,
    required String operation,
    required String payload,
    required String? conversationId,
  }) async {
    await into(pendingOutbox).insert(PendingOutboxCompanion(
      id: Value(id),
      operation: Value(operation),
      payload: Value(payload),
      conversationId: Value(conversationId),
      createdAt: Value(DateTime.now().millisecondsSinceEpoch ~/ 1000),
      retryCount: const Value(0),
    ));
  }

  /// Remove operation from pending outbox (after successful sync)
  Future<int> removePendingOperation(String id) async {
    return (delete(pendingOutbox)..where((p) => p.id.equals(id))).go();
  }

  /// Batch remove multiple operations
  Future<int> removePendingOperations(List<String> ids) async {
    return (delete(pendingOutbox)..where((p) => p.id.isIn(ids))).go();
  }

  /// Update retry count and last error
  Future<void> updateRetryInfo(String id, int retryCount, String? lastError) async {
    await (update(pendingOutbox)..where((p) => p.id.equals(id)))
        .write(PendingOutboxCompanion(
          retryCount: Value(retryCount),
          lastError: Value(lastError),
        ));
  }

  /// Get retryable operations (with retry count < max retries)
  Future<List<PendingOutboxData>> getRetryableOperations({int maxRetries = 3}) async {
    return (select(pendingOutbox)
          ..where((p) => p.retryCount.isSmallerThanValue(maxRetries)))
        .get();
  }

  /// Get oldest pending operation
  Future<PendingOutboxData?> getOldestPendingOperation() async {
    return (select(pendingOutbox)
          ..orderBy([(p) => OrderingTerm(expression: p.createdAt)])
          ..limit(1))
        .getSingleOrNull();
  }

  /// Get pending operations by type
  Future<List<PendingOutboxData>> getPendingOperationsByType(String operationType) async {
    return (select(pendingOutbox)
          ..where((p) => p.operation.equals(operationType)))
        .get();
  }

  /// Clean up old pending operations (older than cutoffTime)
  Future<int> cleanupOldOperations(int cutoffTime) async {
    return (delete(pendingOutbox)..where((p) => p.createdAt.isSmallerThanValue(cutoffTime))).go();
  }

  /// Get pending operations count
  Future<int> getPendingOperationCount() async {
    final result = await select(pendingOutbox).get();
    return result.length;
  }
}
</file>

<file path="lib/data/drift/daos/receipt_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'receipt_dao.g.dart';

@DriftAccessor(tables: [Receipts, Messages])
class ReceiptDao extends DatabaseAccessor<AppDb> with _$ReceiptDaoMixin {
  ReceiptDao(AppDb db) : super(db);

  /// Get all receipts for a message
  Future<List<Receipt>> getReceiptsByMessage(String messageId) async {
    return (select(receipts)
          ..where((r) => r.messageId.equals(messageId)))
        .get();
  }

  /// Get receipt by ID
  Future<Receipt?> getReceiptById(String id) async {
    return (select(receipts)..where((r) => r.id.equals(id)))
        .getSingleOrNull();
  }

  /// Get receipt by message ID and user ID
  Future<Receipt?> getReceipt(String messageId, String userId) async {
    return (select(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.userId.equals(userId)))
        .getSingleOrNull();
  }

  /// Add receipt
  Future<void> addReceipt(Receipt receipt) async {
    await into(receipts).insert(receipt);
  }

  /// Batch add receipts
  Future<void> addReceipts(List<Receipt> recs) async {
    await batch((batch) {
      batch.insertAll(receipts, recs, mode: InsertMode.insertOrReplace);
    });
  }

  /// Update receipt status
  Future<void> updateReceiptStatus(String messageId, String userId, String status) async {
    await (update(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.userId.equals(userId)))
        .write(ReceiptsCompanion(
          status: Value(status),
          updatedAt: Value(DateTime.now().millisecondsSinceEpoch ~/ 1000),
        ));
  }

  /// Mark receipt as synced
  Future<void> markReceiptAsSynced(String id) async {
    await (update(receipts)..where((r) => r.id.equals(id)))
        .write(const ReceiptsCompanion(isSynced: Value(true)));
  }

  /// Mark multiple receipts as synced
  Future<void> markReceiptsAsSynced(List<String> ids) async {
    await batch((batch) {
      for (final id in ids) {
        batch.update(receipts, const ReceiptsCompanion(isSynced: Value(true)),
            where: (r) => r.id.equals(id));
      }
    });
  }

  /// Delete receipt
  Future<int> deleteReceipt(String id) async {
    return (delete(receipts)..where((r) => r.id.equals(id))).go();
  }

  /// Get unsynced receipts
  Future<List<Receipt>> getUnsyncedReceipts() async {
    return (select(receipts)..where((r) => r.isSynced.equals(false)))
        .get();
  }

  /// Get read count for a message
  Future<int> getReadCount(String messageId) async {
    final countResult = await (select(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.status.equals('read')))
        .get();
    return countResult.length;
  }

  /// Get delivered count for a message
  Future<int> getDeliveredCount(String messageId) async {
    final countResult = await (select(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.status.equals('delivered')))
        .get();
    return countResult.length;
  }

  /// Get all receipts for messages in conversation
  Future<List<Receipt>> getReceiptsByConversation(String conversationId) async {
    return (select(receipts).join([
      innerJoin(messages, messages.id.equalsExp(receipts.messageId)),
    ])
      ..where(messages.conversationId.equals(conversationId)))
        .map((row) => row.readTable(receipts))
        .get();
  }

  /// Check if message is read by all participants
  Future<bool> isReadByAll(String messageId, int expectedCount) async {
    final readCount = await getReadCount(messageId);
    return readCount >= expectedCount;
  }

  /// Get unsynced receipt count
  Future<int> getUnsyncedReceiptCount() async {
    final countResult = await (select(receipts)
          ..where((r) => r.isSynced.equals(false)))
        .get();
    return countResult.length;
  }
}
</file>

<file path="lib/data/drift/entities/ai_analysis_cached.drift.backup">
-- AI Analysis table for local caching of tone and intent analysis
CREATE TABLE ai_analysis (
  id TEXT PRIMARY KEY NOT NULL,
  message_id TEXT NOT NULL,
  tone TEXT NOT NULL,
  urgency_level TEXT,
  intent TEXT,
  confidence_score REAL,
  analysis_timestamp INTEGER NOT NULL,
  is_synced INTEGER NOT NULL DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

-- Index for efficient lookups by message
CREATE INDEX IF NOT EXISTS idx_ai_analysis_message_id ON ai_analysis(message_id);

-- Index for timestamp queries
CREATE INDEX IF NOT EXISTS idx_ai_analysis_timestamp ON ai_analysis(analysis_timestamp DESC);
</file>

<file path="lib/data/drift/entities/conversation.drift">
CREATE TABLE conversations (
  id TEXT PRIMARY KEY NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  is_group BOOLEAN NOT NULL DEFAULT 0,
  last_message_at INTEGER,
  is_synced BOOLEAN NOT NULL DEFAULT 0
) AS Conversation;

CREATE TABLE messages (
  id TEXT PRIMARY KEY NOT NULL,
  conversation_id TEXT NOT NULL,
  sender_id TEXT NOT NULL,
  body TEXT NOT NULL,
  media_url TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  is_synced BOOLEAN NOT NULL DEFAULT 0,
  FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
) AS Message;

CREATE TABLE participants (
  id TEXT PRIMARY KEY NOT NULL,
  conversation_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  joined_at INTEGER NOT NULL,
  is_admin BOOLEAN NOT NULL DEFAULT 0,
  is_synced BOOLEAN NOT NULL DEFAULT 0,
  FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE,
  UNIQUE(conversation_id, user_id)
) AS Participant;

CREATE TABLE receipts (
  id TEXT PRIMARY KEY NOT NULL,
  message_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  status TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  is_synced BOOLEAN NOT NULL DEFAULT 0,
  FOREIGN KEY(message_id) REFERENCES messages(id) ON DELETE CASCADE,
  UNIQUE(message_id, user_id)
) AS Receipt;

CREATE TABLE pending_outbox (
  id TEXT PRIMARY KEY NOT NULL,
  operation TEXT NOT NULL,
  payload TEXT NOT NULL,
  conversation_id TEXT,
  created_at INTEGER NOT NULL,
  retry_count INTEGER NOT NULL DEFAULT 0,
  last_error TEXT,
  FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
) AS PendingOutboxItem;
</file>

<file path="lib/data/remote/supabase_client.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/core/env.dart';

/// Singleton Supabase client for the application.
/// 
/// Initialize with [initializeSupabase] before accessing the client.
class SupabaseClientProvider {
  static late final Supabase _instance;

  /// Get the initialized Supabase client instance
  static Supabase get instance => _instance;

  /// Get the Supabase client for convenience
  static SupabaseClient get client => _instance.client;

  /// Initialize the Supabase client with environment config
  static Future<void> initialize() async {
    Env.validate();
    
    _instance = await Supabase.initialize(
      url: Env.supabaseUrl,
      anonKey: Env.supabaseAnonKey,
      // Enable realtime
      // Note: The underlying realtime_client has heartbeat enabled by default (30s)
      realtimeClientOptions: const RealtimeClientOptions(
        eventsPerSecond: 10,
        logLevel: RealtimeLogLevel.info, // Enable logging for diagnostics
      ),
    );
  }
}
</file>

<file path="lib/data/repositories/group_repository.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/conversation_dao.dart';
import 'package:messageai/data/drift/daos/participant_dao.dart';
import 'package:uuid/uuid.dart';

/// Repository for group operations
class GroupRepository {
  final ConversationDao _conversationDao;
  final ParticipantDao _participantDao;

  GroupRepository({
    required ConversationDao conversationDao,
    required ParticipantDao participantDao,
  })  : _conversationDao = conversationDao,
        _participantDao = participantDao;

  /// Create a new group conversation
  Future<Conversation> createGroup({
    required String title,
    required String description,
    required String creatorId,
    required List<String> memberIds,
  }) async {
    const uuid = Uuid();
    final conversationId = uuid.v4();
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Create conversation
    final conversation = Conversation(
      id: conversationId,
      title: title,
      description: description,
      createdAt: now,
      updatedAt: now,
      isGroup: true,
      isSynced: false,
    );
    
    await _conversationDao.upsertConversation(conversation);
    
    // Add creator as admin
    final creatorParticipant = Participant(
      id: uuid.v4(),
      conversationId: conversationId,
      userId: creatorId,
      joinedAt: now,
      isAdmin: true,
      isSynced: false,
    );
    
    await _participantDao.addParticipant(creatorParticipant);
    
    // Add other members
    final participants = memberIds.map((userId) {
      return Participant(
        id: uuid.v4(),
        conversationId: conversationId,
        userId: userId,
        joinedAt: now,
        isAdmin: false,
        isSynced: false,
      );
    }).toList();
    
    await _participantDao.addParticipants(participants);
    
    return conversation;
  }

  /// Get group details with members
  Future<(Conversation, List<Participant>)> getGroupWithMembers(String groupId) async {
    final conversation = await _conversationDao.getConversationById(groupId);
    if (conversation == null) {
      throw Exception('Group not found: $groupId');
    }
    
    final participants = await _participantDao.getParticipantsByConversation(groupId);
    
    return (conversation, participants);
  }

  /// Update group info
  Future<void> updateGroupInfo({
    required String groupId,
    String? title,
    String? description,
  }) async {
    // This would require a Conversation update method in ConversationDao
    // For now, creating a placeholder
    // TODO: Implement in ConversationDao
  }

  /// Add member to group
  Future<void> addGroupMember({
    required String groupId,
    required String userId,
  }) async {
    const uuid = Uuid();
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Check if already a member
    final existing = await _participantDao.getParticipant(groupId, userId);
    if (existing != null) {
      throw Exception('User is already a member of this group');
    }
    
    final participant = Participant(
      id: uuid.v4(),
      conversationId: groupId,
      userId: userId,
      joinedAt: now,
      isAdmin: false,
      isSynced: false,
    );
    
    await _participantDao.addParticipant(participant);
  }

  /// Remove member from group
  Future<void> removeGroupMember({
    required String groupId,
    required String userId,
  }) async {
    await _participantDao.removeParticipant(groupId, userId);
  }

  /// Promote member to admin
  Future<void> promoteToAdmin({
    required String groupId,
    required String userId,
  }) async {
    final participant = await _participantDao.getParticipant(groupId, userId);
    if (participant == null) {
      throw Exception('Member not found in group');
    }
    
    await _participantDao.promoteToAdmin(participant.id);
  }

  /// Demote admin to member
  Future<void> demoteFromAdmin({
    required String groupId,
    required String userId,
  }) async {
    final participant = await _participantDao.getParticipant(groupId, userId);
    if (participant == null) {
      throw Exception('Member not found in group');
    }
    
    await _participantDao.demoteFromAdmin(participant.id);
  }

  /// Get user's groups
  Future<List<Conversation>> getUserGroups(String userId) async {
    final allConversations = await _conversationDao.getAllConversations();
    
    // Filter to only groups where user is a participant
    final userGroups = <Conversation>[];
    
    for (final conversation in allConversations) {
      if (conversation.isGroup) {
        final isParticipant = await _participantDao.isParticipant(
          conversation.id,
          userId,
        );
        if (isParticipant) {
          userGroups.add(conversation);
        }
      }
    }
    
    return userGroups;
  }

  /// Leave group
  Future<void> leaveGroup({
    required String groupId,
    required String userId,
  }) async {
    await _participantDao.removeParticipant(groupId, userId);
  }

  /// Delete group (admin only)
  Future<void> deleteGroup(String groupId) async {
    // Remove all participants
    await _participantDao.removeConversationParticipants(groupId);
    
    // Delete conversation
    await _conversationDao.deleteConversation(groupId);
  }

  /// Get group members count
  Future<int> getGroupMemberCount(String groupId) async {
    return _participantDao.getParticipantCount(groupId);
  }

  /// Check if user is group admin
  Future<bool> isUserGroupAdmin(String groupId, String userId) async {
    return _participantDao.isAdmin(groupId, userId);
  }
}
</file>

<file path="lib/data/repositories/message_repository.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/message_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';
import 'package:messageai/gen/api/clients/messages_api.dart';
import 'package:messageai/gen/api/models/message_payload.dart';

/// Repository for message operations combining API and local database
class MessageRepository {
  final MessagesApi _messagesApi;
  final MessageDao _messageDao;
  final PendingOutboxDao _outboxDao;

  MessageRepository({
    required MessagesApi messagesApi,
    required MessageDao messageDao,
    required PendingOutboxDao outboxDao,
  })  : _messagesApi = messagesApi,
        _messageDao = messageDao,
        _outboxDao = outboxDao;

  /// Send a message (optimistic - save locally first, sync later)
  Future<Message> sendMessage({
    required String id,
    required String conversationId,
    required String senderId,
    required String body,
    String? mediaUrl,
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Create message locally first (optimistic)
    final message = Message(
      id: id,
      conversationId: conversationId,
      senderId: senderId,
      body: body,
      mediaUrl: mediaUrl,
      createdAt: now,
      updatedAt: now,
      isSynced: false,
    );
    
    // Save to local DB
    await _messageDao.insertMessage(message);
    
    // Queue for sync
    await _outboxDao.addPendingOperation(
      id: '${id}_send',
      operation: 'send_message',
      payload: message.toJson().toString(),
      conversationId: conversationId,
    );
    
    return message;
  }

  /// Get messages for a conversation from local DB
  Future<List<Message>> getConversationMessages(String conversationId) async {
    return _messageDao.getMessagesByConversation(conversationId);
  }

  /// Get recent messages for a conversation (paginated)
  Future<List<Message>> getRecentMessages(String conversationId, {int limit = 50}) async {
    return _messageDao.getRecentMessages(conversationId, limit: limit);
  }

  /// Sync unsynced messages to server
  Future<void> syncUnsyncedMessages() async {
    final unsyncedMessages = await _messageDao.getUnsyncedMessages();
    
    for (final message in unsyncedMessages) {
      try {
        final payload = MessagePayload(
          id: message.id,
          conversationId: message.conversationId,
          body: message.body,
        );
        
        // Send to server
        await _messagesApi.send(payload);
        
        // Mark as synced locally
        await _messageDao.markMessageAsSynced(message.id);
        
        // Remove from outbox
        await _outboxDao.removePendingOperation('${message.id}_send');
      } catch (e) {
        // Log error and continue
        print('Error syncing message ${message.id}: $e');
      }
    }
  }

  /// Search messages in a conversation
  Future<List<Message>> searchMessages(String conversationId, String query) async {
    return _messageDao.searchMessages(conversationId, query);
  }

  /// Insert messages from server
  Future<void> insertServerMessages(List<Message> messages) async {
    await _messageDao.insertMessages(messages);
  }

  /// Update message from server
  Future<void> updateMessageFromServer(Message message) async {
    await _messageDao.upsertMessage(message);
  }

  /// Upsert message (helper)
  Future<void> upsertMessage(Message message) async {
    // This would be added to MessageDao
    await _messageDao.insertMessage(message);
  }

  /// Get pending message count (for UI)
  Future<int> getPendingMessageCount() async {
    return _messageDao.getUnsyncedMessageCount();
  }
}

extension on Message {
  Map<String, dynamic> toJson() => {
    'id': id,
    'conversation_id': conversationId,
    'sender_id': senderId,
    'body': body,
    'media_url': mediaUrl,
    'created_at': createdAt,
    'updated_at': updatedAt,
    'is_synced': isSynced,
  };
}
</file>

<file path="lib/data/repositories/receipt_repository.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';
import 'package:messageai/gen/api/clients/receipts_api.dart';
import 'package:messageai/gen/api/models/receipt_payload.dart';

/// Repository for receipt operations combining API and local database
class ReceiptRepository {
  final ReceiptsApi _receiptsApi;
  final ReceiptDao _receiptDao;
  final PendingOutboxDao _outboxDao;

  ReceiptRepository({
    required ReceiptsApi receiptsApi,
    required ReceiptDao receiptDao,
    required PendingOutboxDao outboxDao,
  })  : _receiptsApi = receiptsApi,
        _receiptDao = receiptDao,
        _outboxDao = outboxDao;

  /// Acknowledge message receipts (optimistic)
  Future<void> acknowledgeReceipts({
    required List<String> messageIds,
    required String status, // 'delivered' or 'read'
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Save receipts locally first
    final receipts = messageIds.map((msgId) {
      return Receipt(
        id: '${msgId}_${status}_$now',
        messageId: msgId,
        userId: '', // Would be current user ID
        status: status,
        createdAt: now,
        updatedAt: now,
        isSynced: false,
      );
    }).toList();
    
    await _receiptDao.addReceipts(receipts);
    
    // Queue for sync
    await _outboxDao.addPendingOperation(
      id: 'ack_${status}_$now',
      operation: 'ack_receipt',
      payload: ReceiptPayload(
        messageIds: messageIds,
        status: status == 'delivered' ? ReceiptStatus.delivered : ReceiptStatus.read,
      ).toJson().toString(),
      conversationId: null,
    );
  }

  /// Get receipts for a message
  Future<List<Receipt>> getMessageReceipts(String messageId) async {
    return _receiptDao.getReceiptsByMessage(messageId);
  }

  /// Get read count for a message
  Future<int> getReadCount(String messageId) async {
    return _receiptDao.getReadCount(messageId);
  }

  /// Get delivered count for a message
  Future<int> getDeliveredCount(String messageId) async {
    return _receiptDao.getDeliveredCount(messageId);
  }

  /// Check if message is read by all participants
  Future<bool> isReadByAll(String messageId, int participantCount) async {
    return _receiptDao.isReadByAll(messageId, participantCount);
  }

  /// Sync unsynced receipts to server
  Future<void> syncUnsyncedReceipts() async {
    final unsyncedReceipts = await _receiptDao.getUnsyncedReceipts();
    
    if (unsyncedReceipts.isEmpty) return;
    
    try {
      // Group by status
      final deliveredIds = unsyncedReceipts
          .where((r) => r.status == 'delivered')
          .map((r) => r.messageId)
          .toList();
      
      final readIds = unsyncedReceipts
          .where((r) => r.status == 'read')
          .map((r) => r.messageId)
          .toList();
      
      // Send to server
      if (deliveredIds.isNotEmpty) {
        final payload = ReceiptPayload(
          messageIds: deliveredIds,
          status: ReceiptStatus.delivered,
        );
        await _receiptsApi.ack(payload);
      }
      
      if (readIds.isNotEmpty) {
        final payload = ReceiptPayload(
          messageIds: readIds,
          status: ReceiptStatus.read,
        );
        await _receiptsApi.ack(payload);
      }
      
      // Mark as synced
      final allIds = unsyncedReceipts.map((r) => r.id).toList();
      await _receiptDao.markReceiptsAsSynced(allIds);
    } catch (e) {
      print('Error syncing receipts: $e');
    }
  }

  /// Insert receipts from server
  Future<void> insertServerReceipts(List<Receipt> receipts) async {
    await _receiptDao.addReceipts(receipts);
  }

  /// Get unsynced receipt count (for UI)
  Future<int> getUnsyncedReceiptCount() async {
    return _receiptDao.getUnsyncedReceiptCount();
  }
}

extension on ReceiptPayload {
  Map<String, dynamic> toJson() => {
    'message_ids': messageIds,
    'status': status.toValue(),
  };
}
</file>

<file path="lib/features/auth/screens/auth_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/auth_service.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_ui.dart';

/// Authentication screen for login/signup
class AuthScreen extends StatefulWidget {
  final VoidCallback onAuthSuccess;

  const AuthScreen({
    Key? key,
    required this.onAuthSuccess,
  }) : super(key: key);

  @override
  State<AuthScreen> createState() => _AuthScreenState();
}

class _AuthScreenState extends State<AuthScreen> with ErrorHandlerMixin {
  late TextEditingController _emailController;
  late TextEditingController _passwordController;
  bool _isLoading = false;
  bool _isSignUp = false;
  final _authService = AuthService();

  @override
  void initState() {
    super.initState();
    _emailController = TextEditingController();
    _passwordController = TextEditingController();
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _handleSignIn() async {
    if (_emailController.text.isEmpty || _passwordController.text.isEmpty) {
      ErrorUI.showErrorSnackbar(
        context,
        AppError(
          category: ErrorCategory.validation,
          severity: ErrorSeverity.warning,
          code: 'VAL001',
          message: 'Please enter email and password',
          userMessage: 'Please enter both email and password',
        ),
      );
      return;
    }

    setState(() => _isLoading = true);

    try {
      await _authService.signIn(
        email: _emailController.text.trim(),
        password: _passwordController.text,
      );

      if (mounted) {
        widget.onAuthSuccess();
      }
    } on AppError catch (error) {
      if (mounted) {
        showError(error, onRetry: _handleSignIn);
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  Future<void> _handleSignUp() async {
    // Validation
    if (_emailController.text.isEmpty || _passwordController.text.isEmpty) {
      ErrorUI.showErrorSnackbar(
        context,
        AppError(
          category: ErrorCategory.validation,
          severity: ErrorSeverity.warning,
          code: 'VAL001',
          message: 'Please enter email and password',
          userMessage: 'Please enter both email and password',
        ),
      );
      return;
    }

    if (!_isValidEmail(_emailController.text.trim())) {
      ErrorUI.showErrorSnackbar(
        context,
        AuthError.invalidEmail(),
      );
      return;
    }

    if (_passwordController.text.length < 6) {
      ErrorUI.showErrorSnackbar(
        context,
        AuthError.weakPassword(),
      );
      return;
    }

    setState(() => _isLoading = true);

    try {
      await _authService.signUp(
        email: _emailController.text.trim(),
        password: _passwordController.text,
      );

      if (mounted) {
        // Show success message
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 12),
                Text('Sign up successful! Signing you in...'),
              ],
            ),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
        
        // Auto sign in after signup
        await Future.delayed(const Duration(seconds: 1));
        if (mounted) {
          await _handleSignIn();
        }
      }
    } on AppError catch (error) {
      if (mounted) {
        showError(error, onRetry: _handleSignUp);
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  /// Validate email format
  bool _isValidEmail(String email) {
    final emailRegex = RegExp(
      r'^[a-zA-Z0-9.]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+',
    );
    return emailRegex.hasMatch(email);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('MessageAI'),
        centerTitle: true,
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.chat_bubble,
                size: 64,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(height: 24),
              Text(
                _isSignUp ? 'Create Account' : 'Welcome to MessageAI',
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32),
              TextField(
                controller: _emailController,
                enabled: !_isLoading,
                decoration: InputDecoration(
                  hintText: 'Email',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  prefixIcon: const Icon(Icons.email),
                ),
                keyboardType: TextInputType.emailAddress,
              ),
              const SizedBox(height: 16),
              TextField(
                controller: _passwordController,
                enabled: !_isLoading,
                decoration: InputDecoration(
                  hintText: 'Password',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  prefixIcon: const Icon(Icons.lock),
                ),
                obscureText: true,
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _isLoading
                      ? null
                      : (_isSignUp ? _handleSignUp : _handleSignIn),
                  child: _isLoading
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : Text(_isSignUp ? 'Sign Up' : 'Sign In'),
                ),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(_isSignUp
                      ? 'Already have an account? '
                      : "Don't have an account? "),
                  TextButton(
                    onPressed: _isLoading
                        ? null
                        : () {
                            setState(() {
                              _isSignUp = !_isSignUp;
                              // Clear any previous error messages when switching modes
                              ScaffoldMessenger.of(context).hideCurrentSnackBar();
                            });
                          },
                    child: Text(_isSignUp ? 'Sign In' : 'Sign Up'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/conversations/screens/conversations_list_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/conversation_service.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/features/messages/screens/message_screen.dart';
import 'package:messageai/features/settings/screens/settings_screen.dart';
import 'package:messageai/widgets/network_status_banner.dart';
import 'package:messageai/widgets/user_avatar.dart';

/// Screen showing list of conversations
class ConversationsListScreen extends StatefulWidget {
  const ConversationsListScreen({Key? key}) : super(key: key);

  @override
  State<ConversationsListScreen> createState() =>
      _ConversationsListScreenState();
}

class _ConversationsListScreenState extends State<ConversationsListScreen> {
  final _conversationService = ConversationService();
  late Future<List<Conversation>> _conversationsFuture;

  @override
  void initState() {
    super.initState();
    _conversationsFuture = _conversationService.getAllConversations();
  }
  
  // Add pull-to-refresh
  Future<void> _refreshConversations() async {
    setState(() {
      _conversationsFuture = _conversationService.getAllConversations(syncFirst: true);
    });
  }

  void _showNewConversationDialog() {
    final titleController = TextEditingController();
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('New Conversation'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: titleController,
              decoration: InputDecoration(
                hintText: 'Conversation title',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
              autofocus: true,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () async {
              if (titleController.text.isEmpty) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Please enter a title')),
                );
                return;
              }

              try {
                await _conversationService.createConversation(
                  title: titleController.text,
                );
                if (mounted) {
                  Navigator.pop(context);
                  setState(() {
                    // Don't re-sync from backend (keeps deleted convos deleted)
                    _conversationsFuture =
                        _conversationService.getAllConversations(syncFirst: false);
                  });
                }
              } catch (e) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Error: $e')),
                  );
                }
              }
            },
            child: const Text('Create'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('MessageAI'),
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.settings),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const SettingsScreen(),
                ),
              );
            },
            tooltip: 'Settings',
          ),
        ],
      ),
      body: Column(
        children: [
          const NetworkStatusBanner(),
          Expanded(
            child: RefreshIndicator(
              onRefresh: _refreshConversations,
              child: FutureBuilder<List<Conversation>>(
          future: _conversationsFuture,
          builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.error_outline,
                    size: 64,
                    color: Theme.of(context).colorScheme.error,
                  ),
                  const SizedBox(height: 16),
                  Text('Error: ${snapshot.error}'),
                ],
              ),
            );
          }

          final conversations = snapshot.data ?? [];

          if (conversations.isEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.chat_outlined,
                    size: 80,
                    color: Theme.of(context)
                        .colorScheme
                        .primary
                        .withOpacity(0.3),
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'No conversations yet',
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Start a new conversation to begin messaging',
                    style: Theme.of(context).textTheme.bodyMedium,
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 32),
                  ElevatedButton.icon(
                    onPressed: _showNewConversationDialog,
                    icon: const Icon(Icons.add),
                    label: const Text('New Conversation'),
                  ),
                ],
              ),
            );
          }

          return ListView.separated(
            itemCount: conversations.length,
            separatorBuilder: (context, index) => Divider(
              height: 1,
              indent: 72,
              color: Colors.grey[300],
            ),
            itemBuilder: (context, index) {
              final conv = conversations[index];
              return Dismissible(
                key: Key(conv.id),
                direction: DismissDirection.endToStart,
                background: Container(
                  alignment: Alignment.centerRight,
                  padding: const EdgeInsets.only(right: 20),
                  color: Colors.red,
                  child: const Icon(
                    Icons.delete,
                    color: Colors.white,
                  ),
                ),
                confirmDismiss: (direction) async {
                  return await showDialog(
                    context: context,
                    builder: (BuildContext context) {
                      return AlertDialog(
                        title: const Text('Delete Conversation'),
                        content: Text(
                          'Are you sure you want to delete "${conv.title}"? This cannot be undone.',
                        ),
                        actions: [
                          TextButton(
                            onPressed: () => Navigator.of(context).pop(false),
                            child: const Text('Cancel'),
                          ),
                          TextButton(
                            onPressed: () => Navigator.of(context).pop(true),
                            style: TextButton.styleFrom(
                              foregroundColor: Colors.red,
                            ),
                            child: const Text('Delete'),
                          ),
                        ],
                      );
                    },
                  );
                },
                onDismissed: (direction) async {
                  try {
                    await _conversationService.deleteConversation(conv.id);
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text('Deleted "${conv.title}"')),
                      );
                      setState(() {
                        // Refresh from local DB only (don't re-sync from backend)
                        _conversationsFuture = _conversationService.getAllConversations(syncFirst: false);
                      });
                    }
                  } catch (e) {
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text('Error deleting conversation: $e')),
                      );
                      setState(() {
                        // Re-sync to refresh the list
                        _conversationsFuture = _conversationService.getAllConversations(syncFirst: true);
                      });
                    }
                  }
                },
                child: InkWell(
                  onTap: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => MessageScreen(
                          conversationId: conv.id,
                          conversationTitle: conv.title,
                        ),
                      ),
                    );
                  },
                  child: Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                    child: Row(
                      children: [
                        UserAvatar(
                          fallbackText: conv.title,
                          radius: 28,
                          isGroup: conv.isGroup,
                          // Note: We don't have userId for conversation participant here
                          // In a full implementation, we'd fetch the other user's ID
                          // For now, fallback to initials
                        ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              conv.title,
                              style: const TextStyle(
                                fontSize: 16,
                                fontWeight: FontWeight.w600,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                            const SizedBox(height: 4),
                            FutureBuilder<Message?>(
                              future: _conversationService.getLatestMessage(conv.id),
                              builder: (context, snapshot) {
                                String previewText = 'Tap to start messaging';
                                
                                if (snapshot.hasData && snapshot.data != null) {
                                  final message = snapshot.data!;
                                  if (message.mediaUrl != null && message.mediaUrl!.isNotEmpty) {
                                    previewText = '📷 ${message.body}';
                                  } else {
                                    previewText = message.body;
                                  }
                                }
                                
                                return Text(
                                  previewText,
                                  style: TextStyle(
                                    fontSize: 14,
                                    color: Colors.grey[600],
                                  ),
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis,
                                );
                              },
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(width: 8),
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.end,
                        children: [
                          Text(
                            _formatTime(conv.lastMessageAt),
                            style: TextStyle(
                              fontSize: 12,
                              color: Theme.of(context).colorScheme.primary,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                ),
              );
            },
          );
          },
              ),
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _showNewConversationDialog,
        child: const Icon(Icons.add),
      ),
    );
  }

  String _formatTime(int? timestamp) {
    if (timestamp == null) return '';
    final dateTime = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inMinutes < 1) {
      return 'now';
    } else if (difference.inHours < 1) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inDays < 1) {
      return '${difference.inHours}h ago';
    } else if (difference.inDays < 7) {
      return '${difference.inDays}d ago';
    } else {
      return '${dateTime.month}/${dateTime.day}';
    }
  }
}
</file>

<file path="lib/features/conversations/widgets/message_bubble.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/features/messages/widgets/tone_detail_sheet.dart';
import 'package:messageai/state/ai_providers.dart';

/// Widget to display a single message with AI analysis
class MessageBubble extends ConsumerWidget {
  final Message message;
  final bool isSent;
  final bool isLoading;
  final VoidCallback? onRetry;

  const MessageBubble({
    Key? key,
    required this.message,
    required this.isSent,
    this.isLoading = false,
    this.onRetry,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    
    // Fetch AI analysis for this message
    final analysisAsync = ref.watch(messageAnalysisProvider(message.id));
    
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Row(
        mainAxisAlignment: isSent ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          if (!isSent)
            Padding(
              padding: const EdgeInsets.only(right: 8),
              child: CircleAvatar(
                radius: 16,
                backgroundColor: theme.colorScheme.primaryContainer,
                child: Text(
                  message.senderId.isNotEmpty 
                      ? message.senderId[0].toUpperCase() 
                      : 'U',
                  style: TextStyle(color: theme.colorScheme.onPrimaryContainer),
                ),
              ),
            ),
          Flexible(
            child: GestureDetector(
              onLongPress: isSent && !message.isSynced ? onRetry : null,
              child: Container(
                decoration: BoxDecoration(
                  color: isSent
                      ? theme.colorScheme.primary
                      : theme.colorScheme.surfaceVariant,
                  borderRadius: BorderRadius.circular(12),
                ),
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    if (message.mediaUrl != null && message.mediaUrl!.isNotEmpty)
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: Container(
                          width: 200,
                          height: 200,
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(8),
                            color: Colors.grey[300],
                          ),
                          child: Icon(
                            Icons.image,
                            size: 80,
                            color: Colors.grey[600],
                          ),
                        ),
                      ),
                    Text(
                      message.body,
                      style: TextStyle(
                        color: isSent ? Colors.white : theme.textTheme.bodyMedium?.color,
                        fontSize: 14,
                      ),
                    ),
                    Padding(
                      padding: const EdgeInsets.only(top: 4),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(
                            _formatTime(DateTime.fromMillisecondsSinceEpoch(
                              message.createdAt * 1000,
                            )),
                            style: TextStyle(
                              color: isSent 
                                  ? Colors.white70 
                                  : theme.textTheme.bodySmall?.color,
                              fontSize: 12,
                            ),
                          ),
                          if (isSent) ...[
                            const SizedBox(width: 4),
                            if (isLoading)
                              SizedBox(
                                width: 12,
                                height: 12,
                                child: CircularProgressIndicator(
                                  strokeWidth: 1.5,
                                  valueColor: AlwaysStoppedAnimation(
                                    Colors.white70,
                                  ),
                                ),
                              )
                            else if (message.isSynced)
                              Icon(
                                Icons.check_circle,
                                size: 12,
                                color: Colors.white70,
                              )
                            else
                              Icon(
                                Icons.schedule,
                                size: 12,
                                color: Colors.white70,
                              ),
                          ],
                        ],
                      ),
                    ),
                    // AI Analysis Badge (shows tone analysis if available)
                    analysisAsync.when(
                      data: (analysis) {
                        if (analysis == null) return const SizedBox.shrink();
                        return Padding(
                          padding: const EdgeInsets.only(top: 8),
                          child: ToneBadge(
                            analysis: analysis,
                            onTap: () => ToneDetailSheet.show(
                              context,
                              analysis,
                              message.body,
                            ),
                          ),
                        );
                      },
                      loading: () => const SizedBox.shrink(),
                      error: (_, __) => const SizedBox.shrink(),
                    ),
                  ],
                ),
              ),
            ),
          ),
          if (isSent)
            Padding(
              padding: const EdgeInsets.only(left: 8),
              child: CircleAvatar(
                radius: 16,
                backgroundColor: theme.colorScheme.primary,
                child: Icon(
                  Icons.person,
                  size: 12,
                  color: Colors.white,
                ),
              ),
            ),
        ],
      ),
    );
  }

  /// Format time for display
  String _formatTime(DateTime dateTime) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final yesterday = today.subtract(const Duration(days: 1));
    final messageDate = DateTime(dateTime.year, dateTime.month, dateTime.day);

    if (messageDate == today) {
      return '${dateTime.hour}:${dateTime.minute.toString().padLeft(2, '0')}';
    } else if (messageDate == yesterday) {
      return 'Yesterday';
    } else {
      return '${dateTime.month}/${dateTime.day}';
    }
  }
}
</file>

<file path="lib/features/messages/screens/message_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/message_service.dart';
import 'package:messageai/services/conversation_service.dart';
import 'package:messageai/services/presence_service.dart';
import 'package:messageai/services/realtime_message_service.dart';
import 'package:messageai/services/typing_indicator_service.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/widgets/user_avatar.dart';
import 'package:messageai/widgets/sliding_panel.dart';
import 'package:messageai/features/messages/widgets/message_list_panel.dart';
import 'package:messageai/features/messages/widgets/ai_insights_panel.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:image_picker/image_picker.dart';
import 'package:uuid/uuid.dart';
import 'dart:async';
import 'dart:io';

class MessageScreen extends StatefulWidget {
  final String conversationId;
  final String conversationTitle;

  const MessageScreen({
    Key? key,
    required this.conversationId,
    required this.conversationTitle,
  }) : super(key: key);

  @override
  State<MessageScreen> createState() => _MessageScreenState();
}

class _MessageScreenState extends State<MessageScreen> {
  final _messageService = MessageService();
  final _conversationService = ConversationService();
  final _presenceService = PresenceService();
  final _realtimeService = RealTimeMessageService();
  final _typingService = TypingIndicatorService();
  final _receiptDao = AppDb.instance.receiptDao;
  final _messageController = TextEditingController();
  final _imagePicker = ImagePicker();
  late Future<List<Message>> _messagesFuture;
  late Future<List<Participant>> _participantsFuture;
  bool _isSending = false;
  bool _isUploadingImage = false;
  String? _currentUserId;
  Map<String, List<Receipt>> _receiptsCache = {};
  Set<String> _typingUsers = {};
  Timer? _typingTimer;
  XFile? _selectedImage;
  Set<String> _onlineUsers = {};
  double _panelPosition = 0.8; // Track sliding panel position (0.0 = down, 1.0 = up)

  @override
  void initState() {
    super.initState();
    _currentUserId = _messageService.getCurrentUserId();
    
    // Sync messages from backend first, then load
    _messagesFuture = _messageService.getMessagesByConversation(
      widget.conversationId,
      syncFirst: true,
    );
    _participantsFuture = _conversationService.getParticipants(widget.conversationId);
    
    // Initialize real-time features
    _initializeRealtime();
    
    // Load receipts
    _loadReceipts();
    
    // Mark messages as read when opening conversation
    _messagesFuture.then((_) => _markMessagesAsRead());
    
    // Listen for text changes to send typing indicators
    _messageController.addListener(_onTextChanged);
  }

  Future<void> _loadReceipts() async {
    try {
      final receipts = await _receiptDao.getReceiptsByConversation(widget.conversationId);
      setState(() {
        _receiptsCache.clear();
        for (final receipt in receipts) {
          if (!_receiptsCache.containsKey(receipt.messageId)) {
            _receiptsCache[receipt.messageId] = [];
          }
          _receiptsCache[receipt.messageId]!.add(receipt);
        }
      });
    } catch (e) {
      print('Error loading receipts: $e');
    }
  }

  Future<void> _markMessagesAsRead() async {
    try {
      if (_currentUserId == null) return;
      
      // Get all messages
      final messages = await _messagesFuture;
      
      // Find unread messages from others
      for (final message in messages) {
        // Skip own messages
        if (message.senderId == _currentUserId) continue;
        
        // Check if we already have a read receipt
        final existingReceipts = _receiptsCache[message.id] ?? [];
        final hasReadReceipt = existingReceipts.any((r) => 
          r.userId == _currentUserId && r.status == 'read'
        );
        
        if (!hasReadReceipt) {
          await _createReadReceipt(message.id);
        }
      }
    } catch (e) {
      print('Error marking messages as read: $e');
    }
  }

  Future<void> _createReadReceipt(String messageId) async {
    try {
      if (_currentUserId == null) return;
      
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      
      // Check if receipt already exists
      final existingReceipt = await _receiptDao.getReceipt(messageId, _currentUserId!);
      
      if (existingReceipt != null) {
        // Update existing receipt to "read"
        await _receiptDao.updateReceiptStatus(messageId, _currentUserId!, 'read');
        
        // Sync to backend
        final supabase = SupabaseClientProvider.client;
        await supabase.from('message_receipts')
          .update({
            'status': 'read',
            'at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
          })
          .eq('message_id', messageId)
          .eq('user_id', _currentUserId!);
      } else {
        // Create new receipt
        final receiptId = const Uuid().v4();
        final receipt = Receipt(
          id: receiptId,
          messageId: messageId,
          userId: _currentUserId!,
          status: 'read',
          createdAt: now,
          updatedAt: now,
          isSynced: false,
        );
        
        await _receiptDao.addReceipt(receipt);
        
        final supabase = SupabaseClientProvider.client;
        await supabase.from('message_receipts').insert({
          'id': receiptId,
          'message_id': messageId,
          'user_id': _currentUserId,
          'status': 'read',
          'at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
        });
        
        await _receiptDao.markReceiptAsSynced(receiptId);
      }
    } catch (e) {
      print('Error creating read receipt: $e');
    }
  }

  Timer? _pollTimer;
  Timer? _presenceCheckTimer;

  Future<void> _initializeRealtime() async {
    try {
      // Subscribe to presence updates
      await _presenceService.subscribeToPresence(widget.conversationId);
      // Set current user as online
      await _presenceService.setPresenceStatus(widget.conversationId, true);
      
      // Poll presence status every 2 seconds to update UI
      _presenceCheckTimer = Timer.periodic(const Duration(seconds: 2), (timer) {
        if (mounted) {
          setState(() {
            _onlineUsers = _presenceService.getOnlineUsers(widget.conversationId);
          });
        }
      });
      
      // Subscribe to real-time messages
      _realtimeService.subscribeToMessages(widget.conversationId).listen((messages) {
        setState(() {
          _messagesFuture = Future.value(messages);
        });
        _loadReceipts();
        _markMessagesAsRead(); // Mark new messages as read
      });
      
      // Subscribe to real-time receipts
      _realtimeService.subscribeToReceipts(widget.conversationId).listen((receipts) {
        print('📬 Receipt update: ${receipts.length} total receipts');
        setState(() {
          _receiptsCache.clear();
          for (final receipt in receipts) {
            if (!_receiptsCache.containsKey(receipt.messageId)) {
              _receiptsCache[receipt.messageId] = [];
            }
            _receiptsCache[receipt.messageId]!.add(receipt);
            print('   - Message ${receipt.messageId.substring(0, 8)}: ${receipt.status} by ${receipt.userId.substring(0, 8)}');
          }
        });
      });
      
      // Subscribe to typing indicators
      _typingService.subscribeToTyping(widget.conversationId).listen((typingUserIds) {
        setState(() {
          _typingUsers = typingUserIds;
        });
      });
    } catch (e) {
      print('❌ Realtime init failed: $e');
    }
  }

  @override
  void dispose() {
    _messageController.removeListener(_onTextChanged);
    _messageController.dispose();
    _typingTimer?.cancel();
    _pollTimer?.cancel();
    _presenceCheckTimer?.cancel();
    // Set user as offline before leaving
    _presenceService.setPresenceStatus(widget.conversationId, false);
    // Clean up realtime subscriptions
    _presenceService.unsubscribeFromPresence(widget.conversationId);
    _realtimeService.unsubscribeFromMessages(widget.conversationId);
    _realtimeService.unsubscribeFromReceipts(widget.conversationId);
    _typingService.unsubscribeFromTyping(widget.conversationId);
    super.dispose();
  }

  void _onTextChanged() {
    if (_messageController.text.isNotEmpty) {
      // User is typing
      _typingService.sendTypingIndicator(widget.conversationId, true);
      
      // Reset the timer
      _typingTimer?.cancel();
      _typingTimer = Timer(const Duration(seconds: 2), () {
        // Stop typing after 2 seconds of inactivity
        _typingService.sendTypingIndicator(widget.conversationId, false);
      });
    } else {
      // User cleared text, stop typing
      _typingTimer?.cancel();
      _typingService.sendTypingIndicator(widget.conversationId, false);
    }
  }

  Future<void> _pickImage() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 1920,
        maxHeight: 1920,
        imageQuality: 85,
      );
      
      if (image != null) {
        setState(() {
          _selectedImage = image;
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error picking image: $e')),
        );
      }
    }
  }

  Future<String?> _uploadImage(XFile image) async {
    setState(() => _isUploadingImage = true);
    
    try {
      final userId = SupabaseClientProvider.client.auth.currentUser?.id;
      if (userId == null) throw Exception('User not authenticated');
      
      final fileBytes = await image.readAsBytes();
      final fileName = '${DateTime.now().millisecondsSinceEpoch}_${image.name}';
      final path = '$userId/$fileName';
      
      await SupabaseClientProvider.client.storage
          .from('media')
          .uploadBinary(path, fileBytes);
      
      final url = SupabaseClientProvider.client.storage
          .from('media')
          .getPublicUrl(path);
      
      return url;
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error uploading image: $e')),
        );
      }
      return null;
    } finally {
      if (mounted) {
        setState(() => _isUploadingImage = false);
      }
    }
  }

  Future<void> _sendMessage() async {
    final messageText = _messageController.text.trim();
    final hasText = messageText.isNotEmpty;
    final hasImage = _selectedImage != null;
    
    if (!hasText && !hasImage) return;
    if (_isSending || _isUploadingImage) return;

    // Clear input immediately for better UX
    _messageController.clear();
    final imageToSend = _selectedImage;
    setState(() {
      _selectedImage = null;
    });
    
    // Stop typing indicator when message is sent
    _typingTimer?.cancel();
    _typingService.sendTypingIndicator(widget.conversationId, false);

    setState(() => _isSending = true);

    try {
      String? mediaUrl;
      
      // Upload image if present
      if (imageToSend != null) {
        mediaUrl = await _uploadImage(imageToSend);
        if (mediaUrl == null) {
          throw Exception('Failed to upload image');
        }
      }
      
      await _messageService.sendMessage(
        conversationId: widget.conversationId,
        body: hasText ? messageText : '📷 Photo',
        mediaUrl: mediaUrl,
      );

      setState(() {
        _messagesFuture = _messageService.getMessagesByConversation(widget.conversationId);
      });
      
      // Reload receipts to update delivery status
      _loadReceipts();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
        _messageController.text = messageText;
        if (imageToSend != null) {
          setState(() {
            _selectedImage = imageToSend;
          });
        }
      }
    } finally {
      if (mounted) {
        setState(() => _isSending = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    return Scaffold(
      backgroundColor: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
      appBar: AppBar(
        title: Row(
          children: [
            Stack(
              children: [
                CircleAvatar(
                  radius: 18,
                  backgroundColor: Colors.grey[300],
                  child: Icon(
                    Icons.group,
                    size: 20,
                    color: Colors.grey[700],
                  ),
                ),
                if (_onlineUsers.isNotEmpty)
                  Positioned(
                    right: 0,
                    bottom: 0,
                    child: Container(
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(
                        color: Colors.green,
                        shape: BoxShape.circle,
                        border: Border.all(color: Colors.white, width: 2),
                      ),
                      child: Text(
                        '${_onlineUsers.length}',
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
              ],
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    widget.conversationTitle,
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  if (_onlineUsers.isNotEmpty)
                    Text(
                      '${_onlineUsers.length} online',
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.white.withOpacity(0.8),
                      ),
                    ),
                ],
              ),
            ),
          ],
        ),
        elevation: 1,
        actions: [
          IconButton(
            icon: const Icon(Icons.person_add),
            onPressed: _showAddParticipantsDialog,
            tooltip: 'Add participants',
          ),
          IconButton(
            icon: const Icon(Icons.more_vert),
            onPressed: () => _showParticipantsInfo(context),
            tooltip: 'Options',
          ),
        ],
      ),
      body: FutureBuilder<List<Message>>(
        future: _messagesFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(
              child: Text(
                'Error: ${snapshot.error}',
                style: theme.textTheme.bodyMedium,
              ),
            );
          }

          final messages = snapshot.data ?? [];

          return Stack(
            children: [
              // Background: AI Insights Panel
              AIInsightsPanel(
                conversationId: widget.conversationId,
                messages: messages,
                panelPosition: _panelPosition,
              ),
              
              // Foreground: Sliding Message Panel
              SlidingPanel(
                onSlide: (position) {
                  setState(() {
                    _panelPosition = position;
                  });
                },
                child: MessageListPanel(
                  messages: messages,
                  currentUserId: _currentUserId,
                  receiptsCache: _receiptsCache,
                  typingUsers: _typingUsers,
                  onlineUsers: _onlineUsers,
                  messageController: _messageController,
                  isSending: _isSending,
                  isUploadingImage: _isUploadingImage,
                  selectedImage: _selectedImage,
                  onSendMessage: _sendMessage,
                  onPickImage: _pickImage,
                  onClearImage: () {
                    setState(() {
                      _selectedImage = null;
                    });
                  },
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  void _showAddParticipantsDialog() {
    final emailController = TextEditingController();
    bool isSearching = false;
    
    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: const Text('Add Participant'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                controller: emailController,
                decoration: InputDecoration(
                  hintText: 'Enter email address',
                  helperText: 'Example: user@example.com',
                  prefixIcon: const Icon(Icons.email),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
                keyboardType: TextInputType.emailAddress,
                autofocus: true,
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: isSearching ? null : () async {
                final email = emailController.text.trim();
                if (email.isEmpty) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Please enter an email')),
                  );
                  return;
                }

                setState(() => isSearching = true);

                try {
                  // Add participant by email using database function
                  final response = await SupabaseClientProvider.client
                      .rpc('add_participant_by_email', params: {
                    'p_conversation_id': widget.conversationId,
                    'p_email': email,
                  });

                  final result = response as Map<String, dynamic>;
                  
                  if (result['success'] == false) {
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text(result['error'] ?? 'Failed to add participant')),
                      );
                    }
                    setState(() => isSearching = false);
                    return;
                  }
                  
                  if (mounted) {
                    Navigator.pop(context);
                    // Force refresh participants from backend
                    this.setState(() {
                      _participantsFuture = _conversationService.getParticipants(
                        widget.conversationId, 
                        syncFirst: true,  // Force sync from backend
                      );
                    });
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Added $email to conversation')),
                    );
                  }
                } catch (e) {
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Error: $e')),
                    );
                  }
                  setState(() => isSearching = false);
                }
              },
              child: isSearching 
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Text('Add'),
            ),
          ],
        ),
      ),
    );
  }

  void _showParticipantsInfo(BuildContext context) {
    showModalBottomSheet(
      context: context,
      builder: (context) => FutureBuilder<List<Participant>>(
        future: _participantsFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(child: Text('Error: ${snapshot.error}'));
          }

          final participants = snapshot.data ?? [];

          return SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Participants (${participants.length})',
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                  const SizedBox(height: 16),
                  if (participants.isEmpty)
                    const Center(
                      child: Padding(
                        padding: EdgeInsets.all(16),
                        child: Text('No participants yet'),
                      ),
                    )
                  else
                    ListView.builder(
                      shrinkWrap: true,
                      physics: const NeverScrollableScrollPhysics(),
                      itemCount: participants.length,
                      itemBuilder: (context, index) {
                        final participant = participants[index];
                        final isOnline = _presenceService.isUserOnline(
                          widget.conversationId,
                          participant.userId,
                        );
                        
                        return FutureBuilder<Map<String, dynamic>?>(
                          future: _conversationService.getParticipantProfile(participant.userId),
                          builder: (context, profileSnapshot) {
                            final profile = profileSnapshot.data;
                            final displayName = profile?['email'] as String? ?? 
                                              profile?['username'] as String? ?? 
                                              profile?['display_name'] as String? ??
                                              participant.userId.substring(0, 8);
                            final avatarUrl = profile?['avatar_url'] as String?;
                            final initial = displayName.isNotEmpty 
                                ? displayName[0].toUpperCase() 
                                : 'U';
                            
                            return ListTile(
                              leading: Stack(
                                children: [
                                  CircleAvatar(
                                    backgroundImage: avatarUrl != null
                                        ? NetworkImage(avatarUrl)
                                        : null,
                                    child: avatarUrl == null
                                        ? Text(initial)
                                        : null,
                                  ),
                                  Positioned(
                                    right: 0,
                                    bottom: 0,
                                    child: Container(
                                      width: 12,
                                      height: 12,
                                      decoration: BoxDecoration(
                                        color: isOnline ? Colors.green : Colors.grey,
                                        shape: BoxShape.circle,
                                        border: Border.all(
                                          color: Colors.white,
                                          width: 2,
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                              title: Text(displayName),
                              subtitle: Text(
                                isOnline
                                    ? (participant.isAdmin ? 'Admin • Online' : 'Member • Online')
                                    : (participant.isAdmin ? 'Admin • Offline' : 'Member • Offline'),
                              ),
                              trailing: participant.userId != _currentUserId
                                  ? IconButton(
                                      icon: const Icon(Icons.remove_circle),
                                      onPressed: () {
                                        Navigator.pop(context);
                                        _removeParticipant(participant.userId);
                                      },
                                    )
                                  : null,
                            );
                          },
                        );
                      },
                    ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Future<void> _removeParticipant(String userId) async {
    try {
      await _conversationService.removeParticipant(
        widget.conversationId,
        userId,
      );
      setState(() {
        _participantsFuture = _conversationService.getParticipants(widget.conversationId);
      });
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Participant removed')),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    }
  }

}
</file>

<file path="lib/features/messages/widgets/ai_insights_background.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';

/// Background panel for AI insights that appears behind the sliding message panel
/// Users can swipe down the message panel to reveal this content
class AIInsightsBackground extends StatelessWidget {
  final String conversationId;
  final double panelPosition;

  const AIInsightsBackground({
    Key? key,
    required this.conversationId,
    this.panelPosition = 0.0,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    // Calculate opacity based on panel position
    // When panel is fully up (position = 1.0), fade out insights
    // When panel is down (position = 0.0), show insights fully
    final opacity = 1.0 - panelPosition;
    
    return Container(
      color: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
      padding: const EdgeInsets.all(AppTheme.spacingL),
      child: SafeArea(
        child: Opacity(
          opacity: opacity.clamp(0.3, 1.0), // Keep minimum visibility
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  Icon(
                    Icons.auto_awesome,
                    size: 28,
                    color: isDark ? AppTheme.white : AppTheme.black,
                  ),
                  const SizedBox(width: AppTheme.spacingS),
                  Text(
                    'AI Insights',
                    style: theme.textTheme.displaySmall?.copyWith(
                      fontWeight: AppTheme.fontWeightBold,
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: AppTheme.spacingXL),
              
              // Placeholder content
              _buildPlaceholderCard(
                context,
                icon: Icons.insights,
                title: 'Tone Analysis',
                description: 'Pull down to see how messages are being interpreted',
                isDark: isDark,
              ),
              
              const SizedBox(height: AppTheme.spacingM),
              
              _buildPlaceholderCard(
                context,
                icon: Icons.lightbulb_outline,
                title: 'Smart Suggestions',
                description: 'AI-powered response recommendations coming soon',
                isDark: isDark,
              ),
              
              const SizedBox(height: AppTheme.spacingM),
              
              _buildPlaceholderCard(
                context,
                icon: Icons.analytics_outlined,
                title: 'Conversation Health',
                description: 'Monitor communication patterns and insights',
                isDark: isDark,
              ),
              
              const Spacer(),
              
              // Hint text
              Center(
                child: Column(
                  children: [
                    Icon(
                      Icons.keyboard_arrow_down,
                      size: 32,
                      color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                    ),
                    const SizedBox(height: AppTheme.spacingXS),
                    Text(
                      'Pull down messages to view insights',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: isDark ? AppTheme.gray600 : AppTheme.gray500,
                      ),
                    ),
                  ],
                ),
              ),
              
              const SizedBox(height: AppTheme.spacingXXL),
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildPlaceholderCard(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String description,
    required bool isDark,
  }) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingS),
            decoration: BoxDecoration(
              color: isDark 
                ? AppTheme.darkGray300 
                : AppTheme.gray100,
              borderRadius: BorderRadius.circular(AppTheme.radiusS),
            ),
            child: Icon(
              icon,
              size: 24,
              color: isDark ? AppTheme.white : AppTheme.black,
            ),
          ),
          const SizedBox(width: AppTheme.spacingM),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: theme.textTheme.labelLarge?.copyWith(
                    fontWeight: AppTheme.fontWeightSemibold,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  description,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/messages/widgets/ai_insights_panel.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/state/ai_providers.dart';

/// Enhanced AI insights panel that displays conversation-level analysis
/// Replaces the placeholder background when user pulls down the message panel
class AIInsightsPanel extends ConsumerWidget {
  final String conversationId;
  final List<Message> messages;
  final double panelPosition;

  const AIInsightsPanel({
    Key? key,
    required this.conversationId,
    required this.messages,
    this.panelPosition = 0.0,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    // Calculate opacity based on panel position
    final opacity = 1.0 - panelPosition;
    
    // Fetch analyses for the conversation
    final analysisAsync = ref.watch(
      conversationAnalysisProvider(conversationId),
    );

    return Container(
      color: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
      padding: const EdgeInsets.all(AppTheme.spacingL),
      child: SafeArea(
        child: Opacity(
          opacity: opacity.clamp(0.3, 1.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  Icon(
                    Icons.auto_awesome,
                    size: 28,
                    color: isDark ? AppTheme.white : AppTheme.black,
                  ),
                  const SizedBox(width: AppTheme.spacingS),
                  Text(
                    'AI Insights',
                    style: theme.textTheme.displaySmall?.copyWith(
                      fontWeight: AppTheme.fontWeightBold,
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: AppTheme.spacingXL),
              
              // Analysis content
              Expanded(
                child: analysisAsync.when(
                  data: (analyses) {
                    if (analyses.isEmpty) {
                      return _buildEmptyState(context, isDark);
                    }
                    return _buildAnalysisCards(context, analyses, isDark);
                  },
                  loading: () => _buildLoadingState(context, isDark),
                  error: (error, stack) => _buildErrorState(context, error, isDark),
                ),
              ),
              
              // Hint text
              if (panelPosition > 0.5)
                Center(
                  child: Column(
                    children: [
                      Icon(
                        Icons.keyboard_arrow_down,
                        size: 32,
                        color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                      ),
                      const SizedBox(height: AppTheme.spacingXS),
                      Text(
                        'Pull down to view insights',
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: isDark ? AppTheme.gray600 : AppTheme.gray500,
                        ),
                      ),
                    ],
                  ),
                ),
              
              const SizedBox(height: AppTheme.spacingL),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildAnalysisCards(
    BuildContext context,
    Map<String, AIAnalysis> analyses,
    bool isDark,
  ) {
    final theme = Theme.of(context);
    
    // Calculate summary statistics
    final toneDistribution = <String, int>{};
    int urgentCount = 0;
    double avgConfidence = 0.0;
    
    for (final analysis in analyses.values) {
      toneDistribution[analysis.tone] = (toneDistribution[analysis.tone] ?? 0) + 1;
      if (analysis.urgencyLevel == 'High' || analysis.urgencyLevel == 'Critical') {
        urgentCount++;
      }
      avgConfidence += analysis.confidenceScore ?? 0.0;
    }
    
    if (analyses.isNotEmpty) {
      avgConfidence /= analyses.length;
    }
    
    final mostCommonTone = toneDistribution.entries
        .reduce((a, b) => a.value > b.value ? a : b)
        .key;

    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Overall tone card
          _buildInsightCard(
            context,
            icon: Icons.psychology,
            title: 'Overall Tone',
            value: mostCommonTone,
            description: '${analyses.length} messages analyzed',
            color: AppTheme.accentBlue,
            isDark: isDark,
          ),
          
          const SizedBox(height: AppTheme.spacingM),
          
          // Urgency indicator card
          if (urgentCount > 0)
            _buildInsightCard(
              context,
              icon: Icons.warning_amber,
              title: 'Urgent Messages',
              value: urgentCount.toString(),
              description: 'Requires attention',
              color: AppTheme.accentOrange,
              isDark: isDark,
            ),
          
          if (urgentCount > 0) const SizedBox(height: AppTheme.spacingM),
          
          // Confidence indicator
          _buildInsightCard(
            context,
            icon: Icons.thumb_up_outlined,
            title: 'Analysis Quality',
            value: '${(avgConfidence * 100).round()}%',
            description: 'Average confidence',
            color: avgConfidence > 0.8
                ? AppTheme.accentGreen
                : avgConfidence > 0.6
                    ? AppTheme.accentBlue
                    : AppTheme.accentOrange,
            isDark: isDark,
          ),
          
          const SizedBox(height: AppTheme.spacingM),
          
          // Recent analysis
          if (analyses.isNotEmpty) ...[
            Text(
              'Recent Analysis',
              style: theme.textTheme.labelLarge?.copyWith(
                fontWeight: AppTheme.fontWeightBold,
              ),
            ),
            const SizedBox(height: AppTheme.spacingS),
            ...analyses.entries.take(3).map(
              (entry) => Padding(
                padding: const EdgeInsets.only(bottom: AppTheme.spacingS),
                child: _buildRecentAnalysisItem(
                  context,
                  entry.value,
                  isDark,
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildInsightCard(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String value,
    required String description,
    required Color color,
    required bool isDark,
  }) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingM),
            decoration: BoxDecoration(
              color: color.withOpacity(0.1),
              borderRadius: BorderRadius.circular(AppTheme.radiusS),
            ),
            child: Icon(
              icon,
              size: 24,
              color: color,
            ),
          ),
          const SizedBox(width: AppTheme.spacingM),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  value,
                  style: theme.textTheme.displaySmall?.copyWith(
                    fontWeight: AppTheme.fontWeightBold,
                    color: color,
                  ),
                ),
                Text(
                  description,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray600 : AppTheme.gray500,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildRecentAnalysisItem(
    BuildContext context,
    AIAnalysis analysis,
    bool isDark,
  ) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingS),
      decoration: BoxDecoration(
        color: (isDark ? AppTheme.darkGray100 : AppTheme.white).withOpacity(0.5),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(
          color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Text(
            _getToneEmoji(analysis.tone),
            style: const TextStyle(fontSize: 20),
          ),
          const SizedBox(width: AppTheme.spacingS),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  analysis.tone,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    fontWeight: AppTheme.fontWeightSemibold,
                  ),
                ),
                if (analysis.intent != null)
                  Text(
                    analysis.intent!,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: isDark ? AppTheme.gray600 : AppTheme.gray500,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyState(BuildContext context, bool isDark) {
    final theme = Theme.of(context);
    
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.auto_awesome_outlined,
            size: 64,
            color: isDark ? AppTheme.gray600 : AppTheme.gray400,
          ),
          const SizedBox(height: AppTheme.spacingM),
          Text(
            'No AI analysis yet',
            style: theme.textTheme.titleLarge?.copyWith(
              fontWeight: AppTheme.fontWeightSemibold,
            ),
          ),
          const SizedBox(height: AppTheme.spacingS),
          Text(
            'Send messages to see AI-powered insights',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: isDark ? AppTheme.gray500 : AppTheme.gray600,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildLoadingState(BuildContext context, bool isDark) {
    return const Center(
      child: CircularProgressIndicator(),
    );
  }

  Widget _buildErrorState(BuildContext context, Object error, bool isDark) {
    final theme = Theme.of(context);
    
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.error_outline,
            size: 64,
            color: AppTheme.accentRed,
          ),
          const SizedBox(height: AppTheme.spacingM),
          Text(
            'Error loading insights',
            style: theme.textTheme.titleLarge,
          ),
          const SizedBox(height: AppTheme.spacingS),
          Text(
            error.toString(),
            style: theme.textTheme.bodySmall,
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  String _getToneEmoji(String tone) {
    switch (tone.toLowerCase()) {
      case 'friendly':
        return '😊';
      case 'professional':
        return '💼';
      case 'urgent':
        return '⚡';
      case 'casual':
        return '😎';
      case 'formal':
        return '👔';
      case 'concerned':
        return '😟';
      case 'excited':
        return '🎉';
      case 'neutral':
      default:
        return '💬';
    }
  }
}
</file>

<file path="lib/features/messages/widgets/message_list_panel.dart">
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/features/messages/widgets/tone_detail_sheet.dart';
import 'package:messageai/state/ai_providers.dart';
import 'package:messageai/widgets/user_avatar.dart';

/// Panel containing the message list and compose bar
/// This widget slides up and down over the AI insights background
class MessageListPanel extends ConsumerWidget {
  final List<Message> messages;
  final String? currentUserId;
  final Map<String, List<Receipt>> receiptsCache;
  final Set<String> typingUsers;
  final Set<String> onlineUsers;
  final TextEditingController messageController;
  final bool isSending;
  final bool isUploadingImage;
  final XFile? selectedImage;
  final VoidCallback onSendMessage;
  final VoidCallback onPickImage;
  final VoidCallback onClearImage;

  const MessageListPanel({
    Key? key,
    required this.messages,
    required this.currentUserId,
    required this.receiptsCache,
    required this.typingUsers,
    required this.onlineUsers,
    required this.messageController,
    required this.isSending,
    required this.isUploadingImage,
    required this.selectedImage,
    required this.onSendMessage,
    required this.onPickImage,
    required this.onClearImage,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    return Column(
      children: [
        // Message list
        Expanded(
          child: messages.isEmpty
              ? Center(
                  child: Text(
                    'No messages yet. Start the conversation!',
                    style: theme.textTheme.bodyMedium,
                  ),
                )
              : ListView.builder(
                  reverse: true,
                  padding: const EdgeInsets.symmetric(
                    vertical: AppTheme.spacingS,
                    horizontal: AppTheme.spacingXS,
                  ),
                  itemCount: messages.length + (typingUsers.isNotEmpty ? 1 : 0),
                  itemBuilder: (context, index) {
                    // Show typing indicator as first item (at bottom)
                    if (index == 0 && typingUsers.isNotEmpty) {
                      return _buildTypingIndicator(context, isDark);
                    }
                    
                    // Adjust index if typing indicator is showing
                    final messageIndex = typingUsers.isNotEmpty ? index - 1 : index;
                    final message = messages[messages.length - 1 - messageIndex];
                    final isOwn = message.senderId == currentUserId;
                    final isOnline = onlineUsers.contains(message.senderId);

                    return _buildMessageBubble(
                      context,
                      ref,
                      message,
                      isOwn,
                      isOnline,
                      isDark,
                    );
                  },
                ),
        ),
        
        // Compose bar
        _buildComposeBar(context, isDark),
      ],
    );
  }
  
  Widget _buildMessageBubble(
    BuildContext context,
    WidgetRef ref,
    Message message,
    bool isOwn,
    bool isOnline,
    bool isDark,
  ) {
    // Fetch AI analysis for this message
    final analysisAsync = ref.watch(messageAnalysisProvider(message.id));
    return Align(
      alignment: isOwn ? Alignment.centerRight : Alignment.centerLeft,
      child: Row(
        mainAxisAlignment: isOwn ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          // Show avatar for other users' messages (left side)
          if (!isOwn) ...[
            Padding(
              padding: const EdgeInsets.only(
                left: AppTheme.spacingS,
                right: AppTheme.spacingXXS,
                bottom: AppTheme.spacingXXS,
              ),
              child: Stack(
                children: [
                  UserAvatar(
                    userId: message.senderId,
                    fallbackText: message.senderId.substring(0, 1).toUpperCase(),
                    radius: 16,
                  ),
                  Positioned(
                    right: 0,
                    bottom: 0,
                    child: Container(
                      width: 12,
                      height: 12,
                      decoration: BoxDecoration(
                        color: isOnline ? AppTheme.accentGreen : AppTheme.gray500,
                        shape: BoxShape.circle,
                        border: Border.all(
                          color: isDark ? AppTheme.black : AppTheme.white,
                          width: 2,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
          
          // Message bubble
          Container(
            constraints: BoxConstraints(
              maxWidth: MediaQuery.of(context).size.width * 0.65,
            ),
            margin: EdgeInsets.only(
              left: isOwn ? 64 : 0,
              right: isOwn ? AppTheme.spacingS : 64,
              top: AppTheme.spacingXXS,
              bottom: AppTheme.spacingXXS,
            ),
            padding: const EdgeInsets.symmetric(
              horizontal: AppTheme.spacingS,
              vertical: AppTheme.spacingS,
            ),
            decoration: BoxDecoration(
              color: isOwn
                  ? (isDark ? AppTheme.darkGray300 : AppTheme.gray200)
                  : (isDark ? AppTheme.darkGray100 : AppTheme.white),
              borderRadius: BorderRadius.only(
                topLeft: const Radius.circular(AppTheme.radiusXL),
                topRight: const Radius.circular(AppTheme.radiusXL),
                bottomLeft: Radius.circular(isOwn ? AppTheme.radiusXL : AppTheme.radiusXS),
                bottomRight: Radius.circular(isOwn ? AppTheme.radiusXS : AppTheme.radiusXL),
              ),
              border: !isOwn
                  ? Border.all(
                      color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                      width: 1,
                    )
                  : null,
            ),
            child: Column(
              crossAxisAlignment: isOwn ? CrossAxisAlignment.end : CrossAxisAlignment.start,
              children: [
                // Show image if present
                if (message.mediaUrl != null && message.mediaUrl!.isNotEmpty) ...[
                  ClipRRect(
                    borderRadius: BorderRadius.circular(AppTheme.radiusS),
                    child: Image.network(
                      message.mediaUrl!,
                      width: 250,
                      fit: BoxFit.cover,
                      loadingBuilder: (context, child, loadingProgress) {
                        if (loadingProgress == null) return child;
                        return Container(
                          width: 250,
                          height: 250,
                          color: isDark ? AppTheme.darkGray200 : AppTheme.gray200,
                          child: Center(
                            child: CircularProgressIndicator(
                              value: loadingProgress.expectedTotalBytes != null
                                  ? loadingProgress.cumulativeBytesLoaded /
                                      loadingProgress.expectedTotalBytes!
                                  : null,
                            ),
                          ),
                        );
                      },
                      errorBuilder: (context, error, stackTrace) {
                        return Container(
                          width: 250,
                          height: 250,
                          color: isDark ? AppTheme.darkGray200 : AppTheme.gray200,
                          child: const Icon(Icons.broken_image, size: 50),
                        );
                      },
                    ),
                  ),
                  const SizedBox(height: AppTheme.spacingXXS),
                ],
                
                // Message text
                Text(
                  message.body,
                  style: TextStyle(
                    color: isDark ? AppTheme.white : AppTheme.black,
                    fontSize: AppTheme.fontSizeM,
                    height: AppTheme.lineHeightNormal,
                  ),
                ),
                
                const SizedBox(height: AppTheme.spacingXXS),
                
                // Timestamp and delivery indicator
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      _formatTime(message.createdAt),
                      style: TextStyle(
                        fontSize: AppTheme.fontSizeXS,
                        color: isDark ? AppTheme.gray600 : AppTheme.gray600,
                      ),
                    ),
                    if (isOwn) ...[
                      const SizedBox(width: AppTheme.spacingXXS),
                      _buildDeliveryIndicator(message),
                    ],
                  ],
                ),
                
                // AI Analysis Badge (shows tone analysis if available)
                analysisAsync.when(
                  data: (analysis) {
                    if (analysis == null) return const SizedBox.shrink();
                    return Padding(
                      padding: const EdgeInsets.only(top: 8),
                      child: ToneBadge(
                        analysis: analysis,
                        onTap: () => ToneDetailSheet.show(
                          context,
                          analysis,
                          message.body,
                        ),
                      ),
                    );
                  },
                  loading: () => const SizedBox.shrink(),
                  error: (_, __) => const SizedBox.shrink(),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildTypingIndicator(BuildContext context, bool isDark) {
    final count = typingUsers.length;
    final text = count == 1 
        ? 'Someone is typing...' 
        : '$count people are typing...';
    
    return Padding(
      padding: const EdgeInsets.symmetric(
        horizontal: AppTheme.spacingM,
        vertical: AppTheme.spacingS,
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.symmetric(
              horizontal: AppTheme.spacingS,
              vertical: AppTheme.spacingS,
            ),
            decoration: BoxDecoration(
              color: isDark ? AppTheme.darkGray100 : AppTheme.white,
              borderRadius: BorderRadius.circular(AppTheme.radiusM),
              border: Border.all(
                color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                width: 1,
              ),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  text,
                  style: TextStyle(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                    fontSize: AppTheme.fontSizeS,
                    fontStyle: FontStyle.italic,
                  ),
                ),
                const SizedBox(width: AppTheme.spacingS),
                SizedBox(
                  width: 20,
                  height: 20,
                  child: _TypingAnimation(isDark: isDark),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildComposeBar(BuildContext context, bool isDark) {
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingS),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        border: Border(
          top: BorderSide(
            color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
            width: 1,
          ),
        ),
      ),
      child: SafeArea(
        top: false,
        child: Column(
          children: [
            // Show selected image preview
            if (selectedImage != null) ...[
              Container(
                padding: const EdgeInsets.all(AppTheme.spacingS),
                child: Stack(
                  children: [
                    ClipRRect(
                      borderRadius: BorderRadius.circular(AppTheme.radiusS),
                      child: Image.file(
                        File(selectedImage!.path),
                        height: 150,
                        width: 150,
                        fit: BoxFit.cover,
                      ),
                    ),
                    Positioned(
                      top: AppTheme.spacingXXS,
                      right: AppTheme.spacingXXS,
                      child: GestureDetector(
                        onTap: onClearImage,
                        child: Container(
                          decoration: BoxDecoration(
                            color: AppTheme.black.withOpacity(0.6),
                            shape: BoxShape.circle,
                          ),
                          padding: const EdgeInsets.all(AppTheme.spacingXXS),
                          child: const Icon(
                            Icons.close,
                            color: AppTheme.white,
                            size: 20,
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
            
            // Input row
            Row(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                // Image picker button
                IconButton(
                  onPressed: isUploadingImage || isSending ? null : onPickImage,
                  icon: Icon(
                    Icons.image,
                    color: isUploadingImage || isSending
                        ? (isDark ? AppTheme.gray600 : AppTheme.gray400)
                        : AppTheme.accentBlue,
                  ),
                  padding: const EdgeInsets.all(AppTheme.spacingS),
                ),
                
                const SizedBox(width: AppTheme.spacingXXS),
                
                // Text input
                Expanded(
                  child: Container(
                    decoration: BoxDecoration(
                      color: isDark ? AppTheme.darkGray200 : AppTheme.gray100,
                      borderRadius: BorderRadius.circular(AppTheme.radiusXL),
                      border: Border.all(
                        color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                        width: 1,
                      ),
                    ),
                    padding: const EdgeInsets.symmetric(
                      horizontal: AppTheme.spacingM,
                    ),
                    child: TextField(
                      controller: messageController,
                      enabled: !isSending && !isUploadingImage,
                      decoration: const InputDecoration(
                        hintText: 'Message',
                        border: InputBorder.none,
                        contentPadding: EdgeInsets.symmetric(
                          vertical: AppTheme.spacingS,
                        ),
                      ),
                      maxLines: 5,
                      minLines: 1,
                      textCapitalization: TextCapitalization.sentences,
                      style: TextStyle(
                        color: isDark ? AppTheme.white : AppTheme.black,
                      ),
                    ),
                  ),
                ),
                
                const SizedBox(width: AppTheme.spacingS),
                
                // Send button
                Container(
                  decoration: BoxDecoration(
                    color: isDark ? AppTheme.white : AppTheme.black,
                    shape: BoxShape.circle,
                  ),
                  child: IconButton(
                    onPressed: (isSending || isUploadingImage) ? null : onSendMessage,
                    icon: (isSending || isUploadingImage)
                        ? SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              color: isDark ? AppTheme.black : AppTheme.white,
                            ),
                          )
                        : Icon(
                            Icons.send,
                            size: 20,
                            color: isDark ? AppTheme.black : AppTheme.white,
                          ),
                    padding: const EdgeInsets.all(AppTheme.spacingS),
                    constraints: const BoxConstraints(),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildDeliveryIndicator(Message message) {
    final receipts = receiptsCache[message.id] ?? [];
    
    // Filter out own receipts (shouldn't exist for sent messages, but just in case)
    final otherReceipts = receipts.where((r) => r.userId != currentUserId).toList();
    
    final hasDelivered = otherReceipts.any((r) => r.status == 'delivered' || r.status == 'read');
    final hasRead = otherReceipts.any((r) => r.status == 'read');

    IconData icon;
    Color color;

    if (hasRead) {
      icon = Icons.done_all;
      color = AppTheme.accentBlue;
    } else if (hasDelivered) {
      icon = Icons.done_all;
      color = AppTheme.gray600;
    } else {
      icon = Icons.done;
      color = AppTheme.gray600;
    }

    return Icon(
      icon,
      size: 14,
      color: color,
    );
  }
  
  String _formatTime(int timestamp) {
    final dateTime = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);
    final hour = dateTime.hour.toString().padLeft(2, '0');
    final minute = dateTime.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }
}

/// Animated typing indicator dots
class _TypingAnimation extends StatefulWidget {
  final bool isDark;
  
  const _TypingAnimation({required this.isDark});

  @override
  State<_TypingAnimation> createState() => _TypingAnimationState();
}

class _TypingAnimationState extends State<_TypingAnimation>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1000),
    )..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return Row(
          mainAxisSize: MainAxisSize.min,
          children: List.generate(3, (index) {
            final delay = index * 0.2;
            final value = (_controller.value - delay) % 1.0;
            final opacity = value < 0.5 ? value * 2 : (1 - value) * 2;
            
            return Container(
              width: 4,
              height: 4,
              margin: const EdgeInsets.symmetric(horizontal: 1),
              decoration: BoxDecoration(
                color: (widget.isDark ? AppTheme.gray600 : AppTheme.gray600)
                    .withOpacity(opacity),
                shape: BoxShape.circle,
              ),
            );
          }),
        );
      },
    );
  }
}
</file>

<file path="lib/features/messages/widgets/tone_badge.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/ai_analysis.dart';

/// A small badge widget that displays tone analysis for a message
/// Appears at the bottom-right of message bubbles
class ToneBadge extends StatelessWidget {
  final AIAnalysis analysis;
  final VoidCallback? onTap;

  const ToneBadge({
    Key? key,
    required this.analysis,
    this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    final toneInfo = _getToneInfo(analysis.tone);
    final urgencyColor = _getUrgencyColor(analysis.urgencyLevel);

    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: AppTheme.spacingXS,
          vertical: AppTheme.spacingXXS,
        ),
        decoration: BoxDecoration(
          color: (isDark ? AppTheme.darkGray200 : AppTheme.gray100)
              .withOpacity(0.9),
          borderRadius: BorderRadius.circular(AppTheme.radiusS),
          border: Border.all(
            color: urgencyColor.withOpacity(0.3),
            width: 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              toneInfo.emoji,
              style: const TextStyle(fontSize: 12),
            ),
            const SizedBox(width: AppTheme.spacingXXS),
            Text(
              toneInfo.label,
              style: TextStyle(
                fontSize: AppTheme.fontSizeXXS,
                fontWeight: AppTheme.fontWeightMedium,
                color: isDark ? AppTheme.white : AppTheme.black,
              ),
            ),
            if (analysis.urgencyLevel != null && analysis.urgencyLevel != 'Low') ...[
              const SizedBox(width: AppTheme.spacingXXS),
              Container(
                width: 6,
                height: 6,
                decoration: BoxDecoration(
                  color: urgencyColor,
                  shape: BoxShape.circle,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  ToneInfo _getToneInfo(String tone) {
    switch (tone.toLowerCase()) {
      case 'friendly':
        return ToneInfo(emoji: '😊', label: 'Friendly');
      case 'professional':
        return ToneInfo(emoji: '💼', label: 'Professional');
      case 'urgent':
        return ToneInfo(emoji: '⚡', label: 'Urgent');
      case 'casual':
        return ToneInfo(emoji: '😎', label: 'Casual');
      case 'formal':
        return ToneInfo(emoji: '👔', label: 'Formal');
      case 'concerned':
        return ToneInfo(emoji: '😟', label: 'Concerned');
      case 'excited':
        return ToneInfo(emoji: '🎉', label: 'Excited');
      case 'neutral':
      default:
        return ToneInfo(emoji: '💬', label: 'Neutral');
    }
  }

  Color _getUrgencyColor(String? urgencyLevel) {
    if (urgencyLevel == null) return AppTheme.gray500;
    
    switch (urgencyLevel.toLowerCase()) {
      case 'critical':
        return AppTheme.accentRed;
      case 'high':
        return AppTheme.accentOrange;
      case 'medium':
        return AppTheme.accentBlue;
      case 'low':
      default:
        return AppTheme.accentGreen;
    }
  }
}

class ToneInfo {
  final String emoji;
  final String label;

  ToneInfo({required this.emoji, required this.label});
}
</file>

<file path="lib/features/messages/widgets/tone_detail_sheet.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Bottom sheet showing detailed tone analysis
class ToneDetailSheet extends StatelessWidget {
  final AIAnalysis analysis;
  final String messageBody;

  const ToneDetailSheet({
    Key? key,
    required this.analysis,
    required this.messageBody,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingL),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(AppTheme.radiusXL),
          topRight: Radius.circular(AppTheme.radiusXL),
        ),
      ),
      child: SafeArea(
        top: false,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Handle bar
            Center(
              child: Container(
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                  borderRadius: BorderRadius.circular(AppTheme.radiusPill),
                ),
              ),
            ),
            
            const SizedBox(height: AppTheme.spacingL),
            
            // Header
            Row(
              children: [
                Icon(
                  Icons.psychology,
                  size: 28,
                  color: isDark ? AppTheme.white : AppTheme.black,
                ),
                const SizedBox(width: AppTheme.spacingS),
                Text(
                  'AI Analysis',
                  style: theme.textTheme.displaySmall?.copyWith(
                    fontWeight: AppTheme.fontWeightBold,
                  ),
                ),
              ],
            ),
            
            const SizedBox(height: AppTheme.spacingL),
            
            // Message preview
            _buildSection(
              context,
              'Message',
              messageBody.length > 100
                  ? '${messageBody.substring(0, 100)}...'
                  : messageBody,
              Icons.chat_bubble_outline,
              isDark,
            ),
            
            const SizedBox(height: AppTheme.spacingM),
            
            // Tone
            _buildSection(
              context,
              'Tone',
              analysis.tone,
              Icons.sentiment_satisfied,
              isDark,
              highlight: true,
            ),
            
            const SizedBox(height: AppTheme.spacingM),
            
            // Urgency
            if (analysis.urgencyLevel != null)
              _buildSection(
                context,
                'Urgency Level',
                analysis.urgencyLevel!,
                Icons.priority_high,
                isDark,
                color: _getUrgencyColor(analysis.urgencyLevel),
              ),
            
            if (analysis.urgencyLevel != null)
              const SizedBox(height: AppTheme.spacingM),
            
            // Intent
            if (analysis.intent != null)
              _buildSection(
                context,
                'Intent',
                analysis.intent!,
                Icons.lightbulb_outline,
                isDark,
              ),
            
            if (analysis.intent != null)
              const SizedBox(height: AppTheme.spacingM),
            
            // Confidence
            if (analysis.confidenceScore != null) ...[
              _buildConfidenceBar(
                context,
                analysis.confidenceScore!,
                isDark,
              ),
              const SizedBox(height: AppTheme.spacingL),
            ],
            
            // Feedback section
            _buildFeedbackSection(context, isDark),
            
            const SizedBox(height: AppTheme.spacingM),
            
            // Close button
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () => Navigator.pop(context),
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(
                    vertical: AppTheme.spacingM,
                  ),
                ),
                child: const Text('Close'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSection(
    BuildContext context,
    String label,
    String value,
    IconData icon,
    bool isDark, {
    bool highlight = false,
    Color? color,
  }) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: highlight
            ? (isDark ? AppTheme.darkGray200 : AppTheme.gray100)
            : (isDark ? AppTheme.darkGray200.withOpacity(0.5) : AppTheme.gray50),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: color ?? (isDark ? AppTheme.darkGray300 : AppTheme.gray300),
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingS),
            decoration: BoxDecoration(
              color: (color ?? (isDark ? AppTheme.darkGray300 : AppTheme.gray200))
                  .withOpacity(0.3),
              borderRadius: BorderRadius.circular(AppTheme.radiusS),
            ),
            child: Icon(
              icon,
              size: 20,
              color: color ?? (isDark ? AppTheme.white : AppTheme.black),
            ),
          ),
          const SizedBox(width: AppTheme.spacingM),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  label,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                    fontWeight: AppTheme.fontWeightMedium,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  value,
                  style: theme.textTheme.bodyLarge?.copyWith(
                    fontWeight: AppTheme.fontWeightSemibold,
                    color: color,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildConfidenceBar(
    BuildContext context,
    double confidence,
    bool isDark,
  ) {
    final theme = Theme.of(context);
    final percentage = (confidence * 100).round();
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Confidence',
              style: theme.textTheme.bodySmall?.copyWith(
                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                fontWeight: AppTheme.fontWeightMedium,
              ),
            ),
            Text(
              '$percentage%',
              style: theme.textTheme.bodySmall?.copyWith(
                fontWeight: AppTheme.fontWeightBold,
              ),
            ),
          ],
        ),
        const SizedBox(height: AppTheme.spacingXS),
        ClipRRect(
          borderRadius: BorderRadius.circular(AppTheme.radiusPill),
          child: LinearProgressIndicator(
            value: confidence,
            minHeight: 8,
            backgroundColor: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
            valueColor: AlwaysStoppedAnimation<Color>(
              confidence > 0.8
                  ? AppTheme.accentGreen
                  : confidence > 0.6
                      ? AppTheme.accentBlue
                      : AppTheme.accentOrange,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildFeedbackSection(BuildContext context, bool isDark) {
    final theme = Theme.of(context);
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Was this analysis helpful?',
          style: theme.textTheme.bodySmall?.copyWith(
            color: isDark ? AppTheme.gray500 : AppTheme.gray600,
            fontWeight: AppTheme.fontWeightMedium,
          ),
        ),
        const SizedBox(height: AppTheme.spacingXS),
        Row(
          children: [
            OutlinedButton.icon(
              onPressed: () {
                // TODO: Implement feedback logic
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Thanks for your feedback!')),
                );
              },
              icon: const Icon(Icons.thumb_up_outlined, size: 18),
              label: const Text('Helpful'),
              style: OutlinedButton.styleFrom(
                side: BorderSide(
                  color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                ),
              ),
            ),
            const SizedBox(width: AppTheme.spacingS),
            OutlinedButton.icon(
              onPressed: () {
                // TODO: Implement feedback logic
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Thanks for your feedback!')),
                );
              },
              icon: const Icon(Icons.thumb_down_outlined, size: 18),
              label: const Text('Not helpful'),
              style: OutlinedButton.styleFrom(
                side: BorderSide(
                  color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                ),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Color _getUrgencyColor(String? urgencyLevel) {
    if (urgencyLevel == null) return AppTheme.gray500;
    
    switch (urgencyLevel.toLowerCase()) {
      case 'critical':
        return AppTheme.accentRed;
      case 'high':
        return AppTheme.accentOrange;
      case 'medium':
        return AppTheme.accentBlue;
      case 'low':
      default:
        return AppTheme.accentGreen;
    }
  }

  static void show(
    BuildContext context,
    AIAnalysis analysis,
    String messageBody,
  ) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => ToneDetailSheet(
        analysis: analysis,
        messageBody: messageBody,
      ),
    );
  }
}
</file>

<file path="lib/features/notifications/widgets/notification_widgets.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/notification_providers.dart';
import 'package:messageai/services/notification_service.dart';

/// Widget to request notification permissions
class NotificationPermissionRequest extends ConsumerWidget {
  final VoidCallback? onPermissionGranted;
  final VoidCallback? onPermissionDenied;

  const NotificationPermissionRequest({
    Key? key,
    this.onPermissionGranted,
    this.onPermissionDenied,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final hasPermission = ref.watch(notificationPermissionProvider);

    return hasPermission.when(
      data: (hasPermission) {
        if (hasPermission) {
          return const SizedBox.shrink();
        }
        return _PermissionBanner(
          onGranted: onPermissionGranted,
          onDenied: onPermissionDenied,
        );
      },
      loading: () => const SizedBox.shrink(),
      error: (error, st) => const SizedBox.shrink(),
    );
  }
}

/// Permission request banner
class _PermissionBanner extends ConsumerWidget {
  final VoidCallback? onGranted;
  final VoidCallback? onDenied;

  const _PermissionBanner({
    this.onGranted,
    this.onDenied,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Container(
      color: Colors.blue.shade50,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      child: Row(
        children: [
          Icon(
            Icons.notifications_none,
            color: Colors.blue.shade700,
            size: 24,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  'Enable Notifications',
                  style: Theme.of(context).textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                ),
                Text(
                  'Get notified when you receive messages',
                  style: Theme.of(context).textTheme.bodySmall,
                ),
              ],
            ),
          ),
          const SizedBox(width: 12),
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextButton(
                onPressed: () {
                  onDenied?.call();
                },
                child: const Text('Not Now'),
              ),
              const SizedBox(width: 8),
              ElevatedButton(
                onPressed: () async {
                  final service = ref.read(notificationServiceProvider);
                  final granted = await service.areNotificationsEnabled();
                  if (granted) {
                    onGranted?.call();
                  } else {
                    onDenied?.call();
                  }
                },
                child: const Text('Enable'),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

/// Notification status indicator
class NotificationStatusIndicator extends ConsumerWidget {
  const NotificationStatusIndicator({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);

    if (!notificationState.isInitialized) {
      return const SizedBox.shrink();
    }

    final hasPermission = notificationState.hasPermission;

    return Tooltip(
      message: hasPermission ? 'Notifications enabled' : 'Notifications disabled',
      child: Icon(
        hasPermission ? Icons.notifications_active : Icons.notifications_off,
        color: hasPermission ? Colors.green : Colors.grey,
        size: 24,
      ),
    );
  }
}

/// Notification settings tile
class NotificationSettingsTile extends ConsumerWidget {
  final VoidCallback? onPressed;

  const NotificationSettingsTile({
    Key? key,
    this.onPressed,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);
    final hasPermission = notificationState.hasPermission;

    return ListTile(
      leading: Icon(
        hasPermission ? Icons.notifications_active : Icons.notifications_off,
        color: hasPermission ? Colors.green : Colors.grey,
      ),
      title: const Text('Notifications'),
      subtitle: Text(
        hasPermission ? 'Enabled' : 'Disabled',
        style: TextStyle(
          color: hasPermission ? Colors.green : Colors.grey,
        ),
      ),
      trailing: Icon(
        Icons.chevron_right,
        color: Theme.of(context).dividerColor,
      ),
      onTap: onPressed,
    );
  }
}

/// Unread notification badge
class NotificationBadge extends ConsumerWidget {
  final Widget child;
  final Color? backgroundColor;
  final TextStyle? textStyle;

  const NotificationBadge({
    Key? key,
    required this.child,
    this.backgroundColor,
    this.textStyle,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);
    final unreadCount = notificationState.unreadCount;

    if (unreadCount == 0) {
      return child;
    }

    return Badge(
      label: Text(
        unreadCount > 99 ? '99+' : '$unreadCount',
        style: textStyle,
      ),
      backgroundColor: backgroundColor ?? Colors.red,
      child: child,
    );
  }
}

/// Notification bottom sheet
class NotificationSettingsBottomSheet extends ConsumerWidget {
  const NotificationSettingsBottomSheet({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);
    final hasPermission = notificationState.hasPermission;
    final deviceToken = notificationState.deviceToken;

    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Text(
            'Notification Settings',
            style: Theme.of(context).textTheme.headlineSmall,
          ),
          const SizedBox(height: 24),

          // Permission status
          ListTile(
            leading: Icon(
              hasPermission ? Icons.check_circle : Icons.error_circle,
              color: hasPermission ? Colors.green : Colors.red,
            ),
            title: const Text('Notifications'),
            subtitle: Text(
              hasPermission ? 'Enabled' : 'Disabled',
              style: TextStyle(
                color: hasPermission ? Colors.green : Colors.red,
              ),
            ),
          ),
          const Divider(),

          // Device token info
          if (deviceToken != null)
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 8.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Device Token',
                    style: Theme.of(context).textTheme.labelMedium,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    deviceToken.substring(0, 20) + '...',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          fontFamily: 'monospace',
                        ),
                  ),
                ],
              ),
            ),
          const SizedBox(height: 24),

          // Close button
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Close'),
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/settings/screens/settings_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/features/auth/screens/auth_screen.dart';
import 'package:messageai/services/avatar_service.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_ui.dart';

/// User settings and account management screen
class SettingsScreen extends StatefulWidget {
  const SettingsScreen({Key? key}) : super(key: key);

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> with ErrorHandlerMixin {
  final _supabase = SupabaseClientProvider.client;
  final _avatarService = AvatarService();
  bool _notificationsEnabled = true;
  bool _isLoading = false;
  bool _isUploadingAvatar = false;
  String? _avatarUrl;

  @override
  void initState() {
    super.initState();
    _loadProfile();
  }

  Future<void> _loadProfile() async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      final response = await _supabase
          .from('profiles')
          .select('avatar_url')
          .eq('user_id', userId)
          .maybeSingle();

      if (response != null && mounted) {
        setState(() {
          _avatarUrl = response['avatar_url'] as String?;
        });
      }
    } catch (e) {
      print('Error loading profile: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    final user = _supabase.auth.currentUser;
    final email = user?.email ?? 'Not logged in';
    final userId = user?.id ?? '';

    return Scaffold(
      appBar: AppBar(
        title: const Text('Settings'),
        elevation: 1,
      ),
      body: ListView(
        children: [
          // Profile Section
          Container(
            padding: const EdgeInsets.all(24),
            color: Theme.of(context).colorScheme.surfaceContainer,
            child: Column(
              children: [
                Stack(
                  children: [
                    _isUploadingAvatar
                        ? const CircleAvatar(
                            radius: 50,
                            child: CircularProgressIndicator(),
                          )
                        : CircleAvatar(
                            radius: 50,
                            backgroundColor: Theme.of(context).colorScheme.primary,
                            backgroundImage: _avatarUrl != null
                                ? NetworkImage(_avatarUrl!)
                                : null,
                            child: _avatarUrl == null
                                ? Text(
                                    email[0].toUpperCase(),
                                    style: const TextStyle(
                                      fontSize: 40,
                                      fontWeight: FontWeight.bold,
                                      color: Colors.white,
                                    ),
                                  )
                                : null,
                          ),
                    Positioned(
                      bottom: 0,
                      right: 0,
                      child: Container(
                        decoration: BoxDecoration(
                          color: Theme.of(context).colorScheme.primary,
                          shape: BoxShape.circle,
                        ),
                        child: IconButton(
                          icon: const Icon(Icons.camera_alt, color: Colors.white, size: 20),
                          onPressed: _isUploadingAvatar ? null : _showAvatarOptions,
                          padding: const EdgeInsets.all(8),
                          constraints: const BoxConstraints(),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                Text(
                  email,
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                const SizedBox(height: 4),
                Text(
                  'ID: ${userId.substring(0, 8)}...',
                  style: Theme.of(context).textTheme.bodySmall,
                ),
              ],
            ),
          ),

          const SizedBox(height: 8),

          // Account Settings
          _buildSectionTitle('Account'),
          _buildSettingsTile(
            icon: Icons.person,
            title: 'Display Name',
            subtitle: email.split('@')[0],
            onTap: () => _showEditDisplayNameDialog(),
          ),
          _buildSettingsTile(
            icon: Icons.email,
            title: 'Email',
            subtitle: email,
            onTap: () {},
          ),
          _buildSettingsTile(
            icon: Icons.lock,
            title: 'Change Password',
            onTap: () => _showComingSoonDialog('Change Password'),
          ),

          const Divider(height: 1),

          // Notifications
          _buildSectionTitle('Notifications'),
          SwitchListTile(
            secondary: const Icon(Icons.notifications),
            title: const Text('Push Notifications'),
            subtitle: const Text('Receive message notifications'),
            value: _notificationsEnabled,
            onChanged: (value) {
              setState(() => _notificationsEnabled = value);
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(
                    value ? 'Notifications enabled' : 'Notifications disabled',
                  ),
                ),
              );
            },
          ),
          _buildSettingsTile(
            icon: Icons.volume_up,
            title: 'Notification Sound',
            subtitle: 'Default',
            onTap: () => _showComingSoonDialog('Notification Sounds'),
          ),

          const Divider(height: 1),

          // Privacy & Security
          _buildSectionTitle('Privacy & Security'),
          _buildSettingsTile(
            icon: Icons.shield,
            title: 'Blocked Users',
            onTap: () => _showComingSoonDialog('Blocked Users'),
          ),
          _buildSettingsTile(
            icon: Icons.visibility,
            title: 'Online Status',
            subtitle: 'Visible to everyone',
            onTap: () => _showComingSoonDialog('Online Status Settings'),
          ),
          _buildSettingsTile(
            icon: Icons.check_circle,
            title: 'Read Receipts',
            subtitle: 'Enabled',
            onTap: () => _showComingSoonDialog('Read Receipts Settings'),
          ),

          const Divider(height: 1),

          // Storage
          _buildSectionTitle('Storage'),
          _buildSettingsTile(
            icon: Icons.storage,
            title: 'Storage Usage',
            subtitle: 'Calculate storage...',
            onTap: () => _showComingSoonDialog('Storage Management'),
          ),
          _buildSettingsTile(
            icon: Icons.delete_sweep,
            title: 'Clear Cache',
            onTap: () => _showClearCacheDialog(),
          ),

          const Divider(height: 1),

          // About
          _buildSectionTitle('About'),
          _buildSettingsTile(
            icon: Icons.info,
            title: 'App Version',
            subtitle: '1.0.0 (MVP)',
            onTap: () {},
          ),
          _buildSettingsTile(
            icon: Icons.privacy_tip,
            title: 'Privacy Policy',
            onTap: () => _showComingSoonDialog('Privacy Policy'),
          ),
          _buildSettingsTile(
            icon: Icons.description,
            title: 'Terms of Service',
            onTap: () => _showComingSoonDialog('Terms of Service'),
          ),

          const SizedBox(height: 16),

          // Logout Button
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: ElevatedButton.icon(
              onPressed: _isLoading ? null : _handleLogout,
              icon: _isLoading
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Icon(Icons.logout),
              label: const Text('Log Out'),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.red,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(vertical: 16),
              ),
            ),
          ),

          const SizedBox(height: 32),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 24, 16, 8),
      child: Text(
        title.toUpperCase(),
        style: TextStyle(
          fontSize: 12,
          fontWeight: FontWeight.w600,
          color: Theme.of(context).colorScheme.primary,
        ),
      ),
    );
  }

  Widget _buildSettingsTile({
    required IconData icon,
    required String title,
    String? subtitle,
    VoidCallback? onTap,
  }) {
    return ListTile(
      leading: Icon(icon),
      title: Text(title),
      subtitle: subtitle != null ? Text(subtitle) : null,
      trailing: const Icon(Icons.chevron_right),
      onTap: onTap,
    );
  }

  /// Show avatar options (Gallery, Camera, Delete)
  void _showAvatarOptions() {
    showModalBottomSheet(
      context: context,
      builder: (BuildContext context) {
        return SafeArea(
          child: Wrap(
            children: [
              ListTile(
                leading: const Icon(Icons.photo_library),
                title: const Text('Choose from Gallery'),
                onTap: () {
                  Navigator.pop(context);
                  _uploadAvatarFromGallery();
                },
              ),
              ListTile(
                leading: const Icon(Icons.camera_alt),
                title: const Text('Take Photo'),
                onTap: () {
                  Navigator.pop(context);
                  _uploadAvatarFromCamera();
                },
              ),
              if (_avatarUrl != null)
                ListTile(
                  leading: const Icon(Icons.delete, color: Colors.red),
                  title: const Text('Remove Photo', style: TextStyle(color: Colors.red)),
                  onTap: () {
                    Navigator.pop(context);
                    _deleteAvatar();
                  },
                ),
              ListTile(
                leading: const Icon(Icons.cancel),
                title: const Text('Cancel'),
                onTap: () => Navigator.pop(context),
              ),
            ],
          ),
        );
      },
    );
  }

  /// Upload avatar from gallery
  Future<void> _uploadAvatarFromGallery() async {
    try {
      final image = await _avatarService.pickImage();
      if (image == null) return;

      await _uploadAvatar(image);
    } on AppError catch (error) {
      if (mounted) {
        showError(error);
      }
    }
  }

  /// Upload avatar from camera
  Future<void> _uploadAvatarFromCamera() async {
    try {
      final image = await _avatarService.pickImageFromCamera();
      if (image == null) return;

      await _uploadAvatar(image);
    } on AppError catch (error) {
      if (mounted) {
        showError(error);
      }
    }
  }

  /// Upload avatar to server
  Future<void> _uploadAvatar(image) async {
    if (mounted) {
      setState(() => _isUploadingAvatar = true);
    }

    try {
      final url = await _avatarService.uploadAvatar(image);

      if (mounted) {
        setState(() {
          _avatarUrl = url;
          _isUploadingAvatar = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 12),
                Text('Profile picture updated successfully'),
              ],
            ),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
      }
    } on AppError catch (error) {
      if (mounted) {
        setState(() => _isUploadingAvatar = false);
        showError(error);
      }
    }
  }

  /// Delete avatar
  Future<void> _deleteAvatar() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Remove Photo'),
        content: const Text('Are you sure you want to remove your profile picture?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('Remove'),
          ),
        ],
      ),
    );

    if (confirm != true) return;

    setState(() => _isUploadingAvatar = true);

    try {
      await _avatarService.deleteAvatar();

      if (mounted) {
        setState(() {
          _avatarUrl = null;
          _isUploadingAvatar = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Profile picture removed')),
        );
      }
    } on AppError catch (error) {
      if (mounted) {
        setState(() => _isUploadingAvatar = false);
        showError(error);
      }
    }
  }

  void _showEditDisplayNameDialog() {
    final controller = TextEditingController();
    final user = _supabase.auth.currentUser;
    controller.text = user?.email?.split('@')[0] ?? '';

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Edit Display Name'),
        content: TextField(
          controller: controller,
          decoration: const InputDecoration(
            labelText: 'Display Name',
            border: OutlineInputBorder(),
          ),
          autofocus: true,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Display name updated')),
              );
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  void _showComingSoonDialog(String feature) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Coming Soon'),
        content: Text('$feature will be available in a future update.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  void _showClearCacheDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Clear Cache'),
        content: const Text(
          'This will clear all cached images and files. Your messages will not be affected.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Cache cleared')),
              );
            },
            child: const Text('Clear'),
          ),
        ],
      ),
    );
  }

  Future<void> _handleLogout() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Log Out'),
        content: const Text('Are you sure you want to log out?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('Log Out'),
          ),
        ],
      ),
    );

    if (confirm == true && mounted) {
      setState(() => _isLoading = true);
      
      try {
        await _supabase.auth.signOut();
        
        if (mounted) {
          Navigator.of(context).pushAndRemoveUntil(
            MaterialPageRoute(
              builder: (context) => AuthScreen(onAuthSuccess: () {}),
            ),
            (route) => false,
          );
        }
      } catch (e) {
        if (mounted) {
          setState(() => _isLoading = false);
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error logging out: $e')),
          );
        }
      }
    }
  }
}
</file>

<file path="lib/firebase_options.dart">
// File generated by FlutterFire CLI.
// This is a placeholder file. To use Firebase, you need to:
// 1. Install FlutterFire CLI: dart pub global activate flutterfire_cli
// 2. Run: flutterfire configure
// 3. Follow the prompts to select your Firebase project
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import firebase_options.dart;
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyABa-DcxTR4T4CHlfJuy-7DKG1F_hDRNcg',
    appId: '1:397483513751:web:3121cbb846ddd8381c56d2',
    messagingSenderId: '397483513751',
    projectId: 'messageai-e2e9e',
    authDomain: 'messageai-e2e9e.firebaseapp.com',
    storageBucket: 'messageai-e2e9e.firebasestorage.app',
    measurementId: 'G-VCVQDFPTLV',
  );

  // Placeholder values - replace with your actual Firebase configuration

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyBBc-17a_EvWPvCutNSTEV9QEB2w2DUM_4',
    appId: '1:397483513751:android:bb838799a2cd3f7f1c56d2',
    messagingSenderId: '397483513751',
    projectId: 'messageai-e2e9e',
    storageBucket: 'messageai-e2e9e.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIza...',  // Replace with your iOS API key
    appId: '1:...',     // Replace with your iOS app ID
    messagingSenderId: '...',  // Replace with your sender ID
    projectId: 'your-project-id',  // Replace with your project ID
    storageBucket: 'your-project-id.appspot.com',
    iosBundleId: 'com.example.messageai',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIza...',  // Replace with your macOS API key
    appId: '1:...',     // Replace with your macOS app ID
    messagingSenderId: '...',  // Replace with your sender ID
    projectId: 'your-project-id',  // Replace with your project ID
    storageBucket: 'your-project-id.appspot.com',
    iosBundleId: 'com.example.messageai',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyABa-DcxTR4T4CHlfJuy-7DKG1F_hDRNcg',
    appId: '1:397483513751:web:ba73c764d577f4f51c56d2',
    messagingSenderId: '397483513751',
    projectId: 'messageai-e2e9e',
    authDomain: 'messageai-e2e9e.firebaseapp.com',
    storageBucket: 'messageai-e2e9e.firebasestorage.app',
    measurementId: 'G-C6R3PHYG95',
  );

}
</file>

<file path="lib/gen/api/api.dart">
// Generated API models and clients
export 'models/message_payload.dart';
export 'models/receipt_payload.dart';
export 'clients/messages_api.dart';
export 'clients/receipts_api.dart';
</file>

<file path="lib/gen/api/clients/messages_api.dart">
import 'package:dio/dio.dart';
import '../models/message_payload.dart';

/// API client for message operations
class MessagesApi {
  final Dio dio;
  final String baseUrl;

  MessagesApi({
    required this.dio,
    required this.baseUrl,
  });

  /// Send a message to the backend
  /// 
  /// [message] - The message payload to send
  /// 
  /// Returns the response from the server
  Future<Response> send(MessagePayload message) async {
    try {
      final response = await dio.post(
        '$baseUrl/v1/messages.send',
        data: message.toJson(),
      );
      return response;
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Exception _handleDioError(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.receiveTimeout:
      case DioExceptionType.sendTimeout:
        return Exception('Connection timeout: ${e.message}');
      case DioExceptionType.badResponse:
        return Exception(
          'Server error: ${e.response?.statusCode} - ${e.response?.data}',
        );
      case DioExceptionType.cancel:
        return Exception('Request cancelled');
      default:
        return Exception('Network error: ${e.message}');
    }
  }
}
</file>

<file path="lib/gen/api/clients/receipts_api.dart">
import 'package:dio/dio.dart';
import '../models/receipt_payload.dart';

/// API client for receipt operations
class ReceiptsApi {
  final Dio dio;
  final String baseUrl;

  ReceiptsApi({
    required this.dio,
    required this.baseUrl,
  });

  /// Acknowledge message receipts to the backend
  /// 
  /// [receipt] - The receipt payload to send
  /// 
  /// Returns the response from the server
  Future<Response> ack(ReceiptPayload receipt) async {
    try {
      final response = await dio.post(
        '$baseUrl/v1/receipts.ack',
        data: receipt.toJson(),
      );
      return response;
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Exception _handleDioError(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.receiveTimeout:
      case DioExceptionType.sendTimeout:
        return Exception('Connection timeout: ${e.message}');
      case DioExceptionType.badResponse:
        return Exception(
          'Server error: ${e.response?.statusCode} - ${e.response?.data}',
        );
      case DioExceptionType.cancel:
        return Exception('Request cancelled');
      default:
        return Exception('Network error: ${e.message}');
    }
  }
}
</file>

<file path="lib/gen/api/models/message_payload.dart">
class MessagePayload {
  final String id;
  final String conversationId;
  final String? body;

  MessagePayload({
    required this.id,
    required this.conversationId,
    this.body,
  });

  factory MessagePayload.fromJson(Map<String, dynamic> json) {
    return MessagePayload(
      id: json['id'] as String,
      conversationId: json['conversation_id'] as String,
      body: json['body'] as String?,
    );
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'conversation_id': conversationId,
        if (body != null) 'body': body,
      };

  @override
  String toString() =>
      'MessagePayload(id: $id, conversationId: $conversationId, body: $body)';
}
</file>

<file path="lib/gen/api/models/receipt_payload.dart">
enum ReceiptStatus {
  delivered,
  read;

  static ReceiptStatus fromString(String value) {
    return ReceiptStatus.values.firstWhere(
      (e) => e.name == value,
      orElse: () => throw ArgumentError('Unknown status: $value'),
    );
  }

  String toValue() => name;
}

class ReceiptPayload {
  final List<String> messageIds;
  final ReceiptStatus status;

  ReceiptPayload({
    required this.messageIds,
    required this.status,
  });

  factory ReceiptPayload.fromJson(Map<String, dynamic> json) {
    return ReceiptPayload(
      messageIds: List<String>.from(json['message_ids'] as List),
      status: ReceiptStatus.fromString(json['status'] as String),
    );
  }

  Map<String, dynamic> toJson() => {
        'message_ids': messageIds,
        'status': status.toValue(),
      };

  @override
  String toString() =>
      'ReceiptPayload(messageIds: $messageIds, status: ${status.name})';
}
</file>

<file path="lib/main.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:messageai/core/env.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/state/notification_providers.dart';
import 'package:messageai/services/network_connectivity_service.dart';
import 'package:messageai/services/offline_queue_service.dart';
import 'package:messageai/app.dart';
import 'firebase_options.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

/// Background message handler for Firebase Cloud Messaging
/// This MUST be a top-level function (not inside a class)
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // Initialize Firebase if not already done
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  
  print('🔔 Background message received!');
  print('   Title: ${message.notification?.title}');
  print('   Body: ${message.notification?.body}');
  print('   Data: ${message.data}');
  
  // Handle the background message here if needed
  // For now, just log it - the system notification will still appear
}

void main() async {
  // Ensure Flutter bindings are initialized
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase (required before any Firebase services)
  try {
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    print('✅ Firebase initialized successfully');
    
    // Register background message handler (must be done after Firebase init)
    FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
    print('✅ Background message handler registered');
  } catch (e) {
    print('❌ Firebase initialization error: $e');
    print('Push notifications will not work. Run "flutterfire configure" to set up Firebase.');
  }

  // Validate environment configuration
  Env.validate();

  // Initialize Supabase client
  await SupabaseClientProvider.initialize();

  // Initialize Drift database
  final db = AppDb.instance;
  
  // Initialize network services
  final connectivityService = NetworkConnectivityService();
  connectivityService.startMonitoring();
  
  final offlineQueueService = OfflineQueueService();
  offlineQueueService.startMonitoring();
  
  print('✅ Network services initialized');
  
  // Run the app with Riverpod provider scope
  runApp(
    ProviderScope(
      child: _AppWithNotifications(),
    ),
  );
}

/// Wrapper widget to initialize notifications after ProviderScope
class _AppWithNotifications extends ConsumerWidget {
  const _AppWithNotifications();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Initialize notifications on app start
    final notificationInit = ref.watch(notificationInitializerProvider);
    
    notificationInit.when(
      data: (_) {
        print('🔔 Notifications fully initialized!');
      },
      loading: () {
        print('🔄 Initializing notifications...');
      },
      error: (error, stack) {
        print('❌ Notification initialization error: $error');
        print('Stack trace: $stack');
      },
    );

    return const MessageAIApp();
  }
}
</file>

<file path="lib/models/ai_analysis.dart">
/// Simple AI Analysis model - no Drift dependency
/// Fetched directly from Supabase with in-memory session caching
class AIAnalysis {
  final String id;
  final String messageId;
  final String tone;
  final String? urgencyLevel;
  final String? intent;
  final double? confidenceScore;
  final int analysisTimestamp;
  
  const AIAnalysis({
    required this.id,
    required this.messageId,
    required this.tone,
    this.urgencyLevel,
    this.intent,
    this.confidenceScore,
    required this.analysisTimestamp,
  });
  
  /// Create from Supabase JSON response
  factory AIAnalysis.fromJson(Map<String, dynamic> json) {
    try {
      // Handle both direct table columns and RPC function results
      final id = json['id'] as String? ?? json['analysis_id'] as String?;
      final messageId = json['message_id'] as String?;
      final tone = json['tone'] as String?;
      
      if (id == null || messageId == null || tone == null) {
        throw FormatException(
          'Missing required fields in AI analysis JSON: '
          'id=$id, message_id=$messageId, tone=$tone. '
          'Full JSON: $json'
        );
      }
      
      return AIAnalysis(
        id: id,
        messageId: messageId,
        tone: tone,
        urgencyLevel: json['urgency_level'] as String?,
        intent: json['intent'] as String?,
        confidenceScore: (json['confidence_score'] as num?)?.toDouble(),
        analysisTimestamp: (json['analysis_timestamp'] as num?)?.toInt() ?? 
                           DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );
    } catch (e) {
      throw FormatException('Failed to parse AIAnalysis from JSON: $e\nJSON: $json');
    }
  }
  
  /// Convert to JSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'message_id': messageId,
      'tone': tone,
      'urgency_level': urgencyLevel,
      'intent': intent,
      'confidence_score': confidenceScore,
      'analysis_timestamp': analysisTimestamp,
    };
  }
  
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AIAnalysis &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          messageId == other.messageId;
  
  @override
  int get hashCode => id.hashCode ^ messageId.hashCode;
  
  @override
  String toString() {
    return 'AIAnalysis(id: $id, messageId: $messageId, tone: $tone, '
           'urgency: $urgencyLevel, intent: $intent, confidence: $confidenceScore)';
  }
}
</file>

<file path="lib/services/ai_analysis_service_cached.dart.backup">
import 'dart:async';
import 'dart:convert';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/ai_analysis_dao.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:uuid/uuid.dart';

/// Service for managing AI message analysis (tone, intent, urgency)
class AIAnalysisService {
  final _analysisDao = AppDb.instance.aiAnalysisDao;
  final _supabase = SupabaseClientProvider.client;
  final _uuid = const Uuid();

  // Debouncing: Track pending analysis requests to avoid duplicates
  final Map<String, Timer> _pendingRequests = {};
  final Duration _debounceDelay = const Duration(milliseconds: 500);

  /// Request AI analysis for a message
  /// Debounces requests to avoid spamming the API
  Future<AiAnalysi?> requestAnalysis(
    String messageId,
    String messageBody, {
    List<String>? conversationContext,
    bool forceRefresh = false,
  }) async {
    // Cancel any pending request for this message
    _pendingRequests[messageId]?.cancel();

    // Check if we already have cached analysis
    if (!forceRefresh) {
      final cached = await _analysisDao.getAnalysisByMessageId(messageId);
      if (cached != null) {
        print('📊 Using cached analysis for message ${messageId.substring(0, 8)}');
        return cached;
      }
    }

    // Create a debounced request
    final completer = Completer<AiAnalysi?>();
    
    _pendingRequests[messageId] = Timer(_debounceDelay, () async {
      try {
        print('🤖 Requesting AI analysis for message ${messageId.substring(0, 8)}...');
        
        final analysis = await _callAnalysisAPI(
          messageId,
          messageBody,
          conversationContext,
        );
        
        if (!completer.isCompleted) {
          completer.complete(analysis);
        }
      } catch (e) {
        print('❌ Analysis request failed: $e');
        if (!completer.isCompleted) {
          completer.completeError(e);
        }
      } finally {
        _pendingRequests.remove(messageId);
      }
    });

    return completer.future;
  }

  /// Call the AI analysis Edge Function
  Future<AiAnalysi> _callAnalysisAPI(
    String messageId,
    String messageBody,
    List<String>? conversationContext,
  ) async {
    try {
      final response = await _supabase.functions.invoke(
        'ai_analyze_tone',
        body: {
          'message_id': messageId,
          'message_body': messageBody,
          if (conversationContext != null)
            'conversation_context': conversationContext,
        },
      );

      if (response.status != 200) {
        throw Exception('API returned status ${response.status}');
      }

      final data = response.data;
      if (data == null || !data['success']) {
        throw Exception(data?['error'] ?? 'Unknown error');
      }

      final analysisData = data['analysis'];
      
      // Store in local database
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final analysis = AiAnalysisCompanion.insert(
        id: analysisData['id'] as String,
        messageId: messageId,
        tone: analysisData['tone'] as String,
        urgencyLevel: Value(analysisData['urgency_level'] as String?),
        intent: Value(analysisData['intent'] as String?),
        confidenceScore: Value(
          (analysisData['confidence_score'] as num?)?.toDouble(),
        ),
        analysisTimestamp: analysisData['analysis_timestamp'] as int? ?? now,
        isSynced: const Value(true),
        createdAt: now,
        updatedAt: now,
      );

      await _analysisDao.upsertAnalysis(analysis);
      
      print('✅ Analysis complete: ${analysisData['tone']} (${analysisData['urgency_level']})');
      
      // Return the stored analysis
      return (await _analysisDao.getAnalysisByMessageId(messageId))!;
    } catch (e) {
      print('❌ Failed to call analysis API: $e');
      rethrow;
    }
  }

  /// Get analysis for a specific message
  Future<AiAnalysi?> getAnalysis(String messageId) async {
    return _analysisDao.getAnalysisByMessageId(messageId);
  }

  /// Get analyses for multiple messages
  Future<Map<String, AiAnalysi>> getAnalysesForMessages(
    List<String> messageIds,
  ) async {
    final analyses = await _analysisDao.getAnalysesByMessageIds(messageIds);
    return Map.fromEntries(
      analyses.map((a) => MapEntry(a.messageId, a)),
    );
  }

  /// Get analyses for a conversation
  Future<Map<String, AiAnalysi>> getConversationAnalysis(
    String conversationId,
    List<String> messageIds,
  ) async {
    final analyses = await _analysisDao.getAnalysesForConversation(messageIds);
    return Map.fromEntries(
      analyses.map((a) => MapEntry(a.messageId, a)),
    );
  }

  /// Sync analysis from backend for a message
  Future<AiAnalysi?> syncAnalysisFromBackend(String messageId) async {
    try {
      print('🔄 Syncing analysis for message ${messageId.substring(0, 8)} from backend...');
      
      final response = await _supabase.rpc(
        'get_message_ai_analysis',
        params: {'p_message_id': messageId},
      );

      if (response == null || (response as List).isEmpty) {
        print('ℹ️ No analysis found on backend');
        return null;
      }

      final data = (response as List).first;
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      
      final analysis = AiAnalysisCompanion.insert(
        id: data['id'] as String,
        messageId: messageId,
        tone: data['tone'] as String,
        urgencyLevel: Value(data['urgency_level'] as String?),
        intent: Value(data['intent'] as String?),
        confidenceScore: Value((data['confidence_score'] as num?)?.toDouble()),
        analysisTimestamp: data['analysis_timestamp'] as int? ?? now,
        isSynced: const Value(true),
        createdAt: now,
        updatedAt: now,
      );

      await _analysisDao.upsertAnalysis(analysis);
      
      return _analysisDao.getAnalysisByMessageId(messageId);
    } catch (e) {
      print('❌ Failed to sync analysis from backend: $e');
      return null;
    }
  }

  /// Sync analyses for a conversation from backend
  Future<void> syncConversationAnalysesFromBackend(
    String conversationId,
  ) async {
    try {
      print('🔄 Syncing analyses for conversation ${conversationId.substring(0, 8)}...');
      
      final response = await _supabase.rpc(
        'get_conversation_ai_analysis',
        params: {'p_conversation_id': conversationId},
      );

      if (response == null || (response as List).isEmpty) {
        print('ℹ️ No analyses found on backend');
        return;
      }

      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final analyses = (response as List).cast<Map<String, dynamic>>();
      
      for (final data in analyses) {
        final analysis = AiAnalysisCompanion.insert(
          id: _uuid.v4(),
          messageId: data['message_id'] as String,
          tone: data['tone'] as String,
          urgencyLevel: Value(data['urgency_level'] as String?),
          intent: Value(data['intent'] as String?),
          confidenceScore: Value((data['confidence_score'] as num?)?.toDouble()),
          analysisTimestamp: data['analysis_timestamp'] as int? ?? now,
          isSynced: const Value(true),
          createdAt: now,
          updatedAt: now,
        );

        await _analysisDao.upsertAnalysis(analysis);
      }
      
      print('✅ Synced ${analyses.length} analyses from backend');
    } catch (e) {
      print('❌ Failed to sync conversation analyses: $e');
    }
  }

  /// Delete analysis for a message
  Future<void> deleteAnalysis(String messageId) async {
    await _analysisDao.deleteAnalysisByMessageId(messageId);
  }

  /// Clear old analyses (older than N days)
  Future<void> cleanupOldAnalyses({int days = 30}) async {
    final deleted = await _analysisDao.deleteOldAnalyses(days: days);
    print('🧹 Cleaned up $deleted old analyses');
  }

  /// Get analysis statistics
  Future<Map<String, dynamic>> getAnalysisStats() async {
    final count = await _analysisDao.getAnalysisCount();
    final byTone = await _analysisDao.getAnalysisCountByTone();
    
    return {
      'total_count': count,
      'by_tone': byTone,
    };
  }

  /// Stream analysis for a message
  Stream<AiAnalysi?> watchAnalysis(String messageId) {
    return _analysisDao.watchAnalysisForMessage(messageId);
  }

  /// Cancel pending analysis request
  void cancelPendingRequest(String messageId) {
    _pendingRequests[messageId]?.cancel();
    _pendingRequests.remove(messageId);
  }

  /// Cancel all pending requests
  void cancelAllPendingRequests() {
    for (final timer in _pendingRequests.values) {
      timer.cancel();
    }
    _pendingRequests.clear();
  }

  /// Dispose resources
  void dispose() {
    cancelAllPendingRequests();
  }
}
</file>

<file path="lib/services/ai_analysis_service.dart">
import 'dart:async';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Simple AI Analysis Service - Supabase only, no local persistence
/// Uses in-memory cache for current session to reduce API calls
class AIAnalysisService {
  final _supabase = SupabaseClientProvider.client;
  
  /// In-memory cache (cleared on app restart)
  final Map<String, AIAnalysis> _sessionCache = {};
  
  /// Pending requests to avoid duplicate API calls
  final Map<String, Future<AIAnalysis?>> _pendingRequests = {};
  
  /// Request AI analysis for a message
  /// Returns cached result if available, otherwise calls Edge Function
  Future<AIAnalysis?> requestAnalysis(
    String messageId,
    String messageBody, {
    List<String>? conversationContext,
  }) async {
    // Check session cache first
    if (_sessionCache.containsKey(messageId)) {
      print('📊 Using cached analysis for $messageId');
      return _sessionCache[messageId];
    }
    
    // Check if request is already in progress
    if (_pendingRequests.containsKey(messageId)) {
      print('⏳ Analysis already in progress for $messageId');
      return _pendingRequests[messageId];
    }
    
    // Make new request
    print('🤖 Requesting new analysis for $messageId');
    final future = _callAnalysisAPI(messageId, messageBody, conversationContext);
    _pendingRequests[messageId] = future;
    
    try {
      final result = await future;
      if (result != null) {
        _sessionCache[messageId] = result;
      }
      return result;
    } finally {
      _pendingRequests.remove(messageId);
    }
  }
  
  /// Call the Edge Function to analyze a message
  Future<AIAnalysis?> _callAnalysisAPI(
    String messageId,
    String messageBody,
    List<String>? conversationContext,
  ) async {
    try {
      final response = await _supabase.functions.invoke(
        'ai_analyze_tone',
        body: {
          'message_id': messageId,
          'message_body': messageBody,
          if (conversationContext != null)
            'conversation_context': conversationContext,
        },
      );
      
      if (response.status != 200) {
        throw Exception('API returned status ${response.status}');
      }
      
      final data = response.data;
      if (data == null || !data['success']) {
        throw Exception(data?['error'] ?? 'Unknown error');
      }
      
      return AIAnalysis.fromJson(data['analysis']);
    } catch (e) {
      print('❌ Analysis request failed: $e');
      return null;
    }
  }
  
  /// Fetch existing analysis from Supabase
  Future<AIAnalysis?> getAnalysis(String messageId) async {
    // Check cache
    if (_sessionCache.containsKey(messageId)) {
      return _sessionCache[messageId];
    }
    
    try {
      final response = await _supabase.rpc(
        'get_message_ai_analysis',
        params: {'p_message_id': messageId},
      );
      
      if (response == null || (response as List).isEmpty) {
        return null;
      }
      
      final analysis = AIAnalysis.fromJson(response[0]);
      _sessionCache[messageId] = analysis;
      return analysis;
    } catch (e) {
      print('❌ Failed to fetch analysis: $e');
      return null;
    }
  }
  
  /// Fetch all analyses for a conversation
  Future<Map<String, AIAnalysis>> getConversationAnalyses(
    String conversationId,
  ) async {
    try {
      final response = await _supabase.rpc(
        'get_conversation_ai_analysis',
        params: {'p_conversation_id': conversationId},
      );
      
      if (response == null || (response as List).isEmpty) {
        return {};
      }
      
      final Map<String, AIAnalysis> analyses = {};
      for (final item in response) {
        final analysis = AIAnalysis.fromJson(item);
        analyses[analysis.messageId] = analysis;
        _sessionCache[analysis.messageId] = analysis; // Cache it
      }
      
      return analyses;
    } catch (e) {
      print('❌ Failed to fetch conversation analyses: $e');
      return {};
    }
  }
  
  /// Clear the session cache
  void clearCache() {
    _sessionCache.clear();
    print('🧹 Analysis cache cleared');
  }
  
  /// Get cache statistics
  Map<String, dynamic> getCacheStats() {
    return {
      'cached_count': _sessionCache.length,
      'pending_count': _pendingRequests.length,
    };
  }
}
</file>

<file path="lib/services/auth_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/services/device_registration_service.dart';
import 'package:messageai/services/notification_service.dart';
import 'package:messageai/core/errors/error_handler.dart';

class AuthService {
  static final AuthService _instance = AuthService._internal();

  factory AuthService() {
    return _instance;
  }

  AuthService._internal();

  final _supabase = SupabaseClientProvider.client;
  final _deviceRegistrationService = DeviceRegistrationService();
  final _notificationService = NotificationService();
  final _errorHandler = ErrorHandler();

  /// Sign up with email and password
  Future<AuthResponse> signUp({
    required String email,
    required String password,
  }) async {
    try {
      print('📝 Attempting sign up for: $email');
      
      final response = await _supabase.auth.signUp(
        email: email,
        password: password,
      );
      
      print('✅ Sign up successful: ${response.user?.id}');
      return response;
    } catch (error, stackTrace) {
      print('❌ Sign up failed: $error');
      throw _errorHandler.handleError(error, stackTrace: stackTrace, context: 'Sign Up');
    }
  }

  /// Sign in with email and password
  Future<AuthResponse> signIn({
    required String email,
    required String password,
  }) async {
    try {
      print('🔐 Attempting sign in for: $email');
      
      final response = await _supabase.auth.signInWithPassword(
        email: email,
        password: password,
      );
      
      print('✅ Sign in successful: ${response.user?.id}');
      return response;
    } catch (error, stackTrace) {
      print('❌ Sign in failed: $error');
      throw _errorHandler.handleError(error, stackTrace: stackTrace, context: 'Sign In');
    }
  }

  /// Sign out
  Future<void> signOut() async {
    try {
      print('👋 Attempting sign out');
      
      // Unregister device token before signing out
      final token = await _notificationService.getDeviceToken();
      if (token != null) {
        try {
          await _deviceRegistrationService.unregisterDeviceToken(token);
          print('✅ Device token unregistered on sign out');
        } catch (e) {
          print('⚠️  Failed to unregister device token: $e');
          // Continue with sign out even if unregistration fails
        }
      }
      
      await _supabase.auth.signOut();
      print('✅ Sign out successful');
    } catch (error, stackTrace) {
      print('❌ Sign out failed: $error');
      throw _errorHandler.handleError(error, stackTrace: stackTrace, context: 'Sign Out');
    }
  }

  /// Get current user
  User? getCurrentUser() {
    return _supabase.auth.currentUser;
  }

  /// Check if user is authenticated
  bool isAuthenticated() {
    return _supabase.auth.currentUser != null;
  }

  /// Get current session
  Session? getCurrentSession() {
    return _supabase.auth.currentSession;
  }
}
</file>

<file path="lib/services/avatar_service.dart">
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:image_picker/image_picker.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_handler.dart';

/// Service for handling avatar uploads and management
class AvatarService {
  static final AvatarService _instance = AvatarService._internal();

  factory AvatarService() {
    return _instance;
  }

  AvatarService._internal();

  final _supabase = SupabaseClientProvider.client;
  final _errorHandler = ErrorHandler();
  final _imagePicker = ImagePicker();

  /// Pick an image from gallery
  Future<XFile?> pickImage() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 512,
        maxHeight: 512,
        imageQuality: 85,
      );
      return image;
    } catch (error, stackTrace) {
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Pick Image',
      );
    }
  }

  /// Pick an image from camera
  Future<XFile?> pickImageFromCamera() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.camera,
        maxWidth: 512,
        maxHeight: 512,
        imageQuality: 85,
      );
      return image;
    } catch (error, stackTrace) {
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Take Photo',
      );
    }
  }

  /// Upload avatar to Supabase Storage and update profile
  Future<String> uploadAvatar(XFile imageFile) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      print('📤 Uploading avatar for user: ${currentUser.id}');

      // Generate unique filename
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final extension = imageFile.path.split('.').last;
      final fileName = '${currentUser.id}/avatar_$timestamp.$extension';

      // Read file bytes
      final Uint8List fileBytes;
      if (kIsWeb) {
        fileBytes = await imageFile.readAsBytes();
      } else {
        fileBytes = await File(imageFile.path).readAsBytes();
      }

      print('📁 File size: ${fileBytes.length} bytes');
      print('📁 File name: $fileName');

      // Delete old avatar if exists
      await _deleteOldAvatar(currentUser.id);

      // Upload to Supabase Storage
      final uploadPath = await _supabase.storage
          .from('avatars')
          .uploadBinary(fileName, fileBytes);

      print('✅ Avatar uploaded: $uploadPath');

      // Get public URL
      final publicUrl = _supabase.storage
          .from('avatars')
          .getPublicUrl(fileName);

      print('🔗 Public URL: $publicUrl');

      // Update profile with new avatar URL
      await _updateProfileAvatar(currentUser.id, publicUrl);

      return publicUrl;
    } catch (error, stackTrace) {
      print('❌ Error uploading avatar: $error');
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Upload Avatar',
      );
    }
  }

  /// Delete old avatar files for a user
  Future<void> _deleteOldAvatar(String userId) async {
    try {
      // List all files in user's folder
      final files = await _supabase.storage
          .from('avatars')
          .list(path: userId);

      // Delete each file
      for (final file in files) {
        final filePath = '$userId/${file.name}';
        await _supabase.storage
            .from('avatars')
            .remove([filePath]);
        print('🗑️  Deleted old avatar: $filePath');
      }
    } catch (e) {
      print('⚠️  Error deleting old avatar (non-critical): $e');
      // Don't throw - old avatar deletion is non-critical
    }
  }

  /// Update profile table with new avatar URL
  Future<void> _updateProfileAvatar(String userId, String avatarUrl) async {
    try {
      await _supabase
          .from('profiles')
          .update({'avatar_url': avatarUrl, 'updated_at': DateTime.now().toIso8601String()})
          .eq('user_id', userId);

      print('✅ Profile updated with new avatar URL');
    } catch (error, stackTrace) {
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Update Profile Avatar',
      );
    }
  }

  /// Get avatar URL for a user
  Future<String?> getAvatarUrl(String userId) async {
    try {
      final response = await _supabase
          .from('profiles')
          .select('avatar_url')
          .eq('user_id', userId)
          .maybeSingle();

      if (response != null && response['avatar_url'] != null) {
        return response['avatar_url'] as String;
      }
      return null;
    } catch (error, stackTrace) {
      print('⚠️  Error fetching avatar URL: $error');
      // Return null instead of throwing - missing avatar is not critical
      return null;
    }
  }

  /// Delete avatar for current user
  Future<void> deleteAvatar() async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      print('🗑️  Deleting avatar for user: ${currentUser.id}');

      // Delete from storage
      await _deleteOldAvatar(currentUser.id);

      // Update profile to remove avatar URL
      await _supabase
          .from('profiles')
          .update({'avatar_url': null, 'updated_at': DateTime.now().toIso8601String()})
          .eq('user_id', currentUser.id);

      print('✅ Avatar deleted successfully');
    } catch (error, stackTrace) {
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Delete Avatar',
      );
    }
  }

  /// Get current user's avatar URL
  Future<String?> getCurrentUserAvatar() async {
    final currentUser = _supabase.auth.currentUser;
    if (currentUser == null) {
      return null;
    }
    return getAvatarUrl(currentUser.id);
  }
}
</file>

<file path="lib/services/conversation_service.dart">
import 'package:uuid/uuid.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';

class ConversationService {
  static final ConversationService _instance =
      ConversationService._internal();

  factory ConversationService() {
    return _instance;
  }

  ConversationService._internal();

  final _db = AppDb.instance;
  final _supabase = SupabaseClientProvider.client;

  /// Create a new conversation
  Future<Conversation> createConversation({
    required String title,
    String? description,
    bool isGroup = false,
  }) async {
    final currentUser = _supabase.auth.currentUser;
    if (currentUser == null) {
      throw 'User not authenticated';
    }

    final now = DateTime.now();
    final timestamp = now.millisecondsSinceEpoch ~/ 1000;
    final conversationId = const Uuid().v4();
    
    final conversation = Conversation(
      id: conversationId,
      title: title,
      description: description,
      createdAt: timestamp,
      updatedAt: timestamp,
      isGroup: isGroup,
      lastMessageAt: timestamp,
      isSynced: false,
    );

    // Save to local database first (optimistic UI)
    await _db.conversationDao.upsertConversation(conversation);

    // Sync to backend
    try {
      // Create conversation in backend
      await _supabase.from('conversations').insert({
        'id': conversationId,
        'title': title,
        'description': description,
        'is_group': isGroup,
        'created_by': currentUser.id,
        'created_at': DateTime.fromMillisecondsSinceEpoch(timestamp * 1000).toIso8601String(),
        'updated_at': DateTime.fromMillisecondsSinceEpoch(timestamp * 1000).toIso8601String(),
      });

      // Add current user as participant
      final participantId = const Uuid().v4();
      await _supabase.from('conversation_participants').insert({
        'id': participantId,
        'conversation_id': conversationId,
        'user_id': currentUser.id,
        'joined_at': DateTime.fromMillisecondsSinceEpoch(timestamp * 1000).toIso8601String(),
      });

      // Save participant locally
      await _db.participantDao.addParticipant(Participant(
        id: participantId,
        conversationId: conversationId,
        userId: currentUser.id,
        joinedAt: timestamp,
        isAdmin: true,
        isSynced: true,
      ));

      // Mark conversation as synced
      await _db.conversationDao.markConversationAsSynced(conversationId);
      
      print('Conversation synced to backend: $conversationId');
    } catch (e) {
      print('Error syncing conversation to backend: $e');
      // Conversation stays in local DB with isSynced=false for retry later
    }

    return conversation;
  }

  /// Sync conversations from backend
  Future<void> syncConversations() async {
    try {
      print('🔄 Syncing conversations from backend...');
      
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        print('❌ User not authenticated, skipping sync');
        return;
      }

      // Fetch conversations where user is a participant
      final response = await _supabase
          .from('conversation_participants')
          .select('conversation_id')
          .eq('user_id', currentUser.id);

      final conversationIds = (response as List)
          .map((p) => p['conversation_id'] as String)
          .toList();

      if (conversationIds.isEmpty) {
        print('ℹ️  No conversations found for user');
        return;
      }

      // Fetch full conversation details
      final conversationsResponse = await _supabase
          .from('conversations')
          .select('*')
          .in_('id', conversationIds);

      print('📥 Fetched ${(conversationsResponse as List).length} conversations from backend');

      // Save to local database
      for (final convData in conversationsResponse) {
        final conversation = Conversation(
          id: convData['id'] as String,
          title: convData['title'] as String,
          description: convData['description'] as String?,
          createdAt: DateTime.parse(convData['created_at'] as String)
              .millisecondsSinceEpoch ~/
              1000,
          updatedAt: DateTime.parse(convData['updated_at'] as String)
              .millisecondsSinceEpoch ~/
              1000,
          isGroup: convData['is_group'] as bool? ?? false,
          lastMessageAt: convData['last_message_at'] != null
              ? DateTime.parse(convData['last_message_at'] as String)
                  .millisecondsSinceEpoch ~/
                  1000
              : DateTime.parse(convData['created_at'] as String)
                  .millisecondsSinceEpoch ~/
                  1000,
          isSynced: true,
        );

        await _db.conversationDao.upsertConversation(conversation);
      }

      print('✅ Conversations synced successfully');
    } catch (e) {
      print('❌ Error syncing conversations: $e');
    }
  }

  /// Get all conversations (with optional sync)
  Future<List<Conversation>> getAllConversations({bool syncFirst = true}) async {
    if (syncFirst) {
      await syncConversations();
    }
    return _db.conversationDao.getAllConversations();
  }

  /// Get recent conversations
  Future<List<Conversation>> getRecentConversations({int limit = 20}) async {
    return _db.conversationDao.getRecentConversations(limit: limit);
  }

  /// Get conversation by ID
  Future<Conversation?> getConversationById(String id) async {
    return _db.conversationDao.getConversationById(id);
  }

  /// Delete conversation (local and remote)
  Future<void> deleteConversation(String id) async {
    final currentUser = _supabase.auth.currentUser;
    print('━' * 60);
    print('🗑️ DELETING CONVERSATION');
    print('━' * 60);
    print('Conversation ID: $id');
    print('User ID: ${currentUser?.id}');
    
    // Delete from local database first
    await _db.conversationDao.deleteConversation(id);
    print('✅ Deleted from local database');
    
    // Try to delete from Supabase
    try {
      print('Attempting to delete from Supabase...');
      
      // Delete from Supabase (CASCADE will delete participants and messages)
      await _supabase
          .from('conversations')
          .delete()
          .eq('id', id);
      
      print('✅ Conversation deleted from backend: $id');
      print('━' * 60);
    } catch (e) {
      print('━' * 60);
      print('❌ ERROR DELETING FROM BACKEND');
      print('━' * 60);
      print('Error: $e');
      print('Error Type: ${e.runtimeType}');
      
      if (e.toString().contains('row-level security')) {
        print('🔒 RLS POLICY BLOCKING DELETE!');
        print('Solution: Run the SQL in FIX_DELETE_CONVERSATION.md');
      }
      
      print('━' * 60);
      // Already deleted locally, so this is non-critical
      // But we should rethrow so the UI can show the error
      rethrow;
    }
  }

  /// Update conversation title
  Future<void> updateConversationTitle(String id, String title) async {
    final conv = await getConversationById(id);
    if (conv != null) {
      final updated = conv.copyWith(
        title: title,
        updatedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );
      await _db.conversationDao.upsertConversation(updated);
    }
  }

  /// Count conversations
  Future<int> getConversationCount() async {
    return _db.conversationDao.getConversationCount();
  }

  /// Sync participants from backend
  Future<void> syncParticipants(String conversationId) async {
    try {
      print('🔄 Syncing participants for conversation: $conversationId');
      
      // Fetch participants from backend
      final response = await _supabase
          .from('conversation_participants')
          .select('*')
          .eq('conversation_id', conversationId);

      print('📥 Fetched ${(response as List).length} participants from backend');

      // Save participants to local database
      for (final partData in response) {
        final participant = Participant(
          id: partData['id'] as String,
          conversationId: partData['conversation_id'] as String,
          userId: partData['user_id'] as String,
          joinedAt: DateTime.parse(partData['joined_at'] as String)
              .millisecondsSinceEpoch ~/
              1000,
          isAdmin: partData['is_admin'] as bool? ?? false,
          isSynced: true,
        );
        
        await _db.participantDao.addParticipant(participant);
      }

      print('✅ Participants synced successfully');
    } catch (e) {
      print('❌ Error syncing participants: $e');
    }
  }

  /// Get participants in a conversation
  Future<List<Participant>> getParticipants(String conversationId, {bool syncFirst = true}) async {
    if (syncFirst) {
      await syncParticipants(conversationId);
    }
    return _db.participantDao.getParticipantsByConversation(conversationId);
  }
  
  /// Get participant profile from Supabase by user ID
  Future<Map<String, dynamic>?> getParticipantProfile(String userId) async {
    try {
      final response = await _supabase
          .from('profiles')
          .select('user_id, username, email, avatar_url, display_name')
          .eq('user_id', userId)
          .single();
      
      return response as Map<String, dynamic>;
    } catch (e) {
      print('Error fetching profile for $userId: $e');
      return null;
    }
  }

  /// Add participant to conversation
  Future<void> addParticipant({
    required String conversationId,
    required String userId,
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final participantId = const Uuid().v4();
    
    final participant = Participant(
      id: participantId,
      conversationId: conversationId,
      userId: userId,
      joinedAt: now,
      isAdmin: false,
      isSynced: false,
    );
    
    // Save to local database first (optimistic UI)
    await _db.participantDao.addParticipant(participant);
    
    // Sync to backend
    try {
      await _supabase.from('conversation_participants').insert({
        'id': participantId,
        'conversation_id': conversationId,
        'user_id': userId,
        'joined_at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
      });
      
      print('Participant added to backend: $userId');
    } catch (e) {
      print('Error syncing participant to backend: $e');
    }
  }

  /// Remove participant from conversation
  Future<void> removeParticipant(String conversationId, String userId) async {
    await _db.participantDao.removeParticipant(conversationId, userId);
  }

  /// Add current user as participant to conversation
  Future<void> addCurrentUserAsParticipant(String conversationId) async {
    // This would typically be called after creating a conversation
    // For now, we'll add the creator automatically in createConversation
  }

  /// Get the latest message for a conversation
  Future<Message?> getLatestMessage(String conversationId) async {
    return _db.messageDao.getLatestMessageForConversation(conversationId);
  }
}
</file>

<file path="lib/services/deep_link_handler.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Handles deep linking and navigation from notifications
class DeepLinkHandler {
  final WidgetRef ref;
  final NavigatorState? navigatorState;

  DeepLinkHandler({
    required this.ref,
    this.navigatorState,
  });

  /// Handle notification tap - navigate to conversation
  Future<void> handleNotificationTap(String conversationId) async {
    try {
      // Navigate to conversation detail screen
      navigatorState?.pushNamed(
        '/conversation/$conversationId',
      );
      print('Navigated to conversation: $conversationId');
    } catch (e) {
      print('Error handling notification tap: $e');
    }
  }

  /// Handle initial message (app terminated)
  Future<void> handleInitialMessage(String conversationId) async {
    try {
      // Wait for app to fully initialize
      await Future.delayed(const Duration(milliseconds: 500));
      
      // Navigate to conversation
      navigatorState?.pushNamedAndRemoveUntil(
        '/conversation/$conversationId',
        ModalRoute.withName('/conversations'),
      );
      print('Navigated from initial message to: $conversationId');
    } catch (e) {
      print('Error handling initial message: $e');
    }
  }

  /// Handle background message (app in background)
  Future<void> handleBackgroundMessage(String conversationId) async {
    try {
      // Just navigate normally
      navigatorState?.pushNamed('/conversation/$conversationId');
      print('Navigated from background message to: $conversationId');
    } catch (e) {
      print('Error handling background message: $e');
    }
  }

  /// Parse notification payload to extract conversation ID
  String? extractConversationId(Map<String, dynamic> data) {
    return data['conversation_id'] as String?;
  }

  /// Parse notification payload to extract message metadata
  Map<String, dynamic> extractMessageMetadata(Map<String, dynamic> data) {
    return {
      'conversation_id': data['conversation_id'],
      'sender_id': data['sender_id'],
      'message_id': data['message_id'],
      'sender_name': data['sender_name'],
    };
  }
}

/// Notification route arguments
class NotificationRouteArgs {
  final String conversationId;
  final String? senderId;
  final String? messageId;
  final String? senderName;

  NotificationRouteArgs({
    required this.conversationId,
    this.senderId,
    this.messageId,
    this.senderName,
  });

  factory NotificationRouteArgs.fromPayload(Map<String, dynamic> payload) {
    return NotificationRouteArgs(
      conversationId: payload['conversation_id'] as String,
      senderId: payload['sender_id'] as String?,
      messageId: payload['message_id'] as String?,
      senderName: payload['sender_name'] as String?,
    );
  }
}

/// Generate named route for conversation
String conversationRoute(String conversationId) => '/conversation/$conversationId';

/// Parse conversation ID from route
String? parseConversationIdFromRoute(String route) {
  if (route.startsWith('/conversation/')) {
    return route.replaceFirst('/conversation/', '');
  }
  return null;
}
</file>

<file path="lib/services/device_registration_service.dart">
import 'dart:io' show Platform;
import 'package:messageai/data/remote/supabase_client.dart';

/// Service for registering and managing device tokens with the backend
class DeviceRegistrationService {
  /// Register or update device token in Supabase
  Future<void> registerDeviceToken(String token) async {
    try {
      final supabase = SupabaseClientProvider.client;
      final userId = supabase.auth.currentUser?.id;
      
      if (userId == null) {
        print('⚠️ Cannot register device: user not authenticated');
        throw Exception('User not authenticated');
      }
      
      // Determine platform
      String platform;
      if (Platform.isIOS) {
        platform = 'ios';
      } else if (Platform.isAndroid) {
        platform = 'android';
      } else {
        platform = 'web';
      }
      
      print('📱 Registering device token...');
      print('   User ID: $userId');
      print('   Platform: $platform');
      print('   Token: ${token.substring(0, 20)}...');
      
      // Upsert device (insert or update if token already exists)
      // This handles both new registrations and token refreshes
      await supabase.from('profile_devices').upsert({
        'user_id': userId,
        'fcm_token': token,
        'platform': platform,
        'last_seen': DateTime.now().toIso8601String(),
      }, onConflict: 'fcm_token');
      
      print('✅ Device token registered successfully!');
    } catch (e) {
      print('❌ Failed to register device token: $e');
      rethrow;
    }
  }
  
  /// Unregister device token (e.g., on logout)
  Future<void> unregisterDeviceToken(String token) async {
    try {
      final supabase = SupabaseClientProvider.client;
      
      print('🗑️ Unregistering device token...');
      
      await supabase
          .from('profile_devices')
          .delete()
          .eq('fcm_token', token);
      
      print('✅ Device token unregistered');
    } catch (e) {
      print('❌ Failed to unregister device token: $e');
      rethrow;
    }
  }
  
  /// Update last seen timestamp for device
  Future<void> updateDeviceLastSeen(String token) async {
    try {
      final supabase = SupabaseClientProvider.client;
      
      print('🔄 Updating last_seen for token: ${token.substring(0, 20)}...');
      
      final response = await supabase
          .from('profile_devices')
          .update({
            'last_seen': DateTime.now().toIso8601String(),
          })
          .eq('fcm_token', token)
          .select();
      
      if (response.isEmpty) {
        print('⚠️ No device found with that token - device may not be registered');
      } else {
        print('✅ Device last_seen updated successfully');
      }
    } catch (e) {
      print('❌ Failed to update device last_seen: $e');
      // Don't rethrow - this is not critical
    }
  }
}
</file>

<file path="lib/services/local_notification_service.dart">
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter/material.dart';

/// Local notification service for displaying notifications in foreground
class LocalNotificationService {
  static const String _channelId = 'messages';
  static const String _channelName = 'Message Notifications';
  
  final FlutterLocalNotificationsPlugin _plugin;

  LocalNotificationService({FlutterLocalNotificationsPlugin? plugin})
      : _plugin = plugin ?? FlutterLocalNotificationsPlugin();

  /// Initialize local notifications
  Future<void> initialize() async {
    try {
      // Android initialization
      const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');

      // iOS initialization
      const iosSettings = DarwinInitializationSettings(
        requestAlertPermission: true,
        requestBadgePermission: true,
        requestSoundPermission: true,
      );

      const settings = InitializationSettings(
        android: androidSettings,
        iOS: iosSettings,
      );

      await _plugin.initialize(settings);
      print('Local notifications initialized');
    } catch (e) {
      print('Error initializing local notifications: $e');
    }
  }

  /// Show a notification
  Future<void> showNotification({
    required int id,
    required String title,
    required String body,
    String? payload,
  }) async {
    try {
      // Android notification details
      const androidDetails = AndroidNotificationDetails(
        _channelId,
        _channelName,
        channelDescription: 'Notifications for incoming messages',
        importance: Importance.max,
        priority: Priority.high,
        showWhen: true,
        enableVibration: true,
        playSound: true,
        icon: '@mipmap/ic_launcher',
      );

      // iOS notification details
      const iosDetails = DarwinNotificationDetails(
        presentAlert: true,
        presentBadge: true,
        presentSound: true,
        badgeNumber: 1,
      );

      const details = NotificationDetails(
        android: androidDetails,
        iOS: iosDetails,
      );

      await _plugin.show(
        id,
        title,
        body,
        details,
        payload: payload,
      );

      print('Notification shown: $title - $body');
    } catch (e) {
      print('Error showing notification: $e');
    }
  }

  /// Show message notification
  Future<void> showMessageNotification({
    required String conversationId,
    required String senderName,
    required String messageBody,
  }) async {
    final id = conversationId.hashCode % 100000;
    await showNotification(
      id: id,
      title: senderName,
      body: messageBody,
      payload: conversationId,
    );
  }

  /// Cancel a notification
  Future<void> cancelNotification(int id) async {
    try {
      await _plugin.cancel(id);
    } catch (e) {
      print('Error canceling notification: $e');
    }
  }

  /// Cancel all notifications
  Future<void> cancelAllNotifications() async {
    try {
      await _plugin.cancelAll();
    } catch (e) {
      print('Error canceling all notifications: $e');
    }
  }

  /// Get pending notifications
  Future<List<PendingNotificationRequest>> getPendingNotifications() async {
    try {
      return await _plugin.pendingNotificationRequests();
    } catch (e) {
      print('Error getting pending notifications: $e');
      return [];
    }
  }

  /// Setup notification response handler
  void setupNotificationResponseHandler({
    required Function(String) onNotificationTapped,
  }) {
    _plugin.getNotificationAppLaunchDetails().then((details) {
      if (details?.didNotificationLaunchApp ?? false) {
        final payload = details?.notificationResponse?.payload;
        if (payload != null) {
          onNotificationTapped(payload);
        }
      }
    });

    // Listen for notification taps in foreground
  }

  /// Request notification permissions (Android 13+)
  Future<bool> requestPermissions() async {
    try {
      final result = await _plugin
          .resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin>()
          ?.requestNotificationsPermission();
      return result ?? false;
    } catch (e) {
      print('Error requesting permissions: $e');
      return false;
    }
  }
}
</file>

<file path="lib/services/media_service.dart">
import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path/path.dart' as p;
import 'package:uuid/uuid.dart';
import 'package:messageai/state/providers.dart';

/// Media upload progress
class MediaUploadProgress {
  final int bytesTransferred;
  final int totalBytes;
  
  MediaUploadProgress({
    required this.bytesTransferred,
    required this.totalBytes,
  });
  
  double get progress => totalBytes > 0 ? bytesTransferred / totalBytes : 0;
  double get percentage => progress * 100;
}

/// Media service for handling uploads
class MediaService {
  final Ref ref;
  
  static const String _mediaBucket = 'media';
  static const String _avatarBucket = 'avatars';
  
  MediaService({required this.ref});

  /// Pick image from gallery
  Future<XFile?> pickImageFromGallery() async {
    final picker = ImagePicker();
    return picker.pickImage(source: ImageSource.gallery);
  }

  /// Pick image from camera
  Future<XFile?> pickImageFromCamera() async {
    final picker = ImagePicker();
    return picker.pickImage(source: ImageSource.camera);
  }

  /// Upload image to Supabase Storage
  Future<String> uploadImage(XFile file, {String bucket = 'media'}) async {
    final supabase = ref.watch(supabaseClientProvider);
    final userId = supabase.auth.currentUser?.id;
    
    if (userId == null) {
      throw Exception('User not authenticated');
    }
    
    try {
      // Generate unique filename
      const uuid = Uuid();
      final fileName = '${uuid.v4()}_${p.basename(file.path)}';
      final path = '$userId/$fileName';
      
      // Read file bytes
      final fileBytes = await file.readAsBytes();
      
      // Upload to storage
      await supabase.storage
          .from(bucket)
          .uploadBinary(
            path,
            fileBytes,
            fileOptions: const FileOptions(cacheControl: '3600'),
          );
      
      // Get public URL
      final url = supabase.storage
          .from(bucket)
          .getPublicUrl(path);
      
      return url;
    } catch (e) {
      print('Error uploading image: $e');
      rethrow;
    }
  }
  
  /// Upload avatar image
  Future<String> uploadAvatar(XFile file) async {
    return uploadImage(file, bucket: _avatarBucket);
  }

  /// Upload image with progress tracking
  Future<String> uploadImageWithProgress(
    XFile file,
    Function(MediaUploadProgress) onProgress,
  ) async {
    final supabase = ref.watch(supabaseClientProvider);
    
    try {
      // Generate unique filename
      const uuid = Uuid();
      final fileName = '${uuid.v4()}_${p.basename(file.path)}';
      final path = 'conversations/$fileName';
      
      // Read file bytes
      final fileBytes = await file.readAsBytes();
      final totalBytes = fileBytes.length;
      
      // Simulate progress (Supabase doesn't provide built-in progress)
      // In production, use a dedicated upload library
      int bytesTransferred = 0;
      
      // Upload to storage
      await supabase.storage
          .from(_mediaBucket)
          .uploadBinary(
            path,
            fileBytes,
            fileOptions: const FileOptions(cacheControl: '3600'),
          );
      
      bytesTransferred = totalBytes;
      onProgress(MediaUploadProgress(
        bytesTransferred: bytesTransferred,
        totalBytes: totalBytes,
      ));
      
      // Get public URL
      final url = supabase.storage
          .from(_mediaBucket)
          .getPublicUrl(path);
      
      return url;
    } catch (e) {
      print('Error uploading image with progress: $e');
      rethrow;
    }
  }

  /// Delete image from storage
  Future<void> deleteImage(String url) async {
    final supabase = ref.watch(supabaseClientProvider);
    
    try {
      // Extract path from URL
      final uri = Uri.parse(url);
      final pathSegments = uri.pathSegments;
      final path = pathSegments.sublist(4).join('/'); // Skip storage, v1, object, public
      
      await supabase.storage.from(_mediaBucket).remove([path]);
    } catch (e) {
      print('Error deleting image: $e');
    }
  }

  /// Compress image before upload
  Future<File> compressImage(XFile file, {int quality = 85}) async {
    // TODO: Implement image compression using image package
    // For now, return original file
    return File(file.path);
  }
}

/// Provider for media service
final mediaServiceProvider = Provider<MediaService>((ref) {
  return MediaService(ref: ref);
});

/// State notifier for handling media uploads
class MediaUploadNotifier extends StateNotifier<AsyncValue<String>> {
  final Ref ref;

  MediaUploadNotifier({required this.ref}) : super(const AsyncValue.data(''));

  /// Upload image
  Future<String> uploadImage(XFile file) async {
    state = const AsyncValue.loading();
    
    try {
      final mediaService = ref.watch(mediaServiceProvider);
      final url = await mediaService.uploadImage(file);
      state = AsyncValue.data(url);
      return url;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }

  /// Upload image with progress
  Future<String> uploadImageWithProgress(
    XFile file,
    Function(MediaUploadProgress) onProgress,
  ) async {
    state = const AsyncValue.loading();
    
    try {
      final mediaService = ref.watch(mediaServiceProvider);
      final url = await mediaService.uploadImageWithProgress(file, onProgress);
      state = AsyncValue.data(url);
      return url;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }
}

/// State notifier provider for media uploads
final mediaUploadNotifierProvider =
    StateNotifierProvider<MediaUploadNotifier, AsyncValue<String>>((ref) {
  return MediaUploadNotifier(ref: ref);
});
</file>

<file path="lib/services/message_service.dart">
import 'package:uuid/uuid.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/core/errors/error_handler.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/services/ai_analysis_service.dart';

class MessageService {
  static final MessageService _instance = MessageService._internal();

  factory MessageService() {
    return _instance;
  }

  MessageService._internal();

  final _db = AppDb.instance;
  final _supabase = SupabaseClientProvider.client;
  final _errorHandler = ErrorHandler();
  final _aiAnalysis = AIAnalysisService();
  
  // Callback for when message is successfully sent (for triggering push notifications)
  void Function(String conversationId, String messageId)? onMessageSent;

  /// Send a new message
  Future<Message> sendMessage({
    required String conversationId,
    required String body,
    String? mediaUrl,
  }) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final messageId = const Uuid().v4();
      
      final message = Message(
        id: messageId,
        conversationId: conversationId,
        senderId: currentUser.id,
        body: body,
        mediaUrl: mediaUrl,
        createdAt: now,
        updatedAt: now,
        isSynced: false,
      );

      // Save to local database first (optimistic UI)
      try {
        await _db.messageDao.upsertMessage(message);
        await _db.conversationDao.updateLastMessageTime(conversationId);
      } catch (error, stackTrace) {
        // Critical: Can't even save locally
        throw _errorHandler.handleError(
          error, 
          stackTrace: stackTrace, 
          context: 'Save Message Locally',
        );
      }

      // Sync to backend
      try {
        final payload = {
          'id': messageId,
          'conversation_id': conversationId,
          'sender_id': currentUser.id,
          'body': body,
          'media_url': mediaUrl,
          'created_at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
          'updated_at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
        };
        
        await _supabase.from('messages').insert(payload);
        await _db.messageDao.markMessageAsSynced(messageId);
        
        // Trigger push notifications (don't wait for it)
        _sendPushNotification(conversationId, messageId, body).catchError((e) {
          print('⚠️ Push notification failed: $e');
        });
        
        // Trigger AI analysis for sent messages (don't wait for it)
        _triggerAIAnalysis(messageId, body).catchError((e) {
          print('⚠️ AI analysis failed: $e');
        });
      } catch (error, stackTrace) {
        // Convert to AppError
        final appError = _errorHandler.handleError(
          error, 
          stackTrace: stackTrace, 
          context: 'Send Message',
        );
        
        // If it's a network error, message is saved locally for retry
        if (_errorHandler.isNetworkError(appError)) {
          // Don't throw - message will sync later
        } else if (!appError.isRetryable) {
          // For non-retryable errors (like unauthorized), delete the local message
          await _db.messageDao.deleteMessage(messageId);
          throw appError;
        } else {
          // For other errors, throw so UI can handle
          throw appError;
        }
      }

      return message;
    } catch (error, stackTrace) {
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error, 
        stackTrace: stackTrace, 
        context: 'Send Message',
      );
    }
  }

  /// Sync messages from backend for a conversation
  Future<void> syncMessages(String conversationId) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      // Fetch messages from backend ordered by created_at
      final response = await _supabase
          .from('messages')
          .select('*')
          .eq('conversation_id', conversationId)
          .order('created_at', ascending: true);

      // Save to local database with proper timestamps
      for (final msgData in response as List) {
        final createdAt = DateTime.parse(msgData['created_at'] as String);
        final updatedAt = DateTime.parse(msgData['updated_at'] as String);
        
        final message = Message(
          id: msgData['id'] as String,
          conversationId: msgData['conversation_id'] as String,
          senderId: msgData['sender_id'] as String,
          body: msgData['body'] as String,
          mediaUrl: msgData['media_url'] as String?,
          createdAt: createdAt.millisecondsSinceEpoch ~/ 1000,
          updatedAt: updatedAt.millisecondsSinceEpoch ~/ 1000,
          isSynced: true,
        );

        // Use upsert to avoid duplicates
        await _db.messageDao.upsertMessage(message);
      }
    } catch (error, stackTrace) {
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error, 
        stackTrace: stackTrace, 
        context: 'Sync Messages',
      );
    }
  }

  /// Get messages for a conversation (with optional sync)
  Future<List<Message>> getMessagesByConversation(
    String conversationId, {
    bool syncFirst = false,
  }) async {
    if (syncFirst) {
      await syncMessages(conversationId);
    }
    return _db.messageDao.getMessagesByConversation(conversationId);
  }

  /// Get recent messages for a conversation
  Future<List<Message>> getRecentMessages(String conversationId, {int limit = 50}) async {
    return _db.messageDao.getRecentMessages(conversationId, limit: limit);
  }

  /// Get message by ID
  Future<Message?> getMessageById(String id) async {
    return _db.messageDao.getMessageById(id);
  }

  /// Delete message
  Future<void> deleteMessage(String id) async {
    await _db.messageDao.deleteMessage(id);
  }

  /// Get current user ID
  String? getCurrentUserId() {
    return _supabase.auth.currentUser?.id;
  }

  /// Send push notification for new message
  Future<void> _sendPushNotification(
    String conversationId,
    String messageId,
    String messageBody,
  ) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) return;

      // Get sender profile for notification (use maybeSingle to handle missing profile)
      final profile = await _supabase
          .from('profiles')
          .select('username, email')
          .eq('user_id', currentUser.id)
          .maybeSingle();

      final senderName = profile?['username'] as String? ?? 
                         profile?['email'] as String? ?? 
                         currentUser.email ?? 
                         'Someone';

      // Call push notification edge function with auth header
      final accessToken = _supabase.auth.currentSession?.accessToken;
      if (accessToken == null) return;
      
      print('🔔 Sending push notification for message: ${messageId.substring(0, 8)}');
      final response = await _supabase.functions.invoke(
        'push_notify',
        body: {
          'message_id': messageId,
          'conversation_id': conversationId,
          'sender_id': currentUser.id,
          'sender_name': senderName,
          'title': senderName,
          'body': messageBody,
        },
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      );
      print('✅ Push notification sent: ${response.data}');
    } catch (e) {
      print('❌ Failed to send push notification: $e');
    }
  }
  
  /// Trigger AI analysis for a message (non-blocking)
  Future<void> _triggerAIAnalysis(String messageId, String messageBody) async {
    try {
      final analysis = await _aiAnalysis.requestAnalysis(messageId, messageBody);
      if (analysis != null) {
        print('✨ AI analysis completed for ${messageId.substring(0, 8)}: ${analysis.tone}');
      }
    } catch (e) {
      print('⚠️ AI analysis failed for ${messageId.substring(0, 8)}: $e');
    }
  }
}
</file>

<file path="lib/services/network_connectivity_service.dart">
import 'dart:async';
import 'package:flutter/foundation.dart';

/// Network connectivity states
enum ConnectivityStatus {
  online,
  offline,
  unknown,
}

/// Service for monitoring network connectivity
/// Note: For production, consider using connectivity_plus package
class NetworkConnectivityService {
  static final NetworkConnectivityService _instance =
      NetworkConnectivityService._internal();

  factory NetworkConnectivityService() {
    return _instance;
  }

  NetworkConnectivityService._internal();

  final _statusController = StreamController<ConnectivityStatus>.broadcast();
  ConnectivityStatus _currentStatus = ConnectivityStatus.unknown;
  Timer? _pingTimer;
  bool _isMonitoring = false;

  /// Get current connectivity status
  ConnectivityStatus get currentStatus => _currentStatus;

  /// Stream of connectivity status changes
  Stream<ConnectivityStatus> get onStatusChange => _statusController.stream;

  /// Check if currently online
  bool get isOnline => _currentStatus == ConnectivityStatus.online;

  /// Check if currently offline
  bool get isOffline => _currentStatus == ConnectivityStatus.offline;

  /// Start monitoring connectivity
  void startMonitoring({Duration checkInterval = const Duration(seconds: 10)}) {
    if (_isMonitoring) {
      print('⚠️  Connectivity monitoring already started');
      return;
    }

    _isMonitoring = true;
    print('🌐 Starting connectivity monitoring (every ${checkInterval.inSeconds}s)');

    // Check immediately
    _checkConnectivity();

    // Then check periodically
    _pingTimer = Timer.periodic(checkInterval, (_) {
      _checkConnectivity();
    });
  }

  /// Stop monitoring connectivity
  void stopMonitoring() {
    _pingTimer?.cancel();
    _pingTimer = null;
    _isMonitoring = false;
    print('🌐 Stopped connectivity monitoring');
  }

  /// Check connectivity status
  Future<void> _checkConnectivity() async {
    try {
      // Simple connectivity check
      // In production, use connectivity_plus package for better detection
      final previousStatus = _currentStatus;
      final newStatus = await _performConnectivityCheck();

      if (newStatus != previousStatus) {
        _currentStatus = newStatus;
        _statusController.add(_currentStatus);
        _logStatusChange(previousStatus, newStatus);
      }
    } catch (e) {
      print('❌ Error checking connectivity: $e');
    }
  }

  /// Perform actual connectivity check
  /// Override this method to use connectivity_plus or other packages
  Future<ConnectivityStatus> _performConnectivityCheck() async {
    try {
      // For now, we assume online unless explicitly set offline
      // In production, use connectivity_plus to check actual network state
      
      // You can enhance this by:
      // 1. Using connectivity_plus package
      // 2. Pinging a known endpoint
      // 3. Checking platform-specific APIs
      
      return ConnectivityStatus.online;
    } catch (e) {
      return ConnectivityStatus.offline;
    }
  }

  /// Manually set connectivity status (useful for testing)
  void setStatus(ConnectivityStatus status) {
    if (_currentStatus != status) {
      final previousStatus = _currentStatus;
      _currentStatus = status;
      _statusController.add(_currentStatus);
      _logStatusChange(previousStatus, status);
    }
  }

  /// Force a connectivity check now
  Future<ConnectivityStatus> checkNow() async {
    final status = await _performConnectivityCheck();
    if (status != _currentStatus) {
      final previousStatus = _currentStatus;
      _currentStatus = status;
      _statusController.add(_currentStatus);
      _logStatusChange(previousStatus, status);
    }
    return _currentStatus;
  }

  /// Log status changes
  void _logStatusChange(
    ConnectivityStatus previous,
    ConnectivityStatus current,
  ) {
    final emoji = current == ConnectivityStatus.online ? '✅' : '📴';
    print('$emoji Connectivity: ${previous.name} → ${current.name}');
  }

  /// Dispose resources
  void dispose() {
    stopMonitoring();
    _statusController.close();
  }
}

/// Extension for convenience methods
extension ConnectivityStatusExtension on ConnectivityStatus {
  bool get isOnline => this == ConnectivityStatus.online;
  bool get isOffline => this == ConnectivityStatus.offline;
  bool get isUnknown => this == ConnectivityStatus.unknown;
}
</file>

<file path="lib/services/notification_service.dart">
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/foundation.dart' show kIsWeb;

/// Notification payload model
class NotificationPayload {
  final String? title;
  final String? body;
  final Map<String, dynamic> data;
  final String? messageId;

  NotificationPayload({
    this.title,
    this.body,
    required this.data,
    this.messageId,
  });

  /// Extract conversation ID from payload
  String? get conversationId => data['conversation_id'] as String?;

  /// Extract sender ID from payload
  String? get senderId => data['sender_id'] as String?;

  /// Extract message ID from payload
  String? get messageIdFromPayload => data['message_id'] as String?;

  /// Extract message body from payload
  String? get messageBody => data['message_body'] as String?;
}

/// Firebase Cloud Messaging service
class NotificationService {
  final FirebaseMessaging _messaging = FirebaseMessaging.instance;
  
  static const String _channelId = 'messages';
  static const String _channelName = 'Message Notifications';

  /// Initialize Firebase Messaging
  Future<void> initialize({
    required Function(NotificationPayload) onMessageReceived,
    required Function(String) onTokenRefresh,
  }) async {
    print('🔔 ========================================');
    print('🔔 INITIALIZING FIREBASE MESSAGING');
    print('🔔 ========================================');
    
    // Skip Firebase Messaging on web due to compatibility issues
    if (kIsWeb) {
      print('⚠️  Firebase Messaging not supported on web platform');
      return;
    }
    
    print('📱 Platform: Mobile (FCM supported)');
    
    try {
      print('📝 Requesting notification permissions...');
      // Request notification permissions
      final settings = await _messaging.requestPermission(
        alert: true,
        announcement: false,
        badge: true,
        criticalAlert: false,
        provisional: false,
        sound: true,
      );

      print('✅ Permission status: ${settings.authorizationStatus}');

      // Get initial token
      print('📱 Getting FCM device token...');
      final token = await getDeviceToken();
      if (token != null) {
        print('✅ FCM Token obtained: ${token.substring(0, 50)}...');
        print('   Full token: $token');
      } else {
        print('⚠️  No FCM token obtained');
      }

      // Listen for token refresh
      FirebaseMessaging.instance.onTokenRefresh.listen((newToken) {
        print('FCM Token refreshed: $newToken');
        onTokenRefresh(newToken);
      });

      // Listen for foreground messages
      FirebaseMessaging.onMessage.listen((RemoteMessage message) {
        print('Got a message whilst in the foreground!');
        print('Message data: ${message.data}');

        final payload = NotificationPayload(
          title: message.notification?.title,
          body: message.notification?.body,
          data: message.data,
          messageId: message.messageId,
        );

        onMessageReceived(payload);
      });

      // Handle background message (top-level function)
      // This should be registered before the app starts
    } catch (e, stackTrace) {
      print('❌ ========================================');
      print('❌ ERROR INITIALIZING FIREBASE MESSAGING');
      print('❌ ========================================');
      print('Error: $e');
      print('Stack trace: $stackTrace');
      print('❌ ========================================');
    }
  }

  /// Get device token for sending notifications
  Future<String?> getDeviceToken() async {
    if (kIsWeb) return null;
    
    try {
      final token = await _messaging.getToken();
      return token;
    } catch (e) {
      print('Error getting device token: $e');
      return null;
    }
  }

  /// Subscribe to a topic
  Future<void> subscribeToTopic(String topic) async {
    if (kIsWeb) return;
    
    try {
      await _messaging.subscribeToTopic(topic);
      print('Subscribed to topic: $topic');
    } catch (e) {
      print('Error subscribing to topic: $e');
    }
  }

  /// Unsubscribe from a topic
  Future<void> unsubscribeFromTopic(String topic) async {
    if (kIsWeb) return;
    
    try {
      await _messaging.unsubscribeFromTopic(topic);
      print('Unsubscribed from topic: $topic');
    } catch (e) {
      print('Error unsubscribing from topic: $e');
    }
  }

  /// Check if notifications are enabled
  Future<bool> areNotificationsEnabled() async {
    if (kIsWeb) return false;
    
    try {
      final settings = await _messaging.getNotificationSettings();
      return settings.authorizationStatus == AuthorizationStatus.authorized;
    } catch (e) {
      print('Error checking notification settings: $e');
      return false;
    }
  }

  /// Handle notification tap
  Future<void> setupNotificationTapHandler({
    required Function(String) onNotificationTapped,
  }) async {
    if (kIsWeb) return;
    
    try {
      // When the app is in foreground and user taps notification
      FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
        print('Notification tapped: ${message.data}');
        final conversationId = message.data['conversation_id'] as String?;
        if (conversationId != null) {
          onNotificationTapped(conversationId);
        }
      });

      // Check if app was opened from a notification when app was terminated
      final initialMessage = await _messaging.getInitialMessage();
      if (initialMessage != null) {
        print('App opened from notification: ${initialMessage.data}');
        final conversationId = initialMessage.data['conversation_id'] as String?;
        if (conversationId != null) {
          onNotificationTapped(conversationId);
        }
      }
    } catch (e) {
      print('Error setting up notification tap handler: $e');
    }
  }
}

/// Provider for notification service
final notificationServiceProvider = Provider<NotificationService>((ref) {
  return NotificationService();
});

/// Store device token
final deviceTokenProvider = StateProvider<String?>((ref) {
  return null;
});

/// Handle notification reception
final notificationHandlerProvider = FutureProvider<void>((ref) async {
  final service = ref.watch(notificationServiceProvider);
  
  // This would be called after the service is initialized
  // Placeholder for notification setup
});
</file>

<file path="lib/services/offline_queue_service.dart">
import 'dart:async';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/services/network_connectivity_service.dart';
import 'package:messageai/services/retry_service.dart';
import 'package:messageai/core/errors/app_error.dart';

/// Service for managing offline message queue and auto-sync
class OfflineQueueService {
  static final OfflineQueueService _instance =
      OfflineQueueService._internal();

  factory OfflineQueueService() {
    return _instance;
  }

  OfflineQueueService._internal();

  final _db = AppDb.instance;
  final _supabase = SupabaseClientProvider.client;
  final _connectivityService = NetworkConnectivityService();
  final _retryService = RetryService();

  StreamSubscription<ConnectivityStatus>? _connectivitySubscription;
  Timer? _syncTimer;
  bool _isSyncing = false;
  bool _isMonitoring = false;

  /// Start monitoring and auto-syncing
  void startMonitoring() {
    if (_isMonitoring) {
      return;
    }

    _isMonitoring = true;

    // Listen for connectivity changes - only sync when coming back online
    _connectivitySubscription = _connectivityService.onStatusChange.listen((status) {
      if (status == ConnectivityStatus.online) {
        syncPendingMessages();
      }
    });

    // No periodic polling - sync only happens:
    // 1. When connectivity is restored
    // 2. When explicitly requested (e.g., after sending a message)
  }

  /// Stop monitoring
  void stopMonitoring() {
    _connectivitySubscription?.cancel();
    _connectivitySubscription = null;
    _syncTimer?.cancel();
    _syncTimer = null;
    _isMonitoring = false;
    print('📦 Stopped offline queue monitoring');
  }

  /// Get count of pending messages
  Future<int> getPendingMessageCount() async {
    try {
      final messages = await _db.messageDao.getUnsyncedMessages();
      return messages.length;
    } catch (e) {
      print('❌ Error getting pending message count: $e');
      return 0;
    }
  }

  /// Sync all pending messages
  Future<SyncResult> syncPendingMessages() async {
    if (_isSyncing) {
      return SyncResult.alreadyRunning();
    }

    if (_connectivityService.isOffline) {
      return SyncResult.offline();
    }

    _isSyncing = true;
    int successCount = 0;
    int failureCount = 0;
    final List<String> failedMessageIds = [];

    try {
      final pendingMessages = await _db.messageDao.getUnsyncedMessages();

      if (pendingMessages.isEmpty) {
        return SyncResult.noMessages();
      }

      for (final message in pendingMessages) {
        final result = await _syncSingleMessage(message);
        if (result) {
          successCount++;
        } else {
          failureCount++;
          failedMessageIds.add(message.id);
        }
      }

      if (failureCount > 0) {
        print('⚠️ Sync: $successCount succeeded, $failureCount failed');
      }

      return SyncResult(
        totalMessages: pendingMessages.length,
        successCount: successCount,
        failureCount: failureCount,
        failedMessageIds: failedMessageIds,
      );
    } catch (e) {
      print('❌ Error syncing: $e');
      return SyncResult.error(e.toString());
    } finally {
      _isSyncing = false;
    }
  }

  /// Sync a single message with retry
  Future<bool> _syncSingleMessage(Message message) async {
    try {
      final result = await _retryService.execute(
        operation: () => _sendMessageToBackend(message),
        operationName: 'Sync Message ${message.id.substring(0, 8)}',
        config: RetryConfig.defaultConfig,
      );

      if (result.succeeded) {
        await _db.messageDao.markMessageAsSynced(message.id);
        return true;
      } else {
        final error = result.error;
        
        // If error is non-retryable, delete the message from queue
        if (error != null && !error.isRetryable) {
          print('🗑️ Removed invalid message: ${error.code}');
          await _db.messageDao.deleteMessage(message.id);
          return true;
        }
        
        return false;
      }
    } catch (e) {
      return false;
    }
  }

  /// Send message to backend
  Future<void> _sendMessageToBackend(Message message) async {
    final payload = {
      'id': message.id,
      'conversation_id': message.conversationId,
      'sender_id': message.senderId,
      'body': message.body,
      'media_url': message.mediaUrl,
      'created_at': DateTime.fromMillisecondsSinceEpoch(message.createdAt * 1000)
          .toIso8601String(),
      'updated_at': DateTime.fromMillisecondsSinceEpoch(message.updatedAt * 1000)
          .toIso8601String(),
    };

    await _supabase.from('messages').insert(payload);
    
    // Send push notification (don't wait for it)
    _sendPushNotification(message).catchError((e) {
      // Silently fail - push notifications are not critical
    });
  }

  /// Send push notification for message
  Future<void> _sendPushNotification(Message message) async {
    try {
      // Get sender profile (use maybeSingle to handle missing profile)
      final profile = await _supabase
          .from('profiles')
          .select('username, email')
          .eq('user_id', message.senderId)
          .maybeSingle();

      final senderName = profile?['username'] as String? ?? 
                         profile?['email'] as String? ?? 
                         'Someone';

      // Call push notification edge function with auth header
      final accessToken = _supabase.auth.currentSession?.accessToken;
      if (accessToken == null) return;
      
      await _supabase.functions.invoke(
        'push_notify',
        body: {
          'message_id': message.id,
          'conversation_id': message.conversationId,
          'sender_id': message.senderId,
          'sender_name': senderName,
          'title': senderName,
          'body': message.body,
        },
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      );
    } catch (e) {
      // Ignore errors
    }
  }

  /// Force sync now (called by user action)
  Future<SyncResult> forceSyncNow() async {
    print('🔄 Force sync requested');
    return await syncPendingMessages();
  }

  /// Check if any messages are pending
  Future<bool> hasPendingMessages() async {
    final count = await getPendingMessageCount();
    return count > 0;
  }

  /// Dispose resources
  void dispose() {
    stopMonitoring();
  }
}

/// Result of sync operation
class SyncResult {
  final int totalMessages;
  final int successCount;
  final int failureCount;
  final List<String> failedMessageIds;
  final String? errorMessage;
  final SyncStatus status;

  SyncResult({
    required this.totalMessages,
    required this.successCount,
    required this.failureCount,
    this.failedMessageIds = const [],
    this.errorMessage,
    this.status = SyncStatus.completed,
  });

  SyncResult.noMessages()
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          status: SyncStatus.noMessages,
        );

  SyncResult.offline()
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          status: SyncStatus.offline,
        );

  SyncResult.alreadyRunning()
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          status: SyncStatus.alreadyRunning,
        );

  SyncResult.error(String message)
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          errorMessage: message,
          status: SyncStatus.error,
        );

  bool get hasErrors => failureCount > 0 || errorMessage != null;
  bool get isSuccess => failureCount == 0 && errorMessage == null;
  bool get isPartialSuccess => successCount > 0 && failureCount > 0;
}

/// Status of sync operation
enum SyncStatus {
  completed,
  noMessages,
  offline,
  alreadyRunning,
  error,
}
</file>

<file path="lib/services/presence_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Service for tracking user presence and online status
class PresenceService {
  static final PresenceService _instance = PresenceService._internal();

  factory PresenceService() {
    return _instance;
  }

  PresenceService._internal();

  final _supabase = SupabaseClientProvider.client;
  final Map<String, RealtimeChannel> _channels = {};
  final Map<String, Set<String>> _onlineUsers = {};

  /// Subscribe to presence updates for a conversation
  Future<void> subscribeToPresence(String conversationId) async {
    if (_channels.containsKey(conversationId)) {
      return; // Already subscribed
    }

    final channel = _supabase.realtime.channel('presence:$conversationId');

    // Listen for presence events using the 'on' method
    channel.on(RealtimeListenTypes.presence, ChannelFilter(event: 'sync'), (payload, [ref]) {
      print('👥 Presence sync for $conversationId');
      _updateOnlineUsers(conversationId, channel);
    });

    channel.on(RealtimeListenTypes.presence, ChannelFilter(event: 'join'), (payload, [ref]) {
      print('👋 User joined: ${payload['user_id'] ?? 'unknown'}');
      _updateOnlineUsers(conversationId, channel);
    });

    channel.on(RealtimeListenTypes.presence, ChannelFilter(event: 'leave'), (payload, [ref]) {
      print('👋 User left: ${payload['user_id'] ?? 'unknown'}');
      _updateOnlineUsers(conversationId, channel);
    });

    // Subscribe with extended timeout for slower connections
    channel.subscribe(
      (status, [err]) {
        print('Presence subscription status: $status');
        if (status == 'SUBSCRIBED') {
          _updateOnlineUsers(conversationId, channel);
          // Periodically update to catch any missed events
          Future.delayed(const Duration(seconds: 1), () {
            _updateOnlineUsers(conversationId, channel);
          });
        }
        if (err != null) {
          print('Error subscribing to presence: $err');
        }
      },
      const Duration(seconds: 30), // Increased timeout for mobile networks
    );

    _channels[conversationId] = channel;
  }

  /// Unsubscribe from presence updates
  Future<void> unsubscribeFromPresence(String conversationId) async {
    final channel = _channels.remove(conversationId);
    if (channel != null) {
      await channel.unsubscribe();
    }
    _onlineUsers.remove(conversationId);
  }

  /// Broadcast user presence
  Future<void> setPresenceStatus(String conversationId, bool isOnline) async {
    final channel = _channels[conversationId];
    if (channel == null) return;

    final currentUser = _supabase.auth.currentUser;
    if (currentUser == null) return;

    try {
      await channel.track({
        'user_id': currentUser.id,
        'online': isOnline,
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('Error setting presence: $e');
    }
  }

  /// Get online users for a conversation
  Set<String> getOnlineUsers(String conversationId) {
    return _onlineUsers[conversationId] ?? {};
  }

  /// Check if a user is online
  bool isUserOnline(String conversationId, String userId) {
    return _onlineUsers[conversationId]?.contains(userId) ?? false;
  }

  void _updateOnlineUsers(String conversationId, RealtimeChannel channel) {
    try {
      final presenceState = channel.presenceState();
      final onlineSet = <String>{};

      // Iterate through all presence states
      for (final entry in presenceState.entries) {
        for (final presence in entry.value) {
          // Access the payload property which contains the tracked data
          final payload = presence.payload;
          if (payload is Map<String, dynamic>) {
            if (payload['online'] == true) {
              final userId = payload['user_id'] as String?;
              if (userId != null) {
                onlineSet.add(userId);
              }
            }
          }
        }
      }

      _onlineUsers[conversationId] = onlineSet;
      print('📊 Online users updated: ${onlineSet.length} users online');
    } catch (e) {
      print('Error updating online users: $e');
    }
  }

  /// Clean up all subscriptions
  Future<void> dispose() async {
    for (final channel in _channels.values) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        print('Error unsubscribing: $e');
      }
    }
    _channels.clear();
    _onlineUsers.clear();
  }
}
</file>

<file path="lib/services/realtime_diagnostic_service.dart">
import 'dart:async';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Diagnostic information about a Realtime channel
class RealtimeChannelDiagnostics {
  final String channelName;
  final String status;
  final DateTime subscribedAt;
  final DateTime? lastMessageAt;
  final int messagesReceived;
  final List<String> errors;
  final Duration? latency;

  RealtimeChannelDiagnostics({
    required this.channelName,
    required this.status,
    required this.subscribedAt,
    this.lastMessageAt,
    this.messagesReceived = 0,
    this.errors = const [],
    this.latency,
  });

  bool get isHealthy => status == 'SUBSCRIBED' && errors.isEmpty;
  
  Duration get timeSinceLastMessage => 
      lastMessageAt != null 
          ? DateTime.now().difference(lastMessageAt!)
          : Duration.zero;
}

/// Service for diagnosing and monitoring Realtime connections
class RealtimeDiagnosticService {
  static final RealtimeDiagnosticService _instance =
      RealtimeDiagnosticService._internal();

  factory RealtimeDiagnosticService() {
    return _instance;
  }

  RealtimeDiagnosticService._internal();

  final _supabase = SupabaseClientProvider.client;
  final Map<String, RealtimeChannelDiagnostics> _channelDiagnostics = {};
  final Map<String, DateTime> _messageTimestamps = {};
  Timer? _healthCheckTimer;
  bool _isMonitoring = false;

  /// Start monitoring Realtime health
  void startMonitoring({Duration checkInterval = const Duration(seconds: 5)}) {
    if (_isMonitoring) {
      return;
    }

    _isMonitoring = true;
    _healthCheckTimer = Timer.periodic(checkInterval, (_) {
      _performHealthCheck();
    });
  }

  /// Stop monitoring
  void stopMonitoring() {
    _healthCheckTimer?.cancel();
    _healthCheckTimer = null;
    _isMonitoring = false;
  }

  /// Register a channel for monitoring
  void registerChannel(String channelName, RealtimeChannel channel) {
    _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
      channelName: channelName,
      status: 'SUBSCRIBING',
      subscribedAt: DateTime.now(),
    );
  }

  /// Update channel status
  void updateChannelStatus(String channelName, String status) {
    final current = _channelDiagnostics[channelName];
    if (current != null) {
      _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
        channelName: channelName,
        status: status,
        subscribedAt: current.subscribedAt,
        lastMessageAt: current.lastMessageAt,
        messagesReceived: current.messagesReceived,
        errors: current.errors,
        latency: current.latency,
      );
    }
  }

  /// Record message received
  void recordMessageReceived(String channelName) {
    final current = _channelDiagnostics[channelName];
    if (current != null) {
      final now = DateTime.now();
      
      // Calculate latency if we have a timestamp
      Duration? latency;
      if (_messageTimestamps.containsKey(channelName)) {
        latency = now.difference(_messageTimestamps[channelName]!);
      }

      _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
        channelName: channelName,
        status: current.status,
        subscribedAt: current.subscribedAt,
        lastMessageAt: now,
        messagesReceived: current.messagesReceived + 1,
        errors: current.errors,
        latency: latency,
      );
    }
  }

  /// Record error
  void recordError(String channelName, String error) {
    final current = _channelDiagnostics[channelName];
    if (current != null) {
      final newErrors = List<String>.from(current.errors)..add(error);
      
      _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
        channelName: channelName,
        status: current.status,
        subscribedAt: current.subscribedAt,
        lastMessageAt: current.lastMessageAt,
        messagesReceived: current.messagesReceived,
        errors: newErrors,
        latency: current.latency,
      );

      print('❌ Error on $channelName: $error');
    }
  }

  /// Mark message send timestamp (for latency calculation)
  void markMessageSent(String channelName) {
    _messageTimestamps[channelName] = DateTime.now();
  }

  /// Perform health check on all channels
  void _performHealthCheck() {
    print('🏥 Realtime Health Check');
    print('━' * 60);

    if (_channelDiagnostics.isEmpty) {
      print('   No active channels');
      return;
    }

    for (final entry in _channelDiagnostics.entries) {
      final channel = entry.key;
      final diag = entry.value;

      final healthEmoji = diag.isHealthy ? '✅' : '⚠️';
      final statusEmoji = _getStatusEmoji(diag.status);

      print('$healthEmoji $channel');
      print('   $statusEmoji Status: ${diag.status}');
      print('   📊 Messages: ${diag.messagesReceived}');
      
      if (diag.lastMessageAt != null) {
        final timeSince = DateTime.now().difference(diag.lastMessageAt!);
        print('   ⏱️  Last message: ${timeSince.inSeconds}s ago');
      }

      if (diag.latency != null) {
        print('   🚀 Latency: ${diag.latency!.inMilliseconds}ms');
      }

      if (diag.errors.isNotEmpty) {
        print('   ❌ Errors: ${diag.errors.length}');
        for (final error in diag.errors.take(3)) {
          print('      - $error');
        }
      }

      final uptime = DateTime.now().difference(diag.subscribedAt);
      print('   ⏰ Uptime: ${_formatDuration(uptime)}');
      print('');
    }

    print('━' * 60);
  }

  /// Get emoji for status
  String _getStatusEmoji(String status) {
    switch (status) {
      case 'SUBSCRIBED':
        return '✅';
      case 'SUBSCRIBING':
        return '🔄';
      case 'CLOSED':
        return '⏸️';
      case 'CHANNEL_ERROR':
        return '❌';
      case 'TIMED_OUT':
        return '⏰';
      default:
        return '❓';
    }
  }

  /// Format duration nicely
  String _formatDuration(Duration duration) {
    if (duration.inSeconds < 60) {
      return '${duration.inSeconds}s';
    } else if (duration.inMinutes < 60) {
      return '${duration.inMinutes}m ${duration.inSeconds % 60}s';
    } else {
      return '${duration.inHours}h ${duration.inMinutes % 60}m';
    }
  }

  /// Get diagnostics for a channel
  RealtimeChannelDiagnostics? getDiagnostics(String channelName) {
    return _channelDiagnostics[channelName];
  }

  /// Get all diagnostics
  Map<String, RealtimeChannelDiagnostics> getAllDiagnostics() {
    return Map.from(_channelDiagnostics);
  }

  /// Test Realtime connection
  Future<RealtimeTestResult> testConnection() async {
    print('🧪 Testing Realtime connection...');
    
    final startTime = DateTime.now();
    final testChannel = _supabase.realtime.channel('test_${startTime.millisecondsSinceEpoch}');
    
    try {
      final completer = Completer<RealtimeTestResult>();
      var subscribeStatus = 'UNKNOWN';

      testChannel.subscribe(
        (status, [error]) {
          subscribeStatus = status;
          
          if (status == 'SUBSCRIBED') {
            final latency = DateTime.now().difference(startTime);
            completer.complete(RealtimeTestResult(
              success: true,
              latency: latency,
              status: status,
            ));
          } else if (status == 'CHANNEL_ERROR' || status == 'TIMED_OUT') {
            completer.complete(RealtimeTestResult(
            success: false,
            status: status,
            error: error?.toString(),
          ));
        }
      },
      const Duration(seconds: 30), // Test with 30s timeout
      );

      // Timeout after 10 seconds
      final result = await completer.future.timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          return RealtimeTestResult(
            success: false,
            status: 'TIMEOUT',
            error: 'Connection test timed out after 10 seconds',
          );
        },
      );

      // Clean up
      await testChannel.unsubscribe();

      return result;
    } catch (e) {
      return RealtimeTestResult(
        success: false,
        status: 'ERROR',
        error: e.toString(),
      );
    }
  }

  /// Generate diagnostic report
  String generateReport() {
    final buffer = StringBuffer();
    
    buffer.writeln('═' * 60);
    buffer.writeln('REALTIME DIAGNOSTICS REPORT');
    buffer.writeln('Generated: ${DateTime.now()}');
    buffer.writeln('═' * 60);
    buffer.writeln();

    if (_channelDiagnostics.isEmpty) {
      buffer.writeln('No active channels');
      return buffer.toString();
    }

    for (final entry in _channelDiagnostics.entries) {
      final diag = entry.value;
      
      buffer.writeln('Channel: ${diag.channelName}');
      buffer.writeln('  Status: ${diag.status} ${diag.isHealthy ? '✓' : '✗'}');
      buffer.writeln('  Messages Received: ${diag.messagesReceived}');
      buffer.writeln('  Subscribed At: ${diag.subscribedAt}');
      
      if (diag.lastMessageAt != null) {
        buffer.writeln('  Last Message: ${diag.lastMessageAt}');
        buffer.writeln('  Time Since Last: ${diag.timeSinceLastMessage.inSeconds}s');
      }
      
      if (diag.latency != null) {
        buffer.writeln('  Latency: ${diag.latency!.inMilliseconds}ms');
      }
      
      if (diag.errors.isNotEmpty) {
        buffer.writeln('  Errors: ${diag.errors.length}');
        for (final error in diag.errors) {
          buffer.writeln('    - $error');
        }
      }
      
      buffer.writeln();
    }

    buffer.writeln('═' * 60);
    return buffer.toString();
  }

  /// Dispose resources
  void dispose() {
    stopMonitoring();
    _channelDiagnostics.clear();
    _messageTimestamps.clear();
  }
}

/// Result of Realtime connection test
class RealtimeTestResult {
  final bool success;
  final Duration? latency;
  final String status;
  final String? error;

  RealtimeTestResult({
    required this.success,
    this.latency,
    required this.status,
    this.error,
  });

  @override
  String toString() {
    if (success) {
      return 'SUCCESS: Connected in ${latency?.inMilliseconds}ms (Status: $status)';
    } else {
      return 'FAILED: $status${error != null ? ' - $error' : ''}';
    }
  }
}
</file>

<file path="lib/services/realtime_message_service.dart">
import 'dart:async';
import 'package:uuid/uuid.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/services/realtime_diagnostic_service.dart';
import 'package:messageai/services/ai_analysis_service.dart';

/// Service for real-time message synchronization
class RealTimeMessageService {
  static final RealTimeMessageService _instance =
      RealTimeMessageService._internal();

  factory RealTimeMessageService() {
    return _instance;
  }

  RealTimeMessageService._internal();

  final _supabase = SupabaseClientProvider.client;
  final _db = AppDb.instance;
  final _diagnostics = RealtimeDiagnosticService();
  final _aiAnalysis = AIAnalysisService();
  final Map<String, RealtimeChannel> _channels = {};
  final Map<String, RealtimeChannel> _receiptChannels = {};
  final Map<String, StreamController<List<Message>>> _messageControllers = {};
  final Map<String, StreamController<List<Receipt>>> _receiptControllers = {};

  /// Subscribe to real-time messages for a conversation
  Stream<List<Message>> subscribeToMessages(String conversationId) {
    if (_messageControllers.containsKey(conversationId)) {
      return _messageControllers[conversationId]!.stream;
    }

    final controller = StreamController<List<Message>>.broadcast();
    _messageControllers[conversationId] = controller;

    _setupRealtimeListener(conversationId, controller);

    return controller.stream;
  }

  void _setupRealtimeListener(
    String conversationId,
    StreamController<List<Message>> controller,
  ) {
    try {
      final channelName = 'messages:$conversationId';
      final channel = _supabase.realtime.channel(channelName);
      
      // Register channel for diagnostics
      _diagnostics.registerChannel(channelName, channel);
      
      // Listen for postgres changes using the correct API
      channel.on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          filter: 'conversation_id=eq.$conversationId',
        ),
        (payload, [ref]) async {
          _diagnostics.recordMessageReceived(channelName);
          print('📨 Realtime message received');
          
          try {
            final data = payload['new'] as Map<String, dynamic>;
            final timestamp = DateTime.parse(data['created_at'] as String)
                .millisecondsSinceEpoch ~/
                1000;
            
            final message = Message(
              id: data['id'] as String,
              conversationId: data['conversation_id'] as String,
              senderId: data['sender_id'] as String,
              body: data['body'] as String,
              mediaUrl: data['media_url'] as String?,
              createdAt: timestamp,
              updatedAt: DateTime.parse(data['updated_at'] as String)
                  .millisecondsSinceEpoch ~/
                  1000,
              isSynced: true,
            );
            
            await _db.messageDao.upsertMessage(message);
            
            // Refresh the stream
            final messages =
                await _db.messageDao.getMessagesByConversation(conversationId);
            controller.add(messages);
            print('✅ UI updated with ${messages.length} messages');
            
            // Create delivery receipt for received message
            final currentUser = _supabase.auth.currentUser;
            if (currentUser != null && message.senderId != currentUser.id) {
              await _createReceipt(message.id, currentUser.id, 'delivered');
              
              // Trigger AI analysis for received messages (non-blocking)
              _triggerAIAnalysis(message);
            }
          } catch (e) {
            print('❌ Error processing message: $e');
          }
        },
      );

      // Subscribe with extended timeout for slower connections
      channel.subscribe(
        (status, [err]) {
          _diagnostics.updateChannelStatus(channelName, status);
          
          // Log all status changes for debugging
          print('📡 Realtime [$conversationId]: $status');
          
          if (status == 'CHANNEL_ERROR' || status == 'TIMED_OUT' || err != null) {
            print('❌ Realtime error for $conversationId: $status ${err ?? ""}');
            if (err != null) {
              _diagnostics.recordError(channelName, err.toString());
              controller.addError(err);
            }
          }
        },
        const Duration(seconds: 30), // Increased timeout for mobile networks
      );

      _channels[conversationId] = channel;
      
      // Load initial messages
      Future.delayed(Duration.zero, () async {
        try {
          final messages =
              await _db.messageDao.getMessagesByConversation(conversationId);
          controller.add(messages);
        } catch (e) {
          controller.addError(e);
        }
      });
    } catch (e) {
      print('Error setting up realtime listener: $e');
      controller.addError(e);
    }
  }

  /// Trigger AI analysis for a message (non-blocking)
  void _triggerAIAnalysis(Message message) {
    // Run in background, don't await
    _aiAnalysis.requestAnalysis(message.id, message.body).then((analysis) {
      if (analysis != null) {
        print('✨ AI analysis completed for ${message.id.substring(0, 8)}: ${analysis.tone}');
      }
    }).catchError((error) {
      print('⚠️ AI analysis failed for ${message.id.substring(0, 8)}: $error');
    });
  }

  Future<void> _createReceipt(String messageId, String userId, String status) async {
    try {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final receiptId = const Uuid().v4();
      
      await _db.receiptDao.addReceipt(Receipt(
        id: receiptId,
        messageId: messageId,
        userId: userId,
        status: status,
        createdAt: now,
        updatedAt: now,
        isSynced: false,
      ));
      
      // Note: message_receipts table uses 'at' column, not 'created_at'
      await _supabase.from('message_receipts').insert({
        'id': receiptId,
        'message_id': messageId,
        'user_id': userId,
        'status': status,
        'at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
      });
      
      await _db.receiptDao.markReceiptAsSynced(receiptId);
    } catch (e) {
      // Silently fail - receipts are not critical
    }
  }

  /// Subscribe to real-time receipts for a conversation
  Stream<List<Receipt>> subscribeToReceipts(String conversationId) {
    if (_receiptControllers.containsKey(conversationId)) {
      return _receiptControllers[conversationId]!.stream;
    }

    final controller = StreamController<List<Receipt>>.broadcast();
    _receiptControllers[conversationId] = controller;

    _setupReceiptListener(conversationId, controller);

    return controller.stream;
  }

  void _setupReceiptListener(
    String conversationId,
    StreamController<List<Receipt>> controller,
  ) {
    try {
      final channelName = 'receipts:$conversationId';
      final channel = _supabase.realtime.channel(channelName);
      
      // Listen for receipt changes
      channel.on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: '*',  // All events (INSERT, UPDATE)
          schema: 'public',
          table: 'message_receipts',
        ),
        (payload, [ref]) async {
          print('📨 Receipt change received');
          
          try {
            // Reload all receipts for this conversation
            final receipts = await _db.receiptDao.getReceiptsByConversation(conversationId);
            controller.add(receipts);
          } catch (e) {
            print('❌ Error processing receipt: $e');
          }
        },
      );

      channel.subscribe(
        (status, [err]) {
          print('📡 Receipts [$conversationId]: $status');
          if (err != null) {
            controller.addError(err);
          }
        },
        const Duration(seconds: 30),
      );

      _receiptChannels[conversationId] = channel;
      
      // Load initial receipts
      Future.delayed(Duration.zero, () async {
        try {
          final receipts = await _db.receiptDao.getReceiptsByConversation(conversationId);
          controller.add(receipts);
        } catch (e) {
          controller.addError(e);
        }
      });
    } catch (e) {
      print('Error setting up receipt listener: $e');
      controller.addError(e);
    }
  }

  /// Unsubscribe from real-time messages
  Future<void> unsubscribeFromMessages(String conversationId) async {
    final controller = _messageControllers.remove(conversationId);
    controller?.close();

    final channel = _channels.remove(conversationId);
    if (channel != null) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
  }

  /// Unsubscribe from real-time receipts
  Future<void> unsubscribeFromReceipts(String conversationId) async {
    final controller = _receiptControllers.remove(conversationId);
    controller?.close();

    final channel = _receiptChannels.remove(conversationId);
    if (channel != null) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
  }

  /// Clean up all subscriptions
  Future<void> dispose() async {
    for (final controller in _messageControllers.values) {
      controller.close();
    }
    _messageControllers.clear();

    for (final controller in _receiptControllers.values) {
      controller.close();
    }
    _receiptControllers.clear();

    for (final channel in _channels.values) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
    _channels.clear();

    for (final channel in _receiptChannels.values) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
    _receiptChannels.clear();
    
    _diagnostics.dispose();
  }

  /// Get diagnostic report
  String getDiagnosticsReport() {
    return _diagnostics.generateReport();
  }

  /// Start diagnostic monitoring
  void startDiagnostics() {
    _diagnostics.startMonitoring();
  }

  /// Stop diagnostic monitoring
  void stopDiagnostics() {
    _diagnostics.stopMonitoring();
  }

  /// Test Realtime connection
  Future<RealtimeTestResult> testConnection() {
    return _diagnostics.testConnection();
  }
}
</file>

<file path="lib/services/retry_service.dart">
import 'dart:async';
import 'dart:math';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_handler.dart';

/// Configuration for retry behavior
class RetryConfig {
  final int maxAttempts;
  final Duration initialDelay;
  final Duration maxDelay;
  final double backoffMultiplier;
  final bool useJitter;

  const RetryConfig({
    this.maxAttempts = 3,
    this.initialDelay = const Duration(seconds: 1),
    this.maxDelay = const Duration(seconds: 30),
    this.backoffMultiplier = 2.0,
    this.useJitter = true,
  });

  /// Aggressive retry (more attempts, faster)
  static const aggressive = RetryConfig(
    maxAttempts: 5,
    initialDelay: Duration(milliseconds: 500),
    maxDelay: Duration(seconds: 15),
  );

  /// Conservative retry (fewer attempts, slower)
  static const conservative = RetryConfig(
    maxAttempts: 2,
    initialDelay: Duration(seconds: 2),
    maxDelay: Duration(seconds: 60),
  );

  /// Default retry configuration
  static const defaultConfig = RetryConfig();
}

/// Result of a retry operation
class RetryResult<T> {
  final T? data;
  final AppError? error;
  final int attempts;
  final bool succeeded;

  RetryResult({
    this.data,
    this.error,
    required this.attempts,
    required this.succeeded,
  });

  RetryResult.success(T data, int attempts)
      : this(
          data: data,
          succeeded: true,
          attempts: attempts,
        );

  RetryResult.failure(AppError error, int attempts)
      : this(
          error: error,
          succeeded: false,
          attempts: attempts,
        );
}

/// Service for handling retries with exponential backoff
class RetryService {
  static final RetryService _instance = RetryService._internal();

  factory RetryService() {
    return _instance;
  }

  RetryService._internal();

  final _errorHandler = ErrorHandler();
  final _random = Random();

  /// Execute operation with retry logic
  Future<RetryResult<T>> execute<T>({
    required Future<T> Function() operation,
    required String operationName,
    RetryConfig config = RetryConfig.defaultConfig,
    bool Function(AppError)? shouldRetry,
  }) async {
    int attemptNumber = 0;
    AppError? lastError;

    while (attemptNumber < config.maxAttempts) {
      attemptNumber++;

      try {
        final result = await operation();
        return RetryResult.success(result, attemptNumber);
      } catch (error, stackTrace) {
        // Convert to AppError
        final appError = error is AppError
            ? error
            : _errorHandler.handleError(
                error,
                stackTrace: stackTrace,
                context: operationName,
              );

        lastError = appError;

        // Check if we should retry
        final shouldRetryThis = shouldRetry?.call(appError) ??
            _errorHandler.shouldRetry(appError, attemptNumber, maxAttempts: config.maxAttempts);

        if (!shouldRetryThis) {
          return RetryResult.failure(appError, attemptNumber);
        }

        // Calculate delay before next attempt
        if (attemptNumber < config.maxAttempts) {
          final delay = _calculateDelay(
            attemptNumber,
            config: config,
          );
          await Future.delayed(delay);
        }
      }
    }

    return RetryResult.failure(
      lastError ?? AppError(
        category: ErrorCategory.unknown,
        severity: ErrorSeverity.error,
        code: 'RETRY001',
        message: 'Max retry attempts exceeded',
        userMessage: 'Operation failed after multiple attempts',
      ),
      attemptNumber,
    );
  }

  /// Calculate delay for next retry attempt (exponential backoff with jitter)
  Duration _calculateDelay(int attemptNumber, {required RetryConfig config}) {
    // Calculate base delay: initialDelay * (backoffMultiplier ^ attemptNumber)
    final exponentialDelay = config.initialDelay.inMilliseconds *
        pow(config.backoffMultiplier, attemptNumber - 1);

    // Cap at max delay
    final cappedDelay = min(exponentialDelay, config.maxDelay.inMilliseconds.toDouble());

    // Add jitter to avoid thundering herd
    final delayWithJitter = config.useJitter
        ? _addJitter(cappedDelay.toDouble())
        : cappedDelay.toDouble();

    return Duration(milliseconds: delayWithJitter.round());
  }

  /// Add random jitter to delay (±25%)
  double _addJitter(double delay) {
    final jitterRange = delay * 0.25; // ±25%
    final jitter = (_random.nextDouble() * 2 - 1) * jitterRange;
    return delay + jitter;
  }

  /// Execute with simple retry (no configuration)
  Future<T> executeSimple<T>({
    required Future<T> Function() operation,
    int maxAttempts = 3,
  }) async {
    final result = await execute(
      operation: operation,
      operationName: 'Operation',
      config: RetryConfig(maxAttempts: maxAttempts),
    );

    if (result.succeeded) {
      return result.data as T;
    } else {
      throw result.error!;
    }
  }

  /// Execute with timeout and retry
  Future<RetryResult<T>> executeWithTimeout<T>({
    required Future<T> Function() operation,
    required String operationName,
    Duration timeout = const Duration(seconds: 30),
    RetryConfig config = RetryConfig.defaultConfig,
  }) async {
    return execute<T>(
      operation: () async {
        return await operation().timeout(
          timeout,
          onTimeout: () {
            throw AppError(
              category: ErrorCategory.network,
              severity: ErrorSeverity.warning,
              code: 'NET002',
              message: 'Operation timeout',
              userMessage: 'The operation took too long. Please try again.',
              isRetryable: true,
            );
          },
        );
      },
      operationName: operationName,
      config: config,
    );
  }
}

/// Extension to add retry capability to Future
extension RetryExtension<T> on Future<T> {
  /// Retry this future with exponential backoff
  Future<T> withRetry({
    String operationName = 'Operation',
    int maxAttempts = 3,
  }) async {
    final retryService = RetryService();
    return retryService.executeSimple(
      operation: () => this,
      maxAttempts: maxAttempts,
    );
  }

  /// Retry with full configuration
  Future<RetryResult<T>> withRetryConfig({
    required String operationName,
    RetryConfig config = RetryConfig.defaultConfig,
  }) async {
    final retryService = RetryService();
    return retryService.execute(
      operation: () => this,
      operationName: operationName,
      config: config,
    );
  }
}
</file>

<file path="lib/services/typing_indicator_service.dart">
import 'dart:async';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Service to handle typing indicators using Supabase Realtime
class TypingIndicatorService {
  static final TypingIndicatorService _instance = TypingIndicatorService._internal();
  factory TypingIndicatorService() => _instance;
  TypingIndicatorService._internal();

  final _supabase = SupabaseClientProvider.client;
  final Map<String, RealtimeChannel> _channels = {};
  final Map<String, Set<String>> _typingUsers = {}; // conversationId -> Set of userIds
  final Map<String, StreamController<Set<String>>> _typingControllers = {};
  final Map<String, Timer?> _typingTimeouts = {}; // userId -> Timer

  static const _typingTimeout = Duration(seconds: 3);

  /// Subscribe to typing events for a conversation
  Stream<Set<String>> subscribeToTyping(String conversationId) {
    // Return existing stream if already subscribed
    if (_typingControllers.containsKey(conversationId)) {
      return _typingControllers[conversationId]!.stream;
    }

    // Create new stream controller
    final controller = StreamController<Set<String>>.broadcast();
    _typingControllers[conversationId] = controller;
    _typingUsers[conversationId] = {};

    // Create channel for this conversation
    final channel = _supabase.channel('typing:$conversationId');
    _channels[conversationId] = channel;

    // Listen for typing events using on() method
    channel.on(
      RealtimeListenTypes.broadcast,
      ChannelFilter(event: 'typing'),
      (payload, [ref]) {
        final data = payload as Map<String, dynamic>;
        final userId = data['user_id'] as String?;
        final isTyping = data['is_typing'] as bool? ?? false;
        final currentUserId = _supabase.auth.currentUser?.id;

        // Ignore own typing events
        if (userId == null || userId == currentUserId) return;

        final typingSet = _typingUsers[conversationId] ?? {};

        if (isTyping) {
          typingSet.add(userId);
          
          // Clear existing timeout for this user
          _typingTimeouts['$conversationId:$userId']?.cancel();
          
          // Set timeout to remove user from typing after inactivity
          _typingTimeouts['$conversationId:$userId'] = Timer(_typingTimeout, () {
            typingSet.remove(userId);
            _typingUsers[conversationId] = typingSet;
            if (!controller.isClosed) {
              controller.add(Set.from(typingSet));
            }
          });
        } else {
          typingSet.remove(userId);
          _typingTimeouts['$conversationId:$userId']?.cancel();
        }

        _typingUsers[conversationId] = typingSet;
        if (!controller.isClosed) {
          controller.add(Set.from(typingSet));
        }
      },
    );

    // Subscribe to channel with extended timeout
    channel.subscribe(
      (status, [err]) {
        print('Typing indicator subscription status: $status');
        if (err != null) {
          print('Error subscribing to typing indicator: $err');
        }
      },
      const Duration(seconds: 30), // Increased timeout for mobile networks
    );

    return controller.stream;
  }

  /// Send typing indicator
  Future<void> sendTypingIndicator(String conversationId, bool isTyping) async {
    final channel = _channels[conversationId];
    if (channel == null) return;

    final currentUserId = _supabase.auth.currentUser?.id;
    if (currentUserId == null) return;

    try {
      channel.send(
        type: RealtimeListenTypes.broadcast,
        event: 'typing',
        payload: {
          'user_id': currentUserId,
          'is_typing': isTyping,
        },
      );
    } catch (e) {
      print('Error sending typing indicator: $e');
    }
  }

  /// Unsubscribe from typing events for a conversation
  Future<void> unsubscribeFromTyping(String conversationId) async {
    final channel = _channels[conversationId];
    if (channel != null) {
      await channel.unsubscribe();
      _channels.remove(conversationId);
    }

    final controller = _typingControllers[conversationId];
    if (controller != null && !controller.isClosed) {
      await controller.close();
    }
    _typingControllers.remove(conversationId);
    _typingUsers.remove(conversationId);

    // Clear all timeouts for this conversation
    final keysToRemove = _typingTimeouts.keys
        .where((key) => key.startsWith('$conversationId:'))
        .toList();
    for (final key in keysToRemove) {
      _typingTimeouts[key]?.cancel();
      _typingTimeouts.remove(key);
    }
  }

  /// Get current typing users for a conversation
  Set<String> getTypingUsers(String conversationId) {
    return Set.from(_typingUsers[conversationId] ?? {});
  }

  /// Clean up all subscriptions
  Future<void> dispose() async {
    for (final channel in _channels.values) {
      await channel.unsubscribe();
    }
    _channels.clear();

    for (final controller in _typingControllers.values) {
      if (!controller.isClosed) {
        await controller.close();
      }
    }
    _typingControllers.clear();
    _typingUsers.clear();

    for (final timer in _typingTimeouts.values) {
      timer?.cancel();
    }
    _typingTimeouts.clear();
  }
}
</file>

<file path="lib/state/ai_providers_cached.dart.backup">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/services/ai_analysis_service.dart';

/// Provider for the AI Analysis Service singleton
final aiAnalysisServiceProvider = Provider<AIAnalysisService>((ref) {
  return AIAnalysisService();
});

/// Provider for getting analysis for a specific message
final messageAnalysisProvider = FutureProvider.family<AiAnalysi?, String>(
  (ref, messageId) async {
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getAnalysis(messageId);
  },
);

/// Stream provider for watching analysis changes for a message
final messageAnalysisStreamProvider = StreamProvider.family<AiAnalysi?, String>(
  (ref, messageId) {
    final service = ref.watch(aiAnalysisServiceProvider);
    return service.watchAnalysis(messageId);
  },
);

/// Provider for getting analyses for a conversation
final conversationAnalysisProvider = FutureProvider.family<Map<String, AiAnalysi>, ConversationAnalysisParams>(
  (ref, params) async {
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getConversationAnalysis(
      params.conversationId,
      params.messageIds,
    );
  },
);

/// Provider for analysis statistics
final analysisStatsProvider = FutureProvider<Map<String, dynamic>>(
  (ref) async {
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getAnalysisStats();
  },
);

/// Provider for requesting analysis (returns the service method)
/// Use this to trigger analysis requests from UI
final requestAnalysisProvider = Provider<Future<AiAnalysi?> Function(String, String)>((ref) {
  final service = ref.watch(aiAnalysisServiceProvider);
  return (messageId, messageBody) => service.requestAnalysis(messageId, messageBody);
});

/// Parameters for conversation analysis provider
class ConversationAnalysisParams {
  final String conversationId;
  final List<String> messageIds;

  ConversationAnalysisParams({
    required this.conversationId,
    required this.messageIds,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConversationAnalysisParams &&
          runtimeType == other.runtimeType &&
          conversationId == other.conversationId &&
          _listEquals(messageIds, other.messageIds);

  @override
  int get hashCode => conversationId.hashCode ^ messageIds.hashCode;

  bool _listEquals(List<String> a, List<String> b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }
}
</file>

<file path="lib/state/ai_providers.dart">
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/services/ai_analysis_service.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Provider for AI Analysis Service singleton
final aiAnalysisServiceProvider = Provider<AIAnalysisService>((ref) {
  return AIAnalysisService();
});

/// StateNotifier to track when to refresh analysis
class AnalysisRefreshNotifier extends StateNotifier<int> {
  AnalysisRefreshNotifier() : super(0);
  
  void refresh() {
    state++;
  }
}

final analysisRefreshProvider = StateNotifierProvider<AnalysisRefreshNotifier, int>((ref) {
  final notifier = AnalysisRefreshNotifier();
  
  // Listen to realtime updates on message_ai_analysis table
  final supabase = SupabaseClientProvider.client;
  final channel = supabase.realtime.channel('ai_analysis_updates');
  
  channel.on(
    RealtimeListenTypes.postgresChanges,
    ChannelFilter(
      event: 'INSERT',
      schema: 'public',
      table: 'message_ai_analysis',
    ),
    (payload, [ref]) {
      print('🔄 AI analysis updated, refreshing providers...');
      notifier.refresh();
    },
  );
  
  channel.subscribe(
    (status, [error]) {
      if (status == 'SUBSCRIBED') {
        print('✅ AI analysis realtime listener subscribed');
      } else if (error != null) {
        print('❌ AI analysis realtime error: $error');
      }
    },
    timeout: const Duration(seconds: 30),
  );
  
  ref.onDispose(() {
    channel.unsubscribe();
  });
  
  return notifier;
});

/// Fetch analysis for a single message (auto-refreshes on realtime updates)
final messageAnalysisProvider = FutureProvider.family<AIAnalysis?, String>(
  (ref, messageId) async {
    // Watch the refresh notifier to trigger rebuilds
    ref.watch(analysisRefreshProvider);
    
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getAnalysis(messageId);
  },
);

/// Fetch all analyses for a conversation (auto-refreshes on realtime updates)
final conversationAnalysisProvider = FutureProvider.family<Map<String, AIAnalysis>, String>(
  (ref, conversationId) async {
    // Watch the refresh notifier to trigger rebuilds
    ref.watch(analysisRefreshProvider);
    
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getConversationAnalyses(conversationId);
  },
);

/// Provider for triggering analysis requests
final requestAnalysisProvider = Provider((ref) {
  final service = ref.watch(aiAnalysisServiceProvider);
  return (String messageId, String messageBody) => 
      service.requestAnalysis(messageId, messageBody);
});
</file>

<file path="lib/state/database_provider.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/conversation_dao.dart';
import 'package:messageai/data/drift/daos/message_dao.dart';
import 'package:messageai/data/drift/daos/participant_dao.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';

/// Provides the main database instance
final appDbProvider = Provider<AppDb>((ref) {
  return AppDb.instance;
});

/// Provides the ConversationDao
final conversationDaoProvider = Provider<ConversationDao>((ref) {
  final db = ref.watch(appDbProvider);
  return ConversationDao(db);
});

/// Provides the MessageDao
final messageDaoProvider = Provider<MessageDao>((ref) {
  final db = ref.watch(appDbProvider);
  return MessageDao(db);
});

/// Provides the ParticipantDao
final participantDaoProvider = Provider<ParticipantDao>((ref) {
  final db = ref.watch(appDbProvider);
  return ParticipantDao(db);
});

/// Provides the ReceiptDao
final receiptDaoProvider = Provider<ReceiptDao>((ref) {
  final db = ref.watch(appDbProvider);
  return ReceiptDao(db);
});

/// Provides the PendingOutboxDao
final pendingOutboxDaoProvider = Provider<PendingOutboxDao>((ref) {
  final db = ref.watch(appDbProvider);
  return PendingOutboxDao(db);
});

/// Stream of all conversations (watching for changes)
final conversationsStreamProvider = StreamProvider<List<Conversation>>((ref) async* {
  final dao = ref.watch(conversationDaoProvider);
  
  // Initial load
  yield await dao.getAllConversations();
  
  // TODO: Set up watch stream for real-time updates
  // For now, update every time this is accessed
});

/// Stream of messages for a specific conversation
final messagesStreamProvider = StreamProvider.family<List<Message>, String>((ref, conversationId) async* {
  final dao = ref.watch(messageDaoProvider);
  
  // Initial load
  yield await dao.getMessagesByConversation(conversationId);
  
  // TODO: Set up watch stream for real-time updates
});

/// Stream of pending operations count (for UI indicators)
final pendingOperationsCountProvider = StreamProvider<int>((ref) async* {
  final dao = ref.watch(pendingOutboxDaoProvider);
  
  // Initial load
  yield await dao.getPendingOperationCount();
  
  // TODO: Set up periodic check or subscription
});

/// Check if there are any pending operations
final hasPendingOperationsProvider = FutureProvider<bool>((ref) async {
  final dao = ref.watch(pendingOutboxDaoProvider);
  return dao.hasPendingOperations();
});
</file>

<file path="lib/state/notification_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/services/notification_service.dart';
import 'package:messageai/services/local_notification_service.dart';
import 'package:messageai/services/deep_link_handler.dart';
import 'package:messageai/services/device_registration_service.dart';
import 'package:messageai/app.dart' show navigatorKey;

/// Device token state
final deviceTokenProvider = StateProvider<String?>((ref) {
  return null;
});

/// Notification service provider
final notificationServiceProvider = Provider<NotificationService>((ref) {
  return NotificationService();
});

/// Local notification service provider
final localNotificationServiceProvider = Provider<LocalNotificationService>((ref) {
  return LocalNotificationService();
});

/// Device registration service provider
final deviceRegistrationServiceProvider = Provider<DeviceRegistrationService>((ref) {
  return DeviceRegistrationService();
});

/// Initialize notifications (Firebase + Local)
final initializeNotificationsProvider = FutureProvider<void>((ref) async {
  print('📢 ========================================');
  print('📢 STARTING NOTIFICATION INITIALIZATION');
  print('📢 ========================================');
  
  final fcmService = ref.watch(notificationServiceProvider);
  final localService = ref.watch(localNotificationServiceProvider);
  final deviceRegistrationService = ref.watch(deviceRegistrationServiceProvider);

  print('📱 Initializing local notifications...');
  // Initialize local notifications first
  await localService.initialize();
  print('✅ Local notifications initialized');

  print('🔥 Initializing Firebase Messaging...');
  // Initialize Firebase Messaging
  await fcmService.initialize(
    onMessageReceived: (payload) {
      // Handle foreground message
      _handleForegroundMessage(ref, payload, localService);
    },
    onTokenRefresh: (token) async {
      // Update device token state
      ref.read(deviceTokenProvider.notifier).state = token;
      print('🔄 Device token refreshed: ${token.substring(0, 20)}...');
      
      // Register refreshed token with backend
      try {
        await deviceRegistrationService.registerDeviceToken(token);
        print('✅ Refreshed token registered with backend');
      } catch (e) {
        print('❌ Failed to register refreshed token: $e');
      }
    },
  );

  // Setup notification tap handler
  await fcmService.setupNotificationTapHandler(
    onNotificationTapped: (conversationId) {
      _handleNotificationTap(ref, conversationId);
    },
  );

  // Get initial device token
  final token = await fcmService.getDeviceToken();
  if (token != null) {
    ref.read(deviceTokenProvider.notifier).state = token;
    
    // Register token with backend
    try {
      await deviceRegistrationService.registerDeviceToken(token);
      print('✅ Initial token registered with backend');
    } catch (e) {
      print('❌ Failed to register initial token: $e');
      // Don't fail initialization if registration fails
    }
  }

  print('Notifications initialized successfully');
});

/// Handle foreground notification message
void _handleForegroundMessage(
  Ref ref,
  NotificationPayload payload,
  LocalNotificationService localService,
) async {
  try {
    final conversationId = payload.conversationId;
    final senderName = payload.data['sender_name'] as String? ?? 'New Message';
    final messageBody = payload.messageBody ?? payload.body ?? '';

    if (conversationId != null && messageBody.isNotEmpty) {
      await localService.showMessageNotification(
        conversationId: conversationId,
        senderName: senderName,
        messageBody: messageBody,
      );
    }
  } catch (e) {
    print('Error handling foreground message: $e');
  }
}

/// Handle notification tap
void _handleNotificationTap(Ref ref, String conversationId) {
  print('📱 Notification tapped: $conversationId');
  
  try {
    // Use the global navigator key to navigate
    final navigator = navigatorKey.currentState;
    
    if (navigator == null) {
      print('❌ Navigator not available');
      return;
    }
    
    // Navigate to conversation detail screen
    navigator.pushNamed(
      '/conversation/$conversationId',
      arguments: {'title': 'Conversation'},
    );
    
    print('✅ Navigated to conversation: $conversationId');
  } catch (e) {
    print('❌ Error navigating to conversation: $e');
  }
}

/// Notification permission state
final notificationPermissionProvider = FutureProvider<bool>((ref) async {
  final fcmService = ref.watch(notificationServiceProvider);
  return fcmService.areNotificationsEnabled();
});

/// Subscribe to conversation topic for group notifications
final subscribeToConversationTopicProvider = FutureProvider.autoDispose
    .family<void, String>((ref, conversationId) async {
  final fcmService = ref.watch(notificationServiceProvider);
  await fcmService.subscribeToTopic('conversation_$conversationId');
});

/// Unsubscribe from conversation topic
final unsubscribeFromConversationTopicProvider = FutureProvider.autoDispose
    .family<void, String>((ref, conversationId) async {
  final fcmService = ref.watch(notificationServiceProvider);
  await fcmService.unsubscribeFromTopic('conversation_$conversationId');
});

/// Subscribe to user topic for direct messages
final subscribeToUserTopicProvider = FutureProvider<void>((ref) async {
  final fcmService = ref.watch(notificationServiceProvider);
  // Subscribe to user's personal notification topic
  // (would use current user ID in real app)
  await fcmService.subscribeToTopic('user_direct_messages');
});

/// Notification state for UI
final notificationStateProvider = StateProvider<NotificationState>((ref) {
  return const NotificationState();
});

/// Notification state model
class NotificationState {
  final bool isInitialized;
  final bool hasPermission;
  final String? deviceToken;
  final int unreadCount;
  final List<String> subscribedTopics;

  const NotificationState({
    this.isInitialized = false,
    this.hasPermission = false,
    this.deviceToken,
    this.unreadCount = 0,
    this.subscribedTopics = const [],
  });

  NotificationState copyWith({
    bool? isInitialized,
    bool? hasPermission,
    String? deviceToken,
    int? unreadCount,
    List<String>? subscribedTopics,
  }) {
    return NotificationState(
      isInitialized: isInitialized ?? this.isInitialized,
      hasPermission: hasPermission ?? this.hasPermission,
      deviceToken: deviceToken ?? this.deviceToken,
      unreadCount: unreadCount ?? this.unreadCount,
      subscribedTopics: subscribedTopics ?? this.subscribedTopics,
    );
  }
}

/// Initialize notification system
final notificationInitializerProvider = FutureProvider<void>((ref) async {
  try {
    // Initialize notifications
    await ref.watch(initializeNotificationsProvider.future);

    // Check permissions
    final hasPermission = await ref.watch(notificationPermissionProvider.future);

    // Get device token
    final deviceToken = ref.watch(deviceTokenProvider);

    // Update state
    ref.read(notificationStateProvider.notifier).state =
        ref.read(notificationStateProvider).copyWith(
          isInitialized: true,
          hasPermission: hasPermission,
          deviceToken: deviceToken,
        );

    print('Notification system initialized');
  } catch (e) {
    print('Error initializing notification system: $e');
    rethrow;
  }
});
</file>

<file path="lib/state/presence_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/providers.dart';

/// User presence status
enum PresenceStatus {
  online,
  away,
  offline,
}

/// User presence information
class UserPresence {
  final String userId;
  final String conversationId;
  final PresenceStatus status;
  final DateTime lastSeen;

  UserPresence({
    required this.userId,
    required this.conversationId,
    required this.status,
    required this.lastSeen,
  });
}

/// Manages user presence for a conversation
class PresenceManager {
  final Ref ref;
  final String conversationId;
  final String userId;
  
  PresenceManager({
    required this.ref,
    required this.conversationId,
    required this.userId,
  });

  /// Join presence channel (user is viewing conversation)
  Future<void> joinPresence() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    // Subscribe to presence channel
    final presence = supabase.channel('presence:$conversationId').onPresenceSync(
      (_) {
        print('Presence synced for $conversationId');
      },
    ).onPresenceChange(
      PresenceAction.sync,
      (_) {
        print('Presence state changed for $conversationId');
      },
    );

    // Subscribe to presence channel
    await presence.subscribe(
      (status, [err]) {
        print('Presence subscription: $status - $err');
      },
      const Duration(seconds: 30), // Increased timeout for mobile networks
    );

    // Track this user's presence
    await presence.track({
      'user_id': userId,
      'status': 'online',
      'last_seen': DateTime.now().toIso8601String(),
    });
  }

  /// Leave presence channel (user is no longer viewing)
  Future<void> leavePresence() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('presence:$conversationId');
    await presence.unsubscribe();
  }

  /// Update user status
  Future<void> updateStatus(PresenceStatus status) async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('presence:$conversationId');
    await presence.track({
      'user_id': userId,
      'status': status.name,
      'last_seen': DateTime.now().toIso8601String(),
    });
  }

  /// Get all users' presence in conversation
  Future<List<UserPresence>> getConversationPresence() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('presence:$conversationId');
    final state = presence.presenceState();
    
    final presences = <UserPresence>[];
    
    for (final entry in state.entries) {
      for (final presence in entry.value) {
        final presenceMap = presence as Map<String, dynamic>;
        presences.add(UserPresence(
          userId: presenceMap['user_id'] as String,
          conversationId: conversationId,
          status: PresenceStatus.values.firstWhere(
            (s) => s.name == (presenceMap['status'] as String),
            orElse: () => PresenceStatus.offline,
          ),
          lastSeen: DateTime.parse(presenceMap['last_seen'] as String),
        ));
      }
    }
    
    return presences;
  }

  /// Check if user is online
  Future<bool> isUserOnline(String otherUserId) async {
    final presences = await getConversationPresence();
    return presences.any((p) =>
        p.userId == otherUserId && p.status == PresenceStatus.online);
  }
}

/// Provider for presence manager
final presenceManagerProvider = Provider.family<PresenceManager, (String, String)>((ref, args) {
  final (conversationId, userId) = args;
  return PresenceManager(
    ref: ref,
    conversationId: conversationId,
    userId: userId,
  );
});

/// Stream of user presence in a conversation
final conversationPresenceProvider =
    StreamProvider.autoDispose.family<List<UserPresence>, String>((ref, conversationId) async* {
  // This would typically subscribe to realtime presence updates
  // For now, we'll yield an empty list
  yield [];
  
  // TODO: Set up realtime presence stream
});

/// Check if a specific user is online
final userOnlineProvider = FutureProvider.autoDispose
    .family<bool, (String, String)>((ref, args) async {
  final (conversationId, userId) = args;
  final manager = ref.watch(presenceManagerProvider((conversationId, userId)));
  return manager.isUserOnline(userId);
});
</file>

<file path="lib/state/providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart' as fpr;
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:dio/dio.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/gen/api/clients/messages_api.dart';
import 'package:messageai/gen/api/clients/receipts_api.dart';

/// Provides the Supabase client instance
final supabaseClientProvider = fpr.Provider<SupabaseClient>((ref) {
  return SupabaseClientProvider.client;
});

/// Provides the Supabase auth client
final authProvider = fpr.Provider((ref) {
  return ref.watch(supabaseClientProvider).auth;
});

/// Provides the current authenticated user
final currentUserProvider = fpr.StreamProvider((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  return supabase.auth.onAuthStateChange.map((data) => data.session?.user);
});

/// Provides a Dio HTTP client configured for the API
final dioProvider = fpr.Provider<Dio>((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  final dio = Dio(
    BaseOptions(
      baseUrl: supabase.restUrl,
      headers: {
        'Authorization': 'Bearer ${supabase.auth.currentSession?.accessToken}',
        'apikey': supabase.auth.currentSession?.user.id ?? '',
      },
    ),
  );
  return dio;
});

/// Provides the Messages API client
final messagesApiProvider = fpr.Provider<MessagesApi>((ref) {
  final dio = ref.watch(dioProvider);
  final supabase = ref.watch(supabaseClientProvider);
  return MessagesApi(
    dio: dio,
    baseUrl: supabase.restUrl,
  );
});

/// Provides the Receipts API client
final receiptsApiProvider = fpr.Provider<ReceiptsApi>((ref) {
  final dio = ref.watch(dioProvider);
  final supabase = ref.watch(supabaseClientProvider);
  return ReceiptsApi(
    dio: dio,
    baseUrl: supabase.restUrl,
  );
});

/// Indicates whether the user is currently authenticated
final isAuthenticatedProvider = fpr.StreamProvider<bool>((ref) async* {
  final authState = ref.watch(currentUserProvider);
  yield* authState.when(
    data: (user) async* {
      yield user != null;
    },
    loading: () async* {
      yield false;
    },
    error: (err, st) async* {
      yield false;
    },
  );
});
</file>

<file path="lib/state/realtime_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/state/database_provider.dart';
import 'package:messageai/state/providers.dart';
import 'package:messageai/state/repository_providers.dart';

/// Manages realtime subscriptions to conversation messages
class RealtimeManager {
  final Ref ref;
  final Map<String, dynamic> _subscriptions = {};

  RealtimeManager({required this.ref});

  /// Subscribe to messages in a conversation
  void subscribeToConversationMessages(String conversationId) {
    final supabase = ref.watch(supabaseClientProvider);
    
    final subscription = supabase
        .channel('public:messages')
        .onPostgresChanges(
          event: PostgresChangeEvent.all,
          schema: 'public',
          table: 'messages',
          filter: PostgresChangeFilter(
            type: FilterType.eq,
            column: 'conversation_id',
            value: conversationId,
          ),
        )
        .subscribe((payload, [ref]) async {
          // Handle new/updated messages
          if (payload.eventType == 'INSERT' || payload.eventType == 'UPDATE') {
            final messageData = payload.newRecord as Map<String, dynamic>;
            final message = Message(
              id: messageData['id'] as String,
              conversationId: messageData['conversation_id'] as String,
              senderId: messageData['sender_id'] as String,
              body: messageData['body'] as String,
              mediaUrl: messageData['media_url'] as String?,
              createdAt: messageData['created_at'] as int,
              updatedAt: messageData['updated_at'] as int,
              isSynced: true,
            );
            
            // Update local DB
            final messageDao = ref.watch(messageDaoProvider);
            await messageDao.insertMessage(message);
          }
        });
    
    _subscriptions[conversationId] = subscription;
  }

  /// Unsubscribe from conversation messages
  Future<void> unsubscribeFromConversation(String conversationId) async {
    final subscription = _subscriptions.remove(conversationId);
    if (subscription != null) {
      await subscription.unsubscribe();
    }
  }

  /// Cleanup all subscriptions
  Future<void> cleanup() async {
    for (final subscription in _subscriptions.values) {
      await subscription.unsubscribe();
    }
    _subscriptions.clear();
  }
}

/// Provider for realtime manager
final realtimeManagerProvider = Provider.autoDispose<RealtimeManager>((ref) {
  return RealtimeManager(ref: ref);
});

/// Subscribe to messages in a conversation
final conversationMessagesRealtimeProvider = 
    FutureProvider.autoDispose.family<void, String>((ref, conversationId) async {
  final manager = ref.watch(realtimeManagerProvider);
  manager.subscribeToConversationMessages(conversationId);
  
  // Cleanup on dispose
  ref.onDispose(() {
    manager.unsubscribeFromConversation(conversationId);
  });
});

/// Watch for realtime message updates in a conversation
final realtimeConversationMessagesProvider = 
    StreamProvider.autoDispose.family<List<Message>, String>((ref, conversationId) async* {
  // Enable realtime subscription
  await ref.watch(conversationMessagesRealtimeProvider(conversationId).future);
  
  // Watch the local messages
  yield* ref.watch(messagesStreamProvider(conversationId));
});
</file>

<file path="lib/state/repository_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/repositories/message_repository.dart';
import 'package:messageai/data/repositories/receipt_repository.dart';
import 'package:messageai/data/repositories/group_repository.dart';
import 'package:messageai/state/database_provider.dart';
import 'package:messageai/state/providers.dart';

/// Provides the MessageRepository
final messageRepositoryProvider = Provider<MessageRepository>((ref) {
  final messagesApi = ref.watch(messagesApiProvider);
  final messageDao = ref.watch(messageDaoProvider);
  final outboxDao = ref.watch(pendingOutboxDaoProvider);
  
  return MessageRepository(
    messagesApi: messagesApi,
    messageDao: messageDao,
    outboxDao: outboxDao,
  );
});

/// Provides the ReceiptRepository
final receiptRepositoryProvider = Provider<ReceiptRepository>((ref) {
  final receiptsApi = ref.watch(receiptsApiProvider);
  final receiptDao = ref.watch(receiptDaoProvider);
  final outboxDao = ref.watch(pendingOutboxDaoProvider);
  
  return ReceiptRepository(
    receiptsApi: receiptsApi,
    receiptDao: receiptDao,
    outboxDao: outboxDao,
  );
});

/// Provides the GroupRepository
final groupRepositoryProvider = Provider<GroupRepository>((ref) {
  final conversationDao = ref.watch(conversationDaoProvider);
  final participantDao = ref.watch(participantDaoProvider);
  
  return GroupRepository(
    conversationDao: conversationDao,
    participantDao: participantDao,
  );
});

// Add receiptDaoProvider to database_provider.dart if not already there
// final receiptDaoProvider = Provider<ReceiptDao>((ref) {
//   final db = ref.watch(appDbProvider);
//   return ReceiptDao(db);
// });
</file>

<file path="lib/state/send_queue.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/state/repository_providers.dart';

/// Message to send
class SendableMessage {
  final String id;
  final String conversationId;
  final String senderId;
  final String body;
  final String? mediaUrl;

  SendableMessage({
    required this.id,
    required this.conversationId,
    required this.senderId,
    required this.body,
    this.mediaUrl,
  });
}

/// Manages sending messages with optimistic updates
class SendQueue {
  final Ref ref;
  
  SendQueue({required this.ref});

  /// Send a message
  Future<Message> sendMessage({
    required String conversationId,
    required String senderId,
    required String body,
    String? mediaUrl,
  }) async {
    // Generate unique ID
    const uuid = Uuid();
    final messageId = uuid.v4();
    
    // Get repository
    final messageRepo = ref.watch(messageRepositoryProvider);
    
    // Send optimistically (local first)
    final message = await messageRepo.sendMessage(
      id: messageId,
      conversationId: conversationId,
      senderId: senderId,
      body: body,
      mediaUrl: mediaUrl,
    );
    
    // Queue background sync
    _scheduleSyncIfNeeded();
    
    return message;
  }

  /// Drain the send queue (sync pending messages)
  Future<void> drainQueue() async {
    final messageRepo = ref.watch(messageRepositoryProvider);
    final receiptRepo = ref.watch(receiptRepositoryProvider);
    
    try {
      // Sync messages
      await messageRepo.syncUnsyncedMessages();
      
      // Sync receipts
      await receiptRepo.syncUnsyncedReceipts();
    } catch (e) {
      print('Error draining send queue: $e');
      rethrow;
    }
  }

  /// Schedule sync if there are pending operations
  void _scheduleSyncIfNeeded() {
    // In a real app, this would use a periodic timer or background service
    // For now, we'll just sync immediately for demo purposes
    _syncInBackground();
  }

  /// Sync in background
  void _syncInBackground() {
    // Run sync without awaiting (fire and forget)
    drainQueue().catchError((e) {
      print('Background sync error: $e');
    });
  }

  /// Get pending message count
  Future<int> getPendingCount() async {
    final messageRepo = ref.watch(messageRepositoryProvider);
    return messageRepo.getPendingMessageCount();
  }
}

/// Provider for send queue
final sendQueueProvider = Provider<SendQueue>((ref) {
  return SendQueue(ref: ref);
});

/// State notifier for managing message sends
class SendMessageNotifier extends StateNotifier<AsyncValue<void>> {
  final Ref ref;

  SendMessageNotifier({required this.ref}) : super(const AsyncValue.data(null));

  /// Send a message
  Future<Message> sendMessage({
    required String conversationId,
    required String senderId,
    required String body,
    String? mediaUrl,
  }) async {
    state = const AsyncValue.loading();
    
    try {
      final sendQueue = ref.watch(sendQueueProvider);
      final message = await sendQueue.sendMessage(
        conversationId: conversationId,
        senderId: senderId,
        body: body,
        mediaUrl: mediaUrl,
      );
      
      state = const AsyncValue.data(null);
      return message;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }

  /// Retry pending messages
  Future<void> retryPending() async {
    state = const AsyncValue.loading();
    
    try {
      final sendQueue = ref.watch(sendQueueProvider);
      await sendQueue.drainQueue();
      state = const AsyncValue.data(null);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }
}

/// State notifier provider for sending messages
final sendMessageNotifierProvider = 
    StateNotifierProvider<SendMessageNotifier, AsyncValue<void>>((ref) {
  return SendMessageNotifier(ref: ref);
});

/// Get pending message count
final pendingMessageCountProvider = FutureProvider<int>((ref) async {
  final sendQueue = ref.watch(sendQueueProvider);
  return sendQueue.getPendingCount();
});
</file>

<file path="lib/state/typing_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/providers.dart';

/// User typing information
class TypingUser {
  final String userId;
  final DateTime startedAt;
  final Duration timeout;

  TypingUser({
    required this.userId,
    required this.startedAt,
    this.timeout = const Duration(seconds: 3),
  });

  /// Check if typing indicator has expired
  bool get isExpired {
    return DateTime.now().difference(startedAt) > timeout;
  }
}

/// Manages typing indicators for a conversation
class TypingManager {
  final Ref ref;
  final String conversationId;
  final String userId;
  
  final Map<String, TypingUser> _typingUsers = {};
  static const Duration _debounceDelay = Duration(milliseconds: 300);
  DateTime? _lastTypingSent;

  TypingManager({
    required this.ref,
    required this.conversationId,
    required this.userId,
  });

  /// Broadcast that user is typing
  Future<void> sendTypingIndicator() async {
    final now = DateTime.now();
    
    // Debounce: only send every 300ms
    if (_lastTypingSent != null &&
        now.difference(_lastTypingSent!) < _debounceDelay) {
      return;
    }
    
    _lastTypingSent = now;
    
    final supabase = ref.watch(supabaseClientProvider);
    
    // Send typing indicator through presence
    final presence = supabase.channel('typing:$conversationId');
    
    try {
      await presence.subscribe(
        (status, [err]) {
          print('Typing subscription: $status - $err');
        },
        const Duration(seconds: 30), // Increased timeout for mobile networks
      );
      
      await presence.track({
        'user_id': userId,
        'typing': true,
        'timestamp': now.toIso8601String(),
      });
    } catch (e) {
      print('Error sending typing indicator: $e');
    }
  }

  /// Stop broadcasting typing
  Future<void> stopTypingIndicator() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('typing:$conversationId');
    
    try {
      await presence.track({
        'user_id': userId,
        'typing': false,
      });
      
      await presence.unsubscribe();
    } catch (e) {
      print('Error stopping typing indicator: $e');
    }
  }

  /// Add a typing user (received from server)
  void addTypingUser(String otherUserId) {
    _typingUsers[otherUserId] = TypingUser(userId: otherUserId, startedAt: DateTime.now());
  }

  /// Remove a typing user
  void removeTypingUser(String otherUserId) {
    _typingUsers.remove(otherUserId);
  }

  /// Get list of currently typing users (excluding expired ones)
  List<TypingUser> getTypingUsers() {
    // Remove expired entries
    _typingUsers.removeWhere((_, user) => user.isExpired);
    return _typingUsers.values.toList();
  }

  /// Get typing users display text
  String getTypingText() {
    final typingUsers = getTypingUsers();
    
    if (typingUsers.isEmpty) return '';
    if (typingUsers.length == 1) return '${typingUsers.first.userId} is typing...';
    if (typingUsers.length == 2) {
      return '${typingUsers[0].userId} and ${typingUsers[1].userId} are typing...';
    }
    
    return '${typingUsers.length} people are typing...';
  }

  /// Check if anyone is typing
  bool get anyoneTyping => getTypingUsers().isNotEmpty;
}

/// Provider for typing manager
final typingManagerProvider =
    Provider.family<TypingManager, (String, String)>((ref, args) {
  final (conversationId, userId) = args;
  return TypingManager(
    ref: ref,
    conversationId: conversationId,
    userId: userId,
  );
});

/// Stream of typing users in a conversation
final conversationTypingProvider = StreamProvider.autoDispose
    .family<List<TypingUser>, String>((ref, conversationId) async* {
  // This would typically subscribe to realtime typing updates
  // For now, we'll yield an empty list
  yield [];
  
  // TODO: Set up realtime typing stream
});

/// Get typing status text for display
final typingStatusTextProvider = StreamProvider.autoDispose
    .family<String, String>((ref, conversationId) async* {
  yield* ref.watch(conversationTypingProvider(conversationId)).when(
        data: (typingUsers) async* {
          if (typingUsers.isEmpty) {
            yield '';
          } else if (typingUsers.length == 1) {
            yield '${typingUsers.first.userId} is typing...';
          } else {
            yield '${typingUsers.length} people are typing...';
          }
        },
        loading: () async* {
          yield '';
        },
        error: (err, st) async* {
          yield '';
        },
      );
});
</file>

<file path="lib/widgets/network_status_banner.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/network_connectivity_service.dart';
import 'package:messageai/services/offline_queue_service.dart';

/// Banner that shows network status and pending message count
class NetworkStatusBanner extends StatefulWidget {
  const NetworkStatusBanner({Key? key}) : super(key: key);

  @override
  State<NetworkStatusBanner> createState() => _NetworkStatusBannerState();
}

class _NetworkStatusBannerState extends State<NetworkStatusBanner> {
  final _connectivityService = NetworkConnectivityService();
  final _offlineQueueService = OfflineQueueService();
  
  ConnectivityStatus _status = ConnectivityStatus.unknown;
  int _pendingMessages = 0;

  @override
  void initState() {
    super.initState();
    _status = _connectivityService.currentStatus;
    _loadPendingCount();
    
    // Listen to connectivity changes
    _connectivityService.onStatusChange.listen((status) {
      if (mounted) {
        setState(() => _status = status);
        _loadPendingCount();
      }
    });
  }

  Future<void> _loadPendingCount() async {
    final count = await _offlineQueueService.getPendingMessageCount();
    if (mounted) {
      setState(() => _pendingMessages = count);
    }
  }

  Future<void> _handleSyncTap() async {
    // Show loading
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Row(
          children: [
            SizedBox(
              width: 16,
              height: 16,
              child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),
            ),
            SizedBox(width: 12),
            Text('Syncing pending messages...'),
          ],
        ),
        duration: Duration(seconds: 2),
      ),
    );

    final result = await _offlineQueueService.forceSyncNow();
    
    if (!mounted) return;

    ScaffoldMessenger.of(context).hideCurrentSnackBar();
    
    if (result.isSuccess) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.check_circle, color: Colors.white),
              const SizedBox(width: 12),
              Text('${result.successCount} messages synced'),
            ],
          ),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 2),
        ),
      );
      _loadPendingCount();
    } else if (result.status == SyncStatus.noMessages) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Row(
            children: [
              Icon(Icons.check_circle, color: Colors.white),
              SizedBox(width: 12),
              Text('All messages are synced'),
            ],
          ),
          backgroundColor: Colors.blue,
          duration: Duration(seconds: 2),
        ),
      );
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.error, color: Colors.white),
              const SizedBox(width: 12),
              Text('Failed to sync: ${result.errorMessage ?? "Unknown error"}'),
            ],
          ),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    // Only show banner when offline or has pending messages
    if (_status == ConnectivityStatus.online && _pendingMessages == 0) {
      return const SizedBox.shrink();
    }

    return Material(
      color: _getBannerColor(),
      child: InkWell(
        onTap: _status == ConnectivityStatus.online && _pendingMessages > 0
            ? _handleSyncTap
            : null,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: Row(
            children: [
              Icon(
                _getBannerIcon(),
                size: 20,
                color: Colors.white,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  _getBannerText(),
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 14,
                  ),
                ),
              ),
              if (_status == ConnectivityStatus.online && _pendingMessages > 0)
                const Icon(
                  Icons.sync,
                  size: 20,
                  color: Colors.white,
                ),
            ],
          ),
        ),
      ),
    );
  }

  Color _getBannerColor() {
    if (_status == ConnectivityStatus.offline) {
      return Colors.red.shade700;
    } else if (_pendingMessages > 0) {
      return Colors.orange.shade700;
    }
    return Colors.blue;
  }

  IconData _getBannerIcon() {
    if (_status == ConnectivityStatus.offline) {
      return Icons.cloud_off;
    } else if (_pendingMessages > 0) {
      return Icons.cloud_sync;
    }
    return Icons.cloud_done;
  }

  String _getBannerText() {
    if (_status == ConnectivityStatus.offline) {
      if (_pendingMessages > 0) {
        return 'Offline • $_pendingMessages message${_pendingMessages == 1 ? '' : 's'} pending';
      }
      return 'You are offline';
    } else if (_pendingMessages > 0) {
      return 'Syncing $_pendingMessages message${_pendingMessages == 1 ? '' : 's'} • Tap to sync now';
    }
    return 'All messages synced';
  }
}

/// Small inline network indicator
class NetworkStatusIndicator extends StatefulWidget {
  final bool showLabel;

  const NetworkStatusIndicator({
    Key? key,
    this.showLabel = true,
  }) : super(key: key);

  @override
  State<NetworkStatusIndicator> createState() => _NetworkStatusIndicatorState();
}

class _NetworkStatusIndicatorState extends State<NetworkStatusIndicator> {
  final _connectivityService = NetworkConnectivityService();
  ConnectivityStatus _status = ConnectivityStatus.unknown;

  @override
  void initState() {
    super.initState();
    _status = _connectivityService.currentStatus;
    
    _connectivityService.onStatusChange.listen((status) {
      if (mounted) {
        setState(() => _status = status);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          width: 8,
          height: 8,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: _getStatusColor(),
          ),
        ),
        if (widget.showLabel) ...[
          const SizedBox(width: 6),
          Text(
            _getStatusLabel(),
            style: TextStyle(
              fontSize: 12,
              color: Colors.grey[600],
            ),
          ),
        ],
      ],
    );
  }

  Color _getStatusColor() {
    switch (_status) {
      case ConnectivityStatus.online:
        return Colors.green;
      case ConnectivityStatus.offline:
        return Colors.red;
      case ConnectivityStatus.unknown:
        return Colors.grey;
    }
  }

  String _getStatusLabel() {
    switch (_status) {
      case ConnectivityStatus.online:
        return 'Online';
      case ConnectivityStatus.offline:
        return 'Offline';
      case ConnectivityStatus.unknown:
        return 'Unknown';
    }
  }
}
</file>

<file path="lib/widgets/sliding_panel.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';

/// A sliding panel widget that can be dragged up and down
/// Used for the message screen to slide over AI insights
class SlidingPanel extends StatefulWidget {
  /// The content to display in the sliding panel
  final Widget child;
  
  /// Called when the panel position changes (0.0 = collapsed, 1.0 = fully expanded)
  final ValueChanged<double>? onSlide;
  
  /// Minimum height as a fraction of screen (0.0 - 1.0)
  final double minHeight;
  
  /// Maximum height as a fraction of screen (0.0 - 1.0)
  final double maxHeight;
  
  /// Initial height as a fraction of screen (0.0 - 1.0)
  final double initialHeight;
  
  /// Snap positions for the panel (as fractions of screen height)
  final List<double> snapSizes;
  
  /// Background color of the panel
  final Color? backgroundColor;
  
  /// Border radius for the top corners
  final double borderRadius;
  
  /// Whether to show the drag handle
  final bool showDragHandle;

  const SlidingPanel({
    Key? key,
    required this.child,
    this.onSlide,
    this.minHeight = 0.2,
    this.maxHeight = 0.95,
    this.initialHeight = 0.8,
    this.snapSizes = const [0.2, 0.5, 0.8, 0.95],
    this.backgroundColor,
    this.borderRadius = 16.0,
    this.showDragHandle = true,
  }) : super(key: key);

  @override
  State<SlidingPanel> createState() => _SlidingPanelState();
}

class _SlidingPanelState extends State<SlidingPanel> {
  final DraggableScrollableController _controller = DraggableScrollableController();
  
  @override
  void initState() {
    super.initState();
    // Add listener to track position changes
    _controller.addListener(_onPositionChanged);
  }
  
  @override
  void dispose() {
    _controller.removeListener(_onPositionChanged);
    _controller.dispose();
    super.dispose();
  }
  
  void _onPositionChanged() {
    if (_controller.isAttached) {
      final size = _controller.size;
      // Normalize the size to 0.0 - 1.0 range
      final normalizedPosition = (size - widget.minHeight) / (widget.maxHeight - widget.minHeight);
      widget.onSlide?.call(normalizedPosition.clamp(0.0, 1.0));
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final bgColor = widget.backgroundColor ?? 
                    (isDark ? AppTheme.black : AppTheme.white);
    
    return DraggableScrollableSheet(
      controller: _controller,
      initialChildSize: widget.initialHeight,
      minChildSize: widget.minHeight,
      maxChildSize: widget.maxHeight,
      snap: true,
      snapSizes: widget.snapSizes,
      builder: (BuildContext context, ScrollController scrollController) {
        return Container(
          decoration: BoxDecoration(
            color: bgColor,
            borderRadius: BorderRadius.only(
              topLeft: Radius.circular(widget.borderRadius),
              topRight: Radius.circular(widget.borderRadius),
            ),
            boxShadow: isDark ? AppTheme.shadow2Dark : AppTheme.shadow3Light,
          ),
          child: Column(
            children: [
              // Drag handle area
              if (widget.showDragHandle)
                GestureDetector(
                  onTap: () => _snapToNextPosition(),
                  child: Container(
                    width: double.infinity,
                    padding: const EdgeInsets.symmetric(
                      vertical: AppTheme.spacingS,
                    ),
                    child: Center(
                      child: Container(
                        width: 40,
                        height: 4,
                        decoration: BoxDecoration(
                          color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                          borderRadius: BorderRadius.circular(AppTheme.radiusPill),
                        ),
                      ),
                    ),
                  ),
                ),
              
              // Panel content
              Expanded(
                child: widget.child,
              ),
            ],
          ),
        );
      },
    );
  }
  
  /// Snaps the panel to the next position in the snapSizes list
  void _snapToNextPosition() {
    if (!_controller.isAttached) return;
    
    final currentSize = _controller.size;
    final sortedSnaps = List<double>.from(widget.snapSizes)..sort();
    
    // Find the next snap position
    final nextSnap = sortedSnaps.firstWhere(
      (snap) => snap > currentSize + 0.05, // Add small buffer for floating point
      orElse: () => sortedSnaps.first, // Wrap around to first
    );
    
    _controller.animateTo(
      nextSnap,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
  }
}

/// Extension to provide convenience methods for sliding panel
extension SlidingPanelController on DraggableScrollableController {
  /// Animate to a specific size
  Future<void> animateToSize(
    double size, {
    Duration duration = const Duration(milliseconds: 300),
    Curve curve = Curves.easeInOut,
  }) {
    return animateTo(
      size,
      duration: duration,
      curve: curve,
    );
  }
  
  /// Jump to a specific size without animation
  void jumpToSize(double size) {
    jumpTo(size);
  }
  
  /// Get current size
  double get currentSize => isAttached ? size : 0.0;
}
</file>

<file path="lib/widgets/user_avatar.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/avatar_service.dart';

/// Reusable widget for displaying user avatars
/// Fetches avatar from backend or shows fallback initial
class UserAvatar extends StatefulWidget {
  final String? userId;
  final String? avatarUrl;
  final String fallbackText;
  final double radius;
  final bool isGroup;

  const UserAvatar({
    Key? key,
    this.userId,
    this.avatarUrl,
    required this.fallbackText,
    this.radius = 20,
    this.isGroup = false,
  }) : super(key: key);

  @override
  State<UserAvatar> createState() => _UserAvatarState();
}

class _UserAvatarState extends State<UserAvatar> {
  final _avatarService = AvatarService();
  String? _fetchedAvatarUrl;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _loadAvatar();
  }

  @override
  void didUpdateWidget(UserAvatar oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Reload if userId changed
    if (oldWidget.userId != widget.userId || oldWidget.avatarUrl != widget.avatarUrl) {
      _loadAvatar();
    }
  }

  Future<void> _loadAvatar() async {
    // If avatarUrl is directly provided, use it
    if (widget.avatarUrl != null) {
      setState(() {
        _fetchedAvatarUrl = widget.avatarUrl;
      });
      return;
    }

    // If userId provided, fetch avatar
    if (widget.userId != null) {
      setState(() => _isLoading = true);
      
      try {
        final url = await _avatarService.getAvatarUrl(widget.userId!);
        if (mounted) {
          setState(() {
            _fetchedAvatarUrl = url;
            _isLoading = false;
          });
        }
      } catch (e) {
        if (mounted) {
          setState(() => _isLoading = false);
        }
        // Silently fail - fallback will be shown
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    // Show loading indicator
    if (_isLoading) {
      return CircleAvatar(
        radius: widget.radius,
        backgroundColor: theme.colorScheme.primary.withOpacity(0.2),
        child: SizedBox(
          width: widget.radius,
          height: widget.radius,
          child: const CircularProgressIndicator(strokeWidth: 2),
        ),
      );
    }

    // Show avatar image if available
    if (_fetchedAvatarUrl != null && _fetchedAvatarUrl!.isNotEmpty) {
      return CircleAvatar(
        radius: widget.radius,
        backgroundColor: theme.colorScheme.primary,
        backgroundImage: NetworkImage(_fetchedAvatarUrl!),
        // Error handling: show fallback if image fails to load
        onBackgroundImageError: (exception, stackTrace) {
          print('Error loading avatar: $exception');
        },
        child: Container(), // Empty container as placeholder
      );
    }

    // Fallback: Show initial or group icon
    return CircleAvatar(
      radius: widget.radius,
      backgroundColor: theme.colorScheme.primary,
      child: widget.isGroup
          ? Icon(
              Icons.group,
              color: Colors.white,
              size: widget.radius * 1.2,
            )
          : Text(
              _getInitial(widget.fallbackText),
              style: TextStyle(
                fontSize: widget.radius * 0.9,
                fontWeight: FontWeight.bold,
                color: Colors.white,
              ),
            ),
    );
  }

  /// Get first letter of name for fallback
  String _getInitial(String text) {
    if (text.isEmpty) return '?';
    return text[0].toUpperCase();
  }
}
</file>

<file path="Makefile">
contracts/gen: ; npm --prefix ../contracts run gen:dart
fmt: ; dart format .
dev: ; flutter run --dart-define-from-file=.env.dev.json
test: ; flutter test
</file>

<file path="pubspec.yaml">
name: messageai
description: MessageAI - Cross-platform messaging app with Flutter
version: 0.1.0+1
publish_to: none

environment:
  sdk: ^3.0.0
  flutter: ">=3.10.0"

dependencies:
  flutter:
    sdk: flutter

  # Network & API
  supabase_flutter: ^1.10.0
  dio: ^5.3.0

  # State management
  riverpod: ^2.4.0
  flutter_riverpod: ^2.4.0

  # Local database
  drift: ^2.14.0
  drift_flutter: ^0.2.7
  sqlite3_flutter_libs: ^0.5.16

  # Firebase
  firebase_core: ^2.27.0
  firebase_messaging: ^14.6.0

  # Local notifications (Phase 06)
  flutter_local_notifications: ^19.0.0

  # UI
  cupertino_icons: ^1.0.2

  # Utilities
  uuid: ^4.0.0
  image_picker: ^1.0.4
  path: ^1.8.3

dev_dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter

  flutter_lints: ^3.0.0

  # Code generation
  build_runner: ^2.4.0
  drift_dev: ^2.14.0

flutter:
  uses-material-design: true

dependency_overrides:
  # Completely exclude sign_in_with_apple (uses deprecated Flutter APIs incompatible with latest Android)
  sign_in_with_apple:
  sign_in_with_apple_platform_interface:
  sign_in_with_apple_web:
</file>

<file path="test/models/ai_analysis_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('AIAnalysis Model', () {
    test('fromJson creates valid object with all fields', () {
      final json = {
        'id': 'test-id-123',
        'message_id': 'msg-456',
        'tone': 'Professional',
        'urgency_level': 'Medium',
        'intent': 'requesting information',
        'confidence_score': 0.85,
        'analysis_timestamp': 1234567890,
      };
      
      final analysis = AIAnalysis.fromJson(json);
      
      expect(analysis.id, equals('test-id-123'));
      expect(analysis.messageId, equals('msg-456'));
      expect(analysis.tone, equals('Professional'));
      expect(analysis.urgencyLevel, equals('Medium'));
      expect(analysis.intent, equals('requesting information'));
      expect(analysis.confidenceScore, equals(0.85));
      expect(analysis.analysisTimestamp, equals(1234567890));
    });
    
    test('fromJson handles null optional fields', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-id',
        'tone': 'Neutral',
        'analysis_timestamp': 1234567890,
      };
      
      final analysis = AIAnalysis.fromJson(json);
      
      expect(analysis.tone, equals('Neutral'));
      expect(analysis.urgencyLevel, isNull);
      expect(analysis.intent, isNull);
      expect(analysis.confidenceScore, isNull);
    });
    
    test('toJson creates correct map', () {
      final analysis = AIAnalysis(
        id: 'id-1',
        messageId: 'msg-1',
        tone: 'Friendly',
        urgencyLevel: 'Low',
        intent: 'greeting',
        confidenceScore: 0.9,
        analysisTimestamp: 9876543210,
      );
      
      final json = analysis.toJson();
      
      expect(json['id'], equals('id-1'));
      expect(json['message_id'], equals('msg-1'));
      expect(json['tone'], equals('Friendly'));
      expect(json['urgency_level'], equals('Low'));
      expect(json['intent'], equals('greeting'));
      expect(json['confidence_score'], equals(0.9));
      expect(json['analysis_timestamp'], equals(9876543210));
    });
    
    test('equality works correctly', () {
      final a1 = AIAnalysis(
        id: 'same-id',
        messageId: 'same-msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );
      
      final a2 = AIAnalysis(
        id: 'same-id',
        messageId: 'same-msg',
        tone: 'Professional', // Different tone
        analysisTimestamp: 456, // Different timestamp
      );
      
      final a3 = AIAnalysis(
        id: 'different-id',
        messageId: 'same-msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );
      
      expect(a1, equals(a2)); // Same ID and message ID
      expect(a1, isNot(equals(a3))); // Different ID
    });
    
    test('hashCode is consistent', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Casual',
        analysisTimestamp: 123,
      );
      
      final hash1 = analysis.hashCode;
      final hash2 = analysis.hashCode;
      
      expect(hash1, equals(hash2));
    });
    
    test('toString includes key information', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Urgent',
        urgencyLevel: 'High',
        intent: 'needs response',
        confidenceScore: 0.95,
        analysisTimestamp: 123456,
      );
      
      final str = analysis.toString();
      
      expect(str, contains('test-id'));
      expect(str, contains('msg-id'));
      expect(str, contains('Urgent'));
      expect(str, contains('High'));
    });
    
    test('handles double and int confidence scores', () {
      // Test with integer
      final json1 = {
        'id': 'id-1',
        'message_id': 'msg-1',
        'tone': 'Neutral',
        'confidence_score': 1,
        'analysis_timestamp': 123,
      };
      
      final analysis1 = AIAnalysis.fromJson(json1);
      expect(analysis1.confidenceScore, equals(1.0));
      
      // Test with double
      final json2 = {
        'id': 'id-2',
        'message_id': 'msg-2',
        'tone': 'Neutral',
        'confidence_score': 0.75,
        'analysis_timestamp': 123,
      };
      
      final analysis2 = AIAnalysis.fromJson(json2);
      expect(analysis2.confidenceScore, equals(0.75));
    });
    
    test('round-trip JSON serialization preserves data', () {
      final original = AIAnalysis(
        id: 'round-trip-id',
        messageId: 'round-trip-msg',
        tone: 'Excited',
        urgencyLevel: 'Medium',
        intent: 'celebration',
        confidenceScore: 0.88,
        analysisTimestamp: 1111111111,
      );
      
      final json = original.toJson();
      final reconstructed = AIAnalysis.fromJson(json);
      
      expect(reconstructed, equals(original));
      expect(reconstructed.id, equals(original.id));
      expect(reconstructed.messageId, equals(original.messageId));
      expect(reconstructed.tone, equals(original.tone));
      expect(reconstructed.urgencyLevel, equals(original.urgencyLevel));
      expect(reconstructed.intent, equals(original.intent));
      expect(reconstructed.confidenceScore, equals(original.confidenceScore));
      expect(reconstructed.analysisTimestamp, equals(original.analysisTimestamp));
    });
  });
}
</file>

<file path="test/offline_queue_test.dart">
import 'package:flutter_test/flutter_test.dart';

/// Placeholder test for offline queue functionality
/// Full implementation requires database mocking setup
void main() {
  group('Offline Message Queue', () {
    test('Offline queue service exists', () {
      // Basic test to ensure the test file compiles
      expect(true, isTrue);
    });

    test('Network connectivity service can be instantiated', () {
      // Placeholder test
      expect(1 + 1, equals(2));
    });

    test('Retry service handles exponential backoff', () {
      // Placeholder test
      expect(true, isTrue);
    });
  });

  group('Message Syncing', () {
    test('Messages can be queued', () {
      // Placeholder test
      expect(true, isTrue);
    });

    test('Messages can be synced when online', () {
      // Placeholder test
      expect(true, isTrue);
    });
  });
}
</file>

<file path="test/realtime_diagnostic_test.dart">
import 'package:flutter_test/flutter_test.dart';

/// Placeholder test for realtime diagnostic functionality
void main() {
  group('Realtime Diagnostics', () {
    test('Realtime diagnostic service exists', () {
      // Basic test to ensure the test file compiles
      expect(true, isTrue);
    });

    test('Channel diagnostics can be tracked', () {
      // Placeholder test
      expect(1 + 1, equals(2));
    });

    test('Health checks can be performed', () {
      // Placeholder test  
      expect(true, isTrue);
    });
  });

  group('Connection Testing', () {
    test('Connection test can be executed', () {
      // Placeholder test
      expect(true, isTrue);
    });

    test('Latency can be measured', () {
      // Placeholder test
      expect(true, isTrue);
    });
  });
}
</file>

<file path="test/services/ai_analysis_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  // Note: Service tests that require Supabase client are skipped in unit tests
  // These should be tested in integration tests with proper Supabase setup
  
  group('AIAnalysisService - Unit Tests', () {
    test('service requires Supabase initialization', () {
      // This test documents that the service requires Supabase
      // Full service tests should be done in integration tests
      expect(true, isTrue);
    });
  });
  
  group('AIAnalysis Model Integration', () {
    test('AIAnalysis can be stored and retrieved', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-123',
        tone: 'Friendly',
        urgencyLevel: 'Low',
        intent: 'greeting',
        confidenceScore: 0.9,
        analysisTimestamp: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );
      
      expect(analysis.id, equals('test-id'));
      expect(analysis.messageId, equals('msg-123'));
      expect(analysis.tone, equals('Friendly'));
    });
    
    test('Multiple AIAnalysis objects can coexist', () {
      final analysis1 = AIAnalysis(
        id: 'id-1',
        messageId: 'msg-1',
        tone: 'Professional',
        analysisTimestamp: 123,
      );
      
      final analysis2 = AIAnalysis(
        id: 'id-2',
        messageId: 'msg-2',
        tone: 'Casual',
        analysisTimestamp: 456,
      );
      
      expect(analysis1.id, isNot(equals(analysis2.id)));
      expect(analysis1.tone, isNot(equals(analysis2.tone)));
    });
  });
}
</file>

<file path="test/widget_test.dart">
// Basic Flutter widget test for MessageAI app

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/app.dart';

void main() {
  testWidgets('MessageAI app loads', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(
      const ProviderScope(
        child: MessageAIApp(),
      ),
    );

    // Verify app loads without errors
    expect(find.byType(MaterialApp), findsOneWidget);
  });
}
</file>

<file path="test/widgets/tone_badge_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('ToneBadge Widget', () {
    testWidgets('displays Friendly tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        urgencyLevel: 'Low',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('😊'), findsOneWidget);
      expect(find.text('Friendly'), findsOneWidget);
    });
    
    testWidgets('displays Professional tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Professional',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('💼'), findsOneWidget);
      expect(find.text('Professional'), findsOneWidget);
    });
    
    testWidgets('displays Urgent tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Urgent',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('⚡'), findsOneWidget);
      expect(find.text('Urgent'), findsOneWidget);
    });
    
    testWidgets('displays Casual tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Casual',
        urgencyLevel: 'Low',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('😎'), findsOneWidget);
      expect(find.text('Casual'), findsOneWidget);
    });
    
    testWidgets('displays Formal tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Formal',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('👔'), findsOneWidget);
      expect(find.text('Formal'), findsOneWidget);
    });
    
    testWidgets('displays Excited tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Excited',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('🎉'), findsOneWidget);
      expect(find.text('Excited'), findsOneWidget);
    });
    
    testWidgets('displays Concerned tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Concerned',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('😟'), findsOneWidget);
      expect(find.text('Concerned'), findsOneWidget);
    });
    
    testWidgets('displays Neutral tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Neutral',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('💬'), findsOneWidget);
      expect(find.text('Neutral'), findsOneWidget);
    });
    
    testWidgets('shows urgency indicator for High urgency', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Urgent',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      // Urgency dot should be present (multiple Containers exist)
      expect(find.byType(Container), findsWidgets);
      expect(find.text('Urgent'), findsOneWidget);
    });
    
    testWidgets('shows urgency indicator for Critical urgency', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Professional',
        urgencyLevel: 'Critical',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.byType(Container), findsWidgets);
      expect(find.text('Professional'), findsOneWidget);
    });
    
    testWidgets('does not show urgency indicator for Low urgency', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Casual',
        urgencyLevel: 'Low',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('Casual'), findsOneWidget);
    });
    
    testWidgets('calls onTap callback when tapped', (tester) async {
      bool wasTapped = false;
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Excited',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(
              analysis: analysis,
              onTap: () => wasTapped = true,
            ),
          ),
        ),
      );
      
      await tester.tap(find.byType(ToneBadge));
      await tester.pump();
      
      expect(wasTapped, isTrue);
    });
    
    testWidgets('can be tapped without onTap callback', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      // Should not throw when tapped without callback
      await tester.tap(find.byType(ToneBadge));
      await tester.pump();
      
      expect(find.byType(ToneBadge), findsOneWidget);
    });
    
    testWidgets('handles case-insensitive tone names', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'FRIENDLY', // Uppercase
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      // Should still show the emoji (case handling in _getToneInfo)
      expect(find.text('😊'), findsOneWidget);
    });
  });
}
</file>

<file path="web/index.html">
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="messageai">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>messageai</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>
</file>

<file path="web/manifest.json">
{
    "name": "messageai",
    "short_name": "messageai",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}
</file>

<file path="windows/.gitignore">
flutter/ephemeral/

# Visual Studio user-specific files.
*.suo
*.user
*.userosscache
*.sln.docstates

# Visual Studio build-related files.
x64/
x86/

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/
</file>

<file path="windows/CMakeLists.txt">
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(messageai LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "messageai")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)
</file>

<file path="windows/flutter/CMakeLists.txt">
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)
</file>

<file path="windows/runner/CMakeLists.txt">
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)
</file>

<file path="windows/runner/flutter_window.cpp">
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}
</file>

<file path="windows/runner/flutter_window.h">
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_
</file>

<file path="windows/runner/main.cpp">
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"messageai", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}
</file>

<file path="windows/runner/resource.h">
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
</file>

<file path="windows/runner/runner.exe.manifest">
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>
</file>

<file path="windows/runner/Runner.rc">
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "com.example" "\0"
            VALUE "FileDescription", "messageai" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "messageai" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2025 com.example. All rights reserved." "\0"
            VALUE "OriginalFilename", "messageai.exe" "\0"
            VALUE "ProductName", "messageai" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
</file>

<file path="windows/runner/utils.cpp">
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}
</file>

<file path="windows/runner/utils.h">
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_
</file>

<file path="windows/runner/win32_window.cpp">
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}
</file>

<file path="windows/runner/win32_window.h">
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_
</file>

</files>
</file>

<file path="frontend/test/models/action_item_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/action_item.dart';

void main() {
  group('ActionItem', () {
    test('fromJson creates correct instance', () {
      final json = {
        'id': 'action-123',
        'follow_up_item_id': 'follow-456',
        'action_type': 'send',
        'action_target': 'quarterly report',
        'commitment_text': "I'll send you the quarterly report by Friday",
        'mentioned_deadline': 'by Friday',
        'extracted_deadline': 1640000000,
      };

      final action = ActionItem.fromJson(json);

      expect(action.id, 'action-123');
      expect(action.followUpItemId, 'follow-456');
      expect(action.actionType, 'send');
      expect(action.actionTarget, 'quarterly report');
      expect(action.commitmentText, "I'll send you the quarterly report by Friday");
      expect(action.mentionedDeadline, 'by Friday');
      expect(action.extractedDeadline, 1640000000);
    });

    test('fromJson handles null optional fields', () {
      final json = {
        'id': 'action-123',
        'follow_up_item_id': 'follow-456',
        'action_type': 'call',
        'commitment_text': "I'll call you later",
      };

      final action = ActionItem.fromJson(json);

      expect(action.actionTarget, isNull);
      expect(action.mentionedDeadline, isNull);
      expect(action.extractedDeadline, isNull);
    });

    group('getActionEmoji', () {
      test('returns correct emoji for send', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'send',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '📤');
      });

      test('returns correct emoji for call', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'call',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '📞');
      });

      test('returns correct emoji for meet', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'meet',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '🤝');
      });

      test('returns correct emoji for review', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'review',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '📋');
      });

      test('returns correct emoji for decide', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'decide',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '🤔');
      });

      test('returns correct emoji for follow_up', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'follow_up',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '🔄');
      });

      test('returns correct emoji for check', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'check',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '✅');
      });

      test('returns correct emoji for schedule', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'schedule',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '📅');
      });

      test('returns default emoji for unknown type', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'unknown',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '📌');
      });

      test('handles case insensitive action types', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'SEND',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '📤');
      });
    });
  });
}
</file>

<file path="frontend/test/models/ai_analysis_enhanced_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('AIAnalysis Enhanced Fields', () {
    test('parses complete enhanced analysis from JSON', () {
      final json = {
        'id': 'test-id-123',
        'message_id': 'msg-456',
        'tone': 'Overwhelmed',
        'urgency_level': 'High',
        'intent': 'expressing severe stress',
        'confidence_score': 0.92,
        'analysis_timestamp': 1234567890,
        'intensity': 'very_high',
        'secondary_tones': ['Frustrated', 'Concerned'],
        'context_flags': {
          'tone_indicator_present': true,
          'sarcasm_detected': false,
          'ambiguous': false,
        },
        'anxiety_assessment': {
          'risk_level': 'high',
          'mitigation_suggestions': [
            'Urgent tone detected. Consider asking for a specific timeline.'
          ],
        },
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.id, 'test-id-123');
      expect(analysis.messageId, 'msg-456');
      expect(analysis.tone, 'Overwhelmed');
      expect(analysis.urgencyLevel, 'High');
      expect(analysis.intent, 'expressing severe stress');
      expect(analysis.confidenceScore, 0.92);
      expect(analysis.intensity, 'very_high');
      expect(analysis.secondaryTones, ['Frustrated', 'Concerned']);
      expect(analysis.contextFlags?['tone_indicator_present'], true);
      expect(analysis.anxietyAssessment?['risk_level'], 'high');
    });

    test('parses analysis without enhanced fields (backward compatibility)', () {
      final json = {
        'id': 'test-id-123',
        'message_id': 'msg-456',
        'tone': 'Friendly',
        'urgency_level': 'Low',
        'intent': 'greeting',
        'confidence_score': 0.85,
        'analysis_timestamp': 1234567890,
        // No enhanced fields
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.tone, 'Friendly');
      expect(analysis.intensity, null);
      expect(analysis.secondaryTones, null);
      expect(analysis.contextFlags, null);
      expect(analysis.anxietyAssessment, null);
    });

    test('toJson includes all enhanced fields', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Playful',
        urgencyLevel: 'Low',
        intent: 'joking around',
        confidenceScore: 0.88,
        analysisTimestamp: 1234567890,
        intensity: 'medium',
        secondaryTones: ['Friendly'],
        contextFlags: {'tone_indicator_present': true},
        anxietyAssessment: {'risk_level': 'low'},
      );

      final json = analysis.toJson();

      expect(json['tone'], 'Playful');
      expect(json['intensity'], 'medium');
      expect(json['secondary_tones'], ['Friendly']);
      expect(json['context_flags'], {'tone_indicator_present': true});
      expect(json['anxiety_assessment'], {'risk_level': 'low'});
    });

    test('toJson excludes null enhanced fields', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Neutral',
        analysisTimestamp: 1234567890,
        // All optional fields are null
      );

      final json = analysis.toJson();

      expect(json.containsKey('intensity'), false);
      expect(json.containsKey('secondary_tones'), false);
      expect(json.containsKey('context_flags'), false);
      expect(json.containsKey('anxiety_assessment'), false);
    });

    test('toString includes intensity field', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Excited',
        intensity: 'high',
        analysisTimestamp: 1234567890,
      );

      final str = analysis.toString();

      expect(str.contains('Excited'), true);
      expect(str.contains('high'), true);
    });

    test('handles all 23 tone types', () {
      final tones = [
        'Friendly', 'Professional', 'Urgent', 'Casual', 'Formal', 'Concerned',
        'Excited', 'Neutral', 'Apologetic', 'Appreciative', 'Frustrated', 'Playful',
        'Sarcastic', 'Empathetic', 'Inquisitive', 'Assertive', 'Tentative', 'Defensive',
        'Encouraging', 'Disappointed', 'Overwhelmed', 'Relieved', 'Confused'
      ];

      for (final tone in tones) {
        final json = {
          'id': 'test-id',
          'message_id': 'msg-id',
          'tone': tone,
          'analysis_timestamp': 1234567890,
        };

        final analysis = AIAnalysis.fromJson(json);
        expect(analysis.tone, tone);
      }
    });

    test('handles all 5 intensity levels', () {
      final intensities = ['very_low', 'low', 'medium', 'high', 'very_high'];

      for (final intensity in intensities) {
        final json = {
          'id': 'test-id',
          'message_id': 'msg-id',
          'tone': 'Friendly',
          'intensity': intensity,
          'analysis_timestamp': 1234567890,
        };

        final analysis = AIAnalysis.fromJson(json);
        expect(analysis.intensity, intensity);
      }
    });

    test('parses complex context flags', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-id',
        'tone': 'Sarcastic',
        'analysis_timestamp': 1234567890,
        'context_flags': {
          'sarcasm_detected': true,
          'tone_indicator_present': true,
          'ambiguous': false,
          'figurative_language': true,
        },
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.contextFlags?['sarcasm_detected'], true);
      expect(analysis.contextFlags?['tone_indicator_present'], true);
      expect(analysis.contextFlags?['ambiguous'], false);
      expect(analysis.contextFlags?['figurative_language'], true);
    });

    test('parses anxiety assessment with suggestions', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-id',
        'tone': 'Urgent',
        'analysis_timestamp': 1234567890,
        'anxiety_assessment': {
          'risk_level': 'high',
          'mitigation_suggestions': [
            'Urgent tone detected. Consider asking for a specific timeline.',
            'Take a deep breath before responding.',
          ],
        },
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.anxietyAssessment?['risk_level'], 'high');
      final suggestions = analysis.anxietyAssessment?['mitigation_suggestions'] as List;
      expect(suggestions.length, 2);
      expect(suggestions[0], contains('Urgent tone'));
    });
  });
}
</file>

<file path="frontend/test/models/ai_analysis_phase1_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('AIAnalysis Phase 1 Integration Tests', () {
    test('fromJson parses Phase 1 fields correctly', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-123',
        'tone': 'Neutral',
        'urgency_level': 'Low',
        'intent': 'Quick acknowledgment',
        'confidence_score': 0.85,
        'analysis_timestamp': 1234567890,
        'rsd_triggers': [
          {
            'pattern': 'ok',
            'severity': 'high',
            'explanation': 'Single-word responses can trigger RSD',
            'reassurance': 'This is likely just a quick acknowledgment',
          }
        ],
        'alternative_interpretations': [
          {
            'interpretation': 'Simple acknowledgment',
            'tone': 'Neutral',
            'likelihood': 70,
            'reasoning': 'Most common use',
            'context_clues': ['No conflict'],
          }
        ],
        'evidence': [
          {
            'type': 'length',
            'quote': 'ok',
            'supports': 'brevity',
            'reasoning': 'Very short message',
          }
        ],
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.id, 'test-id');
      expect(analysis.messageId, 'msg-123');
      expect(analysis.tone, 'Neutral');
      
      // Check Phase 1 fields
      expect(analysis.rsdTriggers, isNotNull);
      expect(analysis.rsdTriggers!.length, 1);
      expect(analysis.rsdTriggers![0].pattern, 'ok');
      expect(analysis.rsdTriggers![0].severity, 'high');
      
      expect(analysis.alternativeInterpretations, isNotNull);
      expect(analysis.alternativeInterpretations!.length, 1);
      expect(analysis.alternativeInterpretations![0].interpretation, 'Simple acknowledgment');
      expect(analysis.alternativeInterpretations![0].likelihood, 70);
      
      expect(analysis.evidence, isNotNull);
      expect(analysis.evidence!.length, 1);
      expect(analysis.evidence![0].type, 'length');
      expect(analysis.evidence![0].quote, 'ok');
    });

    test('toJson serializes Phase 1 fields correctly', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-123',
        tone: 'Neutral',
        urgencyLevel: 'Low',
        intent: 'Test',
        confidenceScore: 0.85,
        analysisTimestamp: 1234567890,
        rsdTriggers: [
          const RSDTrigger(
            pattern: 'ok',
            severity: 'high',
            explanation: 'test',
            reassurance: 'test',
          )
        ],
        alternativeInterpretations: [
          const MessageInterpretation(
            interpretation: 'test',
            tone: 'Neutral',
            likelihood: 70,
            reasoning: 'test',
            contextClues: [],
          )
        ],
        evidence: [
          const Evidence(
            type: 'keyword',
            quote: 'ASAP',
            supports: 'urgency',
            reasoning: 'test',
          )
        ],
      );

      final json = analysis.toJson();

      expect(json['rsd_triggers'], isNotNull);
      expect(json['rsd_triggers'], isList);
      expect((json['rsd_triggers'] as List).length, 1);
      
      expect(json['alternative_interpretations'], isNotNull);
      expect(json['alternative_interpretations'], isList);
      expect((json['alternative_interpretations'] as List).length, 1);
      
      expect(json['evidence'], isNotNull);
      expect(json['evidence'], isList);
      expect((json['evidence'] as List).length, 1);
    });

    test('fromJson handles null Phase 1 fields', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-123',
        'tone': 'Neutral',
        'analysis_timestamp': 1234567890,
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.rsdTriggers, null);
      expect(analysis.alternativeInterpretations, null);
      expect(analysis.evidence, null);
    });

    test('fromJson handles empty Phase 1 arrays', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-123',
        'tone': 'Neutral',
        'analysis_timestamp': 1234567890,
        'rsd_triggers': [],
        'alternative_interpretations': [],
        'evidence': [],
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.rsdTriggers, isNotNull);
      expect(analysis.rsdTriggers!.isEmpty, true);
      expect(analysis.alternativeInterpretations, isNotNull);
      expect(analysis.alternativeInterpretations!.isEmpty, true);
      expect(analysis.evidence, isNotNull);
      expect(analysis.evidence!.isEmpty, true);
    });
  });
}
</file>

<file path="frontend/test/models/ai_analysis_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('AIAnalysis Model', () {
    test('fromJson creates valid object with all fields', () {
      final json = {
        'id': 'test-id-123',
        'message_id': 'msg-456',
        'tone': 'Professional',
        'urgency_level': 'Medium',
        'intent': 'requesting information',
        'confidence_score': 0.85,
        'analysis_timestamp': 1234567890,
      };
      
      final analysis = AIAnalysis.fromJson(json);
      
      expect(analysis.id, equals('test-id-123'));
      expect(analysis.messageId, equals('msg-456'));
      expect(analysis.tone, equals('Professional'));
      expect(analysis.urgencyLevel, equals('Medium'));
      expect(analysis.intent, equals('requesting information'));
      expect(analysis.confidenceScore, equals(0.85));
      expect(analysis.analysisTimestamp, equals(1234567890));
    });
    
    test('fromJson handles null optional fields', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-id',
        'tone': 'Neutral',
        'analysis_timestamp': 1234567890,
      };
      
      final analysis = AIAnalysis.fromJson(json);
      
      expect(analysis.tone, equals('Neutral'));
      expect(analysis.urgencyLevel, isNull);
      expect(analysis.intent, isNull);
      expect(analysis.confidenceScore, isNull);
    });
    
    test('toJson creates correct map', () {
      final analysis = AIAnalysis(
        id: 'id-1',
        messageId: 'msg-1',
        tone: 'Friendly',
        urgencyLevel: 'Low',
        intent: 'greeting',
        confidenceScore: 0.9,
        analysisTimestamp: 9876543210,
      );
      
      final json = analysis.toJson();
      
      expect(json['id'], equals('id-1'));
      expect(json['message_id'], equals('msg-1'));
      expect(json['tone'], equals('Friendly'));
      expect(json['urgency_level'], equals('Low'));
      expect(json['intent'], equals('greeting'));
      expect(json['confidence_score'], equals(0.9));
      expect(json['analysis_timestamp'], equals(9876543210));
    });
    
    test('equality works correctly', () {
      final a1 = AIAnalysis(
        id: 'same-id',
        messageId: 'same-msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );
      
      final a2 = AIAnalysis(
        id: 'same-id',
        messageId: 'same-msg',
        tone: 'Professional', // Different tone
        analysisTimestamp: 456, // Different timestamp
      );
      
      final a3 = AIAnalysis(
        id: 'different-id',
        messageId: 'same-msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );
      
      expect(a1, equals(a2)); // Same ID and message ID
      expect(a1, isNot(equals(a3))); // Different ID
    });
    
    test('hashCode is consistent', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Casual',
        analysisTimestamp: 123,
      );
      
      final hash1 = analysis.hashCode;
      final hash2 = analysis.hashCode;
      
      expect(hash1, equals(hash2));
    });
    
    test('toString includes key information', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Urgent',
        urgencyLevel: 'High',
        intent: 'needs response',
        confidenceScore: 0.95,
        analysisTimestamp: 123456,
      );
      
      final str = analysis.toString();
      
      expect(str, contains('test-id'));
      expect(str, contains('msg-id'));
      expect(str, contains('Urgent'));
      expect(str, contains('High'));
    });
    
    test('handles double and int confidence scores', () {
      // Test with integer
      final json1 = {
        'id': 'id-1',
        'message_id': 'msg-1',
        'tone': 'Neutral',
        'confidence_score': 1,
        'analysis_timestamp': 123,
      };
      
      final analysis1 = AIAnalysis.fromJson(json1);
      expect(analysis1.confidenceScore, equals(1.0));
      
      // Test with double
      final json2 = {
        'id': 'id-2',
        'message_id': 'msg-2',
        'tone': 'Neutral',
        'confidence_score': 0.75,
        'analysis_timestamp': 123,
      };
      
      final analysis2 = AIAnalysis.fromJson(json2);
      expect(analysis2.confidenceScore, equals(0.75));
    });
    
    test('round-trip JSON serialization preserves data', () {
      final original = AIAnalysis(
        id: 'round-trip-id',
        messageId: 'round-trip-msg',
        tone: 'Excited',
        urgencyLevel: 'Medium',
        intent: 'celebration',
        confidenceScore: 0.88,
        analysisTimestamp: 1111111111,
      );
      
      final json = original.toJson();
      final reconstructed = AIAnalysis.fromJson(json);
      
      expect(reconstructed, equals(original));
      expect(reconstructed.id, equals(original.id));
      expect(reconstructed.messageId, equals(original.messageId));
      expect(reconstructed.tone, equals(original.tone));
      expect(reconstructed.urgencyLevel, equals(original.urgencyLevel));
      expect(reconstructed.intent, equals(original.intent));
      expect(reconstructed.confidenceScore, equals(original.confidenceScore));
      expect(reconstructed.analysisTimestamp, equals(original.analysisTimestamp));
    });
  });
}
</file>

<file path="frontend/test/models/conversation_context_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/conversation_context.dart';

void main() {
  group('KeyPoint', () {
    test('fromJson creates KeyPoint correctly', () {
      final json = {
        'text': 'Discussed project deadline',
        'timestamp': 1640000000,
      };

      final keyPoint = KeyPoint.fromJson(json);

      expect(keyPoint.text, 'Discussed project deadline');
      expect(keyPoint.timestamp, 1640000000);
    });

    test('getTimeAgo returns "just now" for recent timestamps', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final keyPoint = KeyPoint(
        text: 'Test',
        timestamp: now - 30, // 30 seconds ago
      );

      expect(keyPoint.getTimeAgo(), 'just now');
    });

    test('getTimeAgo returns minutes for timestamps < 1 hour', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final keyPoint = KeyPoint(
        text: 'Test',
        timestamp: now - 600, // 10 minutes ago
      );

      expect(keyPoint.getTimeAgo(), '10m ago');
    });

    test('getTimeAgo returns hours for timestamps < 1 day', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final keyPoint = KeyPoint(
        text: 'Test',
        timestamp: now - 7200, // 2 hours ago
      );

      expect(keyPoint.getTimeAgo(), '2h ago');
    });

    test('getTimeAgo returns days for timestamps < 1 week', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final keyPoint = KeyPoint(
        text: 'Test',
        timestamp: now - 259200, // 3 days ago
      );

      expect(keyPoint.getTimeAgo(), '3d ago');
    });

    test('getTimeAgo returns weeks for older timestamps', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final keyPoint = KeyPoint(
        text: 'Test',
        timestamp: now - 1209600, // 2 weeks ago
      );

      expect(keyPoint.getTimeAgo(), '2w ago');
    });
  });

  group('ConversationContext', () {
    test('fromJson creates ConversationContext correctly', () {
      final json = {
        'conversation_id': 'conv-123',
        'last_discussed': 'Project deadline and budget',
        'key_points': [
          {'text': 'Deadline is next Friday', 'timestamp': 1640000000},
          {'text': 'Budget approved', 'timestamp': 1640001000},
        ],
        'pending_questions': ['When can we start?', 'Who is the lead?'],
        'from_cache': true,
        'cache_age': 120,
      };

      final context = ConversationContext.fromJson(json);

      expect(context.conversationId, 'conv-123');
      expect(context.lastDiscussed, 'Project deadline and budget');
      expect(context.keyPoints.length, 2);
      expect(context.keyPoints[0].text, 'Deadline is next Friday');
      expect(context.keyPoints[1].text, 'Budget approved');
      expect(context.pendingQuestions.length, 2);
      expect(context.pendingQuestions[0], 'When can we start?');
      expect(context.fromCache, true);
      expect(context.cacheAge, 120);
    });

    test('fromJson handles missing optional fields', () {
      final json = {
        'conversation_id': 'conv-123',
        'last_discussed': 'Project deadline',
        'key_points': [],
      };

      final context = ConversationContext.fromJson(json);

      expect(context.conversationId, 'conv-123');
      expect(context.keyPoints.isEmpty, true);
      expect(context.pendingQuestions.isEmpty, true);
      expect(context.fromCache, false);
      expect(context.cacheAge, null);
    });

    test('fromJson defaults conversation_id to empty string if null', () {
      final json = {
        'last_discussed': 'Test',
        'key_points': [],
      };

      final context = ConversationContext.fromJson(json);

      expect(context.conversationId, '');
    });

    test('handles empty key_points and pending_questions lists', () {
      final json = {
        'conversation_id': 'conv-123',
        'last_discussed': 'Test',
        'key_points': [],
        'pending_questions': [],
      };

      final context = ConversationContext.fromJson(json);

      expect(context.keyPoints.isEmpty, true);
      expect(context.pendingQuestions.isEmpty, true);
    });
  });
}
</file>

<file path="frontend/test/models/evidence_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('Evidence Model Tests', () {
    test('fromJson parses correctly', () {
      final json = {
        'type': 'keyword',
        'quote': 'ASAP',
        'supports': 'urgency',
        'reasoning': 'Explicit urgency marker',
      };

      final evidence = Evidence.fromJson(json);

      expect(evidence.type, 'keyword');
      expect(evidence.quote, 'ASAP');
      expect(evidence.supports, 'urgency');
      expect(evidence.reasoning, 'Explicit urgency marker');
    });

    test('toJson serializes correctly', () {
      const evidence = Evidence(
        type: 'punctuation',
        quote: '!!!',
        supports: 'high intensity',
        reasoning: 'Multiple exclamation marks show strong emotion',
      );

      final json = evidence.toJson();

      expect(json['type'], 'punctuation');
      expect(json['quote'], '!!!');
      expect(json['supports'], 'high intensity');
      expect(json['reasoning'], 'Multiple exclamation marks show strong emotion');
    });

    test('isKeywordEvidence returns true for keyword type', () {
      const evidence = Evidence(
        type: 'keyword',
        quote: 'ASAP',
        supports: 'urgency',
        reasoning: 'test',
      );

      expect(evidence.isKeywordEvidence, true);
      expect(evidence.isPunctuationEvidence, false);
      expect(evidence.isEmojiEvidence, false);
    });

    test('isPunctuationEvidence returns true for punctuation type', () {
      const evidence = Evidence(
        type: 'punctuation',
        quote: '!!!',
        supports: 'intensity',
        reasoning: 'test',
      );

      expect(evidence.isKeywordEvidence, false);
      expect(evidence.isPunctuationEvidence, true);
      expect(evidence.isEmojiEvidence, false);
    });

    test('isEmojiEvidence returns true for emoji type', () {
      const evidence = Evidence(
        type: 'emoji',
        quote: '😊',
        supports: 'friendly tone',
        reasoning: 'test',
      );

      expect(evidence.isKeywordEvidence, false);
      expect(evidence.isPunctuationEvidence, false);
      expect(evidence.isEmojiEvidence, true);
    });
  });
}
</file>

<file path="frontend/test/models/follow_up_item_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/follow_up_item.dart';

void main() {
  group('FollowUpItemType', () {
    test('fromString returns correct enum', () {
      expect(
        FollowUpItemType.fromString('action_item'),
        FollowUpItemType.actionItem,
      );
      expect(
        FollowUpItemType.fromString('unanswered_question'),
        FollowUpItemType.unansweredQuestion,
      );
    });

    test('fromString returns default for invalid value', () {
      expect(
        FollowUpItemType.fromString('invalid'),
        FollowUpItemType.pendingResponse,
      );
    });

    test('getColor returns correct colors', () {
      expect(
        FollowUpItemType.actionItem.getColor().value,
        greaterThan(0),
      );
    });

    test('enum has correct values', () {
      expect(FollowUpItemType.actionItem.value, 'action_item');
      expect(FollowUpItemType.actionItem.displayName, 'Action Item');
    });
  });

  group('FollowUpStatus', () {
    test('fromString returns correct enum', () {
      expect(FollowUpStatus.fromString('pending'), FollowUpStatus.pending);
      expect(FollowUpStatus.fromString('completed'), FollowUpStatus.completed);
    });

    test('fromString returns default for invalid value', () {
      expect(FollowUpStatus.fromString('invalid'), FollowUpStatus.pending);
    });
  });

  group('FollowUpItem', () {
    late FollowUpItem item;

    setUp(() {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      item = FollowUpItem(
        id: 'test-id',
        userId: 'user-123',
        conversationId: 'conv-456',
        itemType: FollowUpItemType.actionItem,
        title: 'Send report',
        description: 'Send quarterly report to client',
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now - 3600, // 1 hour ago
        dueAt: now + 7200, // 2 hours from now
      );
    });

    test('fromJson creates correct instance', () {
      final json = {
        'id': 'test-id',
        'user_id': 'user-123',
        'conversation_id': 'conv-456',
        'item_type': 'action_item',
        'title': 'Test',
        'status': 'pending',
        'priority': 50,
        'detected_at': 1000,
      };

      final item = FollowUpItem.fromJson(json);

      expect(item.id, 'test-id');
      expect(item.userId, 'user-123');
      expect(item.conversationId, 'conv-456');
      expect(item.itemType, FollowUpItemType.actionItem);
      expect(item.status, FollowUpStatus.pending);
    });

    test('isOverdue returns false for future due date', () {
      expect(item.isOverdue, false);
    });

    test('isOverdue returns true for past due date', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final overdueItem = FollowUpItem(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        itemType: FollowUpItemType.actionItem,
        title: 'Overdue',
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now - 7200,
        dueAt: now - 3600, // 1 hour ago
      );

      expect(overdueItem.isOverdue, true);
    });

    test('isDueSoon returns true for items due within 24h', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final dueSoonItem = FollowUpItem(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        itemType: FollowUpItemType.actionItem,
        title: 'Due Soon',
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now,
        dueAt: now + (12 * 3600), // 12 hours from now
      );

      expect(dueSoonItem.isDueSoon, true);
    });

    test('isDueSoon returns false for items due later', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final laterItem = FollowUpItem(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        itemType: FollowUpItemType.actionItem,
        title: 'Later',
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now,
        dueAt: now + (48 * 3600), // 48 hours from now
      );

      expect(laterItem.isDueSoon, false);
    });

    test('getTimeUntilDue returns correct format', () {
      expect(item.getTimeUntilDue(), isNotEmpty);
    });

    test('getTimeUntilDue returns "Overdue" for past due', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final overdueItem = FollowUpItem(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        itemType: FollowUpItemType.actionItem,
        title: 'Overdue',
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now - 7200,
        dueAt: now - 3600,
      );

      expect(overdueItem.getTimeUntilDue(), 'Overdue');
    });

    test('getTimeSinceDetected returns correct format', () {
      expect(item.getTimeSinceDetected(), contains('ago'));
    });

    test('fromJson handles item_id or id field', () {
      final json1 = {
        'item_id': 'test-1',
        'user_id': 'user',
        'conversation_id': 'conv',
        'item_type': 'action_item',
        'title': 'Test',
        'status': 'pending',
        'priority': 50,
        'detected_at': 1000,
      };

      final json2 = {
        'id': 'test-2',
        'user_id': 'user',
        'conversation_id': 'conv',
        'item_type': 'action_item',
        'title': 'Test',
        'status': 'pending',
        'priority': 50,
        'detected_at': 1000,
      };

      expect(FollowUpItem.fromJson(json1).id, 'test-1');
      expect(FollowUpItem.fromJson(json2).id, 'test-2');
    });
  });
}
</file>

<file path="frontend/test/models/message_interpretation_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('MessageInterpretation Model Tests', () {
    test('fromJson parses correctly', () {
      final json = {
        'interpretation': 'Simple acknowledgment',
        'tone': 'Neutral',
        'likelihood': 70,
        'reasoning': 'Most common use of ok',
        'context_clues': ['No prior conflict', 'Normal conversation flow'],
      };

      final interp = MessageInterpretation.fromJson(json);

      expect(interp.interpretation, 'Simple acknowledgment');
      expect(interp.tone, 'Neutral');
      expect(interp.likelihood, 70);
      expect(interp.reasoning, 'Most common use of ok');
      expect(interp.contextClues.length, 2);
      expect(interp.contextClues[0], 'No prior conflict');
    });

    test('toJson serializes correctly', () {
      const interp = MessageInterpretation(
        interpretation: 'Mildly annoyed',
        tone: 'Frustrated',
        likelihood: 20,
        reasoning: 'Brief response could indicate frustration',
        contextClues: ['Shorter than usual', 'No warmth markers'],
      );

      final json = interp.toJson();

      expect(json['interpretation'], 'Mildly annoyed');
      expect(json['tone'], 'Frustrated');
      expect(json['likelihood'], 20);
      expect(json['reasoning'], 'Brief response could indicate frustration');
      expect((json['context_clues'] as List).length, 2);
    });

    test('isLikely returns true for likelihood >= 60', () {
      const interp = MessageInterpretation(
        interpretation: 'test',
        tone: 'test',
        likelihood: 70,
        reasoning: 'test',
        contextClues: [],
      );

      expect(interp.isLikely, true);
      expect(interp.isPossible, false);
      expect(interp.isUnlikely, false);
    });

    test('isPossible returns true for likelihood 30-59', () {
      const interp = MessageInterpretation(
        interpretation: 'test',
        tone: 'test',
        likelihood: 45,
        reasoning: 'test',
        contextClues: [],
      );

      expect(interp.isLikely, false);
      expect(interp.isPossible, true);
      expect(interp.isUnlikely, false);
    });

    test('isUnlikely returns true for likelihood < 30', () {
      const interp = MessageInterpretation(
        interpretation: 'test',
        tone: 'test',
        likelihood: 10,
        reasoning: 'test',
        contextClues: [],
      );

      expect(interp.isLikely, false);
      expect(interp.isPossible, false);
      expect(interp.isUnlikely, true);
    });

    test('edge case: likelihood = 60 is likely', () {
      const interp = MessageInterpretation(
        interpretation: 'test',
        tone: 'test',
        likelihood: 60,
        reasoning: 'test',
        contextClues: [],
      );

      expect(interp.isLikely, true);
    });

    test('edge case: likelihood = 30 is possible', () {
      const interp = MessageInterpretation(
        interpretation: 'test',
        tone: 'test',
        likelihood: 30,
        reasoning: 'test',
        contextClues: [],
      );

      expect(interp.isPossible, true);
    });
  });
}
</file>

<file path="frontend/test/models/relationship_profile_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/relationship_profile.dart';

void main() {
  group('RelationshipProfile', () {
    test('fromJson creates RelationshipProfile correctly', () {
      final json = {
        'profile_id': 'profile-123',
        'user_id': 'user-456',
        'conversation_id': 'conv-789',
        'participant_name': 'John Doe',
        'participant_user_id': 'user-999',
        'relationship_type': 'colleague',
        'relationship_notes': 'Works in marketing',
        'conversation_summary': 'We discuss project updates',
        'safe_topics': ['work', 'sports', 'weather'],
        'topics_to_avoid': ['politics', 'religion'],
        'communication_style': 'Direct and professional',
        'typical_response_time': 3600, // 1 hour
        'total_messages': 150,
        'first_message_at': 1640000000,
        'last_message_at': 1650000000,
      };

      final profile = RelationshipProfile.fromJson(json);

      expect(profile.id, 'profile-123');
      expect(profile.userId, 'user-456');
      expect(profile.conversationId, 'conv-789');
      expect(profile.participantName, 'John Doe');
      expect(profile.participantUserId, 'user-999');
      expect(profile.relationshipType, 'colleague');
      expect(profile.relationshipNotes, 'Works in marketing');
      expect(profile.conversationSummary, 'We discuss project updates');
      expect(profile.safeTopics, ['work', 'sports', 'weather']);
      expect(profile.topicsToAvoid, ['politics', 'religion']);
      expect(profile.communicationStyle, 'Direct and professional');
      expect(profile.typicalResponseTime, 3600);
      expect(profile.totalMessages, 150);
      expect(profile.firstMessageAt, 1640000000);
      expect(profile.lastMessageAt, 1650000000);
    });

    test('fromJson handles id field if profile_id is missing', () {
      final json = {
        'id': 'profile-123',
        'user_id': 'user-456',
        'conversation_id': 'conv-789',
        'participant_name': 'Jane Doe',
      };

      final profile = RelationshipProfile.fromJson(json);

      expect(profile.id, 'profile-123');
    });

    test('fromJson handles missing optional fields', () {
      final json = {
        'profile_id': 'profile-123',
        'user_id': 'user-456',
        'conversation_id': 'conv-789',
        'participant_name': 'John Doe',
      };

      final profile = RelationshipProfile.fromJson(json);

      expect(profile.participantUserId, null);
      expect(profile.relationshipType, null);
      expect(profile.safeTopics, []);
      expect(profile.topicsToAvoid, []);
      expect(profile.totalMessages, 0);
    });

    test('getRelationshipEmoji returns correct emoji for each type', () {
      final testCases = {
        'boss': '👔',
        'colleague': '🤝',
        'friend': '😊',
        'family': '👨‍👩‍👧‍👦',
        'client': '💼',
        'unknown': '👤',
      };

      testCases.forEach((type, expectedEmoji) {
        final profile = RelationshipProfile(
          id: 'test',
          userId: 'user',
          conversationId: 'conv',
          participantName: 'Test',
          relationshipType: type == 'unknown' ? null : type,
        );

        expect(profile.getRelationshipEmoji(), expectedEmoji);
      });
    });

    test('getRelationshipEmoji is case-insensitive', () {
      final profile = RelationshipProfile(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        participantName: 'Test',
        relationshipType: 'BOSS',
      );

      expect(profile.getRelationshipEmoji(), '👔');
    });

    test('formatResponseTime returns "Unknown" for null', () {
      final profile = RelationshipProfile(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        participantName: 'Test',
      );

      expect(profile.formatResponseTime(), 'Unknown');
    });

    test('formatResponseTime returns minutes for < 1 hour', () {
      final profile = RelationshipProfile(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        participantName: 'Test',
        typicalResponseTime: 1800, // 30 minutes
      );

      expect(profile.formatResponseTime(), '30 min');
    });

    test('formatResponseTime returns hours for < 1 day', () {
      final profile = RelationshipProfile(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        participantName: 'Test',
        typicalResponseTime: 7200, // 2 hours
      );

      expect(profile.formatResponseTime(), '2 hr');
    });

    test('formatResponseTime returns days for >= 1 day', () {
      final profile = RelationshipProfile(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        participantName: 'Test',
        typicalResponseTime: 172800, // 2 days
      );

      expect(profile.formatResponseTime(), '2 days');
    });
  });
}
</file>

<file path="frontend/test/models/rsd_trigger_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('RSDTrigger Model Tests', () {
    test('fromJson parses correctly', () {
      final json = {
        'pattern': 'ok',
        'severity': 'high',
        'explanation': 'Single-word responses can trigger RSD',
        'reassurance': 'This is likely just a quick acknowledgment',
      };

      final trigger = RSDTrigger.fromJson(json);

      expect(trigger.pattern, 'ok');
      expect(trigger.severity, 'high');
      expect(trigger.explanation, 'Single-word responses can trigger RSD');
      expect(trigger.reassurance, 'This is likely just a quick acknowledgment');
    });

    test('toJson serializes correctly', () {
      const trigger = RSDTrigger(
        pattern: 'fine',
        severity: 'high',
        explanation: 'Fine can feel passive-aggressive',
        reassurance: 'They might genuinely mean it',
      );

      final json = trigger.toJson();

      expect(json['pattern'], 'fine');
      expect(json['severity'], 'high');
      expect(json['explanation'], 'Fine can feel passive-aggressive');
      expect(json['reassurance'], 'They might genuinely mean it');
    });

    test('isHighSeverity returns true for high severity', () {
      const trigger = RSDTrigger(
        pattern: 'ok',
        severity: 'high',
        explanation: 'test',
        reassurance: 'test',
      );

      expect(trigger.isHighSeverity, true);
      expect(trigger.isMediumSeverity, false);
      expect(trigger.isLowSeverity, false);
    });

    test('isMediumSeverity returns true for medium severity', () {
      const trigger = RSDTrigger(
        pattern: 'sure',
        severity: 'medium',
        explanation: 'test',
        reassurance: 'test',
      );

      expect(trigger.isHighSeverity, false);
      expect(trigger.isMediumSeverity, true);
      expect(trigger.isLowSeverity, false);
    });

    test('isLowSeverity returns true for low severity', () {
      const trigger = RSDTrigger(
        pattern: 'no worries',
        severity: 'low',
        explanation: 'test',
        reassurance: 'test',
      );

      expect(trigger.isHighSeverity, false);
      expect(trigger.isMediumSeverity, false);
      expect(trigger.isLowSeverity, true);
    });
  });
}
</file>

<file path="frontend/test/models/safe_topic_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/safe_topic.dart';

void main() {
  group('SafeTopic', () {
    test('fromJson creates SafeTopic correctly', () {
      final json = {
        'id': 'topic-123',
        'topic_name': 'Project Updates',
        'topic_keywords': ['deadline', 'status', 'progress'],
        'message_count': 25,
        'avg_response_time': 1800,
        'positive_tone_rate': 0.85,
        'is_safe': true,
        'last_discussed': 1640000000,
      };

      final topic = SafeTopic.fromJson(json);

      expect(topic.id, 'topic-123');
      expect(topic.topicName, 'Project Updates');
      expect(topic.keywords, ['deadline', 'status', 'progress']);
      expect(topic.messageCount, 25);
      expect(topic.avgResponseTime, 1800);
      expect(topic.positiveToneRate, 0.85);
      expect(topic.isSafe, true);
      expect(topic.lastDiscussed, 1640000000);
    });

    test('fromJson handles missing optional fields', () {
      final json = {
        'id': 'topic-123',
        'topic_name': 'General',
        'message_count': 10,
      };

      final topic = SafeTopic.fromJson(json);

      expect(topic.keywords, []);
      expect(topic.avgResponseTime, null);
      expect(topic.positiveToneRate, null);
      expect(topic.isSafe, true);
      expect(topic.lastDiscussed, null);
    });

    test('getTopicColor returns green for high positive rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.9,
      );

      expect(topic.getTopicColor(), Colors.green);
    });

    test('getTopicColor returns blue for medium positive rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.7,
      );

      expect(topic.getTopicColor(), Colors.blue);
    });

    test('getTopicColor returns orange for low positive rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.5,
      );

      expect(topic.getTopicColor(), Colors.orange);
    });

    test('getTopicColor returns grey for null positive rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
      );

      expect(topic.getTopicColor(), Colors.grey);
    });

    test('getEngagementLabel returns "Great topic!" for high rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.85,
      );

      expect(topic.getEngagementLabel(), 'Great topic!');
    });

    test('getEngagementLabel returns "Good topic" for medium rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.65,
      );

      expect(topic.getEngagementLabel(), 'Good topic');
    });

    test('getEngagementLabel returns "Neutral" for low rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.5,
      );

      expect(topic.getEngagementLabel(), 'Neutral');
    });

    test('getEngagementLabel returns "Unknown" for null rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
      );

      expect(topic.getEngagementLabel(), 'Unknown');
    });

    test('isSafe defaults to true', () {
      final json = {
        'id': 'topic-123',
        'topic_name': 'Test',
        'message_count': 10,
      };

      final topic = SafeTopic.fromJson(json);

      expect(topic.isSafe, true);
    });
  });
}
</file>

<file path="frontend/test/services/ai_analysis_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  // Note: Service tests that require Supabase client are skipped in unit tests
  // These should be tested in integration tests with proper Supabase setup
  
  group('AIAnalysisService - Unit Tests', () {
    test('service requires Supabase initialization', () {
      // This test documents that the service requires Supabase
      // Full service tests should be done in integration tests
      expect(true, isTrue);
    });
  });
  
  group('AIAnalysis Model Integration', () {
    test('AIAnalysis can be stored and retrieved', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-123',
        tone: 'Friendly',
        urgencyLevel: 'Low',
        intent: 'greeting',
        confidenceScore: 0.9,
        analysisTimestamp: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );
      
      expect(analysis.id, equals('test-id'));
      expect(analysis.messageId, equals('msg-123'));
      expect(analysis.tone, equals('Friendly'));
    });
    
    test('Multiple AIAnalysis objects can coexist', () {
      final analysis1 = AIAnalysis(
        id: 'id-1',
        messageId: 'msg-1',
        tone: 'Professional',
        analysisTimestamp: 123,
      );
      
      final analysis2 = AIAnalysis(
        id: 'id-2',
        messageId: 'msg-2',
        tone: 'Casual',
        analysisTimestamp: 456,
      );
      
      expect(analysis1.id, isNot(equals(analysis2.id)));
      expect(analysis1.tone, isNot(equals(analysis2.tone)));
    });
  });
}
</file>

<file path="frontend/test/services/context_preloader_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:http/http.dart' as http;
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:messageai/services/context_preloader_service.dart';
import 'dart:convert';

// Generate mocks with: dart run build_runner build
@GenerateMocks([http.Client])
import 'context_preloader_service_test.mocks.dart';

void main() {
  group('ContextPreloaderService', () {
    late ContextPreloaderService service;
    late MockClient mockClient;

    setUp(() {
      service = ContextPreloaderService();
      mockClient = MockClient();
      service.clearCache(); // Clear cache before each test
    });

    test('is singleton', () {
      final instance1 = ContextPreloaderService();
      final instance2 = ContextPreloaderService();

      expect(identical(instance1, instance2), true);
    });

    test('clearCache removes all cached contexts', () {
      // This test verifies the cache is cleared
      service.clearCache();
      // If we had access to internal cache, we'd verify it's empty
      // For now, just verify no exception is thrown
      expect(() => service.clearCache(), returnsNormally);
    });

    group('loadContext', () {
      test('returns cached context if less than 5 minutes old', () async {
        // Note: This test would require exposing cache or using integration testing
        // Since we can't easily test caching without modifying the service,
        // we'll document this as a limitation
        expect(true, true); // Placeholder
      });

      test('throws exception when not authenticated', () async {
        // This would require mocking SupabaseClient
        // Documented as needing integration test with actual Supabase mock
        expect(true, true); // Placeholder
      });
    });

    group('preloadContexts', () {
      test('limits parallel requests to 5', () async {
        final conversationIds = List.generate(10, (i) => 'conv-$i');

        // This test verifies only first 5 are processed
        // Would require mocking the HTTP client to verify
        await service.preloadContexts(conversationIds);

        // Verification would check only 5 requests were made
        expect(conversationIds.length, 10);
      });

      test('handles empty list gracefully', () async {
        await service.preloadContexts([]);
        // Should complete without error
        expect(true, true);
      });
    });
  });
}
</file>

<file path="frontend/test/services/relationship_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/services/relationship_service.dart';

void main() {
  group('RelationshipService', () {
    late RelationshipService service;

    setUp(() {
      service = RelationshipService();
    });

    test('is singleton', () {
      final instance1 = RelationshipService();
      final instance2 = RelationshipService();

      expect(identical(instance1, instance2), true);
    });

    group('getProfile', () {
      test('returns null when user not authenticated', () async {
        // This requires mocking Supabase client
        // In a real test, we'd inject a mock Supabase client
        // For now, document this as needing integration testing
        expect(true, true); // Placeholder
      });

      test('returns null when no profile exists', () async {
        // Would test with mocked Supabase returning null/empty response
        expect(true, true); // Placeholder
      });
    });

    group('getSafeTopics', () {
      test('returns empty list when user not authenticated', () async {
        // Would test with mocked Supabase client
        expect(true, true); // Placeholder
      });

      test('returns empty list when no topics exist', () async {
        // Would test with mocked Supabase returning empty list
        expect(true, true); // Placeholder
      });
    });

    group('updateNotes', () {
      test('updates notes successfully', () async {
        // Would test with mocked Supabase client
        expect(true, true); // Placeholder
      });

      test('handles errors gracefully', () async {
        // Would test error handling
        expect(true, true); // Placeholder
      });
    });

    group('updateRelationshipType', () {
      test('updates relationship type successfully', () async {
        // Would test with mocked Supabase client
        expect(true, true); // Placeholder
      });

      test('handles errors gracefully', () async {
        // Would test error handling
        expect(true, true); // Placeholder
      });
    });
  });
}

// NOTE: These service tests are placeholders. Full implementation requires:
// 1. Mocking Supabase client (could use mockito or create a test double)
// 2. Injecting dependencies through constructor or factory
// 3. Testing actual RPC calls and responses
//
// For a production app, consider:
// - Creating an abstract interface for Supabase operations
// - Using dependency injection to provide mock implementations
// - Writing integration tests that use a test Supabase instance
</file>

<file path="frontend/test/widgets/context_preview_card_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/features/conversations/widgets/context_preview_card.dart';
import 'package:messageai/models/conversation_context.dart';

void main() {
  group('ContextPreviewCard', () {
    testWidgets('displays last discussed topic', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project deadline and budget',
        keyPoints: [],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('Last Conversation'), findsOneWidget);
      expect(find.text('Project deadline and budget'), findsOneWidget);
    });

    testWidgets('displays key points', (tester) async {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [
          KeyPoint(text: 'Deadline is Friday', timestamp: now - 3600),
          KeyPoint(text: 'Budget approved', timestamp: now - 7200),
          KeyPoint(text: 'Team meeting scheduled', timestamp: now - 10800),
        ],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('Recent topics:'), findsOneWidget);
      expect(find.text('Deadline is Friday'), findsOneWidget);
      expect(find.text('Budget approved'), findsOneWidget);
      expect(find.text('Team meeting scheduled'), findsOneWidget);
    });

    testWidgets('limits key points to 3', (tester) async {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [
          KeyPoint(text: 'Point 1', timestamp: now),
          KeyPoint(text: 'Point 2', timestamp: now),
          KeyPoint(text: 'Point 3', timestamp: now),
          KeyPoint(text: 'Point 4', timestamp: now),
          KeyPoint(text: 'Point 5', timestamp: now),
        ],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('Point 1'), findsOneWidget);
      expect(find.text('Point 2'), findsOneWidget);
      expect(find.text('Point 3'), findsOneWidget);
      expect(find.text('Point 4'), findsNothing);
      expect(find.text('Point 5'), findsNothing);
    });

    testWidgets('displays pending questions badge', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: ['When do we start?', 'Who is the lead?'],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('2 unanswered questions'), findsOneWidget);
      expect(find.byIcon(Icons.help_outline), findsOneWidget);
    });

    testWidgets('displays singular form for single question', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: ['When do we start?'],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('1 unanswered question'), findsOneWidget);
    });

    testWidgets('displays cached indicator when fromCache is true',
        (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
        fromCache: true,
        cacheAge: 120,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('cached'), findsOneWidget);
    });

    testWidgets('does not display cached indicator when fromCache is false',
        (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
        fromCache: false,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('cached'), findsNothing);
    });

    testWidgets('calls onTap callback when tapped', (tester) async {
      bool tapped = false;
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(
              context: context,
              onTap: () => tapped = true,
            ),
          ),
        ),
      );

      await tester.tap(find.byType(ContextPreviewCard));
      expect(tapped, true);
    });

    testWidgets('does not crash when onTap is null', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      await tester.tap(find.byType(ContextPreviewCard));
      // Should not crash
      expect(find.byType(ContextPreviewCard), findsOneWidget);
    });

    testWidgets('hides key points section when empty', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('Recent topics:'), findsNothing);
    });

    testWidgets('hides pending questions section when empty', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.byIcon(Icons.help_outline), findsNothing);
    });
  });
}
</file>

<file path="frontend/test/widgets/tone_badge_enhanced_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('ToneBadge Enhanced Features', () {
    testWidgets('displays all 23 tones with correct emojis', (tester) async {
      final toneEmojiMap = {
        'Friendly': '😊',
        'Professional': '💼',
        'Urgent': '⚠️',
        'Casual': '😎',
        'Formal': '🎩',
        'Concerned': '😟',
        'Excited': '🎉',
        'Neutral': '😐',
        'Apologetic': '🙏',
        'Appreciative': '🙌',
        'Frustrated': '😤',
        'Playful': '😜',
        'Sarcastic': '🙄',
        'Empathetic': '🤗',
        'Inquisitive': '🤔',
        'Assertive': '💪',
        'Tentative': '😬',
        'Defensive': '🛡️',
        'Encouraging': '💚',
        'Disappointed': '😞',
        'Overwhelmed': '😵',
        'Relieved': '😌',
        'Confused': '😕',
      };

      for (final entry in toneEmojiMap.entries) {
        final analysis = AIAnalysis(
          id: 'test',
          messageId: 'msg',
          tone: entry.key,
          analysisTimestamp: 123,
        );

        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: ToneBadge(analysis: analysis),
            ),
          ),
        );

        expect(find.text(entry.value), findsOneWidget, reason: 'Emoji for ${entry.key}');
        expect(find.text(entry.key), findsOneWidget, reason: 'Label for ${entry.key}');
      }
    });

    testWidgets('displays intensity indicator dot', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        intensity: 'high',
        analysisTimestamp: 123,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      // Should have 2 containers: main badge container + intensity dot
      expect(find.byType(Container), findsWidgets);
      
      // Verify the intensity dot exists (6x6 size)
      final containers = tester.widgetList<Container>(find.byType(Container)).toList();
      final hasDot = containers.any((container) {
        final decoration = container.decoration;
        if (decoration is BoxDecoration) {
          return decoration.shape == BoxShape.circle;
        }
        return false;
      });
      expect(hasDot, true, reason: 'Should have intensity dot');
    });

    testWidgets('displays both intensity and urgency dots', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Overwhelmed',
        intensity: 'very_high',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      // Should have circular indicators for both intensity and urgency
      final containers = tester.widgetList<Container>(find.byType(Container)).toList();
      final circleDots = containers.where((container) {
        final decoration = container.decoration;
        if (decoration is BoxDecoration) {
          return decoration.shape == BoxShape.circle;
        }
        return false;
      }).toList();
      
      expect(circleDots.length, greaterThanOrEqualTo(2), reason: 'Should have both dots');
    });

    testWidgets('does not show intensity dot when intensity is null', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Neutral',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
        // intensity is null
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      // Should only have urgency dot, not intensity
      final containers = tester.widgetList<Container>(find.byType(Container)).toList();
      final circleDots = containers.where((container) {
        final decoration = container.decoration;
        if (decoration is BoxDecoration) {
          return decoration.shape == BoxShape.circle;
        }
        return false;
      }).toList();
      
      expect(circleDots.length, 1, reason: 'Should only have urgency dot');
    });

    testWidgets('calls onTap callback when tapped', (tester) async {
      bool tapped = false;
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(
              analysis: analysis,
              onTap: () => tapped = true,
            ),
          ),
        ),
      );

      await tester.tap(find.byType(ToneBadge));
      expect(tapped, true);
    });

    testWidgets('handles case-insensitive tone matching', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'FRIENDLY', // uppercase
        analysisTimestamp: 123,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      expect(find.text('😊'), findsOneWidget);
    });

    testWidgets('uses default emoji for unknown tone', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'UnknownTone',
        analysisTimestamp: 123,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      expect(find.text('💬'), findsOneWidget, reason: 'Default emoji');
    });
  });
}
</file>

<file path="frontend/test/widgets/tone_badge_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('ToneBadge Widget', () {
    testWidgets('displays Friendly tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        urgencyLevel: 'Low',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('😊'), findsOneWidget);
      expect(find.text('Friendly'), findsOneWidget);
    });
    
    testWidgets('displays Professional tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Professional',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('💼'), findsOneWidget);
      expect(find.text('Professional'), findsOneWidget);
    });
    
    testWidgets('displays Urgent tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Urgent',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('⚡'), findsOneWidget);
      expect(find.text('Urgent'), findsOneWidget);
    });
    
    testWidgets('displays Casual tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Casual',
        urgencyLevel: 'Low',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('😎'), findsOneWidget);
      expect(find.text('Casual'), findsOneWidget);
    });
    
    testWidgets('displays Formal tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Formal',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('👔'), findsOneWidget);
      expect(find.text('Formal'), findsOneWidget);
    });
    
    testWidgets('displays Excited tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Excited',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('🎉'), findsOneWidget);
      expect(find.text('Excited'), findsOneWidget);
    });
    
    testWidgets('displays Concerned tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Concerned',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('😟'), findsOneWidget);
      expect(find.text('Concerned'), findsOneWidget);
    });
    
    testWidgets('displays Neutral tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Neutral',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('💬'), findsOneWidget);
      expect(find.text('Neutral'), findsOneWidget);
    });
    
    testWidgets('shows urgency indicator for High urgency', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Urgent',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      // Urgency dot should be present (multiple Containers exist)
      expect(find.byType(Container), findsWidgets);
      expect(find.text('Urgent'), findsOneWidget);
    });
    
    testWidgets('shows urgency indicator for Critical urgency', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Professional',
        urgencyLevel: 'Critical',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.byType(Container), findsWidgets);
      expect(find.text('Professional'), findsOneWidget);
    });
    
    testWidgets('does not show urgency indicator for Low urgency', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Casual',
        urgencyLevel: 'Low',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('Casual'), findsOneWidget);
    });
    
    testWidgets('calls onTap callback when tapped', (tester) async {
      bool wasTapped = false;
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Excited',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(
              analysis: analysis,
              onTap: () => wasTapped = true,
            ),
          ),
        ),
      );
      
      await tester.tap(find.byType(ToneBadge));
      await tester.pump();
      
      expect(wasTapped, isTrue);
    });
    
    testWidgets('can be tapped without onTap callback', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      // Should not throw when tapped without callback
      await tester.tap(find.byType(ToneBadge));
      await tester.pump();
      
      expect(find.byType(ToneBadge), findsOneWidget);
    });
    
    testWidgets('handles case-insensitive tone names', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'FRIENDLY', // Uppercase
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      // Should still show the emoji (case handling in _getToneInfo)
      expect(find.text('😊'), findsOneWidget);
    });
  });
}
</file>

<file path="frontend/test/widgets/who_is_this_button_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/features/conversations/widgets/who_is_this_button.dart';

void main() {
  group('WhoIsThisButton', () {
    testWidgets('displays icon button in compact mode', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: WhoIsThisButton(
              conversationId: 'conv-123',
              compact: true,
            ),
          ),
        ),
      );

      expect(find.byType(IconButton), findsOneWidget);
      expect(find.byIcon(Icons.info_outline), findsOneWidget);
      expect(find.text('Who is this?'), findsNothing);
    });

    testWidgets('displays outlined button in non-compact mode',
        (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: WhoIsThisButton(
              conversationId: 'conv-123',
              compact: false,
            ),
          ),
        ),
      );

      // OutlinedButton.icon creates a complex widget tree, just check for text and icon
      expect(find.text('Who is this?'), findsOneWidget);
      expect(find.byIcon(Icons.info_outline), findsOneWidget);
      expect(find.byType(IconButton), findsNothing);
    });

    testWidgets('defaults to compact=false', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: WhoIsThisButton(
              conversationId: 'conv-123',
            ),
          ),
        ),
      );

      // Should show text label (not compact mode)
      expect(find.text('Who is this?'), findsOneWidget);
    });

    testWidgets('has correct tooltip in compact mode', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: WhoIsThisButton(
              conversationId: 'conv-123',
              compact: true,
            ),
          ),
        ),
      );

      final iconButton = tester.widget<IconButton>(find.byType(IconButton));
      expect(iconButton.tooltip, 'Who is this?');
    });

    // Skipping tests that require Supabase initialization
    // These would be better tested in integration tests with proper setup
    
    testWidgets('tapping compact button does not crash', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: WhoIsThisButton(
              conversationId: 'conv-123',
              compact: true,
            ),
          ),
        ),
      );

      // Just verify the button exists and is tappable
      expect(find.byType(IconButton), findsOneWidget);
      
      // Note: Actually tapping would open RelationshipSummarySheet which
      // requires Supabase initialization. Skipping for unit test.
    });

    testWidgets('widget renders without crashing', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: Column(
              children: [
                WhoIsThisButton(
                  conversationId: 'conv-123',
                  compact: false,
                ),
                WhoIsThisButton(
                  conversationId: 'conv-123',
                  compact: true,
                ),
              ],
            ),
          ),
        ),
      );

      // Just verify both modes render without crashing
      expect(find.byType(WhoIsThisButton), findsNWidgets(2));
      expect(find.text('Who is this?'), findsOneWidget); // Only in non-compact
      expect(find.byIcon(Icons.info_outline), findsNWidgets(2)); // In both
    });
  });
}
</file>

<file path="messageai-integration-guide.md">
# MessageAI: Enhanced Tone Analysis Integration Guide

## 🎯 Project-Specific Overview

**Your Project:** MessageAI - Flutter messaging app with Supabase backend  
**Current State:** Basic tone analysis with 8 tones already implemented  
**Goal:** Upgrade to enhanced system with 23 tones, intensity scaling, and neurodivergent support  
**Timeline:** 2-4 weeks  
**Risk:** Low - enhanced file already exists, just needs activation

---

## 📁 Your Current File Structure

```
MessageAI/
├── backend/
│   └── supabase/
│       ├── functions/
│       │   ├── shared/
│       │   │   ├── openai-client.ts
│       │   │   └── prompts/
│       │   │       ├── tone-analysis.ts              # ❌ OLD (8 tones)
│       │   │       ├── tone-analysis-v1.backup.ts    # Backup
│       │   │       └── enhanced-tone-analysis.ts     # ✅ NEW (23 tones) - EXISTS!
│       │   └── ai-analyze-tone/
│       │       └── index.ts                          # Edge function
│       └── migrations/
│           ├── 20251024_000002_ai_analysis.sql
│           └── 20251224_000003_fix_ai_analysis_rpc_columns.sql
│
└── frontend/
    └── lib/
        ├── models/
        │   └── ai_analysis.dart                      # Data model
        ├── services/
        │   └── ai_analysis_service.dart              # API service
        ├── state/
        │   └── ai_providers.dart                     # Riverpod providers
        └── features/
            └── messages/
                └── widgets/
                    ├── tone_badge.dart               # UI badge
                    ├── ai_insights_panel.dart        # Insights panel
                    └── tone_detail_sheet.dart        # Detail view
```

---

## 📋 Phase 1: Backend Switch (30 minutes)

### **STEP 1: Update Edge Function Import**

**File:** `backend/supabase/functions/ai_analyze_tone/index.ts`

**Current code (lines 5-9):**
```typescript
import {
  TONE_ANALYSIS_SYSTEM_PROMPT,
  generateAnalysisPrompt,
  validateToneAnalysis,
  type ToneAnalysisResult,
} from '../_shared/prompts/tone-analysis.ts';
```

**Change to:**
```typescript
// ❌ OLD - Remove this import
// import { ... } from '../_shared/prompts/tone-analysis.ts';

// ✅ NEW - Use enhanced version instead
import {
  validateToneAnalysis,
  generateAnalysisPrompt,
  extractToneIndicators,
  detectFigurativeLanguage,
  assessResponseAnxietyRisk,
  type ToneAnalysisResult,
} from '../_shared/prompts/enhanced-tone-analysis.ts';

// Import the enhanced system prompt
import { ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT } from '../_shared/prompts/enhanced-tone-analysis.ts';
```

---

### **STEP 2: Add Enhanced Prompt Constant**

**File:** `backend/supabase/functions/_shared/prompts/enhanced-tone-analysis.ts`

**Add this at the END of the file (after line 240):**

```typescript
/**
 * Enhanced system prompt with 23 tones and neurodivergent support
 */
export const ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT = `You are an expert communication analyst specializing in understanding tone, intent, and urgency in messages, with specific expertise in neurodivergent communication patterns.

**CRITICAL PRIORITY: Neurodivergent Communication Considerations**

1. **Tone Indicator Detection** (HIGHEST PRIORITY):
   - If message contains /tone tags (e.g., "/j", "/srs", "/nm"), ALWAYS respect and cite them
   - These are explicit intent markers used by neurodivergent communities

**Enhanced Tone Categories** (23 total - choose ONE primary):

PRIMARY TONES (Original 8):
- Friendly: Warm, welcoming
- Professional: Business-like, formal
- Urgent: Time-sensitive, pressing
- Casual: Relaxed, informal
- Formal: Structured, official
- Concerned: Worried, distressed
- Excited: Enthusiastic, energetic
- Neutral: Balanced, objective

ADDITIONAL TONES (15 new):
- Apologetic: Expressing regret
- Appreciative: Showing gratitude
- Frustrated: Annoyed by obstacles
- Playful: Teasing, joking (/j)
- Sarcastic: Mocking with opposite meaning (/s)
- Empathetic: Understanding and supportive
- Inquisitive: Curious, seeking info
- Assertive: Confident and direct
- Tentative: Uncertain or hesitant
- Defensive: Protective or justifying
- Encouraging: Supportive and motivating
- Disappointed: Let down
- Overwhelmed: Excessive pressure
- Relieved: Reassured
- Confused: Unclear about meaning

**Intensity Levels** (choose ONE):
- very_low: Minimal expression
- low: Mild expression
- medium: Moderate expression
- high: Strong expression
- very_high: Extreme expression

**Urgency Levels** (choose ONE):
- Low: No time pressure
- Medium: Should be addressed soon
- High: Important and time-sensitive
- Critical: Extremely urgent

**Response Format (JSON):**
{
  "tone": "one of 23 categories",
  "intensity": "one of 5 levels",
  "urgency_level": "one of 4 levels",
  "intent": "3-8 word description",
  "confidence_score": 0.85,
  "context_flags": {
    "sarcasm_detected": false,
    "tone_indicator_present": false,
    "ambiguous": false
  },
  "reasoning": "explanation citing specific phrases"
}`;
```

---

### **STEP 3: Update Edge Function Analysis Logic**

**File:** `backend/supabase/functions/ai_analyze_tone/index.ts`

**Find the OpenAI call section (around lines 85-110) and update:**

```typescript
// ✅ BEFORE calling OpenAI - extract tone indicators
const toneIndicators = extractToneIndicators(message_body);
const figurativeLanguage = detectFigurativeLanguage(message_body);

console.log('Tone indicators found:', toneIndicators);
console.log('Figurative language:', figurativeLanguage);

// Generate the analysis prompt
const userPrompt = generateAnalysisPrompt(
  message_body,
  conversation_context
);

console.log('Sending request to OpenAI...');

// ❌ OLD - Replace this line:
// const analysisResult = await openai.sendMessageForJSON<ToneAnalysisResult>(
//   userPrompt,
//   TONE_ANALYSIS_SYSTEM_PROMPT,  // OLD
//   { temperature: 0.3 }
// );

// ✅ NEW - Use enhanced prompt:
const analysisResult = await openai.sendMessageForJSON<ToneAnalysisResult>(
  userPrompt,
  ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT,  // NEW - 23 tones + intensity
  { temperature: 0.3 }
);

console.log('Received response from OpenAI');

// Validate the result (this stays the same)
const validatedResult = validateToneAnalysis(analysisResult);

// ✅ NEW - Add anxiety assessment
const anxietyAssessment = assessResponseAnxietyRisk(validatedResult);
console.log('Anxiety assessment:', anxietyAssessment);

console.log('Analysis complete', validatedResult.tone, validatedResult.urgency_level);

// Store result (see next step for database updates)
```

---

### **STEP 4: Deploy Backend Changes**

```bash
cd backend/supabase

# Deploy the updated Edge Function
supabase functions deploy ai_analyze_tone

# Verify deployment
supabase functions list

# Test with a message
curl -X POST https://YOUR_PROJECT.supabase.co/functions/v1/ai_analyze_tone \
  -H "Authorization: Bearer YOUR_ANON_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "message_id": "test-123",
    "message_body": "I'\''m SO overwhelmed right now /srs"
  }'
```

**Expected response:**
```json
{
  "success": true,
  "analysis": {
    "tone": "Overwhelmed",
    "intensity": "high",
    "urgency_level": "Medium",
    "intent": "expressing severe distress",
    "confidence_score": 0.92,
    "context_flags": {
      "tone_indicator_present": true
    }
  }
}
```

---

## 📋 Phase 2: Database Migration (Optional - 15 minutes)

**Only if you want to store new fields like intensity, context_flags**

### **STEP 5: Create Migration File**

**Create:** `backend/supabase/migrations/20251225_000001_add_enhanced_analysis_fields.sql`

```sql
-- Add enhanced analysis fields
ALTER TABLE message_ai_analysis 
  ADD COLUMN IF NOT EXISTS intensity TEXT,
  ADD COLUMN IF NOT EXISTS secondary_tones JSONB,
  ADD COLUMN IF NOT EXISTS context_flags JSONB,
  ADD COLUMN IF NOT EXISTS anxiety_assessment JSONB;

-- Update get_message_ai_analysis RPC
CREATE OR REPLACE FUNCTION get_message_ai_analysis(p_message_id UUID)
RETURNS TABLE (
  id UUID,
  message_id UUID,
  tone TEXT,
  urgency_level TEXT,
  intent TEXT,
  confidence_score REAL,
  intensity TEXT,              -- NEW
  secondary_tones JSONB,       -- NEW
  context_flags JSONB,         -- NEW
  anxiety_assessment JSONB,    -- NEW
  analysis_timestamp INTEGER
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM messages m
    JOIN conversation_participants p ON m.conversation_id = p.conversation_id
    WHERE m.id = p_message_id AND p.user_id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Access denied to message';
  END IF;

  RETURN QUERY
  SELECT 
    a.id,
    a.message_id,
    a.tone,
    a.urgency_level,
    a.intent,
    a.confidence_score,
    a.intensity,
    a.secondary_tones,
    a.context_flags,
    a.anxiety_assessment,
    a.analysis_timestamp
  FROM message_ai_analysis a
  WHERE a.message_id = p_message_id
  LIMIT 1;
END;
$$;

-- Update get_conversation_ai_analysis similarly
CREATE OR REPLACE FUNCTION get_conversation_ai_analysis(p_conversation_id UUID)
RETURNS TABLE (
  id UUID,
  message_id UUID,
  tone TEXT,
  urgency_level TEXT,
  intent TEXT,
  confidence_score REAL,
  intensity TEXT,
  secondary_tones JSONB,
  context_flags JSONB,
  anxiety_assessment JSONB,
  analysis_timestamp INTEGER
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM conversation_participants
    WHERE conversation_id = p_conversation_id AND user_id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Access denied to conversation';
  END IF;

  RETURN QUERY
  SELECT 
    a.id,
    a.message_id,
    a.tone,
    a.urgency_level,
    a.intent,
    a.confidence_score,
    a.intensity,
    a.secondary_tones,
    a.context_flags,
    a.anxiety_assessment,
    a.analysis_timestamp
  FROM message_ai_analysis a
  JOIN messages m ON a.message_id = m.id
  WHERE m.conversation_id = p_conversation_id
  ORDER BY m.created_at DESC;
END;
$$;
```

**Run migration:**
```bash
supabase db push
```

---

### **STEP 6: Update Edge Function to Store New Fields**

**File:** `backend/supabase/functions/ai_analyze_tone/index.ts`

**Update the database insert (around line 120):**

```typescript
// Store the analysis in the database
const now = Math.floor(Date.now() / 1000);

const { data: storedAnalysis, error: insertError } = await supabase
  .from('message_ai_analysis')
  .insert({
    message_id: message_id,
    tone: validatedResult.tone,
    urgency_level: validatedResult.urgency_level,
    intent: validatedResult.intent,
    confidence_score: validatedResult.confidence_score,
    analysis_timestamp: now,
    // ✅ NEW FIELDS
    intensity: validatedResult.intensity,
    context_flags: validatedResult.context_flags,
    anxiety_assessment: anxietyAssessment,
  })
  .select()
  .single();
```

---

## 📋 Phase 3: Update Flutter Frontend (45 minutes)

### **STEP 7: Update AIAnalysis Model**

**File:** `frontend/lib/models/ai_analysis.dart`

**Add new fields (after line 10):**

```dart
class AIAnalysis {
  final String id;
  final String messageId;
  final String tone;
  final String? urgencyLevel;
  final String? intent;
  final double? confidenceScore;
  final int analysisTimestamp;
  
  // ✅ NEW ENHANCED FIELDS
  final String? intensity;
  final List<String>? secondaryTones;
  final Map<String, dynamic>? contextFlags;
  final Map<String, dynamic>? anxietyAssessment;

  AIAnalysis({
    required this.id,
    required this.messageId,
    required this.tone,
    this.urgencyLevel,
    this.intent,
    this.confidenceScore,
    required this.analysisTimestamp,
    // ✅ NEW
    this.intensity,
    this.secondaryTones,
    this.contextFlags,
    this.anxietyAssessment,
  });

  factory AIAnalysis.fromJson(Map<String, dynamic> json) {
    return AIAnalysis(
      id: json['id'] as String,
      messageId: json['message_id'] as String,
      tone: json['tone'] as String,
      urgencyLevel: json['urgency_level'] as String?,
      intent: json['intent'] as String?,
      confidenceScore: (json['confidence_score'] as num?)?.toDouble(),
      analysisTimestamp: json['analysis_timestamp'] as int,
      // ✅ Parse new fields
      intensity: json['intensity'] as String?,
      secondaryTones: (json['secondary_tones'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList(),
      contextFlags: json['context_flags'] as Map<String, dynamic>?,
      anxietyAssessment: json['anxiety_assessment'] as Map<String, dynamic>?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'message_id': messageId,
      'tone': tone,
      'urgency_level': urgencyLevel,
      'intent': intent,
      'confidence_score': confidenceScore,
      'analysis_timestamp': analysisTimestamp,
      // ✅ Include new fields
      if (intensity != null) 'intensity': intensity,
      if (secondaryTones != null) 'secondary_tones': secondaryTones,
      if (contextFlags != null) 'context_flags': contextFlags,
      if (anxietyAssessment != null) 'anxiety_assessment': anxietyAssessment,
    };
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is AIAnalysis &&
        other.id == id &&
        other.messageId == messageId;
  }

  @override
  int get hashCode => id.hashCode ^ messageId.hashCode;

  @override
  String toString() {
    return 'AIAnalysis(id: $id, messageId: $messageId, tone: $tone, '
        'urgencyLevel: $urgencyLevel, intensity: $intensity)';
  }
}
```

---

### **STEP 8: Update ToneBadge Widget**

**File:** `frontend/lib/features/messages/widgets/tone_badge.dart`

**Update emoji mapping (around line 74) to support all 23 tones:**

```dart
String _getToneEmoji(String tone) {
  switch (tone.toLowerCase()) {
    // Original 8
    case 'friendly': return '😊';
    case 'professional': return '💼';
    case 'urgent': return '⚠️';
    case 'casual': return '😎';
    case 'formal': return '🎩';
    case 'concerned': return '😟';
    case 'excited': return '🎉';
    case 'neutral': return '😐';
    
    // ✅ NEW: 15 additional tones
    case 'apologetic': return '🙏';
    case 'appreciative': return '🙌';
    case 'frustrated': return '😤';
    case 'playful': return '😜';
    case 'sarcastic': return '🙄';
    case 'empathetic': return '🤗';
    case 'inquisitive': return '🤔';
    case 'assertive': return '💪';
    case 'tentative': return '😬';
    case 'defensive': return '🛡️';
    case 'encouraging': return '💚';
    case 'disappointed': return '😞';
    case 'overwhelmed': return '😵';
    case 'relieved': return '😌';
    case 'confused': return '😕';
    
    default: return '💬';
  }
}
```

**Add intensity indicator (around line 140):**

```dart
@override
Widget build(BuildContext context) {
  final theme = Theme.of(context);
  final isDark = theme.brightness == Brightness.dark;

  return GestureDetector(
    onTap: onTap,
    child: Container(
      padding: const EdgeInsets.symmetric(
        horizontal: 8,
        vertical: 4,
      ),
      decoration: BoxDecoration(
        color: _getToneColor(analysis.tone).withOpacity(0.1),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: _getToneColor(analysis.tone),
          width: 1,
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(_getToneEmoji(analysis.tone), style: const TextStyle(fontSize: 14)),
          const SizedBox(width: 4),
          Text(
            analysis.tone,
            style: theme.textTheme.labelSmall?.copyWith(
              color: _getToneColor(analysis.tone),
              fontWeight: FontWeight.w600,
            ),
          ),
          // ✅ NEW: Show intensity dot
          if (analysis.intensity != null) ...[
            const SizedBox(width: 4),
            Container(
              width: 6,
              height: 6,
              decoration: BoxDecoration(
                color: _getIntensityColor(analysis.intensity!),
                shape: BoxShape.circle,
              ),
            ),
          ],
          // Existing urgency dot
          _buildUrgencyDot(analysis.urgencyLevel, isDark),
        ],
      ),
    ),
  );
}

// ✅ NEW: Helper for intensity colors
Color _getIntensityColor(String intensity) {
  switch (intensity.toLowerCase()) {
    case 'very_high': return Colors.red;
    case 'high': return Colors.orange;
    case 'medium': return Colors.blue;
    case 'low': return Colors.green;
    case 'very_low': return Colors.grey;
    default: return Colors.grey;
  }
}
```

---

### **STEP 9: Update ToneDetailSheet**

**File:** `frontend/lib/features/messages/widgets/tone_detail_sheet.dart`

**Add sections for new data (after existing sections, around line 150):**

```dart
// Existing sections...

// ✅ NEW: Intensity section
if (analysis.intensity != null) ...[
  const SizedBox(height: 16),
  _buildSection(
    context,
    'Intensity',
    _formatIntensity(analysis.intensity!),
    Icons.trending_up,
    isDark,
  ),
],

// ✅ NEW: Context flags
if (analysis.contextFlags != null && analysis.contextFlags!.isNotEmpty) ...[
  const SizedBox(height: 16),
  _buildContextFlags(context, analysis.contextFlags!, isDark),
],

// ✅ NEW: Anxiety assessment
if (analysis.anxietyAssessment != null) ...[
  const SizedBox(height: 16),
  _buildAnxietyAssessment(context, analysis.anxietyAssessment!, isDark),
],
```

**Add helper methods at the end of the class:**

```dart
String _formatIntensity(String intensity) {
  return intensity.replaceAll('_', ' ').split(' ').map((word) => 
    word[0].toUpperCase() + word.substring(1)
  ).join(' ');
}

Widget _buildContextFlags(BuildContext context, Map<String, dynamic> flags, bool isDark) {
  final activeFlags = flags.entries
      .where((e) => e.value == true)
      .map((e) => _formatFlag(e.key))
      .toList();
  
  if (activeFlags.isEmpty) return const SizedBox.shrink();
  
  return Container(
    padding: const EdgeInsets.all(12),
    decoration: BoxDecoration(
      color: Colors.blue.withOpacity(0.1),
      borderRadius: BorderRadius.circular(8),
    ),
    child: Row(
      children: [
        const Icon(Icons.info_outline, size: 18),
        const SizedBox(width: 8),
        Expanded(child: Text(activeFlags.join(', '))),
      ],
    ),
  );
}

String _formatFlag(String flag) {
  return flag.replaceAll('_', ' ').split(' ').map((word) => 
    word[0].toUpperCase() + word.substring(1)
  ).join(' ');
}

Widget _buildAnxietyAssessment(BuildContext context, Map<String, dynamic> assessment, bool isDark) {
  final riskLevel = assessment['risk_level'] as String?;
  final suggestions = (assessment['mitigation_suggestions'] as List<dynamic>?)
      ?.map((e) => e as String)
      .toList() ?? [];
  
  if (riskLevel == null) return const SizedBox.shrink();
  
  return Container(
    padding: const EdgeInsets.all(12),
    decoration: BoxDecoration(
      color: _getRiskColor(riskLevel).withOpacity(0.1),
      borderRadius: BorderRadius.circular(8),
      border: Border.all(color: _getRiskColor(riskLevel)),
    ),
    child: Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(Icons.psychology, size: 18, color: _getRiskColor(riskLevel)),
            const SizedBox(width: 8),
            Text(
              'Response Anxiety: ${riskLevel.toUpperCase()}',
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ],
        ),
        if (suggestions.isNotEmpty) ...[
          const SizedBox(height: 8),
          ...suggestions.map((s) => Padding(
            padding: const EdgeInsets.only(top: 4),
            child: Text('• $s', style: const TextStyle(fontSize: 12)),
          )),
        ],
      ],
    ),
  );
}

Color _getRiskColor(String level) {
  switch (level.toLowerCase()) {
    case 'high': return Colors.red;
    case 'medium': return Colors.orange;
    case 'low': return Colors.green;
    default: return Colors.grey;
  }
}
```

---

## 🧪 Phase 4: Testing (1-2 days)

### **STEP 10: Update Tests**

**File:** `frontend/test/widgets/tone_badge_test.dart`

**Add tests for new tones:**

```dart
// Add after existing tests
testWidgets('displays Overwhelmed tone with correct emoji', (tester) async {
  final analysis = AIAnalysis(
    id: 'test',
    messageId: 'msg',
    tone: 'Overwhelmed',
    intensity: 'high',
    analysisTimestamp: 123,
  );

  await tester.pumpWidget(
    MaterialApp(
      home: Scaffold(
        body: ToneBadge(analysis: analysis),
      ),
    ),
  );

  expect(find.text('😵'), findsOneWidget);
  expect(find.text('Overwhelmed'), findsOneWidget);
});

testWidgets('displays intensity indicator', (tester) async {
  final analysis = AIAnalysis(
    id: 'test',
    messageId: 'msg',
    tone: 'Friendly',
    intensity: 'high',
    analysisTimestamp: 123,
  );

  await tester.pumpWidget(
    MaterialApp(
      home: Scaffold(
        body: ToneBadge(analysis: analysis),
      ),
    ),
  );

  // Should have intensity dot
  expect(find.byType(Container), findsWidgets);
});
```

**Run tests:**
```bash
cd frontend
flutter test test/widgets/tone_badge_test.dart
flutter test test/models/ai_analysis_test.dart
```

---

### **STEP 11: Manual Testing**

```bash
cd frontend
flutter run
```

**Test scenarios:**
1. Send: "Hey! How are you?" → Should be **Friendly** (medium intensity)
2. Send: "I'm SO STRESSED RIGHT NOW" → Should be **Overwhelmed** (very_high intensity)
3. Send: "That's great /s" → Should be **Sarcastic** with tone_indicator flag
4. Send: "Thank you so much!" → Should be **Appreciative**
5. Check that ToneBadge shows intensity dot
6. Tap badge → verify ToneDetailSheet shows new fields

---

## 📊 Phase 5: Gradual Rollout (1 week)

### **STEP 12: Feature Flag Setup (Optional)**

**Create:** `frontend/lib/core/feature_flags.dart`

```dart
class FeatureFlags {
  static const bool useEnhancedAnalysis = true;  // Toggle this
  static const bool showIntensity = true;
  static const bool showAnxietyAssessment = true;
}
```

**Use in widgets:**
```dart
if (FeatureFlags.showIntensity && analysis.intensity != null) {
  // Show intensity indicator
}
```

---

### **STEP 13: Monitor & Rollout**

**Week 1:**
- Deploy to production
- Monitor Edge Function logs: `supabase functions logs ai-analyze-tone`
- Check for errors in analysis results
- Verify new tones appear correctly

**Week 2:**
- Collect user feedback
- Monitor which new tones are used most
- Check if intensity indicators are helpful
- Verify anxiety assessments work

---

## 🎯 Quick Reference

### **Files Modified:**

| File | Change | Lines |
|------|--------|-------|
| `backend/.../ai_analyze_tone/index.ts` | Import enhanced prompt | 5-9, 99 |
| `backend/.../enhanced-tone-analysis.ts` | Add ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT | +40 lines |
| `frontend/.../ai_analysis.dart` | Add 4 new optional fields | 10-20, 30-50 |
| `frontend/.../tone_badge.dart` | Add 15 tone emojis, intensity dot | 74-110, 140-160 |
| `frontend/.../tone_detail_sheet.dart` | Add 3 new sections | 150-200 |

### **Commands:**

```bash
# Deploy backend
cd backend/supabase
supabase functions deploy ai_analyze_tone
supabase db push  # If you ran migration

# Test frontend
cd frontend
flutter test
flutter run

# Monitor
supabase functions logs ai_analyze_tone --follow
```

### **Rollback Plan:**

If issues arise:

1. **Revert Edge Function:**
   ```typescript
   // Change back to:
   import { ... } from '../_shared/prompts/tone-analysis.ts';
   ```

2. **Redeploy:**
   ```bash
   supabase functions deploy ai_analyze_tone
   ```

---

## ✅ Success Checklist

- [ ] Backend imports updated
- [ ] Enhanced prompt added
- [ ] Edge function deployed
- [ ] Test API call works
- [ ] Database migration run (optional)
- [ ] Flutter model updated
- [ ] ToneBadge shows new tones
- [ ] ToneBadge shows intensity
- [ ] ToneDetailSheet shows new data
- [ ] Tests updated and passing
- [ ] Manual testing complete
- [ ] Deployed to production
- [ ] Monitoring active

---

**Total Time:** 2-4 hours for basic upgrade, +2 days for full testing

**Your enhanced tone analysis is now live with 23 tones, intensity scaling, and neurodivergent support!** 🎉
</file>

<file path=".cursorignore">
# Add directories or file patterns to ignore during indexing (e.g. foo/ or *.csv)
</file>

<file path=".gitignore">
# Environment files
.env
.env.local
.env.*.local
.env.dev.json
.env.prod.json

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
*.iml
*.ipr
*.iws
*.sublime-workspace

# OS
.DS_Store
Thumbs.db
.~*

# Build outputs
build/
dist/
node_modules/

# Node/NPM
package-lock.json
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Dart/Flutter
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.packages
pubspec.lock
coverage/

# Generated files
*.g.dart
*.config.dart
*.freezed.dart
*.chopper.dart

# Backend (if Node/Express)
node_modules/
dist/
.env

# Firebase
google-services.json
GoogleService-Info.plist
ServiceAccount.json

# Logs
*.log
logs/

# Temporary
*.tmp
.cache/

# Compiled
*.app/
*.framework/
*.so

# Archives
*.zip
*.tar.gz

# OS temp files
.DS_Store
.AppleDouble
.LSOverride

# Windows
Thumbs.db
ehthumbs.db

# Android
.gradle/
local.properties
*.apk
*.ap_
*.aab

# iOS
Pods/
Podfile.lock
</file>

<file path="backend/supabase/.gitignore">
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local
</file>

<file path="backend/supabase/db/test/rls_messages_tap.sql">
-- RLS Tests for messages table using pgTAP
-- Tests verify that users can only access messages in conversations they participate in

BEGIN;
SELECT plan(8);

-- Setup test data
-- Create test profiles
INSERT INTO profiles (user_id, username) VALUES 
  ('11111111-1111-1111-1111-111111111111'::uuid, 'user1'),
  ('22222222-2222-2222-2222-222222222222'::uuid, 'user2'),
  ('33333333-3333-3333-3333-333333333333'::uuid, 'user3');

-- Create test conversation
INSERT INTO conversations (id, title, is_group, created_by) VALUES 
  ('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, 'Test Conv 1', false, '11111111-1111-1111-1111-111111111111'::uuid);

-- Add participants
INSERT INTO conversation_participants (conversation_id, user_id) VALUES 
  ('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, '11111111-1111-1111-1111-111111111111'::uuid),
  ('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, '22222222-2222-2222-2222-222222222222'::uuid);

-- Insert test messages
INSERT INTO messages (id, conversation_id, sender_id, body) VALUES 
  ('cccccccc-cccc-cccc-cccc-cccccccccccc'::uuid, 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, '11111111-1111-1111-1111-111111111111'::uuid, 'Hello from user1'),
  ('dddddddd-dddd-dddd-dddd-dddddddddddd'::uuid, 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, '22222222-2222-2222-2222-222222222222'::uuid, 'Hello from user2');

-- Test: User1 (member) can read messages
SELECT is(
  (SELECT COUNT(*) FROM messages 
   WHERE conversation_id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid),
  2,
  'User1 can read messages in their conversation'
);

-- Test: User1 (member) can send messages
SELECT is(
  (SELECT COUNT(*) FROM messages 
   WHERE sender_id = '11111111-1111-1111-1111-111111111111'::uuid),
  1,
  'User1 can send messages to their conversation'
);

-- Test: User2 (member) can read messages
SELECT is(
  (SELECT COUNT(*) FROM messages 
   WHERE conversation_id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid),
  2,
  'User2 can read messages in their conversation'
);

-- Test: User3 (non-member) cannot read messages
-- Note: In production with RLS enforced, this would return 0
-- This test verifies policy definition exists
SELECT is(
  (SELECT COUNT(*) FROM pg_policies 
   WHERE tablename = 'messages' 
   AND policyname = 'Users can read messages in their conversations'),
  1,
  'Message read policy exists'
);

-- Test: Message send policy exists
SELECT is(
  (SELECT COUNT(*) FROM pg_policies 
   WHERE tablename = 'messages' 
   AND policyname = 'Users can send messages to their conversations'),
  1,
  'Message send policy exists'
);

-- Test: Message update policy exists
SELECT is(
  (SELECT COUNT(*) FROM pg_policies 
   WHERE tablename = 'messages' 
   AND policyname = 'Users can edit their own messages'),
  1,
  'Message update policy exists'
);

-- Test: Message delete policy exists
SELECT is(
  (SELECT COUNT(*) FROM pg_policies 
   WHERE tablename = 'messages' 
   AND policyname = 'Users can delete their own messages'),
  1,
  'Message delete policy exists'
);

-- Test: RLS is enabled on messages table
SELECT is(
  (SELECT COUNT(*) FROM pg_tables 
   WHERE tablename = 'messages' AND rowsecurity = true),
  1,
  'RLS is enabled on messages table'
);

-- Cleanup
DELETE FROM message_receipts;
DELETE FROM messages;
DELETE FROM conversation_participants;
DELETE FROM conversations;
DELETE FROM profiles;

SELECT * FROM finish();
ROLLBACK;
</file>

<file path="backend/supabase/db/test/rls_participants_tap.sql">
-- RLS Tests for conversation_participants table using pgTAP
-- Tests verify that users can only manage their own participation

BEGIN;
SELECT plan(7);

-- Setup test data
INSERT INTO profiles (user_id, username) VALUES 
  ('11111111-1111-1111-1111-111111111111'::uuid, 'user1'),
  ('22222222-2222-2222-2222-222222222222'::uuid, 'user2'),
  ('33333333-3333-3333-3333-333333333333'::uuid, 'user3');

INSERT INTO conversations (id, title, is_group, created_by) VALUES 
  ('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, 'Test Conv 1', false, '11111111-1111-1111-1111-111111111111'::uuid);

INSERT INTO conversation_participants (conversation_id, user_id) VALUES 
  ('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, '11111111-1111-1111-1111-111111111111'::uuid),
  ('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, '22222222-2222-2222-2222-222222222222'::uuid);

-- Test: Participant count is correct
SELECT is(
  (SELECT COUNT(*) FROM conversation_participants 
   WHERE conversation_id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid),
  2,
  'Conversation has 2 participants'
);

-- Test: User1 is in the conversation
SELECT is(
  (SELECT COUNT(*) FROM conversation_participants 
   WHERE conversation_id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid 
   AND user_id = '11111111-1111-1111-1111-111111111111'::uuid),
  1,
  'User1 is in the conversation'
);

-- Test: User2 is in the conversation
SELECT is(
  (SELECT COUNT(*) FROM conversation_participants 
   WHERE conversation_id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid 
   AND user_id = '22222222-2222-2222-2222-222222222222'::uuid),
  1,
  'User2 is in the conversation'
);

-- Test: User3 is not in the conversation
SELECT is(
  (SELECT COUNT(*) FROM conversation_participants 
   WHERE conversation_id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid 
   AND user_id = '33333333-3333-3333-3333-333333333333'::uuid),
  0,
  'User3 is not in the conversation'
);

-- Test: SELECT policy exists for participants
SELECT is(
  (SELECT COUNT(*) FROM pg_policies 
   WHERE tablename = 'conversation_participants' 
   AND policyname = 'Participants viewable by conversation members'),
  1,
  'Participant view policy exists'
);

-- Test: INSERT policy exists for participants
SELECT is(
  (SELECT COUNT(*) FROM pg_policies 
   WHERE tablename = 'conversation_participants' 
   AND policyname = 'Users can join conversations'),
  1,
  'Participant join policy exists'
);

-- Test: RLS is enabled on conversation_participants table
SELECT is(
  (SELECT COUNT(*) FROM pg_tables 
   WHERE tablename = 'conversation_participants' AND rowsecurity = true),
  1,
  'RLS is enabled on conversation_participants table'
);

-- Cleanup
DELETE FROM message_receipts;
DELETE FROM messages;
DELETE FROM conversation_participants;
DELETE FROM conversations;
DELETE FROM profiles;

SELECT * FROM finish();
ROLLBACK;
</file>

<file path="backend/supabase/db/triggers/messages_notify.sql">
-- Trigger: messages_notify
-- Broadcasts realtime event when a message is inserted
-- Usage: Subscribe to `realtime:messages` channel to receive events

-- Create function to broadcast message events
CREATE OR REPLACE FUNCTION public.messages_notify()
RETURNS trigger AS $$
BEGIN
  -- Perform the realtime broadcast
  PERFORM pg_notify(
    'realtime:messages',
    json_build_object(
      'type', TG_OP,
      'record', row_to_json(NEW),
      'schema', TG_TABLE_SCHEMA,
      'table', TG_TABLE_NAME,
      'timestamp', now()
    )::text
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for INSERT events on messages table
DROP TRIGGER IF EXISTS messages_notify_insert ON messages;
CREATE TRIGGER messages_notify_insert
  AFTER INSERT ON messages
  FOR EACH ROW
  EXECUTE FUNCTION public.messages_notify();

-- Create trigger for UPDATE events on messages table
DROP TRIGGER IF EXISTS messages_notify_update ON messages;
CREATE TRIGGER messages_notify_update
  AFTER UPDATE ON messages
  FOR EACH ROW
  EXECUTE FUNCTION public.messages_notify();
</file>

<file path="backend/supabase/db/triggers/receipts_notify.sql">
-- Trigger: receipts_notify
-- Broadcasts realtime event when a message receipt is inserted
-- Usage: Subscribe to `realtime:receipts` channel to receive events

-- Create function to broadcast receipt events
CREATE OR REPLACE FUNCTION public.receipts_notify()
RETURNS trigger AS $$
BEGIN
  -- Perform the realtime broadcast
  PERFORM pg_notify(
    'realtime:receipts',
    json_build_object(
      'type', TG_OP,
      'record', row_to_json(NEW),
      'schema', TG_TABLE_SCHEMA,
      'table', TG_TABLE_NAME,
      'timestamp', now()
    )::text
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for INSERT events on message_receipts table
DROP TRIGGER IF EXISTS receipts_notify_insert ON message_receipts;
CREATE TRIGGER receipts_notify_insert
  AFTER INSERT ON message_receipts
  FOR EACH ROW
  EXECUTE FUNCTION public.receipts_notify();

-- Create trigger for UPDATE events on message_receipts table
DROP TRIGGER IF EXISTS receipts_notify_update ON message_receipts;
CREATE TRIGGER receipts_notify_update
  AFTER UPDATE ON message_receipts
  FOR EACH ROW
  EXECUTE FUNCTION public.receipts_notify();
</file>

<file path="backend/supabase/functions/create_group/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.38.0";

interface CreateGroupPayload {
  title: string;
  description?: string;
  member_ids: string[]; // Array of user IDs to add to group
}

interface CreateGroupResponse {
  id: string;
  title: string;
  description: string | null;
  is_group: boolean;
  created_by: string;
  created_at: string;
  member_count: number;
  members: Array<{
    user_id: string;
    joined_at: string;
  }>;
}

interface ErrorResponse {
  error: string;
  status: number;
}

// CORS headers
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Content-Type": "application/json",
};

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Get authenticated user
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: "Unauthorized" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Create Supabase client
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Get user ID from JWT token
    const token = authHeader.replace("Bearer ", "");
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: "Invalid token" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Parse request body
    const payload: CreateGroupPayload = await req.json();

    // Validate required fields
    if (!payload.title || !payload.member_ids) {
      return new Response(
        JSON.stringify({
          error: "Missing required fields: title, member_ids",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Validate title
    const title = payload.title.trim();
    if (title.length === 0) {
      return new Response(
        JSON.stringify({ error: "Group title cannot be empty" }),
        { status: 400, headers: corsHeaders }
      );
    }

    if (title.length > 255) {
      return new Response(
        JSON.stringify({ error: "Group title too long (max 255 characters)" }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Validate member_ids
    if (!Array.isArray(payload.member_ids) || payload.member_ids.length === 0) {
      return new Response(
        JSON.stringify({
          error: "member_ids must be a non-empty array",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Limit group size
    if (payload.member_ids.length > 500) {
      return new Response(
        JSON.stringify({
          error: "Too many members: maximum 500 per group",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Ensure creator is included in members
    const memberSet = new Set(payload.member_ids);
    memberSet.add(user.id);
    const uniqueMemberIds = Array.from(memberSet);

    // Validate all members exist in profiles table
    const { data: existingProfiles, error: profileError } = await supabase
      .from("profiles")
      .select("user_id")
      .in("user_id", uniqueMemberIds);

    if (profileError) {
      console.error("Error checking profiles:", profileError);
      return new Response(
        JSON.stringify({ error: "Failed to validate members" }),
        { status: 500, headers: corsHeaders }
      );
    }

    const existingUserIds = new Set(
      existingProfiles?.map((p) => p.user_id) || []
    );
    const invalidMembers = uniqueMemberIds.filter(
      (id) => !existingUserIds.has(id)
    );

    if (invalidMembers.length > 0) {
      return new Response(
        JSON.stringify({
          error: `Invalid member IDs: ${invalidMembers.join(", ")}`,
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Create conversation
    const { data: conversation, error: conversationError } = await supabase
      .from("conversations")
      .insert({
        title: title,
        description: payload.description || null,
        is_group: true,
        created_by: user.id,
      })
      .select()
      .single();

    if (conversationError || !conversation) {
      console.error("Error creating conversation:", conversationError);
      return new Response(
        JSON.stringify({ error: "Failed to create group" }),
        { status: 500, headers: corsHeaders }
      );
    }

    // Add all members to conversation
    const participantRecords = uniqueMemberIds.map((userId) => ({
      conversation_id: conversation.id,
      user_id: userId,
      joined_at: new Date().toISOString(),
    }));

    const { data: participants, error: participantError } = await supabase
      .from("conversation_participants")
      .insert(participantRecords)
      .select();

    if (participantError) {
      console.error("Error adding participants:", participantError);
      // Log error but don't fail - group is created
    }

    const response: CreateGroupResponse = {
      id: conversation.id,
      title: conversation.title,
      description: conversation.description,
      is_group: conversation.is_group,
      created_by: conversation.created_by,
      created_at: conversation.created_at,
      member_count: uniqueMemberIds.length,
      members: (participants || []).map((p) => ({
        user_id: p.user_id,
        joined_at: p.joined_at,
      })),
    };

    return new Response(JSON.stringify(response), {
      status: 200,
      headers: corsHeaders,
    });
  } catch (error) {
    console.error("Error in create_group:", error);
    return new Response(
      JSON.stringify({ error: "Internal server error" }),
      { status: 500, headers: corsHeaders }
    );
  }
});
</file>

<file path="backend/supabase/functions/messages_send/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.38.0";

interface MessagePayload {
  id: string; // UUID - client-generated for idempotency
  conversation_id: string; // UUID
  body: string;
  media_url?: string | null;
}

interface MessageResponse {
  id: string;
  conversation_id: string;
  sender_id: string;
  body: string;
  media_url: string | null;
  created_at: string;
  server_time: string;
  status: "created" | "already_exists";
}

interface ErrorResponse {
  error: string;
  status: number;
}

// CORS headers
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Content-Type": "application/json",
};

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Get authenticated user
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: "Unauthorized" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Create Supabase client
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Get user ID from JWT token
    const token = authHeader.replace("Bearer ", "");
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: "Invalid token" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Parse request body
    const payload: MessagePayload = await req.json();

    // Validate required fields
    if (!payload.id || !payload.conversation_id || !payload.body) {
      return new Response(
        JSON.stringify({
          error: "Missing required fields: id, conversation_id, body",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Trim and validate body
    const body = payload.body.trim();
    if (body.length === 0) {
      return new Response(
        JSON.stringify({ error: "Message body cannot be empty" }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Verify user is participant in conversation
    const { data: participant, error: participantError } = await supabase
      .from("conversation_participants")
      .select("id")
      .eq("conversation_id", payload.conversation_id)
      .eq("user_id", user.id)
      .single();

    if (participantError || !participant) {
      return new Response(
        JSON.stringify({
          error: "Not a participant in this conversation",
        }),
        { status: 403, headers: corsHeaders }
      );
    }

    // UPSERT message (idempotent)
    // If message with this ID already exists, do nothing (returns 409 equivalent)
    const { data: message, error: messageError } = await supabase
      .from("messages")
      .upsert(
        {
          id: payload.id,
          conversation_id: payload.conversation_id,
          sender_id: user.id,
          body: body,
          media_url: payload.media_url || null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        },
        { onConflict: "id" }
      )
      .select()
      .single();

    if (messageError) {
      console.error("Error inserting message:", messageError);
      return new Response(
        JSON.stringify({ error: "Failed to send message" }),
        { status: 500, headers: corsHeaders }
      );
    }

    // Check if this was a new insert or already existed
    const { data: count, error: checkError } = await supabase
      .from("messages")
      .select("id", { count: "exact", head: true })
      .eq("id", payload.id);

    const status = count && count.length > 0 ? "created" : "already_exists";

    const response: MessageResponse = {
      id: message.id,
      conversation_id: message.conversation_id,
      sender_id: message.sender_id,
      body: message.body,
      media_url: message.media_url,
      created_at: message.created_at,
      server_time: new Date().toISOString(),
      status: status,
    };

    return new Response(JSON.stringify(response), {
      status: 200,
      headers: corsHeaders,
    });
  } catch (error) {
    console.error("Error in messages_send:", error);
    return new Response(
      JSON.stringify({ error: "Internal server error" }),
      { status: 500, headers: corsHeaders }
    );
  }
});
</file>

<file path="backend/supabase/functions/push_notify/index.ts">
// @ts-nocheck - Deno Edge Function (disable all TypeScript checks for VS Code)
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.38.0";

interface PushNotifyPayload {
  message_id: string;
  conversation_id: string;
  sender_id: string;
  sender_name: string;
  title: string;
  body: string;
}

interface PushNotifyResponse {
  success: boolean;
  message_id: string;
  notifications_sent: number;
  recipients: Array<{
    user_id: string;
    device_count: number;
  }>;
}

interface ErrorResponse {
  error: string;
  status: number;
}

// CORS headers
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Content-Type": "application/json",
};

// Helper function to generate Firebase OAuth2 access token
async function getFirebaseAccessToken(
  privateKey: string,
  clientEmail: string
): Promise<string> {
  const jwtHeader = btoa(JSON.stringify({ alg: "RS256", typ: "JWT" }));
  
  const now = Math.floor(Date.now() / 1000);
  const jwtClaimSet = {
    iss: clientEmail,
    scope: "https://www.googleapis.com/auth/firebase.messaging",
    aud: "https://oauth2.googleapis.com/token",
    exp: now + 3600,
    iat: now,
  };
  const jwtClaimSetEncoded = btoa(JSON.stringify(jwtClaimSet));
  
  // Import private key
  const pemHeader = "-----BEGIN PRIVATE KEY-----";
  const pemFooter = "-----END PRIVATE KEY-----";
  const pemContents = privateKey
    .replace(pemHeader, "")
    .replace(pemFooter, "")
    .replace(/\\n/g, "")
    .replace(/\s/g, "");
  
  const binaryDer = Uint8Array.from(atob(pemContents), c => c.charCodeAt(0));
  
  const cryptoKey = await crypto.subtle.importKey(
    "pkcs8",
    binaryDer,
    { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
    false,
    ["sign"]
  );
  
  // Sign JWT
  const signatureInput = `${jwtHeader}.${jwtClaimSetEncoded}`;
  const signature = await crypto.subtle.sign(
    "RSASSA-PKCS1-v1_5",
    cryptoKey,
    new TextEncoder().encode(signatureInput)
  );
  
  const signatureBase64 = btoa(String.fromCharCode(...new Uint8Array(signature)))
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=/g, "");
  
  const jwt = `${signatureInput}.${signatureBase64}`;
  
  // Exchange JWT for access token
  const tokenResponse = await fetch("https://oauth2.googleapis.com/token", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({
      grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
      assertion: jwt,
    }),
  });
  
  if (!tokenResponse.ok) {
    throw new Error(`Failed to get access token: ${await tokenResponse.text()}`);
  }
  
  const tokenData = await tokenResponse.json();
  return tokenData.access_token;
}

serve(async (req) => {
  console.log("🔔 Push notify function called");
  
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Get authenticated user
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      console.error("❌ No authorization header");
      return new Response(
        JSON.stringify({ error: "Unauthorized" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Create Supabase client
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Get user ID from JWT token
    const token = authHeader.replace("Bearer ", "");
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: "Invalid token" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Parse request body
    const payload: PushNotifyPayload = await req.json();
    console.log("📬 Payload received:", { 
      message_id: payload.message_id,
      conversation_id: payload.conversation_id,
      sender_id: payload.sender_id 
    });

    // Validate required fields
    if (!payload.conversation_id || !payload.message_id) {
      console.error("❌ Missing required fields");
      return new Response(
        JSON.stringify({
          error: "Missing required fields: conversation_id, message_id",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Get all conversation participants
    console.log("👥 Fetching conversation participants...");
    const { data: participants, error: participantError } = await supabase
      .from("conversation_participants")
      .select("user_id")
      .eq("conversation_id", payload.conversation_id)
      .neq("user_id", user.id); // Exclude sender

    if (participantError) {
      console.error("Error fetching participants:", participantError);
      return new Response(
        JSON.stringify({ error: "Failed to fetch participants" }),
        { status: 500, headers: corsHeaders }
      );
    }

    if (!participants || participants.length === 0) {
      console.log("ℹ️ No other participants to notify");
      return new Response(
        JSON.stringify({
          success: true,
          message_id: payload.message_id,
          notifications_sent: 0,
          recipients: [],
        }),
        { status: 200, headers: corsHeaders }
      );
    }

    const recipientUserIds = participants.map((p) => p.user_id);
    console.log(`📱 Found ${recipientUserIds.length} recipient(s):`, recipientUserIds);

    // Get all devices for participants
    // No timeout check - push notifications should work even if user hasn't opened app in days
    // FCM will handle invalid/uninstalled tokens automatically
    console.log(`📲 Fetching all devices for recipients...`);
    
    const { data: devices, error: deviceError } = await supabase
      .from("profile_devices")
      .select("user_id, fcm_token, platform, last_seen")
      .in("user_id", recipientUserIds);

    if (deviceError) {
      console.error("❌ Error fetching devices:", deviceError);
      // Continue without devices - not critical
    }
    
    console.log(`📲 Found ${devices?.length || 0} device(s)`);
    if (devices && devices.length > 0) {
      devices.forEach(d => {
        const daysSinceLastSeen = Math.floor((Date.now() - new Date(d.last_seen).getTime()) / (1000 * 60 * 60 * 24));
        console.log(`   - User: ${d.user_id}, Platform: ${d.platform}, Last seen: ${daysSinceLastSeen} days ago, Token: ${d.fcm_token.substring(0, 20)}...`);
      });
    } else {
      console.log("⚠️ No devices found! Check:");
      console.log(`   - Are recipient user_ids correct? ${recipientUserIds.join(', ')}`);
      console.log(`   - Are devices registered in profile_devices table?`);
    }

    // Group devices by user
    const devicesByUser = new Map<string, Array<{ fcm_token: string; platform: string }>>();
    (devices || []).forEach((device) => {
      if (!devicesByUser.has(device.user_id)) {
        devicesByUser.set(device.user_id, []);
      }
      devicesByUser.get(device.user_id)!.push({
        fcm_token: device.fcm_token,
        platform: device.platform,
      });
    });

    // Get Firebase credentials from environment
    const firebaseProjectId = Deno.env.get("FIREBASE_PROJECT_ID");
    const firebasePrivateKey = Deno.env.get("FIREBASE_PRIVATE_KEY");
    const firebaseClientEmail = Deno.env.get("FIREBASE_CLIENT_EMAIL");

    console.log("🔥 Firebase config check:", {
      projectId: firebaseProjectId ? "✅ Set" : "❌ Missing",
      privateKey: firebasePrivateKey ? "✅ Set" : "❌ Missing",
      clientEmail: firebaseClientEmail ? "✅ Set" : "❌ Missing"
    });

    // Check if Firebase is configured
    if (!firebaseProjectId || !firebasePrivateKey || !firebaseClientEmail) {
      console.warn("⚠️ Firebase not configured - skipping notifications");
      return new Response(
        JSON.stringify({
          success: true,
          message_id: payload.message_id,
          notifications_sent: 0,
          recipients: Array.from(devicesByUser.keys()).map((userId) => ({
            user_id: userId,
            device_count: devicesByUser.get(userId)?.length || 0,
          })),
        }),
        { status: 200, headers: corsHeaders }
      );
    }

    // Send notifications to each device
    console.log(`🚀 Sending notifications to ${devicesByUser.size} user(s)...`);
    let totalNotificationsSent = 0;
    const recipientsSummary: Array<{ user_id: string; device_count: number }> = [];

    for (const [userId, userDevices] of devicesByUser.entries()) {
      for (const device of userDevices) {
        try {
          console.log(`📤 Sending to ${device.platform}: ${device.fcm_token.substring(0, 20)}...`);
          
          // Prepare FCM message
          const fcmMessage = {
            message: {
              token: device.fcm_token,
              notification: {
                title: payload.title || "New message",
                body: payload.body || `${payload.sender_name} sent a message`,
              },
              data: {
                conversation_id: payload.conversation_id,
                message_id: payload.message_id,
                sender_id: payload.sender_id,
                sender_name: payload.sender_name,
              },
              // Android-specific
              android: {
                priority: "high",
                notification: {
                  sound: "default",
                  click_action: "FLUTTER_NOTIFICATION_CLICK",
                },
              },
              // iOS-specific
              apns: {
                payload: {
                  aps: {
                    alert: {
                      title: payload.title || "New message",
                      body: payload.body || `${payload.sender_name} sent a message`,
                    },
                    sound: "default",
                    badge: 1,
                  },
                },
              },
            },
          };

          // Get OAuth2 access token for FCM
          console.log("🔑 Getting Firebase access token...");
          const accessToken = await getFirebaseAccessToken(
            firebasePrivateKey,
            firebaseClientEmail
          );
          console.log("✅ Got access token");

          // Call Firebase Cloud Messaging API
          console.log(`📡 Calling FCM API for project: ${firebaseProjectId}`);
          const fcmResponse = await fetch(
            `https://fcm.googleapis.com/v1/projects/${firebaseProjectId}/messages:send`,
            {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(fcmMessage),
            }
          );

          if (fcmResponse.ok) {
            totalNotificationsSent++;
            console.log(`✅ SUCCESS! Notification sent to ${device.platform} device`);
          } else {
            const errorText = await fcmResponse.text();
            console.error(`❌ FCM API error ${fcmResponse.status}: ${errorText}`);
          }
        } catch (error) {
          console.error(
            `Error sending notification to ${device.fcm_token}:`,
            error
          );
        }
      }

      recipientsSummary.push({
        user_id: userId,
        device_count: userDevices.length,
      });
    }

    const response: PushNotifyResponse = {
      success: true,
      message_id: payload.message_id,
      notifications_sent: totalNotificationsSent,
      recipients: recipientsSummary,
    };

    return new Response(JSON.stringify(response), {
      status: 200,
      headers: corsHeaders,
    });
  } catch (error) {
    console.error("Error in push_notify:", error);
    return new Response(
      JSON.stringify({ error: "Internal server error" }),
      { status: 500, headers: corsHeaders }
    );
  }
});
</file>

<file path="backend/supabase/functions/receipts_ack/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.38.0";

interface ReceiptPayload {
  message_ids: string[]; // Array of message UUIDs
  status: "delivered" | "read";
}

interface ReceiptResponse {
  success: boolean;
  count: number;
  status: string;
  server_time: string;
}

interface ErrorResponse {
  error: string;
  status: number;
}

// CORS headers
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Content-Type": "application/json",
};

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Get authenticated user
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: "Unauthorized" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Create Supabase client
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Get user ID from JWT token
    const token = authHeader.replace("Bearer ", "");
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: "Invalid token" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Parse request body
    const payload: ReceiptPayload = await req.json();

    // Validate required fields
    if (!payload.message_ids || !Array.isArray(payload.message_ids) || payload.message_ids.length === 0) {
      return new Response(
        JSON.stringify({
          error: "Invalid message_ids: must be a non-empty array of UUIDs",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    if (!payload.status || !["delivered", "read"].includes(payload.status)) {
      return new Response(
        JSON.stringify({
          error: "Invalid status: must be 'delivered' or 'read'",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Limit batch size to prevent abuse
    if (payload.message_ids.length > 1000) {
      return new Response(
        JSON.stringify({
          error: "Too many message IDs: maximum 1000 per request",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Prepare receipt records (batch insert with conflict handling)
    const now = new Date().toISOString();
    const receipts = payload.message_ids.map((messageId) => ({
      id: crypto.randomUUID(), // Generate unique receipt ID
      message_id: messageId,
      user_id: user.id,
      status: payload.status,
      at: now,
    }));

    // Insert receipts with "on conflict do nothing" to handle duplicates gracefully
    const { error: insertError, data: insertedReceipts } = await supabase
      .from("message_receipts")
      .insert(receipts, { onConflict: "message_id,user_id" })
      .select("id");

    if (insertError) {
      console.error("Error inserting receipts:", insertError);
      // Log but don't fail - some receipts may have already existed
      // This is expected for idempotent operations
    }

    // Count successful inserts
    const successCount = insertedReceipts?.length || 0;

    // Also try to update existing receipts if they have a lower status
    // (e.g., "delivered" → "read")
    if (payload.status === "read") {
      const { error: updateError, data: updatedReceipts } = await supabase
        .from("message_receipts")
        .update({ status: "read", at: now })
        .in("message_id", payload.message_ids)
        .eq("user_id", user.id)
        .eq("status", "delivered")
        .select("id");

      if (updateError) {
        console.error("Error updating receipts:", updateError);
      } else if (updatedReceipts) {
        // Log update count for debugging
        console.log(`Updated ${updatedReceipts.length} receipts from delivered to read`);
      }
    }

    const response: ReceiptResponse = {
      success: true,
      count: successCount,
      status: payload.status,
      server_time: now,
    };

    return new Response(JSON.stringify(response), {
      status: 200,
      headers: corsHeaders,
    });
  } catch (error) {
    console.error("Error in receipts_ack:", error);
    return new Response(
      JSON.stringify({ error: "Internal server error" }),
      { status: 500, headers: corsHeaders }
    );
  }
});
</file>

<file path="backend/supabase/policies/conversations.sql">
-- RLS Policies for conversations table
-- Users can only view and interact with conversations they are members of

-- SELECT: Users can view conversations they are participants in
CREATE POLICY "Conversations are viewable by participants" 
  ON conversations FOR SELECT 
  USING (
    EXISTS (
      SELECT 1 FROM conversation_participants 
      WHERE conversation_id = conversations.id 
      AND user_id = auth.uid()
    )
  );

-- INSERT: Users can create new conversations
CREATE POLICY "Users can create conversations" 
  ON conversations FOR INSERT 
  WITH CHECK (auth.uid() = created_by);

-- UPDATE: Users can update conversations they created
CREATE POLICY "Conversation creators can update conversations" 
  ON conversations FOR UPDATE 
  USING (auth.uid() = created_by)
  WITH CHECK (auth.uid() = created_by);

-- DELETE: Conversation creators can delete conversations
CREATE POLICY "Conversation creators can delete conversations" 
  ON conversations FOR DELETE 
  USING (auth.uid() = created_by);
</file>

<file path="backend/supabase/policies/messages.sql">
-- RLS Policies for messages table
-- Users can only read messages in conversations they are participants in
-- Users can only send messages to conversations they are participants in

-- SELECT: Users can read messages in conversations they are in
CREATE POLICY "Users can read messages in their conversations" 
  ON messages FOR SELECT 
  USING (
    EXISTS (
      SELECT 1 FROM conversation_participants 
      WHERE conversation_id = messages.conversation_id 
      AND user_id = auth.uid()
    )
  );

-- INSERT: Users can send messages to conversations they are in
CREATE POLICY "Users can send messages to their conversations" 
  ON messages FOR INSERT 
  WITH CHECK (
    sender_id = auth.uid()
    AND EXISTS (
      SELECT 1 FROM conversation_participants 
      WHERE conversation_id = messages.conversation_id 
      AND user_id = auth.uid()
    )
  );

-- UPDATE: Users can only edit their own messages
CREATE POLICY "Users can edit their own messages" 
  ON messages FOR UPDATE 
  USING (sender_id = auth.uid())
  WITH CHECK (sender_id = auth.uid());

-- DELETE: Users can delete their own messages
CREATE POLICY "Users can delete their own messages" 
  ON messages FOR DELETE 
  USING (sender_id = auth.uid());
</file>

<file path="backend/supabase/policies/participants.sql">
-- RLS Policies for conversation_participants table
-- Users can manage their own participation in conversations

-- SELECT: Users can view participant lists of conversations they are in
CREATE POLICY "Participants viewable by conversation members" 
  ON conversation_participants FOR SELECT 
  USING (
    EXISTS (
      SELECT 1 FROM conversation_participants AS cp
      WHERE cp.conversation_id = conversation_participants.conversation_id 
      AND cp.user_id = auth.uid()
    )
  );

-- INSERT: Users can join conversations
CREATE POLICY "Users can join conversations" 
  ON conversation_participants FOR INSERT 
  WITH CHECK (user_id = auth.uid());

-- UPDATE: Users can update their own participation record (e.g., last_read_at)
CREATE POLICY "Users can update their own participation" 
  ON conversation_participants FOR UPDATE 
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

-- DELETE: Users can leave conversations
CREATE POLICY "Users can leave conversations" 
  ON conversation_participants FOR DELETE 
  USING (user_id = auth.uid());
</file>

<file path="backend/supabase/policies/receipts.sql">
-- RLS Policies for message_receipts table
-- Users can only see receipts for messages in conversations they are in
-- Users can only create receipts for themselves

-- SELECT: Users can read receipts for messages in their conversations
CREATE POLICY "Users can read receipts from their conversations" 
  ON message_receipts FOR SELECT 
  USING (
    EXISTS (
      SELECT 1 FROM messages 
      WHERE messages.id = message_receipts.message_id
      AND EXISTS (
        SELECT 1 FROM conversation_participants 
        WHERE conversation_id = messages.conversation_id 
        AND user_id = auth.uid()
      )
    )
  );

-- INSERT: Users can create receipts for messages in conversations they are in
CREATE POLICY "Users can create receipts in their conversations" 
  ON message_receipts FOR INSERT 
  WITH CHECK (
    user_id = auth.uid()
    AND EXISTS (
      SELECT 1 FROM messages 
      WHERE messages.id = message_receipts.message_id
      AND EXISTS (
        SELECT 1 FROM conversation_participants 
        WHERE conversation_id = messages.conversation_id 
        AND user_id = auth.uid()
      )
    )
  );

-- UPDATE: Users can update their own receipts (e.g., marking as read)
CREATE POLICY "Users can update their own receipts" 
  ON message_receipts FOR UPDATE 
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

-- DELETE: Users can delete their own receipts
CREATE POLICY "Users can delete their own receipts" 
  ON message_receipts FOR DELETE 
  USING (user_id = auth.uid());
</file>

<file path="backend/supabase/storage/buckets.sql">
-- Supabase Storage Buckets Configuration
-- Creates and configures storage buckets for avatars and media uploads

-- ============================================================================
-- Bucket 1: avatars
-- ============================================================================
-- Create avatars bucket if it doesn't exist
INSERT INTO storage.buckets (id, name, owner, public)
VALUES ('avatars', 'avatars', auth.uid(), false)
ON CONFLICT (id) DO NOTHING;

-- Set bucket to public (files are stored with public paths, accessed via signed URLs)
UPDATE storage.buckets 
SET public = true 
WHERE id = 'avatars';

-- Avatar bucket policy: Users can upload avatars
CREATE POLICY "Users can upload avatars"
ON storage.objects
FOR INSERT
TO public
WITH CHECK (
  bucket_id = 'avatars'
  AND (storage.foldername(name))[1] = auth.uid()::text
  AND auth.role() = 'authenticated'
);

-- Avatar bucket policy: Users can read avatars
CREATE POLICY "Users can read avatars"
ON storage.objects
FOR SELECT
TO public
USING (
  bucket_id = 'avatars'
  AND auth.role() = 'authenticated'
);

-- Avatar bucket policy: Users can update their own avatars
CREATE POLICY "Users can update their own avatars"
ON storage.objects
FOR UPDATE
TO public
USING (
  bucket_id = 'avatars'
  AND (storage.foldername(name))[1] = auth.uid()::text
  AND auth.role() = 'authenticated'
)
WITH CHECK (
  bucket_id = 'avatars'
  AND (storage.foldername(name))[1] = auth.uid()::text
  AND auth.role() = 'authenticated'
);

-- Avatar bucket policy: Users can delete their own avatars
CREATE POLICY "Users can delete their own avatars"
ON storage.objects
FOR DELETE
TO public
USING (
  bucket_id = 'avatars'
  AND (storage.foldername(name))[1] = auth.uid()::text
  AND auth.role() = 'authenticated'
);

-- ============================================================================
-- Bucket 2: media
-- ============================================================================
-- Create media bucket if it doesn't exist
INSERT INTO storage.buckets (id, name, owner, public)
VALUES ('media', 'media', auth.uid(), false)
ON CONFLICT (id) DO NOTHING;

-- Set bucket to public (files accessed via signed URLs)
UPDATE storage.buckets 
SET public = true 
WHERE id = 'media';

-- Media bucket policy: Users can upload media
CREATE POLICY "Users can upload media"
ON storage.objects
FOR INSERT
TO public
WITH CHECK (
  bucket_id = 'media'
  AND (storage.foldername(name))[1] = auth.uid()::text
  AND auth.role() = 'authenticated'
);

-- Media bucket policy: Users can read media
CREATE POLICY "Users can read media"
ON storage.objects
FOR SELECT
TO public
USING (
  bucket_id = 'media'
  AND auth.role() = 'authenticated'
);

-- Media bucket policy: Users can delete their own media
CREATE POLICY "Users can delete their own media"
ON storage.objects
FOR DELETE
TO public
USING (
  bucket_id = 'media'
  AND (storage.foldername(name))[1] = auth.uid()::text
  AND auth.role() = 'authenticated'
);
</file>

<file path="backend/test_message_insert.js">
/**
 * Message Insert Diagnostic Test
 * 
 * Tests specifically why messages aren't inserting into Supabase
 */

const { createClient } = require('@supabase/supabase-js');
const { v4: uuidv4 } = require('uuid');
require('dotenv').config();

const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY;

if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
  console.error('❌ Missing SUPABASE_URL or SUPABASE_ANON_KEY in .env file');
  process.exit(1);
}

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

async function testMessageInsert() {
  console.log('🔍 Testing Message Insert to Supabase\n');
  console.log('═'.repeat(60));
  
  try {
    // Step 1: Sign in (use an existing user email)
    console.log('\n📝 Step 1: Enter your test user credentials');
    console.log('Use the email you logged in with on the emulator');
    
    // You'll need to replace these with actual credentials
    const testEmail = 'tannereischen@gmail.com';
    const testPassword = 'password';
    
    console.log(`\n🔐 Signing in as: ${testEmail}`);
    const { data: authData, error: authError } = await supabase.auth.signInWithPassword({
      email: testEmail,
      password: testPassword
    });
    
    if (authError) {
      console.log('❌ Authentication failed:', authError.message);
      console.log('\n💡 TIP: Update testEmail and testPassword in test_message_insert.js');
      return;
    }
    
    console.log('✅ Authenticated as:', authData.user.email);
    console.log('   User ID:', authData.user.id);
    
    // Step 2: Check if user has any conversations
    console.log('\n📋 Step 2: Checking conversations...');
    const { data: conversations, error: convError } = await supabase
      .from('conversation_participants')
      .select('conversation_id, conversations(*)')
      .eq('user_id', authData.user.id);
    
    if (convError) {
      console.log('❌ Error fetching conversations:', convError.message);
      return;
    }
    
    console.log(`✅ Found ${conversations.length} conversation(s)`);
    
    if (conversations.length === 0) {
      console.log('\n⚠️  No conversations found!');
      console.log('   You need to create a conversation first in the app.');
      return;
    }
    
    const conversationId = conversations[0].conversation_id;
    console.log('   Using conversation:', conversationId);
    
    // Step 3: Check RLS policies
    console.log('\n🔒 Step 3: Checking RLS policies...');
    
    // Try to read messages (should work if user is participant)
    const { data: readTest, error: readError } = await supabase
      .from('messages')
      .select('*')
      .eq('conversation_id', conversationId)
      .limit(1);
    
    if (readError) {
      console.log('❌ Cannot read messages:', readError.message);
      console.log('   This means RLS is blocking SELECT');
    } else {
      console.log('✅ Can read messages - RLS SELECT policy OK');
    }
    
    // Step 4: Try to insert a test message
    console.log('\n📤 Step 4: Attempting to insert test message...');
    
    const testMessage = {
      id: uuidv4(), // Proper UUID format
      conversation_id: conversationId,
      sender_id: authData.user.id,
      body: 'Test message from diagnostic script',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
    
    console.log('   Message payload:');
    console.log('   ', JSON.stringify(testMessage, null, 2));
    
    const { data: insertData, error: insertError } = await supabase
      .from('messages')
      .insert(testMessage)
      .select();
    
    if (insertError) {
      console.log('\n❌ MESSAGE INSERT FAILED!');
      console.log('   Error:', insertError.message);
      console.log('   Code:', insertError.code);
      console.log('   Details:', insertError.details);
      console.log('   Hint:', insertError.hint);
      
      // Common issues and solutions
      console.log('\n🔍 Common Issues:');
      
      if (insertError.message.includes('row-level security')) {
        console.log('\n   🔴 RLS Policy Issue');
        console.log('   The user is blocked from inserting messages.');
        console.log('\n   Possible causes:');
        console.log('   1. User is not a participant in the conversation');
        console.log('   2. RLS policy is too restrictive');
        console.log('   3. Policy check is failing');
        
        // Check if user is actually a participant
        const { data: partCheck } = await supabase
          .from('conversation_participants')
          .select('*')
          .eq('conversation_id', conversationId)
          .eq('user_id', authData.user.id);
        
        if (partCheck && partCheck.length > 0) {
          console.log('\n   ✅ User IS a participant');
          console.log('   🔴 But RLS policy is still blocking!');
          console.log('\n   FIX: Check the messages RLS policy in Supabase Dashboard');
          console.log('   Go to: Database > Tables > messages > RLS Policies');
        } else {
          console.log('\n   ❌ User is NOT a participant!');
          console.log('   FIX: Add user as participant to the conversation');
        }
      }
      
      if (insertError.message.includes('duplicate key')) {
        console.log('\n   ⚠️  Duplicate ID');
        console.log('   The message ID already exists');
      }
      
      if (insertError.message.includes('foreign key')) {
        console.log('\n   ⚠️  Foreign Key Violation');
        console.log('   The conversation or user does not exist');
      }
    } else {
      console.log('\n✅ MESSAGE INSERTED SUCCESSFULLY!');
      console.log('   Message ID:', insertData[0].id);
      console.log('   Body:', insertData[0].body);
      
      // Clean up - delete test message
      await supabase.from('messages').delete().eq('id', testMessage.id);
      console.log('   (Test message deleted)');
    }
    
    // Step 5: Summary
    console.log('\n' + '═'.repeat(60));
    console.log('📊 SUMMARY');
    console.log('═'.repeat(60));
    
    if (insertError) {
      console.log('❌ Messages are NOT inserting into Supabase');
      console.log('🔴 Issue:', insertError.message);
      console.log('\n💡 NEXT STEPS:');
      console.log('   1. Check RLS policies for messages table');
      console.log('   2. Verify user is a participant in conversations');
      console.log('   3. Check Flutter app logs for similar errors');
    } else {
      console.log('✅ Messages CAN insert into Supabase');
      console.log('🎯 The database configuration is correct!');
      console.log('\n💡 If messages still don\'t sync from Flutter:');
      console.log('   1. Check Flutter app logs for errors');
      console.log('   2. Verify network connectivity');
      console.log('   3. Check if auth token is valid');
    }
    
  } catch (error) {
    console.error('\n💥 Unexpected error:', error);
  }
}

// Run the test
testMessageInsert();
</file>

<file path="contracts/openapitools.json">
{
  "$schema": "./node_modules/@openapitools/openapi-generator-cli/config.schema.json",
  "spaces": 2,
  "generator-cli": {
    "version": "7.16.0"
  }
}
</file>

<file path="contracts/package.json">
{
  "name": "messageai-contracts",
  "version": "0.1.0",
  "scripts": {
    "validate": "openapi-generator-cli validate -i openapi.yaml && ajv -s events/*.json",
    "gen:dart": "openapi-generator-cli generate -g dart-dio -i openapi.yaml -o ../frontend/lib/gen/api --additional-properties=pubName=message_ai_client"
  },
  "devDependencies": {
    "@openapitools/openapi-generator-cli": "^2.9.0",
    "ajv-cli": "^5.0.0"
  }
}
</file>

<file path="docs/Architecture.puml">
@startuml Architecture
title MessageAI Simplified Layered Architecture
actor User as U
rectangle "Flutter Frontend\n(/frontend)" as FE {
  component "UI Layer\n(Riverpod + Widgets)" as UI
  component "Data Layer\n(Drift + Supabase Client)" as DL
}
rectangle "Contracts\n(/contracts)" as CT {
  artifact "OpenAPI Spec\n(openapi.yaml)"
  artifact "Event Schemas\n(events/*.json)"
  artifact "Dart Client\n(/frontend/lib/gen/api)"
}
rectangle "Supabase Backend\n(/backend)" as BE {
  component "Edge Functions\n(messages_send, receipts_ack)" as EF
  component "Realtime Channels\n(messages, receipts)" as RT
  component "Storage Buckets\n(avatars, media)" as ST
}
database "Postgres DB\n(migrations + RLS)" as DB
U --> UI : Interacts via App
UI --> DL : Local Reads/Writes\nOffline Cache
DL --> CT : Uses Generated Client (OpenAPI)
CT --> EF : API Requests (Validated)
EF --> DB : SQL + Policies
DB --> RT : Broadcast Changes (Realtime)
RT --> DL : Push Updates\nPresence/Receipts
BE --> ST : Signed URL Access
@enduml
</file>

<file path="docs/ERD.puml">
@startuml ERD
title MessageAI Simplified ERD
entity "profiles" {
  *id : uuid [PK]
  --
  display_name : text
  avatar_url : text
  last_seen : timestamptz
}
entity "conversations" {
  *id : uuid [PK]
  --
  title : text
  is_group : boolean
  created_at : timestamptz
}
entity "conversation_participants" {
  *conversation_id : uuid [PK, FK -> conversations.id]
  *user_id : uuid [PK, FK -> profiles.id]
  role : text
  joined_at : timestamptz
}
entity "messages" {
  *id : uuid [PK]
  conversation_id : uuid [FK -> conversations.id]
  sender_id : uuid [FK -> profiles.id]
  body : text
  media_url : text
  created_at : timestamptz
}
entity "message_receipts" {
  *message_id : uuid [PK, FK -> messages.id]
  *user_id : uuid [PK, FK -> profiles.id]
  status : text
  at : timestamptz
}
profiles ||--o{ conversation_participants
conversations ||--o{ conversation_participants
conversations ||--o{ messages
messages ||--o{ message_receipts
profiles ||--o{ messages : "sender"
profiles ||--o{ message_receipts
@enduml
</file>

<file path="frontend/.gitignore">
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.packages
.pub-cache/
.pub/
/build/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release

# iOS/macOS
**/ios/**/*.mode1v3
**/ios/**/*.mode2v3
**/ios/**/*.moved-aside
**/ios/**/*.pbxuser
**/ios/**/*.perspectivev3
**/ios/**/*sync/
**/ios/**/.sconsign.dblite
**/ios/**/.tags*
**/ios/**/.vscode/*
!**/ios/**/.vscode/extensions.json
**/ios/**/DerivedData/
**/ios/**/Flutter/Flutter.framework/*
**/ios/**/Flutter/Flutter.podspec
**/ios/**/Flutter/Generated.xcconfig
**/ios/**/Flutter/ephemeral/
**/ios/**/Flutter/app.flx
**/ios/**/Flutter/app.zip
**/ios/**/Flutter/flutter_assets/
**/ios/**/Flutter/flutter_export_environment.sh
**/ios/**/GoogleService-Info.plist
**/ios/**/ServiceAccount.json
**/ios/**/.symlinks/
**/ios/**/.vagrant
**/ios/**/Flutter/Flutter.framework
**/ios/**/Flutter/Flutter.podspec
**/ios/Podfile
**/ios/Podfile.lock

# Web
lib/generated_plugin_registrant.dart

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
**/android/app/debug
**/android/app/profile
**/android/app/release
**/android/app/outputs
**/android/.gradle
**/android/captures/
**/android/gradlew
**/android/gradlew.bat
**/android/gradle/wrapper/gradle-wrapper.jar
**/android/gradle/wrapper/gradle-wrapper.properties

# Firebase
google-services.json
GoogleService-Info.plist
**/android/app/google-services.json
**/ios/GoogleService-Info.plist

# Exceptions to above rules.
!/packages/flutter_tools/test/data/dart_dependencies_test/**/.packages

# Environment files
.env
.env.local
.env.*.local
.env.dev.json
.env.prod.json

# Generated code
*.g.dart
*.config.dart
*.freezed.dart
*.chopper.dart

# Drift related
.dart_tool/build
lib/data/drift/**/*.g.dart

# Coverage
coverage/
.coverage

# Exceptions to above rules.
!/packages/flutter_tools/test/data/dart_dependencies_test/**/.packages

# Xcode related
*.xcarchive
*.xcworkspace
xcuser.xcuserdatad

# Compiled output
*.app/
*.framework/
*.so
.symbols/

# Obfuscation
app.*.map.json

# macOS
.DS_Store
.AppleDouble
.LSOverride
*.mode1v3
*.mode2v3
*.moved-aside
*.pbxuser
*.perspectivev3
**/*.sconsign.dblite
.sconsign.dblite
dsa_cert.certSigningRequest
profile
DerivedData/
build/
Generated.xcconfig
GeneratedPluginRegistrant.swift

# iOS
**/ios/.symlinks/
**/ios/.vagrant
**/ios/**/Flutter/Flutter.framework
**/ios/**/Flutter/Flutter.podspec
**/ios/**/Flutter/Generated.xcconfig
**/ios/**/Flutter/generated_plugin_registrant.m
**/ios/**/Flutter/ephemeral/
**/ios/**/GoogleService-Info.plist
**/ios/**/ServiceAccount.json
**/ios/**/.sconsign.dblite
**/ios/**/.tags
**/ios/**/.vscode/*
!**/ios/**/.vscode/extensions.json
**/ios/**/Flutter/.last_build_id
**/ios/**/Flutter/app.flx
**/ios/**/Flutter/app.zip
**/ios/**/Flutter/flutter_assets/
**/ios/**/Flutter/flutter_export_environment.sh

# Android
**/android/app/debug
**/android/app/profile
**/android/app/release
**/android/app/outputs/
**/android/.gradle
**/android/captures/
**/android/gradle-app.setting
**/android/gradlew
**/android/gradlew.bat
**/android/gradle/wrapper/gradle-wrapper.jar
**/android/gradle/wrapper/gradle-wrapper.properties
**/android/local.properties

# Web
lib/generated_plugin_registrant.dart

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
**/android/**/gradle-wrapper.jar
**/android/gradle
**/android/gradlew
**/android/gradlew.bat
**/android/local.properties
**/android/**/GeneratedPluginRegistrant.java

# iOS/macOS
**/ios/**/*.mode1v3
**/ios/**/*.mode2v3
**/ios/**/.vscode/*
!**/ios/**/.vscode/extensions.json
**/ios/**/DerivedData/
**/ios/**/Flutter/Flutter.framework
**/ios/**/Flutter/Flutter.podspec
**/ios/**/Flutter/Generated.xcconfig
**/ios/**/Flutter/ephemeral/
**/ios/**/Flutter/app.flx
**/ios/**/Flutter/app.zip
**/ios/**/Flutter/flutter_assets/
**/ios/**/Flutter/flutter_export_environment.sh
**/ios/**/GoogleService-Info.plist
**/ios/**/ServiceAccount.json
**/ios/**/.symlinks/
**/ios/**/.vagrant
**/macos/Flutter/Flutter-Debug.xcconfig
**/macos/Flutter/Flutter-Release.xcconfig
**/macos/Flutter/GeneratedPluginRegistrant.swift

# Windows
windows/flutter/generated_plugin_registrant.cc
windows/flutter/generated_plugin_registrant.h
windows/flutter/generated_plugins.cmake

# Linux
linux/flutter/generated_plugin_registrant.cc
linux/flutter/generated_plugin_registrant.h
linux/flutter/generated_plugins.cmake

# Coverage
coverage/

# Symbols
app.*.symbols

# Local env files
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# VS Code settings
.vscode/*
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json

# misc
*.deb
*.dsc
*.buildinfo
*.changes
*.orig.*
/.dart_tool
/.flutter-plugins
/.flutter-plugins-dependencies
/.packages
/.pub-cache
/pubspec.lock
/build
/linux/flutter/generated_plugin_registrant.cc
/linux/flutter/generated_plugin_registrant.h
/linux/flutter/generated_plugins.cmake
/macos/Flutter/GeneratedPluginRegistrant.swift
/web/plugins.json
/windows/flutter/generated_plugin_registrant.cc
/windows/flutter/generated_plugin_registrant.h
/windows/flutter/generated_plugins.cmake

# Firebase & Google Services
**/GoogleService-Info.plist
**/google-services.json
**/ServiceAccount.json

# Temporary files
*.tmp
*.swp
*.swo
*~
.~*

# System
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
</file>

<file path="frontend/.metadata">
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "9f455d2486bcb28cad87b062475f42edc959f636"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: 9f455d2486bcb28cad87b062475f42edc959f636
      base_revision: 9f455d2486bcb28cad87b062475f42edc959f636
    - platform: windows
      create_revision: 9f455d2486bcb28cad87b062475f42edc959f636
      base_revision: 9f455d2486bcb28cad87b062475f42edc959f636

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'
</file>

<file path="frontend/analysis_options.yaml">
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options
</file>

<file path="frontend/android/.gitignore">
gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java
.cxx/

# Remember to never publicly share your keystore.
# See https://flutter.dev/to/reference-keystore
key.properties
**/*.keystore
**/*.jks
</file>

<file path="frontend/android/app/build.gradle.kts">
plugins {
    id("com.android.application")
    // START: FlutterFire Configuration
    id("com.google.gms.google-services")
    // END: FlutterFire Configuration
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.messageai"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
        isCoreLibraryDesugaringEnabled = true
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_11.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.example.messageai"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
        multiDexEnabled = true
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}

dependencies {
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.1.4")
    
    // Exclude sign_in_with_apple which uses deprecated Flutter APIs
    configurations.all {
        exclude(group = "com.aboutyou.dart_packages", module = "sign_in_with_apple")
    }
}
</file>

<file path="frontend/android/app/src/debug/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
</file>

<file path="frontend/android/app/src/main/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="messageai"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>
</file>

<file path="frontend/android/app/src/main/kotlin/com/example/messageai/MainActivity.kt">
package com.example.messageai

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()
</file>

<file path="frontend/android/app/src/main/res/drawable-v21/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
</file>

<file path="frontend/android/app/src/main/res/drawable/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
</file>

<file path="frontend/android/app/src/main/res/values-night/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="frontend/android/app/src/main/res/values/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="frontend/android/build.gradle.kts">
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}
</file>

<file path="frontend/android/gradle.properties">
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
android.enableJetifier=true
</file>

<file path="frontend/android/settings.gradle.kts">
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.9.1" apply false
    // START: FlutterFire Configuration
    id("com.google.gms.google-services") version("4.3.15") apply false
    // END: FlutterFire Configuration
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
}

include(":app")
</file>

<file path="frontend/devtools_options.yaml">
description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:
</file>

<file path="frontend/lib/core/env.dart">
/// Environment configuration for Supabase connection.
/// 
/// Reads SUPABASE_URL and SUPABASE_ANON_KEY from:
/// 1. Dart defines (via --dart-define-from-file=.env.dev.json)
/// 2. Environment variables as fallback

class Env {
  static const String supabaseUrl = String.fromEnvironment(
    'SUPABASE_URL',
    defaultValue: 'https://your-project.supabase.co',
  );

  static const String supabaseAnonKey = String.fromEnvironment(
    'SUPABASE_ANON_KEY',
    defaultValue: 'your-anon-key',
  );

  // Validate that required config is present
  static void validate() {
    assert(
      supabaseUrl != 'https://your-project.supabase.co',
      'SUPABASE_URL not configured',
    );
    assert(
      supabaseAnonKey != 'your-anon-key',
      'SUPABASE_ANON_KEY not configured',
    );
  }
}
</file>

<file path="frontend/lib/data/repositories/group_repository.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/conversation_dao.dart';
import 'package:messageai/data/drift/daos/participant_dao.dart';
import 'package:uuid/uuid.dart';

/// Repository for group operations
class GroupRepository {
  final ConversationDao _conversationDao;
  final ParticipantDao _participantDao;

  GroupRepository({
    required ConversationDao conversationDao,
    required ParticipantDao participantDao,
  })  : _conversationDao = conversationDao,
        _participantDao = participantDao;

  /// Create a new group conversation
  Future<Conversation> createGroup({
    required String title,
    required String description,
    required String creatorId,
    required List<String> memberIds,
  }) async {
    const uuid = Uuid();
    final conversationId = uuid.v4();
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Create conversation
    final conversation = Conversation(
      id: conversationId,
      title: title,
      description: description,
      createdAt: now,
      updatedAt: now,
      isGroup: true,
      isSynced: false,
    );
    
    await _conversationDao.upsertConversation(conversation);
    
    // Add creator as admin
    final creatorParticipant = Participant(
      id: uuid.v4(),
      conversationId: conversationId,
      userId: creatorId,
      joinedAt: now,
      isAdmin: true,
      isSynced: false,
    );
    
    await _participantDao.addParticipant(creatorParticipant);
    
    // Add other members
    final participants = memberIds.map((userId) {
      return Participant(
        id: uuid.v4(),
        conversationId: conversationId,
        userId: userId,
        joinedAt: now,
        isAdmin: false,
        isSynced: false,
      );
    }).toList();
    
    await _participantDao.addParticipants(participants);
    
    return conversation;
  }

  /// Get group details with members
  Future<(Conversation, List<Participant>)> getGroupWithMembers(String groupId) async {
    final conversation = await _conversationDao.getConversationById(groupId);
    if (conversation == null) {
      throw Exception('Group not found: $groupId');
    }
    
    final participants = await _participantDao.getParticipantsByConversation(groupId);
    
    return (conversation, participants);
  }

  /// Update group info
  Future<void> updateGroupInfo({
    required String groupId,
    String? title,
    String? description,
  }) async {
    // This would require a Conversation update method in ConversationDao
    // For now, creating a placeholder
    // TODO: Implement in ConversationDao
  }

  /// Add member to group
  Future<void> addGroupMember({
    required String groupId,
    required String userId,
  }) async {
    const uuid = Uuid();
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Check if already a member
    final existing = await _participantDao.getParticipant(groupId, userId);
    if (existing != null) {
      throw Exception('User is already a member of this group');
    }
    
    final participant = Participant(
      id: uuid.v4(),
      conversationId: groupId,
      userId: userId,
      joinedAt: now,
      isAdmin: false,
      isSynced: false,
    );
    
    await _participantDao.addParticipant(participant);
  }

  /// Remove member from group
  Future<void> removeGroupMember({
    required String groupId,
    required String userId,
  }) async {
    await _participantDao.removeParticipant(groupId, userId);
  }

  /// Promote member to admin
  Future<void> promoteToAdmin({
    required String groupId,
    required String userId,
  }) async {
    final participant = await _participantDao.getParticipant(groupId, userId);
    if (participant == null) {
      throw Exception('Member not found in group');
    }
    
    await _participantDao.promoteToAdmin(participant.id);
  }

  /// Demote admin to member
  Future<void> demoteFromAdmin({
    required String groupId,
    required String userId,
  }) async {
    final participant = await _participantDao.getParticipant(groupId, userId);
    if (participant == null) {
      throw Exception('Member not found in group');
    }
    
    await _participantDao.demoteFromAdmin(participant.id);
  }

  /// Get user's groups
  Future<List<Conversation>> getUserGroups(String userId) async {
    final allConversations = await _conversationDao.getAllConversations();
    
    // Filter to only groups where user is a participant
    final userGroups = <Conversation>[];
    
    for (final conversation in allConversations) {
      if (conversation.isGroup) {
        final isParticipant = await _participantDao.isParticipant(
          conversation.id,
          userId,
        );
        if (isParticipant) {
          userGroups.add(conversation);
        }
      }
    }
    
    return userGroups;
  }

  /// Leave group
  Future<void> leaveGroup({
    required String groupId,
    required String userId,
  }) async {
    await _participantDao.removeParticipant(groupId, userId);
  }

  /// Delete group (admin only)
  Future<void> deleteGroup(String groupId) async {
    // Remove all participants
    await _participantDao.removeConversationParticipants(groupId);
    
    // Delete conversation
    await _conversationDao.deleteConversation(groupId);
  }

  /// Get group members count
  Future<int> getGroupMemberCount(String groupId) async {
    return _participantDao.getParticipantCount(groupId);
  }

  /// Check if user is group admin
  Future<bool> isUserGroupAdmin(String groupId, String userId) async {
    return _participantDao.isAdmin(groupId, userId);
  }
}
</file>

<file path="frontend/lib/data/repositories/message_repository.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/message_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';
import 'package:messageai/gen/api/clients/messages_api.dart';
import 'package:messageai/gen/api/models/message_payload.dart';

/// Repository for message operations combining API and local database
class MessageRepository {
  final MessagesApi _messagesApi;
  final MessageDao _messageDao;
  final PendingOutboxDao _outboxDao;

  MessageRepository({
    required MessagesApi messagesApi,
    required MessageDao messageDao,
    required PendingOutboxDao outboxDao,
  })  : _messagesApi = messagesApi,
        _messageDao = messageDao,
        _outboxDao = outboxDao;

  /// Send a message (optimistic - save locally first, sync later)
  Future<Message> sendMessage({
    required String id,
    required String conversationId,
    required String senderId,
    required String body,
    String? mediaUrl,
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Create message locally first (optimistic)
    final message = Message(
      id: id,
      conversationId: conversationId,
      senderId: senderId,
      body: body,
      mediaUrl: mediaUrl,
      createdAt: now,
      updatedAt: now,
      isSynced: false,
    );
    
    // Save to local DB
    await _messageDao.insertMessage(message);
    
    // Queue for sync
    await _outboxDao.addPendingOperation(
      id: '${id}_send',
      operation: 'send_message',
      payload: message.toJson().toString(),
      conversationId: conversationId,
    );
    
    return message;
  }

  /// Get messages for a conversation from local DB
  Future<List<Message>> getConversationMessages(String conversationId) async {
    return _messageDao.getMessagesByConversation(conversationId);
  }

  /// Get recent messages for a conversation (paginated)
  Future<List<Message>> getRecentMessages(String conversationId, {int limit = 50}) async {
    return _messageDao.getRecentMessages(conversationId, limit: limit);
  }

  /// Sync unsynced messages to server
  Future<void> syncUnsyncedMessages() async {
    final unsyncedMessages = await _messageDao.getUnsyncedMessages();
    
    for (final message in unsyncedMessages) {
      try {
        final payload = MessagePayload(
          id: message.id,
          conversationId: message.conversationId,
          body: message.body,
        );
        
        // Send to server
        await _messagesApi.send(payload);
        
        // Mark as synced locally
        await _messageDao.markMessageAsSynced(message.id);
        
        // Remove from outbox
        await _outboxDao.removePendingOperation('${message.id}_send');
      } catch (e) {
        // Log error and continue
        print('Error syncing message ${message.id}: $e');
      }
    }
  }

  /// Search messages in a conversation
  Future<List<Message>> searchMessages(String conversationId, String query) async {
    return _messageDao.searchMessages(conversationId, query);
  }

  /// Insert messages from server
  Future<void> insertServerMessages(List<Message> messages) async {
    await _messageDao.insertMessages(messages);
  }

  /// Update message from server
  Future<void> updateMessageFromServer(Message message) async {
    await _messageDao.upsertMessage(message);
  }

  /// Upsert message (helper)
  Future<void> upsertMessage(Message message) async {
    // This would be added to MessageDao
    await _messageDao.insertMessage(message);
  }

  /// Get pending message count (for UI)
  Future<int> getPendingMessageCount() async {
    return _messageDao.getUnsyncedMessageCount();
  }
}

extension on Message {
  Map<String, dynamic> toJson() => {
    'id': id,
    'conversation_id': conversationId,
    'sender_id': senderId,
    'body': body,
    'media_url': mediaUrl,
    'created_at': createdAt,
    'updated_at': updatedAt,
    'is_synced': isSynced,
  };
}
</file>

<file path="frontend/lib/data/repositories/receipt_repository.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';
import 'package:messageai/gen/api/clients/receipts_api.dart';
import 'package:messageai/gen/api/models/receipt_payload.dart';

/// Repository for receipt operations combining API and local database
class ReceiptRepository {
  final ReceiptsApi _receiptsApi;
  final ReceiptDao _receiptDao;
  final PendingOutboxDao _outboxDao;

  ReceiptRepository({
    required ReceiptsApi receiptsApi,
    required ReceiptDao receiptDao,
    required PendingOutboxDao outboxDao,
  })  : _receiptsApi = receiptsApi,
        _receiptDao = receiptDao,
        _outboxDao = outboxDao;

  /// Acknowledge message receipts (optimistic)
  Future<void> acknowledgeReceipts({
    required List<String> messageIds,
    required String status, // 'delivered' or 'read'
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Save receipts locally first
    final receipts = messageIds.map((msgId) {
      return Receipt(
        id: '${msgId}_${status}_$now',
        messageId: msgId,
        userId: '', // Would be current user ID
        status: status,
        createdAt: now,
        updatedAt: now,
        isSynced: false,
      );
    }).toList();
    
    await _receiptDao.addReceipts(receipts);
    
    // Queue for sync
    await _outboxDao.addPendingOperation(
      id: 'ack_${status}_$now',
      operation: 'ack_receipt',
      payload: ReceiptPayload(
        messageIds: messageIds,
        status: status == 'delivered' ? ReceiptStatus.delivered : ReceiptStatus.read,
      ).toJson().toString(),
      conversationId: null,
    );
  }

  /// Get receipts for a message
  Future<List<Receipt>> getMessageReceipts(String messageId) async {
    return _receiptDao.getReceiptsByMessage(messageId);
  }

  /// Get read count for a message
  Future<int> getReadCount(String messageId) async {
    return _receiptDao.getReadCount(messageId);
  }

  /// Get delivered count for a message
  Future<int> getDeliveredCount(String messageId) async {
    return _receiptDao.getDeliveredCount(messageId);
  }

  /// Check if message is read by all participants
  Future<bool> isReadByAll(String messageId, int participantCount) async {
    return _receiptDao.isReadByAll(messageId, participantCount);
  }

  /// Sync unsynced receipts to server
  Future<void> syncUnsyncedReceipts() async {
    final unsyncedReceipts = await _receiptDao.getUnsyncedReceipts();
    
    if (unsyncedReceipts.isEmpty) return;
    
    try {
      // Group by status
      final deliveredIds = unsyncedReceipts
          .where((r) => r.status == 'delivered')
          .map((r) => r.messageId)
          .toList();
      
      final readIds = unsyncedReceipts
          .where((r) => r.status == 'read')
          .map((r) => r.messageId)
          .toList();
      
      // Send to server
      if (deliveredIds.isNotEmpty) {
        final payload = ReceiptPayload(
          messageIds: deliveredIds,
          status: ReceiptStatus.delivered,
        );
        await _receiptsApi.ack(payload);
      }
      
      if (readIds.isNotEmpty) {
        final payload = ReceiptPayload(
          messageIds: readIds,
          status: ReceiptStatus.read,
        );
        await _receiptsApi.ack(payload);
      }
      
      // Mark as synced
      final allIds = unsyncedReceipts.map((r) => r.id).toList();
      await _receiptDao.markReceiptsAsSynced(allIds);
    } catch (e) {
      print('Error syncing receipts: $e');
    }
  }

  /// Insert receipts from server
  Future<void> insertServerReceipts(List<Receipt> receipts) async {
    await _receiptDao.addReceipts(receipts);
  }

  /// Get unsynced receipt count (for UI)
  Future<int> getUnsyncedReceiptCount() async {
    return _receiptDao.getUnsyncedReceiptCount();
  }
}

extension on ReceiptPayload {
  Map<String, dynamic> toJson() => {
    'message_ids': messageIds,
    'status': status.toValue(),
  };
}
</file>

<file path="frontend/lib/features/conversations/widgets/message_bubble.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/features/messages/widgets/tone_detail_sheet.dart';
import 'package:messageai/state/ai_providers.dart';

/// Widget to display a single message with AI analysis
class MessageBubble extends ConsumerWidget {
  final Message message;
  final bool isSent;
  final bool isLoading;
  final VoidCallback? onRetry;

  const MessageBubble({
    Key? key,
    required this.message,
    required this.isSent,
    this.isLoading = false,
    this.onRetry,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    
    // Fetch AI analysis for this message
    final analysisAsync = ref.watch(messageAnalysisProvider(message.id));
    
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Row(
        mainAxisAlignment: isSent ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          if (!isSent)
            Padding(
              padding: const EdgeInsets.only(right: 8),
              child: CircleAvatar(
                radius: 16,
                backgroundColor: theme.colorScheme.primaryContainer,
                child: Text(
                  message.senderId.isNotEmpty 
                      ? message.senderId[0].toUpperCase() 
                      : 'U',
                  style: TextStyle(color: theme.colorScheme.onPrimaryContainer),
                ),
              ),
            ),
          Flexible(
            child: GestureDetector(
              onLongPress: isSent && !message.isSynced ? onRetry : null,
              child: Container(
                decoration: BoxDecoration(
                  color: isSent
                      ? theme.colorScheme.primary
                      : theme.colorScheme.surfaceVariant,
                  borderRadius: BorderRadius.circular(12),
                ),
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    if (message.mediaUrl != null && message.mediaUrl!.isNotEmpty)
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: Container(
                          width: 200,
                          height: 200,
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(8),
                            color: Colors.grey[300],
                          ),
                          child: Icon(
                            Icons.image,
                            size: 80,
                            color: Colors.grey[600],
                          ),
                        ),
                      ),
                    Text(
                      message.body,
                      style: TextStyle(
                        color: isSent ? Colors.white : theme.textTheme.bodyMedium?.color,
                        fontSize: 14,
                      ),
                    ),
                    Padding(
                      padding: const EdgeInsets.only(top: 4),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(
                            _formatTime(DateTime.fromMillisecondsSinceEpoch(
                              message.createdAt * 1000,
                            )),
                            style: TextStyle(
                              color: isSent 
                                  ? Colors.white70 
                                  : theme.textTheme.bodySmall?.color,
                              fontSize: 12,
                            ),
                          ),
                          if (isSent) ...[
                            const SizedBox(width: 4),
                            if (isLoading)
                              SizedBox(
                                width: 12,
                                height: 12,
                                child: CircularProgressIndicator(
                                  strokeWidth: 1.5,
                                  valueColor: AlwaysStoppedAnimation(
                                    Colors.white70,
                                  ),
                                ),
                              )
                            else if (message.isSynced)
                              Icon(
                                Icons.check_circle,
                                size: 12,
                                color: Colors.white70,
                              )
                            else
                              Icon(
                                Icons.schedule,
                                size: 12,
                                color: Colors.white70,
                              ),
                          ],
                        ],
                      ),
                    ),
                    // AI Analysis Badge (shows tone analysis if available)
                    analysisAsync.when(
                      data: (analysis) {
                        if (analysis == null) return const SizedBox.shrink();
                        return Padding(
                          padding: const EdgeInsets.only(top: 8),
                          child: ToneBadge(
                            analysis: analysis,
                            onTap: () => ToneDetailSheet.show(
                              context,
                              analysis,
                              message.body,
                            ),
                          ),
                        );
                      },
                      loading: () => const SizedBox.shrink(),
                      error: (_, __) => const SizedBox.shrink(),
                    ),
                  ],
                ),
              ),
            ),
          ),
          if (isSent)
            Padding(
              padding: const EdgeInsets.only(left: 8),
              child: CircleAvatar(
                radius: 16,
                backgroundColor: theme.colorScheme.primary,
                child: Icon(
                  Icons.person,
                  size: 12,
                  color: Colors.white,
                ),
              ),
            ),
        ],
      ),
    );
  }

  /// Format time for display
  String _formatTime(DateTime dateTime) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final yesterday = today.subtract(const Duration(days: 1));
    final messageDate = DateTime(dateTime.year, dateTime.month, dateTime.day);

    if (messageDate == today) {
      return '${dateTime.hour}:${dateTime.minute.toString().padLeft(2, '0')}';
    } else if (messageDate == yesterday) {
      return 'Yesterday';
    } else {
      return '${dateTime.month}/${dateTime.day}';
    }
  }
}
</file>

<file path="frontend/lib/features/notifications/widgets/notification_widgets.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/notification_providers.dart';
import 'package:messageai/services/notification_service.dart';

/// Widget to request notification permissions
class NotificationPermissionRequest extends ConsumerWidget {
  final VoidCallback? onPermissionGranted;
  final VoidCallback? onPermissionDenied;

  const NotificationPermissionRequest({
    Key? key,
    this.onPermissionGranted,
    this.onPermissionDenied,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final hasPermission = ref.watch(notificationPermissionProvider);

    return hasPermission.when(
      data: (hasPermission) {
        if (hasPermission) {
          return const SizedBox.shrink();
        }
        return _PermissionBanner(
          onGranted: onPermissionGranted,
          onDenied: onPermissionDenied,
        );
      },
      loading: () => const SizedBox.shrink(),
      error: (error, st) => const SizedBox.shrink(),
    );
  }
}

/// Permission request banner
class _PermissionBanner extends ConsumerWidget {
  final VoidCallback? onGranted;
  final VoidCallback? onDenied;

  const _PermissionBanner({
    this.onGranted,
    this.onDenied,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Container(
      color: Colors.blue.shade50,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      child: Row(
        children: [
          Icon(
            Icons.notifications_none,
            color: Colors.blue.shade700,
            size: 24,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  'Enable Notifications',
                  style: Theme.of(context).textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                ),
                Text(
                  'Get notified when you receive messages',
                  style: Theme.of(context).textTheme.bodySmall,
                ),
              ],
            ),
          ),
          const SizedBox(width: 12),
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextButton(
                onPressed: () {
                  onDenied?.call();
                },
                child: const Text('Not Now'),
              ),
              const SizedBox(width: 8),
              ElevatedButton(
                onPressed: () async {
                  final service = ref.read(notificationServiceProvider);
                  final granted = await service.areNotificationsEnabled();
                  if (granted) {
                    onGranted?.call();
                  } else {
                    onDenied?.call();
                  }
                },
                child: const Text('Enable'),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

/// Notification status indicator
class NotificationStatusIndicator extends ConsumerWidget {
  const NotificationStatusIndicator({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);

    if (!notificationState.isInitialized) {
      return const SizedBox.shrink();
    }

    final hasPermission = notificationState.hasPermission;

    return Tooltip(
      message: hasPermission ? 'Notifications enabled' : 'Notifications disabled',
      child: Icon(
        hasPermission ? Icons.notifications_active : Icons.notifications_off,
        color: hasPermission ? Colors.green : Colors.grey,
        size: 24,
      ),
    );
  }
}

/// Notification settings tile
class NotificationSettingsTile extends ConsumerWidget {
  final VoidCallback? onPressed;

  const NotificationSettingsTile({
    Key? key,
    this.onPressed,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);
    final hasPermission = notificationState.hasPermission;

    return ListTile(
      leading: Icon(
        hasPermission ? Icons.notifications_active : Icons.notifications_off,
        color: hasPermission ? Colors.green : Colors.grey,
      ),
      title: const Text('Notifications'),
      subtitle: Text(
        hasPermission ? 'Enabled' : 'Disabled',
        style: TextStyle(
          color: hasPermission ? Colors.green : Colors.grey,
        ),
      ),
      trailing: Icon(
        Icons.chevron_right,
        color: Theme.of(context).dividerColor,
      ),
      onTap: onPressed,
    );
  }
}

/// Unread notification badge
class NotificationBadge extends ConsumerWidget {
  final Widget child;
  final Color? backgroundColor;
  final TextStyle? textStyle;

  const NotificationBadge({
    Key? key,
    required this.child,
    this.backgroundColor,
    this.textStyle,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);
    final unreadCount = notificationState.unreadCount;

    if (unreadCount == 0) {
      return child;
    }

    return Badge(
      label: Text(
        unreadCount > 99 ? '99+' : '$unreadCount',
        style: textStyle,
      ),
      backgroundColor: backgroundColor ?? Colors.red,
      child: child,
    );
  }
}

/// Notification bottom sheet
class NotificationSettingsBottomSheet extends ConsumerWidget {
  const NotificationSettingsBottomSheet({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);
    final hasPermission = notificationState.hasPermission;
    final deviceToken = notificationState.deviceToken;

    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Text(
            'Notification Settings',
            style: Theme.of(context).textTheme.headlineSmall,
          ),
          const SizedBox(height: 24),

          // Permission status
          ListTile(
            leading: Icon(
              hasPermission ? Icons.check_circle : Icons.error_circle,
              color: hasPermission ? Colors.green : Colors.red,
            ),
            title: const Text('Notifications'),
            subtitle: Text(
              hasPermission ? 'Enabled' : 'Disabled',
              style: TextStyle(
                color: hasPermission ? Colors.green : Colors.red,
              ),
            ),
          ),
          const Divider(),

          // Device token info
          if (deviceToken != null)
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 8.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Device Token',
                    style: Theme.of(context).textTheme.labelMedium,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    deviceToken.substring(0, 20) + '...',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          fontFamily: 'monospace',
                        ),
                  ),
                ],
              ),
            ),
          const SizedBox(height: 24),

          // Close button
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Close'),
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/firebase_options.dart">
// File generated by FlutterFire CLI.
// This is a placeholder file. To use Firebase, you need to:
// 1. Install FlutterFire CLI: dart pub global activate flutterfire_cli
// 2. Run: flutterfire configure
// 3. Follow the prompts to select your Firebase project
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import firebase_options.dart;
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyABa-DcxTR4T4CHlfJuy-7DKG1F_hDRNcg',
    appId: '1:397483513751:web:3121cbb846ddd8381c56d2',
    messagingSenderId: '397483513751',
    projectId: 'messageai-e2e9e',
    authDomain: 'messageai-e2e9e.firebaseapp.com',
    storageBucket: 'messageai-e2e9e.firebasestorage.app',
    measurementId: 'G-VCVQDFPTLV',
  );

  // Placeholder values - replace with your actual Firebase configuration

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyBBc-17a_EvWPvCutNSTEV9QEB2w2DUM_4',
    appId: '1:397483513751:android:bb838799a2cd3f7f1c56d2',
    messagingSenderId: '397483513751',
    projectId: 'messageai-e2e9e',
    storageBucket: 'messageai-e2e9e.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIza...',  // Replace with your iOS API key
    appId: '1:...',     // Replace with your iOS app ID
    messagingSenderId: '...',  // Replace with your sender ID
    projectId: 'your-project-id',  // Replace with your project ID
    storageBucket: 'your-project-id.appspot.com',
    iosBundleId: 'com.example.messageai',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIza...',  // Replace with your macOS API key
    appId: '1:...',     // Replace with your macOS app ID
    messagingSenderId: '...',  // Replace with your sender ID
    projectId: 'your-project-id',  // Replace with your project ID
    storageBucket: 'your-project-id.appspot.com',
    iosBundleId: 'com.example.messageai',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyABa-DcxTR4T4CHlfJuy-7DKG1F_hDRNcg',
    appId: '1:397483513751:web:ba73c764d577f4f51c56d2',
    messagingSenderId: '397483513751',
    projectId: 'messageai-e2e9e',
    authDomain: 'messageai-e2e9e.firebaseapp.com',
    storageBucket: 'messageai-e2e9e.firebasestorage.app',
    measurementId: 'G-C6R3PHYG95',
  );

}
</file>

<file path="frontend/lib/gen/api/api.dart">
// Generated API models and clients
export 'models/message_payload.dart';
export 'models/receipt_payload.dart';
export 'clients/messages_api.dart';
export 'clients/receipts_api.dart';
</file>

<file path="frontend/lib/gen/api/clients/messages_api.dart">
import 'package:dio/dio.dart';
import '../models/message_payload.dart';

/// API client for message operations
class MessagesApi {
  final Dio dio;
  final String baseUrl;

  MessagesApi({
    required this.dio,
    required this.baseUrl,
  });

  /// Send a message to the backend
  /// 
  /// [message] - The message payload to send
  /// 
  /// Returns the response from the server
  Future<Response> send(MessagePayload message) async {
    try {
      final response = await dio.post(
        '$baseUrl/v1/messages.send',
        data: message.toJson(),
      );
      return response;
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Exception _handleDioError(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.receiveTimeout:
      case DioExceptionType.sendTimeout:
        return Exception('Connection timeout: ${e.message}');
      case DioExceptionType.badResponse:
        return Exception(
          'Server error: ${e.response?.statusCode} - ${e.response?.data}',
        );
      case DioExceptionType.cancel:
        return Exception('Request cancelled');
      default:
        return Exception('Network error: ${e.message}');
    }
  }
}
</file>

<file path="frontend/lib/gen/api/clients/receipts_api.dart">
import 'package:dio/dio.dart';
import '../models/receipt_payload.dart';

/// API client for receipt operations
class ReceiptsApi {
  final Dio dio;
  final String baseUrl;

  ReceiptsApi({
    required this.dio,
    required this.baseUrl,
  });

  /// Acknowledge message receipts to the backend
  /// 
  /// [receipt] - The receipt payload to send
  /// 
  /// Returns the response from the server
  Future<Response> ack(ReceiptPayload receipt) async {
    try {
      final response = await dio.post(
        '$baseUrl/v1/receipts.ack',
        data: receipt.toJson(),
      );
      return response;
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Exception _handleDioError(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.receiveTimeout:
      case DioExceptionType.sendTimeout:
        return Exception('Connection timeout: ${e.message}');
      case DioExceptionType.badResponse:
        return Exception(
          'Server error: ${e.response?.statusCode} - ${e.response?.data}',
        );
      case DioExceptionType.cancel:
        return Exception('Request cancelled');
      default:
        return Exception('Network error: ${e.message}');
    }
  }
}
</file>

<file path="frontend/lib/gen/api/models/message_payload.dart">
class MessagePayload {
  final String id;
  final String conversationId;
  final String? body;

  MessagePayload({
    required this.id,
    required this.conversationId,
    this.body,
  });

  factory MessagePayload.fromJson(Map<String, dynamic> json) {
    return MessagePayload(
      id: json['id'] as String,
      conversationId: json['conversation_id'] as String,
      body: json['body'] as String?,
    );
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'conversation_id': conversationId,
        if (body != null) 'body': body,
      };

  @override
  String toString() =>
      'MessagePayload(id: $id, conversationId: $conversationId, body: $body)';
}
</file>

<file path="frontend/lib/gen/api/models/receipt_payload.dart">
enum ReceiptStatus {
  delivered,
  read;

  static ReceiptStatus fromString(String value) {
    return ReceiptStatus.values.firstWhere(
      (e) => e.name == value,
      orElse: () => throw ArgumentError('Unknown status: $value'),
    );
  }

  String toValue() => name;
}

class ReceiptPayload {
  final List<String> messageIds;
  final ReceiptStatus status;

  ReceiptPayload({
    required this.messageIds,
    required this.status,
  });

  factory ReceiptPayload.fromJson(Map<String, dynamic> json) {
    return ReceiptPayload(
      messageIds: List<String>.from(json['message_ids'] as List),
      status: ReceiptStatus.fromString(json['status'] as String),
    );
  }

  Map<String, dynamic> toJson() => {
        'message_ids': messageIds,
        'status': status.toValue(),
      };

  @override
  String toString() =>
      'ReceiptPayload(messageIds: $messageIds, status: ${status.name})';
}
</file>

<file path="frontend/lib/services/auth_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/services/device_registration_service.dart';
import 'package:messageai/services/notification_service.dart';
import 'package:messageai/core/errors/error_handler.dart';

class AuthService {
  static final AuthService _instance = AuthService._internal();

  factory AuthService() {
    return _instance;
  }

  AuthService._internal();

  final _supabase = SupabaseClientProvider.client;
  final _deviceRegistrationService = DeviceRegistrationService();
  final _notificationService = NotificationService();
  final _errorHandler = ErrorHandler();

  /// Sign up with email and password
  Future<AuthResponse> signUp({
    required String email,
    required String password,
  }) async {
    try {
      print('📝 Attempting sign up for: $email');
      
      final response = await _supabase.auth.signUp(
        email: email,
        password: password,
      );
      
      print('✅ Sign up successful: ${response.user?.id}');
      return response;
    } catch (error, stackTrace) {
      print('❌ Sign up failed: $error');
      throw _errorHandler.handleError(error, stackTrace: stackTrace, context: 'Sign Up');
    }
  }

  /// Sign in with email and password
  Future<AuthResponse> signIn({
    required String email,
    required String password,
  }) async {
    try {
      print('🔐 Attempting sign in for: $email');
      
      final response = await _supabase.auth.signInWithPassword(
        email: email,
        password: password,
      );
      
      print('✅ Sign in successful: ${response.user?.id}');
      return response;
    } catch (error, stackTrace) {
      print('❌ Sign in failed: $error');
      throw _errorHandler.handleError(error, stackTrace: stackTrace, context: 'Sign In');
    }
  }

  /// Sign out
  Future<void> signOut() async {
    try {
      print('👋 Attempting sign out');
      
      // Unregister device token before signing out
      final token = await _notificationService.getDeviceToken();
      if (token != null) {
        try {
          await _deviceRegistrationService.unregisterDeviceToken(token);
          print('✅ Device token unregistered on sign out');
        } catch (e) {
          print('⚠️  Failed to unregister device token: $e');
          // Continue with sign out even if unregistration fails
        }
      }
      
      await _supabase.auth.signOut();
      print('✅ Sign out successful');
    } catch (error, stackTrace) {
      print('❌ Sign out failed: $error');
      throw _errorHandler.handleError(error, stackTrace: stackTrace, context: 'Sign Out');
    }
  }

  /// Get current user
  User? getCurrentUser() {
    return _supabase.auth.currentUser;
  }

  /// Check if user is authenticated
  bool isAuthenticated() {
    return _supabase.auth.currentUser != null;
  }

  /// Get current session
  Session? getCurrentSession() {
    return _supabase.auth.currentSession;
  }
}
</file>

<file path="frontend/lib/services/deep_link_handler.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Handles deep linking and navigation from notifications
class DeepLinkHandler {
  final WidgetRef ref;
  final NavigatorState? navigatorState;

  DeepLinkHandler({
    required this.ref,
    this.navigatorState,
  });

  /// Handle notification tap - navigate to conversation
  Future<void> handleNotificationTap(String conversationId) async {
    try {
      // Navigate to conversation detail screen
      navigatorState?.pushNamed(
        '/conversation/$conversationId',
      );
      print('Navigated to conversation: $conversationId');
    } catch (e) {
      print('Error handling notification tap: $e');
    }
  }

  /// Handle initial message (app terminated)
  Future<void> handleInitialMessage(String conversationId) async {
    try {
      // Wait for app to fully initialize
      await Future.delayed(const Duration(milliseconds: 500));
      
      // Navigate to conversation
      navigatorState?.pushNamedAndRemoveUntil(
        '/conversation/$conversationId',
        ModalRoute.withName('/conversations'),
      );
      print('Navigated from initial message to: $conversationId');
    } catch (e) {
      print('Error handling initial message: $e');
    }
  }

  /// Handle background message (app in background)
  Future<void> handleBackgroundMessage(String conversationId) async {
    try {
      // Just navigate normally
      navigatorState?.pushNamed('/conversation/$conversationId');
      print('Navigated from background message to: $conversationId');
    } catch (e) {
      print('Error handling background message: $e');
    }
  }

  /// Parse notification payload to extract conversation ID
  String? extractConversationId(Map<String, dynamic> data) {
    return data['conversation_id'] as String?;
  }

  /// Parse notification payload to extract message metadata
  Map<String, dynamic> extractMessageMetadata(Map<String, dynamic> data) {
    return {
      'conversation_id': data['conversation_id'],
      'sender_id': data['sender_id'],
      'message_id': data['message_id'],
      'sender_name': data['sender_name'],
    };
  }
}

/// Notification route arguments
class NotificationRouteArgs {
  final String conversationId;
  final String? senderId;
  final String? messageId;
  final String? senderName;

  NotificationRouteArgs({
    required this.conversationId,
    this.senderId,
    this.messageId,
    this.senderName,
  });

  factory NotificationRouteArgs.fromPayload(Map<String, dynamic> payload) {
    return NotificationRouteArgs(
      conversationId: payload['conversation_id'] as String,
      senderId: payload['sender_id'] as String?,
      messageId: payload['message_id'] as String?,
      senderName: payload['sender_name'] as String?,
    );
  }
}

/// Generate named route for conversation
String conversationRoute(String conversationId) => '/conversation/$conversationId';

/// Parse conversation ID from route
String? parseConversationIdFromRoute(String route) {
  if (route.startsWith('/conversation/')) {
    return route.replaceFirst('/conversation/', '');
  }
  return null;
}
</file>

<file path="frontend/lib/state/notification_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/services/notification_service.dart';
import 'package:messageai/services/local_notification_service.dart';
import 'package:messageai/services/deep_link_handler.dart';
import 'package:messageai/services/device_registration_service.dart';
import 'package:messageai/app.dart' show navigatorKey;

/// Device token state
final deviceTokenProvider = StateProvider<String?>((ref) {
  return null;
});

/// Notification service provider
final notificationServiceProvider = Provider<NotificationService>((ref) {
  return NotificationService();
});

/// Local notification service provider
final localNotificationServiceProvider = Provider<LocalNotificationService>((ref) {
  return LocalNotificationService();
});

/// Device registration service provider
final deviceRegistrationServiceProvider = Provider<DeviceRegistrationService>((ref) {
  return DeviceRegistrationService();
});

/// Initialize notifications (Firebase + Local)
final initializeNotificationsProvider = FutureProvider<void>((ref) async {
  print('📢 ========================================');
  print('📢 STARTING NOTIFICATION INITIALIZATION');
  print('📢 ========================================');
  
  final fcmService = ref.watch(notificationServiceProvider);
  final localService = ref.watch(localNotificationServiceProvider);
  final deviceRegistrationService = ref.watch(deviceRegistrationServiceProvider);

  print('📱 Initializing local notifications...');
  // Initialize local notifications first
  await localService.initialize();
  print('✅ Local notifications initialized');

  print('🔥 Initializing Firebase Messaging...');
  // Initialize Firebase Messaging
  await fcmService.initialize(
    onMessageReceived: (payload) {
      // Handle foreground message
      _handleForegroundMessage(ref, payload, localService);
    },
    onTokenRefresh: (token) async {
      // Update device token state
      ref.read(deviceTokenProvider.notifier).state = token;
      print('🔄 Device token refreshed: ${token.substring(0, 20)}...');
      
      // Register refreshed token with backend
      try {
        await deviceRegistrationService.registerDeviceToken(token);
        print('✅ Refreshed token registered with backend');
      } catch (e) {
        print('❌ Failed to register refreshed token: $e');
      }
    },
  );

  // Setup notification tap handler
  await fcmService.setupNotificationTapHandler(
    onNotificationTapped: (conversationId) {
      _handleNotificationTap(ref, conversationId);
    },
  );

  // Get initial device token
  final token = await fcmService.getDeviceToken();
  if (token != null) {
    ref.read(deviceTokenProvider.notifier).state = token;
    
    // Register token with backend
    try {
      await deviceRegistrationService.registerDeviceToken(token);
      print('✅ Initial token registered with backend');
    } catch (e) {
      print('❌ Failed to register initial token: $e');
      // Don't fail initialization if registration fails
    }
  }

  print('Notifications initialized successfully');
});

/// Handle foreground notification message
void _handleForegroundMessage(
  Ref ref,
  NotificationPayload payload,
  LocalNotificationService localService,
) async {
  try {
    final conversationId = payload.conversationId;
    final senderName = payload.data['sender_name'] as String? ?? 'New Message';
    final messageBody = payload.messageBody ?? payload.body ?? '';

    if (conversationId != null && messageBody.isNotEmpty) {
      await localService.showMessageNotification(
        conversationId: conversationId,
        senderName: senderName,
        messageBody: messageBody,
      );
    }
  } catch (e) {
    print('Error handling foreground message: $e');
  }
}

/// Handle notification tap
void _handleNotificationTap(Ref ref, String conversationId) {
  print('📱 Notification tapped: $conversationId');
  
  try {
    // Use the global navigator key to navigate
    final navigator = navigatorKey.currentState;
    
    if (navigator == null) {
      print('❌ Navigator not available');
      return;
    }
    
    // Navigate to conversation detail screen
    navigator.pushNamed(
      '/conversation/$conversationId',
      arguments: {'title': 'Conversation'},
    );
    
    print('✅ Navigated to conversation: $conversationId');
  } catch (e) {
    print('❌ Error navigating to conversation: $e');
  }
}

/// Notification permission state
final notificationPermissionProvider = FutureProvider<bool>((ref) async {
  final fcmService = ref.watch(notificationServiceProvider);
  return fcmService.areNotificationsEnabled();
});

/// Subscribe to conversation topic for group notifications
final subscribeToConversationTopicProvider = FutureProvider.autoDispose
    .family<void, String>((ref, conversationId) async {
  final fcmService = ref.watch(notificationServiceProvider);
  await fcmService.subscribeToTopic('conversation_$conversationId');
});

/// Unsubscribe from conversation topic
final unsubscribeFromConversationTopicProvider = FutureProvider.autoDispose
    .family<void, String>((ref, conversationId) async {
  final fcmService = ref.watch(notificationServiceProvider);
  await fcmService.unsubscribeFromTopic('conversation_$conversationId');
});

/// Subscribe to user topic for direct messages
final subscribeToUserTopicProvider = FutureProvider<void>((ref) async {
  final fcmService = ref.watch(notificationServiceProvider);
  // Subscribe to user's personal notification topic
  // (would use current user ID in real app)
  await fcmService.subscribeToTopic('user_direct_messages');
});

/// Notification state for UI
final notificationStateProvider = StateProvider<NotificationState>((ref) {
  return const NotificationState();
});

/// Notification state model
class NotificationState {
  final bool isInitialized;
  final bool hasPermission;
  final String? deviceToken;
  final int unreadCount;
  final List<String> subscribedTopics;

  const NotificationState({
    this.isInitialized = false,
    this.hasPermission = false,
    this.deviceToken,
    this.unreadCount = 0,
    this.subscribedTopics = const [],
  });

  NotificationState copyWith({
    bool? isInitialized,
    bool? hasPermission,
    String? deviceToken,
    int? unreadCount,
    List<String>? subscribedTopics,
  }) {
    return NotificationState(
      isInitialized: isInitialized ?? this.isInitialized,
      hasPermission: hasPermission ?? this.hasPermission,
      deviceToken: deviceToken ?? this.deviceToken,
      unreadCount: unreadCount ?? this.unreadCount,
      subscribedTopics: subscribedTopics ?? this.subscribedTopics,
    );
  }
}

/// Initialize notification system
final notificationInitializerProvider = FutureProvider<void>((ref) async {
  try {
    // Initialize notifications
    await ref.watch(initializeNotificationsProvider.future);

    // Check permissions
    final hasPermission = await ref.watch(notificationPermissionProvider.future);

    // Get device token
    final deviceToken = ref.watch(deviceTokenProvider);

    // Update state
    ref.read(notificationStateProvider.notifier).state =
        ref.read(notificationStateProvider).copyWith(
          isInitialized: true,
          hasPermission: hasPermission,
          deviceToken: deviceToken,
        );

    print('Notification system initialized');
  } catch (e) {
    print('Error initializing notification system: $e');
    rethrow;
  }
});
</file>

<file path="frontend/lib/state/presence_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/providers.dart';

/// User presence status
enum PresenceStatus {
  online,
  away,
  offline,
}

/// User presence information
class UserPresence {
  final String userId;
  final String conversationId;
  final PresenceStatus status;
  final DateTime lastSeen;

  UserPresence({
    required this.userId,
    required this.conversationId,
    required this.status,
    required this.lastSeen,
  });
}

/// Manages user presence for a conversation
class PresenceManager {
  final Ref ref;
  final String conversationId;
  final String userId;
  
  PresenceManager({
    required this.ref,
    required this.conversationId,
    required this.userId,
  });

  /// Join presence channel (user is viewing conversation)
  Future<void> joinPresence() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    // Subscribe to presence channel
    final presence = supabase.channel('presence:$conversationId').onPresenceSync(
      (_) {
        print('Presence synced for $conversationId');
      },
    ).onPresenceChange(
      PresenceAction.sync,
      (_) {
        print('Presence state changed for $conversationId');
      },
    );

    // Subscribe to presence channel
    await presence.subscribe(
      (status, [err]) {
        print('Presence subscription: $status - $err');
      },
      const Duration(seconds: 30), // Increased timeout for mobile networks
    );

    // Track this user's presence
    await presence.track({
      'user_id': userId,
      'status': 'online',
      'last_seen': DateTime.now().toIso8601String(),
    });
  }

  /// Leave presence channel (user is no longer viewing)
  Future<void> leavePresence() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('presence:$conversationId');
    await presence.unsubscribe();
  }

  /// Update user status
  Future<void> updateStatus(PresenceStatus status) async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('presence:$conversationId');
    await presence.track({
      'user_id': userId,
      'status': status.name,
      'last_seen': DateTime.now().toIso8601String(),
    });
  }

  /// Get all users' presence in conversation
  Future<List<UserPresence>> getConversationPresence() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('presence:$conversationId');
    final state = presence.presenceState();
    
    final presences = <UserPresence>[];
    
    for (final entry in state.entries) {
      for (final presence in entry.value) {
        final presenceMap = presence as Map<String, dynamic>;
        presences.add(UserPresence(
          userId: presenceMap['user_id'] as String,
          conversationId: conversationId,
          status: PresenceStatus.values.firstWhere(
            (s) => s.name == (presenceMap['status'] as String),
            orElse: () => PresenceStatus.offline,
          ),
          lastSeen: DateTime.parse(presenceMap['last_seen'] as String),
        ));
      }
    }
    
    return presences;
  }

  /// Check if user is online
  Future<bool> isUserOnline(String otherUserId) async {
    final presences = await getConversationPresence();
    return presences.any((p) =>
        p.userId == otherUserId && p.status == PresenceStatus.online);
  }
}

/// Provider for presence manager
final presenceManagerProvider = Provider.family<PresenceManager, (String, String)>((ref, args) {
  final (conversationId, userId) = args;
  return PresenceManager(
    ref: ref,
    conversationId: conversationId,
    userId: userId,
  );
});

/// Stream of user presence in a conversation
final conversationPresenceProvider =
    StreamProvider.autoDispose.family<List<UserPresence>, String>((ref, conversationId) async* {
  // This would typically subscribe to realtime presence updates
  // For now, we'll yield an empty list
  yield [];
  
  // TODO: Set up realtime presence stream
});

/// Check if a specific user is online
final userOnlineProvider = FutureProvider.autoDispose
    .family<bool, (String, String)>((ref, args) async {
  final (conversationId, userId) = args;
  final manager = ref.watch(presenceManagerProvider((conversationId, userId)));
  return manager.isUserOnline(userId);
});
</file>

<file path="frontend/lib/state/realtime_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/state/database_provider.dart';
import 'package:messageai/state/providers.dart';
import 'package:messageai/state/repository_providers.dart';

/// Manages realtime subscriptions to conversation messages
class RealtimeManager {
  final Ref ref;
  final Map<String, dynamic> _subscriptions = {};

  RealtimeManager({required this.ref});

  /// Subscribe to messages in a conversation
  void subscribeToConversationMessages(String conversationId) {
    final supabase = ref.watch(supabaseClientProvider);
    
    final subscription = supabase
        .channel('public:messages')
        .onPostgresChanges(
          event: PostgresChangeEvent.all,
          schema: 'public',
          table: 'messages',
          filter: PostgresChangeFilter(
            type: FilterType.eq,
            column: 'conversation_id',
            value: conversationId,
          ),
        )
        .subscribe((payload, [ref]) async {
          // Handle new/updated messages
          if (payload.eventType == 'INSERT' || payload.eventType == 'UPDATE') {
            final messageData = payload.newRecord as Map<String, dynamic>;
            final message = Message(
              id: messageData['id'] as String,
              conversationId: messageData['conversation_id'] as String,
              senderId: messageData['sender_id'] as String,
              body: messageData['body'] as String,
              mediaUrl: messageData['media_url'] as String?,
              createdAt: messageData['created_at'] as int,
              updatedAt: messageData['updated_at'] as int,
              isSynced: true,
            );
            
            // Update local DB
            final messageDao = ref.watch(messageDaoProvider);
            await messageDao.insertMessage(message);
          }
        });
    
    _subscriptions[conversationId] = subscription;
  }

  /// Unsubscribe from conversation messages
  Future<void> unsubscribeFromConversation(String conversationId) async {
    final subscription = _subscriptions.remove(conversationId);
    if (subscription != null) {
      await subscription.unsubscribe();
    }
  }

  /// Cleanup all subscriptions
  Future<void> cleanup() async {
    for (final subscription in _subscriptions.values) {
      await subscription.unsubscribe();
    }
    _subscriptions.clear();
  }
}

/// Provider for realtime manager
final realtimeManagerProvider = Provider.autoDispose<RealtimeManager>((ref) {
  return RealtimeManager(ref: ref);
});

/// Subscribe to messages in a conversation
final conversationMessagesRealtimeProvider = 
    FutureProvider.autoDispose.family<void, String>((ref, conversationId) async {
  final manager = ref.watch(realtimeManagerProvider);
  manager.subscribeToConversationMessages(conversationId);
  
  // Cleanup on dispose
  ref.onDispose(() {
    manager.unsubscribeFromConversation(conversationId);
  });
});

/// Watch for realtime message updates in a conversation
final realtimeConversationMessagesProvider = 
    StreamProvider.autoDispose.family<List<Message>, String>((ref, conversationId) async* {
  // Enable realtime subscription
  await ref.watch(conversationMessagesRealtimeProvider(conversationId).future);
  
  // Watch the local messages
  yield* ref.watch(messagesStreamProvider(conversationId));
});
</file>

<file path="frontend/lib/state/repository_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/repositories/message_repository.dart';
import 'package:messageai/data/repositories/receipt_repository.dart';
import 'package:messageai/data/repositories/group_repository.dart';
import 'package:messageai/state/database_provider.dart';
import 'package:messageai/state/providers.dart';

/// Provides the MessageRepository
final messageRepositoryProvider = Provider<MessageRepository>((ref) {
  final messagesApi = ref.watch(messagesApiProvider);
  final messageDao = ref.watch(messageDaoProvider);
  final outboxDao = ref.watch(pendingOutboxDaoProvider);
  
  return MessageRepository(
    messagesApi: messagesApi,
    messageDao: messageDao,
    outboxDao: outboxDao,
  );
});

/// Provides the ReceiptRepository
final receiptRepositoryProvider = Provider<ReceiptRepository>((ref) {
  final receiptsApi = ref.watch(receiptsApiProvider);
  final receiptDao = ref.watch(receiptDaoProvider);
  final outboxDao = ref.watch(pendingOutboxDaoProvider);
  
  return ReceiptRepository(
    receiptsApi: receiptsApi,
    receiptDao: receiptDao,
    outboxDao: outboxDao,
  );
});

/// Provides the GroupRepository
final groupRepositoryProvider = Provider<GroupRepository>((ref) {
  final conversationDao = ref.watch(conversationDaoProvider);
  final participantDao = ref.watch(participantDaoProvider);
  
  return GroupRepository(
    conversationDao: conversationDao,
    participantDao: participantDao,
  );
});

// Add receiptDaoProvider to database_provider.dart if not already there
// final receiptDaoProvider = Provider<ReceiptDao>((ref) {
//   final db = ref.watch(appDbProvider);
//   return ReceiptDao(db);
// });
</file>

<file path="frontend/lib/state/send_queue.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/state/repository_providers.dart';

/// Message to send
class SendableMessage {
  final String id;
  final String conversationId;
  final String senderId;
  final String body;
  final String? mediaUrl;

  SendableMessage({
    required this.id,
    required this.conversationId,
    required this.senderId,
    required this.body,
    this.mediaUrl,
  });
}

/// Manages sending messages with optimistic updates
class SendQueue {
  final Ref ref;
  
  SendQueue({required this.ref});

  /// Send a message
  Future<Message> sendMessage({
    required String conversationId,
    required String senderId,
    required String body,
    String? mediaUrl,
  }) async {
    // Generate unique ID
    const uuid = Uuid();
    final messageId = uuid.v4();
    
    // Get repository
    final messageRepo = ref.watch(messageRepositoryProvider);
    
    // Send optimistically (local first)
    final message = await messageRepo.sendMessage(
      id: messageId,
      conversationId: conversationId,
      senderId: senderId,
      body: body,
      mediaUrl: mediaUrl,
    );
    
    // Queue background sync
    _scheduleSyncIfNeeded();
    
    return message;
  }

  /// Drain the send queue (sync pending messages)
  Future<void> drainQueue() async {
    final messageRepo = ref.watch(messageRepositoryProvider);
    final receiptRepo = ref.watch(receiptRepositoryProvider);
    
    try {
      // Sync messages
      await messageRepo.syncUnsyncedMessages();
      
      // Sync receipts
      await receiptRepo.syncUnsyncedReceipts();
    } catch (e) {
      print('Error draining send queue: $e');
      rethrow;
    }
  }

  /// Schedule sync if there are pending operations
  void _scheduleSyncIfNeeded() {
    // In a real app, this would use a periodic timer or background service
    // For now, we'll just sync immediately for demo purposes
    _syncInBackground();
  }

  /// Sync in background
  void _syncInBackground() {
    // Run sync without awaiting (fire and forget)
    drainQueue().catchError((e) {
      print('Background sync error: $e');
    });
  }

  /// Get pending message count
  Future<int> getPendingCount() async {
    final messageRepo = ref.watch(messageRepositoryProvider);
    return messageRepo.getPendingMessageCount();
  }
}

/// Provider for send queue
final sendQueueProvider = Provider<SendQueue>((ref) {
  return SendQueue(ref: ref);
});

/// State notifier for managing message sends
class SendMessageNotifier extends StateNotifier<AsyncValue<void>> {
  final Ref ref;

  SendMessageNotifier({required this.ref}) : super(const AsyncValue.data(null));

  /// Send a message
  Future<Message> sendMessage({
    required String conversationId,
    required String senderId,
    required String body,
    String? mediaUrl,
  }) async {
    state = const AsyncValue.loading();
    
    try {
      final sendQueue = ref.watch(sendQueueProvider);
      final message = await sendQueue.sendMessage(
        conversationId: conversationId,
        senderId: senderId,
        body: body,
        mediaUrl: mediaUrl,
      );
      
      state = const AsyncValue.data(null);
      return message;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }

  /// Retry pending messages
  Future<void> retryPending() async {
    state = const AsyncValue.loading();
    
    try {
      final sendQueue = ref.watch(sendQueueProvider);
      await sendQueue.drainQueue();
      state = const AsyncValue.data(null);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }
}

/// State notifier provider for sending messages
final sendMessageNotifierProvider = 
    StateNotifierProvider<SendMessageNotifier, AsyncValue<void>>((ref) {
  return SendMessageNotifier(ref: ref);
});

/// Get pending message count
final pendingMessageCountProvider = FutureProvider<int>((ref) async {
  final sendQueue = ref.watch(sendQueueProvider);
  return sendQueue.getPendingCount();
});
</file>

<file path="frontend/lib/state/typing_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/providers.dart';

/// User typing information
class TypingUser {
  final String userId;
  final DateTime startedAt;
  final Duration timeout;

  TypingUser({
    required this.userId,
    required this.startedAt,
    this.timeout = const Duration(seconds: 3),
  });

  /// Check if typing indicator has expired
  bool get isExpired {
    return DateTime.now().difference(startedAt) > timeout;
  }
}

/// Manages typing indicators for a conversation
class TypingManager {
  final Ref ref;
  final String conversationId;
  final String userId;
  
  final Map<String, TypingUser> _typingUsers = {};
  static const Duration _debounceDelay = Duration(milliseconds: 300);
  DateTime? _lastTypingSent;

  TypingManager({
    required this.ref,
    required this.conversationId,
    required this.userId,
  });

  /// Broadcast that user is typing
  Future<void> sendTypingIndicator() async {
    final now = DateTime.now();
    
    // Debounce: only send every 300ms
    if (_lastTypingSent != null &&
        now.difference(_lastTypingSent!) < _debounceDelay) {
      return;
    }
    
    _lastTypingSent = now;
    
    final supabase = ref.watch(supabaseClientProvider);
    
    // Send typing indicator through presence
    final presence = supabase.channel('typing:$conversationId');
    
    try {
      await presence.subscribe(
        (status, [err]) {
          print('Typing subscription: $status - $err');
        },
        const Duration(seconds: 30), // Increased timeout for mobile networks
      );
      
      await presence.track({
        'user_id': userId,
        'typing': true,
        'timestamp': now.toIso8601String(),
      });
    } catch (e) {
      print('Error sending typing indicator: $e');
    }
  }

  /// Stop broadcasting typing
  Future<void> stopTypingIndicator() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('typing:$conversationId');
    
    try {
      await presence.track({
        'user_id': userId,
        'typing': false,
      });
      
      await presence.unsubscribe();
    } catch (e) {
      print('Error stopping typing indicator: $e');
    }
  }

  /// Add a typing user (received from server)
  void addTypingUser(String otherUserId) {
    _typingUsers[otherUserId] = TypingUser(userId: otherUserId, startedAt: DateTime.now());
  }

  /// Remove a typing user
  void removeTypingUser(String otherUserId) {
    _typingUsers.remove(otherUserId);
  }

  /// Get list of currently typing users (excluding expired ones)
  List<TypingUser> getTypingUsers() {
    // Remove expired entries
    _typingUsers.removeWhere((_, user) => user.isExpired);
    return _typingUsers.values.toList();
  }

  /// Get typing users display text
  String getTypingText() {
    final typingUsers = getTypingUsers();
    
    if (typingUsers.isEmpty) return '';
    if (typingUsers.length == 1) return '${typingUsers.first.userId} is typing...';
    if (typingUsers.length == 2) {
      return '${typingUsers[0].userId} and ${typingUsers[1].userId} are typing...';
    }
    
    return '${typingUsers.length} people are typing...';
  }

  /// Check if anyone is typing
  bool get anyoneTyping => getTypingUsers().isNotEmpty;
}

/// Provider for typing manager
final typingManagerProvider =
    Provider.family<TypingManager, (String, String)>((ref, args) {
  final (conversationId, userId) = args;
  return TypingManager(
    ref: ref,
    conversationId: conversationId,
    userId: userId,
  );
});

/// Stream of typing users in a conversation
final conversationTypingProvider = StreamProvider.autoDispose
    .family<List<TypingUser>, String>((ref, conversationId) async* {
  // This would typically subscribe to realtime typing updates
  // For now, we'll yield an empty list
  yield [];
  
  // TODO: Set up realtime typing stream
});

/// Get typing status text for display
final typingStatusTextProvider = StreamProvider.autoDispose
    .family<String, String>((ref, conversationId) async* {
  yield* ref.watch(conversationTypingProvider(conversationId)).when(
        data: (typingUsers) async* {
          if (typingUsers.isEmpty) {
            yield '';
          } else if (typingUsers.length == 1) {
            yield '${typingUsers.first.userId} is typing...';
          } else {
            yield '${typingUsers.length} people are typing...';
          }
        },
        loading: () async* {
          yield '';
        },
        error: (err, st) async* {
          yield '';
        },
      );
});
</file>

<file path="frontend/Makefile">
contracts/gen: ; npm --prefix ../contracts run gen:dart
fmt: ; dart format .
dev: ; flutter run --dart-define-from-file=.env.dev.json
test: ; flutter test
</file>

<file path="frontend/test/offline_queue_test.dart">
import 'package:flutter_test/flutter_test.dart';

/// Placeholder test for offline queue functionality
/// Full implementation requires database mocking setup
void main() {
  group('Offline Message Queue', () {
    test('Offline queue service exists', () {
      // Basic test to ensure the test file compiles
      expect(true, isTrue);
    });

    test('Network connectivity service can be instantiated', () {
      // Placeholder test
      expect(1 + 1, equals(2));
    });

    test('Retry service handles exponential backoff', () {
      // Placeholder test
      expect(true, isTrue);
    });
  });

  group('Message Syncing', () {
    test('Messages can be queued', () {
      // Placeholder test
      expect(true, isTrue);
    });

    test('Messages can be synced when online', () {
      // Placeholder test
      expect(true, isTrue);
    });
  });
}
</file>

<file path="frontend/test/realtime_diagnostic_test.dart">
import 'package:flutter_test/flutter_test.dart';

/// Placeholder test for realtime diagnostic functionality
void main() {
  group('Realtime Diagnostics', () {
    test('Realtime diagnostic service exists', () {
      // Basic test to ensure the test file compiles
      expect(true, isTrue);
    });

    test('Channel diagnostics can be tracked', () {
      // Placeholder test
      expect(1 + 1, equals(2));
    });

    test('Health checks can be performed', () {
      // Placeholder test  
      expect(true, isTrue);
    });
  });

  group('Connection Testing', () {
    test('Connection test can be executed', () {
      // Placeholder test
      expect(true, isTrue);
    });

    test('Latency can be measured', () {
      // Placeholder test
      expect(true, isTrue);
    });
  });
}
</file>

<file path="frontend/test/widget_test.dart">
// Basic Flutter widget test for MessageAI app

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/app.dart';

void main() {
  testWidgets('MessageAI app loads', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(
      const ProviderScope(
        child: MessageAIApp(),
      ),
    );

    // Verify app loads without errors
    expect(find.byType(MaterialApp), findsOneWidget);
  });
}
</file>

<file path="frontend/web/index.html">
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="messageai">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>messageai</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>
</file>

<file path="frontend/web/manifest.json">
{
    "name": "messageai",
    "short_name": "messageai",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}
</file>

<file path="frontend/windows/.gitignore">
flutter/ephemeral/

# Visual Studio user-specific files.
*.suo
*.user
*.userosscache
*.sln.docstates

# Visual Studio build-related files.
x64/
x86/

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/
</file>

<file path="frontend/windows/CMakeLists.txt">
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(messageai LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "messageai")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)
</file>

<file path="frontend/windows/flutter/CMakeLists.txt">
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)
</file>

<file path="frontend/windows/runner/CMakeLists.txt">
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)
</file>

<file path="frontend/windows/runner/flutter_window.cpp">
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}
</file>

<file path="frontend/windows/runner/flutter_window.h">
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_
</file>

<file path="frontend/windows/runner/main.cpp">
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"messageai", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}
</file>

<file path="frontend/windows/runner/resource.h">
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
</file>

<file path="frontend/windows/runner/runner.exe.manifest">
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>
</file>

<file path="frontend/windows/runner/Runner.rc">
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "com.example" "\0"
            VALUE "FileDescription", "messageai" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "messageai" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2025 com.example. All rights reserved." "\0"
            VALUE "OriginalFilename", "messageai.exe" "\0"
            VALUE "ProductName", "messageai" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
</file>

<file path="frontend/windows/runner/utils.cpp">
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}
</file>

<file path="frontend/windows/runner/utils.h">
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_
</file>

<file path="frontend/windows/runner/win32_window.cpp">
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}
</file>

<file path="frontend/windows/runner/win32_window.h">
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_
</file>

<file path="package.json">
{
  "dependencies": {
    "supabase": "^2.51.0"
  }
}
</file>

<file path="README.md">
# MessageAI

A modern, cross-platform messaging application built with Flutter and Supabase, featuring real-time messaging, typing indicators, image sharing, and offline support.

## ✨ Features

- 🔐 **Secure Authentication** - Email/password authentication with Supabase
- 💬 **Real-time Messaging** - Instant message delivery with Supabase Realtime
- ⌨️ **Typing Indicators** - See when others are typing with animated indicators
- 📷 **Image Sharing** - Upload and share images in conversations
- 👤 **Profile Pictures** - Custom avatar support with image upload
- 📧 **Add by Email** - Add participants to conversations using email addresses
- 📱 **Offline Support** - Queue messages when offline, auto-sync when back online
- 🎨 **Modern UI** - Burnt orange theme 
- 📖 **Message Previews** - See the last message in each conversation
- ✓ **Read Receipts** - Track message delivery and read status

## 📋 Prerequisites

Before you begin, ensure you have the following installed:

### Required Software

1. **Flutter SDK** (3.10.0 or higher)
   - [Download Flutter](https://docs.flutter.dev/get-started/install)
   - Verify installation: `flutter doctor`

2. **Android Studio** (for Android development)
   - [Download Android Studio](https://developer.android.com/studio)
   - Install Android SDK and emulator

3. **Xcode** (for iOS development - macOS only)
   - Install from Mac App Store
   - Run: `sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer`

4. **Git**
   - [Download Git](https://git-scm.com/downloads)

5. **Node.js** (16.x or higher) - for backend
   - [Download Node.js](https://nodejs.org/)

6. **Supabase CLI** (optional, for local development)
   - Install: `npm install -g supabase`

## 🚀 Getting Started

### Step 1: Clone the Repository

```bash
git clone https://github.com/yourusername/MessageAI.git
cd MessageAI
```

### Step 2: Set Up the Backend

#### Option A: Use Supabase Cloud (Recommended for Quick Start)

Create .env in backend folder and add 
   - Project URL (e.g., `https://abcdefghijk.supabase.co`)
   - `anon/public` API key



### Step 3: Configure the Frontend

1. Navigate to the frontend directory:
   ```bash
   cd frontend
   ```

2. Create a configuration file:
   ```bash
   # Create .env.dev.json in the frontend directory
   cat > .env.dev.json << EOF
   {
     "SUPABASE_URL": "https://your-project-id.supabase.co",
     "SUPABASE_ANON_KEY": "your-anon-key-here"
   }
   EOF
   ```

3. Replace the placeholder values with your actual Supabase credentials

4. Install Flutter dependencies:
   ```bash
   flutter pub get
   ```

## 📱 Running the App

### Android Emulator Setup

1. **Open Android Studio**
2. Go to **Tools** → **Device Manager**
3. Click **Create Device**
4. Select a device (e.g., Pixel 7) and click **Next**
5. Select a system image (e.g., Android 13) and click **Next**
6. Click **Finish** to create the emulator
7. Click the **Play** button to start the emulator

### iOS Simulator Setup (macOS only)

1. **Open Xcode**
2. Go to **Xcode** → **Open Developer Tool** → **Simulator**
3. The simulator will launch with a default device

### Run the App

1. **Check available devices:**
   ```bash
   flutter devices
   ```

2. **Run the app:**

   **Option A: Without configuration file** (if you hardcoded credentials)
   ```bash
   flutter run
   ```

   **Option B: With configuration file** (recommended)
   ```bash
   flutter run --dart-define-from-file=.env.dev.json
   ```

   **Option C: On a specific device**
   ```bash
   flutter run -d <device-id> --dart-define-from-file=.env.dev.json
   ```

3. **Hot Reload during development:**
   - Press `r` in the terminal to hot reload
   - Press `R` to hot restart
   - Press `q` to quit

### Build for Production

**Android APK:**
```bash
flutter build apk --release --dart-define-from-file=.env.dev.json
# Output: build/app/outputs/flutter-apk/app-release.apk
```

**Android App Bundle:**
```bash
flutter build appbundle --release --dart-define-from-file=.env.dev.json
# Output: build/app/outputs/bundle/release/app-release.aab
```

**iOS (macOS only):**
```bash
cd ios
pod install
cd ..
flutter build ios --release --dart-define-from-file=.env.dev.json
```

## 🔧 Troubleshooting

### Common Issues

#### 1. "SUPABASE_URL not configured" Error

**Solution:** Make sure you created `.env.dev.json` with your Supabase credentials and run with:
```bash
flutter run --dart-define-from-file=.env.dev.json
```

#### 2. Flutter Doctor Issues

**Run:**
```bash
flutter doctor
```

Follow the instructions to fix any issues (Android licenses, Xcode setup, etc.)

#### 3. Android License Not Accepted

**Run:**
```bash
flutter doctor --android-licenses
```
Accept all licenses when prompted.

#### 4. Gradle Build Errors

**Solution:**
```bash
cd android
./gradlew clean
cd ..
flutter clean
flutter pub get
```

#### 5. iOS Pod Installation Errors

**Solution:**
```bash
cd ios
pod deintegrate
pod install
cd ..
```

#### 6. Image Picker Not Working

Make sure you have the required permissions in:
- **Android:** `android/app/src/main/AndroidManifest.xml`
- **iOS:** `ios/Runner/Info.plist`

#### 7. Emulator Not Detected

**Android:**
```bash
# List Android Virtual Devices
emulator -list-avds

# Start a specific AVD
emulator -avd <avd-name>
```

**iOS:**
```bash
# List simulators
xcrun simctl list devices

# Boot a simulator
xcrun simctl boot <device-id>
```

## 🏗️ Project Structure

```
MessageAI/
├── backend/
│   ├── supabase/
│   │   ├── functions/         # Edge Functions
│   │   ├── migrations/        # Database migrations
│   │   ├── policies/          # RLS policies
│   │   └── storage/           # Storage bucket configs
│   └── package.json
├── frontend/
│   ├── lib/
│   │   ├── core/              # Core configurations
│   │   ├── data/              # Data layer (Drift, repos)
│   │   ├── features/          # Feature modules
│   │   ├── services/          # Business logic services
│   │   ├── state/             # State management
│   │   ├── app.dart           # Main app widget
│   │   └── main.dart          # Entry point
│   ├── android/               # Android platform code
│   ├── ios/                   # iOS platform code
│   └── pubspec.yaml           # Flutter dependencies
├── .gitignore
└── README.md
```

## 🛠️ Tech Stack

### Frontend
- **Flutter** - Cross-platform UI framework
- **Riverpod** - State management
- **Drift** - Local SQLite database
- **Supabase Flutter** - Backend client
- **Image Picker** - Image selection

### Backend
- **Supabase** - Backend as a Service
  - PostgreSQL database
  - Real-time subscriptions
  - Authentication
  - Storage
  - Edge Functions (Deno)

## 📝 Environment Variables

Create `.env.dev.json` in the `frontend` directory:

```json
{
  "SUPABASE_URL": "https://your-project-id.supabase.co",
  "SUPABASE_ANON_KEY": "your-anon-key-here"
}
```

For production, create `.env.prod.json` with production credentials.

## 🧪 Testing

### Run Tests
```bash
cd frontend
flutter test
```

### Run Specific Test
```bash
flutter test test/offline_queue_test.dart
```

### Test Offline Message Queueing

See `frontend/OFFLINE_QUEUE_TEST.md` for detailed testing instructions.

## 📚 Additional Documentation

- **Architecture**: See `docs/Architecture.puml`
- **ERD**: See `docs/ERD.puml`
- **Offline Queueing**: See `frontend/OFFLINE_QUEUE_TEST.md`
- **API Contracts**: See `contracts/openapi.yaml`

## 🤝 Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## 📄 License

This project is licensed under the MIT License - see the LICENSE file for details.

## 🆘 Support

If you encounter any issues:

1. Check the [Troubleshooting](#-troubleshooting) section
2. Review closed issues on GitHub
3. Open a new issue with:
   - Your environment details (`flutter doctor -v`)
   - Steps to reproduce
   - Error messages/screenshots

## 🎨 Color Scheme

- **Primary**: Burnt orange with transparency (`#C77506` at 60% opacity)
- **Secondary**: Same burnt orange
- **Accent**: Slate grey (`#475569`)
- **Background**: Adaptive (light/dark mode)

## 🔮 Roadmap

- [ ] Voice messages
- [ ] Video calls
- [ ] End-to-end encryption
- [ ] Message reactions
- [ ] Group admin controls
- [ ] Message search
- [ ] File sharing (PDFs, documents)
- [ ] Location sharing
- [ ] Desktop apps (Windows, macOS, Linux)

## 👥 Authors

- Your Name - Initial work

## 🙏 Acknowledgments

- Flutter team for the amazing framework
- Supabase for the backend infrastructure
- Community contributors

---

Made with ❤️ using Flutter and Supabase
</file>

<file path="backend/Makefile">
.PHONY: db/start db/migrate db/test funcs/dev contracts/validate contracts/gen

db/start:
	npx supabase start

db/migrate:
	npx supabase db reset

db/test:
	pg_prove supabase/db/test/*.sql

funcs/dev:
	npx supabase functions serve --env-file backend/.env

contracts/validate:
	npm --prefix ../contracts ci && npm --prefix ../contracts run validate

contracts/gen:
	npm --prefix ../contracts run gen:dart
</file>

<file path="backend/package.json">
{
  "name": "messageai-backend",
  "version": "1.0.0",
  "description": "MessageAI Backend Diagnostic Tests",
  "scripts": {
    "test": "node test_diagnostics.js"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.39.0",
    "dotenv": "^16.3.1",
    "uuid": "^13.0.0"
  }
}
</file>

<file path="backend/supabase/config.toml">
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "backend"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false
# Paths to self-signed certificate pair.
# cert_path = "../certs/my-cert.pem"
# key_path = "../certs/my-key.pem"

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 17

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# If disabled, migrations will be skipped during a db push or reset.
enabled = true
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[db.network_restrictions]
# Enable management of network restrictions.
enabled = false
# List of IPv4 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv4 connections. Set empty array to block all IPs.
allowed_cidrs = ["0.0.0.0/0"]
# List of IPv6 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv6 connections. Set empty array to block all IPs.
allowed_cidrs_v6 = ["::/0"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# Path to JWT signing key. DO NOT commit your signing keys file to git.
# signing_keys_path = "./signing_keys.json"
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30
# Number of Web3 logins that can be made in a 5 minute interval per IP address.
web3 = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a new user is created and allows developers to reject the request based on the incoming user object.
# [auth.hook.before_user_created]
# enabled = true
# uri = "pg-functions://postgres/auth/before-user-created-hook"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false
# If enabled, it will allow the user to successfully authenticate when the provider does not return an email address.
email_optional = false

# Allow Solana wallet holders to sign in to your project via the Sign in with Solana (SIWS, EIP-4361) standard.
# You can configure "web3" rate limit in the [auth.rate_limit] section and set up [auth.captcha] if self-hosting.
[auth.web3.solana]
enabled = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

# OAuth server configuration
[auth.oauth_server]
# Enable OAuth server functionality
enabled = false
# Path for OAuth consent flow UI
authorization_url_path = "/oauth/consent"
# Allow dynamic client registration
allow_dynamic_registration = false

[edge_runtime]
enabled = true
# Supported request policies: `oneshot`, `per_worker`.
# `per_worker` (default) — enables hot reload during local development.
# `oneshot` — fallback mode if hot reload causes issues (e.g. in large repos or with symlinks).
policy = "per_worker"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 2

[edge_runtime.secrets]
OPENAI_API_KEY = "env(OPENAI_API_KEY)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"
</file>

<file path="contracts/events/message_inserted.schema.json">
{
  "$id": "message_inserted.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Message Inserted Event",
  "description": "Event emitted when a new message is inserted into a conversation (via database trigger)",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Unique message identifier"
    },
    "conversation_id": {
      "type": "string",
      "format": "uuid",
      "description": "ID of the conversation this message belongs to"
    },
    "sender_id": {
      "type": "string",
      "format": "uuid",
      "description": "ID of the user who sent this message"
    },
    "body": {
      "type": "string",
      "description": "Message text content",
      "minLength": 1
    },
    "media_url": {
      "type": ["string", "null"],
      "format": "uri",
      "description": "Optional URL to attached media (image, video, file)"
    },
    "created_at": {
      "type": "string",
      "format": "date-time",
      "description": "ISO 8601 timestamp when the message was created"
    },
    "updated_at": {
      "type": "string",
      "format": "date-time",
      "description": "ISO 8601 timestamp of last update"
    }
  },
  "required": [
    "id",
    "conversation_id",
    "sender_id",
    "body",
    "created_at"
  ],
  "additionalProperties": false
}
</file>

<file path="contracts/events/receipt_inserted.schema.json">
{
  "$id": "receipt_inserted.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Receipt Inserted Event",
  "description": "Event emitted when a message receipt (read/delivered status) is recorded (via database trigger)",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Unique receipt identifier"
    },
    "message_id": {
      "type": "string",
      "format": "uuid",
      "description": "ID of the message this receipt is for"
    },
    "user_id": {
      "type": "string",
      "format": "uuid",
      "description": "ID of the user who received/read the message"
    },
    "status": {
      "type": "string",
      "enum": [
        "delivered",
        "read"
      ],
      "description": "Receipt status: 'delivered' = message received, 'read' = message read by user"
    },
    "at": {
      "type": "string",
      "format": "date-time",
      "description": "ISO 8601 timestamp when the receipt was recorded"
    }
  },
  "required": [
    "id",
    "message_id",
    "user_id",
    "status",
    "at"
  ],
  "additionalProperties": false
}
</file>

<file path="contracts/scripts/generate_dart.sh">
#!/usr/bin/env bash
set -e
npm --prefix contracts run validate
npm --prefix contracts run gen:dart
echo "Generated Dart client to /frontend/lib/gen/api"
</file>

<file path="frontend/lib/data/drift/app_db.dart">
import 'package:drift/drift.dart';
import 'package:drift_flutter/drift_flutter.dart';
import 'package:messageai/data/drift/daos/conversation_dao.dart';
import 'package:messageai/data/drift/daos/message_dao.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/drift/daos/participant_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';
// AI Analysis DAO commented out (using remote-only approach)
// Uncomment and restore from backup files when scaling to local cache
// import 'package:messageai/data/drift/daos/ai_analysis_dao.dart';

part 'app_db.g.dart';

// Table definitions
class Conversations extends Table {
  TextColumn get id => text()();
  TextColumn get title => text()();
  TextColumn get description => text().nullable()();
  IntColumn get createdAt => integer()(); // Unix timestamp
  IntColumn get updatedAt => integer()();
  BoolColumn get isGroup => boolean().withDefault(const Constant(false))();
  IntColumn get lastMessageAt => integer().nullable()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};
}

class Messages extends Table {
  TextColumn get id => text()();
  TextColumn get conversationId => text()();
  TextColumn get senderId => text()();
  TextColumn get body => text()();
  TextColumn get mediaUrl => text().nullable()();
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    {conversationId, id}
  ];
}

class Participants extends Table {
  TextColumn get id => text()();
  TextColumn get conversationId => text()();
  TextColumn get userId => text()();
  IntColumn get joinedAt => integer()();
  BoolColumn get isAdmin => boolean().withDefault(const Constant(false))();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    {conversationId, userId}
  ];
}

class Receipts extends Table {
  TextColumn get id => text()();
  TextColumn get messageId => text()();
  TextColumn get userId => text()();
  TextColumn get status => text()(); // 'delivered', 'read'
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    {messageId, userId}
  ];
}

class PendingOutbox extends Table {
  TextColumn get id => text()();
  TextColumn get operation => text()(); // 'send_message', 'ack_receipt'
  TextColumn get payload => text()(); // JSON serialized
  TextColumn get conversationId => text().nullable()();
  IntColumn get createdAt => integer()();
  IntColumn get retryCount => integer().withDefault(const Constant(0))();
  TextColumn get lastError => text().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

// AI Analysis table commented out for now (using remote-only approach)
// Uncomment and restore from backup files when scaling to local cache
/*
class AiAnalysis extends Table {
  TextColumn get id => text()();
  TextColumn get messageId => text()();
  TextColumn get tone => text()();
  TextColumn get urgencyLevel => text().nullable()();
  TextColumn get intent => text().nullable()();
  RealColumn get confidenceScore => real().nullable()();
  IntColumn get analysisTimestamp => integer()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();

  @override
  Set<Column> get primaryKey => {id};
}
*/

// Main database class
// Note: AiAnalysis table and AIAnalysisDao commented out (using remote-only approach)
@DriftDatabase(
  tables: [Conversations, Messages, Participants, Receipts, PendingOutbox],
  daos: [ConversationDao, MessageDao, ReceiptDao, ParticipantDao, PendingOutboxDao],
)
class AppDb extends _$AppDb {
  AppDb() : super(_openConnection());

  @override
  int get schemaVersion => 1; // Reverted to 1 (AI table removed)

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) async {
        await m.createAll();
      },
      onUpgrade: (Migrator m, int from, int to) async {
        // AI Analysis migration commented out (using remote-only approach)
        // if (from == 1 && to == 2) {
        //   await m.createTable(aiAnalysis);
        // }
      },
    );
  }

  /// Get the singleton instance of the database
  static AppDb? _instance;

  static AppDb get instance => _instance ??= AppDb();

  /// Close the database connection
  Future<void> close() async {
    await super.close();
    _instance = null;
  }
}

// Connection logic
QueryExecutor _openConnection() {
  return driftDatabase(
    name: 'messageai_db',
  );
}
</file>

<file path="frontend/lib/data/drift/daos/conversation_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'conversation_dao.g.dart';

@DriftAccessor(tables: [Conversations])
class ConversationDao extends DatabaseAccessor<AppDb> with _$ConversationDaoMixin {
  ConversationDao(AppDb db) : super(db);

  /// Get all conversations ordered by last message
  Future<List<Conversation>> getAllConversations() async {
    final query = select(conversations)
      ..orderBy([(c) => OrderingTerm(expression: c.lastMessageAt, mode: OrderingMode.desc)]);
    return query.get();
  }

  /// Get conversation by ID
  Future<Conversation?> getConversationById(String id) async {
    return (select(conversations)..where((c) => c.id.equals(id)))
        .getSingleOrNull();
  }

  /// Insert or update conversation
  Future<void> upsertConversation(Conversation conversation) async {
    await into(conversations).insert(
      conversation,
      onConflict: DoUpdate((_) => conversation),
    );
  }

  /// Batch insert conversations
  Future<void> insertConversations(List<Conversation> convs) async {
    await batch((batch) {
      batch.insertAll(conversations, convs, mode: InsertMode.insertOrReplace);
    });
  }

  /// Delete conversation by ID
  Future<int> deleteConversation(String id) async {
    return (delete(conversations)..where((c) => c.id.equals(id))).go();
  }

  /// Update conversation sync status
  Future<void> markConversationAsSynced(String id) async {
    await (update(conversations)..where((c) => c.id.equals(id)))
        .write(const ConversationsCompanion(isSynced: Value(true)));
  }

  /// Get unsynced conversations
  Future<List<Conversation>> getUnsyncedConversations() async {
    return (select(conversations)..where((c) => c.isSynced.equals(false)))
        .get();
  }

  /// Update last message time
  Future<void> updateLastMessageTime(String conversationId) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    await (update(conversations)..where((c) => c.id.equals(conversationId)))
        .write(ConversationsCompanion(
          updatedAt: Value(now),
          lastMessageAt: Value(now),
        ));
  }

  /// Get recent conversations (for list)
  Future<List<Conversation>> getRecentConversations({int limit = 20}) async {
    return (select(conversations)
          ..orderBy([(c) => OrderingTerm(expression: c.lastMessageAt, mode: OrderingMode.desc)])
          ..limit(limit))
        .get();
  }

  /// Count total conversations
  Future<int> getConversationCount() async {
    final result = await select(conversations).get();
    return result.length;
  }
}
</file>

<file path="frontend/lib/data/drift/daos/pending_outbox_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'pending_outbox_dao.g.dart';

@DriftAccessor(tables: [PendingOutbox])
class PendingOutboxDao extends DatabaseAccessor<AppDb> with _$PendingOutboxDaoMixin {
  PendingOutboxDao(AppDb db) : super(db);

  /// Get all pending operations
  Future<List<PendingOutboxData>> getAllPendingOperations() async {
    return (select(pendingOutbox)
          ..orderBy([(p) => OrderingTerm(expression: p.createdAt)]))
        .get();
  }

  /// Get pending operations for a specific conversation
  Future<List<PendingOutboxData>> getPendingOperationsByConversation(String conversationId) async {
    return (select(pendingOutbox)
          ..where((p) => p.conversationId.equals(conversationId))
          ..orderBy([(p) => OrderingTerm(expression: p.createdAt)]))
        .get();
  }

  /// Add operation to pending outbox
  Future<void> addPendingOperation({
    required String id,
    required String operation,
    required String payload,
    required String? conversationId,
  }) async {
    await into(pendingOutbox).insert(PendingOutboxCompanion(
      id: Value(id),
      operation: Value(operation),
      payload: Value(payload),
      conversationId: Value(conversationId),
      createdAt: Value(DateTime.now().millisecondsSinceEpoch ~/ 1000),
      retryCount: const Value(0),
    ));
  }

  /// Remove operation from pending outbox (after successful sync)
  Future<int> removePendingOperation(String id) async {
    return (delete(pendingOutbox)..where((p) => p.id.equals(id))).go();
  }

  /// Batch remove multiple operations
  Future<int> removePendingOperations(List<String> ids) async {
    return (delete(pendingOutbox)..where((p) => p.id.isIn(ids))).go();
  }

  /// Update retry count and last error
  Future<void> updateRetryInfo(String id, int retryCount, String? lastError) async {
    await (update(pendingOutbox)..where((p) => p.id.equals(id)))
        .write(PendingOutboxCompanion(
          retryCount: Value(retryCount),
          lastError: Value(lastError),
        ));
  }

  /// Get retryable operations (with retry count < max retries)
  Future<List<PendingOutboxData>> getRetryableOperations({int maxRetries = 3}) async {
    return (select(pendingOutbox)
          ..where((p) => p.retryCount.isSmallerThanValue(maxRetries)))
        .get();
  }

  /// Get oldest pending operation
  Future<PendingOutboxData?> getOldestPendingOperation() async {
    return (select(pendingOutbox)
          ..orderBy([(p) => OrderingTerm(expression: p.createdAt)])
          ..limit(1))
        .getSingleOrNull();
  }

  /// Get pending operations by type
  Future<List<PendingOutboxData>> getPendingOperationsByType(String operationType) async {
    return (select(pendingOutbox)
          ..where((p) => p.operation.equals(operationType)))
        .get();
  }

  /// Clean up old pending operations (older than cutoffTime)
  Future<int> cleanupOldOperations(int cutoffTime) async {
    return (delete(pendingOutbox)..where((p) => p.createdAt.isSmallerThanValue(cutoffTime))).go();
  }

  /// Get pending operations count
  Future<int> getPendingOperationCount() async {
    final result = await select(pendingOutbox).get();
    return result.length;
  }
}
</file>

<file path="frontend/lib/data/drift/daos/receipt_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'receipt_dao.g.dart';

@DriftAccessor(tables: [Receipts, Messages])
class ReceiptDao extends DatabaseAccessor<AppDb> with _$ReceiptDaoMixin {
  ReceiptDao(AppDb db) : super(db);

  /// Get all receipts for a message
  Future<List<Receipt>> getReceiptsByMessage(String messageId) async {
    return (select(receipts)
          ..where((r) => r.messageId.equals(messageId)))
        .get();
  }

  /// Get receipt by ID
  Future<Receipt?> getReceiptById(String id) async {
    return (select(receipts)..where((r) => r.id.equals(id)))
        .getSingleOrNull();
  }

  /// Get receipt by message ID and user ID
  Future<Receipt?> getReceipt(String messageId, String userId) async {
    return (select(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.userId.equals(userId)))
        .getSingleOrNull();
  }

  /// Add receipt
  Future<void> addReceipt(Receipt receipt) async {
    await into(receipts).insert(receipt);
  }

  /// Batch add receipts
  Future<void> addReceipts(List<Receipt> recs) async {
    await batch((batch) {
      batch.insertAll(receipts, recs, mode: InsertMode.insertOrReplace);
    });
  }

  /// Update receipt status
  Future<void> updateReceiptStatus(String messageId, String userId, String status) async {
    await (update(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.userId.equals(userId)))
        .write(ReceiptsCompanion(
          status: Value(status),
          updatedAt: Value(DateTime.now().millisecondsSinceEpoch ~/ 1000),
        ));
  }

  /// Mark receipt as synced
  Future<void> markReceiptAsSynced(String id) async {
    await (update(receipts)..where((r) => r.id.equals(id)))
        .write(const ReceiptsCompanion(isSynced: Value(true)));
  }

  /// Mark multiple receipts as synced
  Future<void> markReceiptsAsSynced(List<String> ids) async {
    await batch((batch) {
      for (final id in ids) {
        batch.update(receipts, const ReceiptsCompanion(isSynced: Value(true)),
            where: (r) => r.id.equals(id));
      }
    });
  }

  /// Delete receipt
  Future<int> deleteReceipt(String id) async {
    return (delete(receipts)..where((r) => r.id.equals(id))).go();
  }

  /// Get unsynced receipts
  Future<List<Receipt>> getUnsyncedReceipts() async {
    return (select(receipts)..where((r) => r.isSynced.equals(false)))
        .get();
  }

  /// Get read count for a message
  Future<int> getReadCount(String messageId) async {
    final countResult = await (select(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.status.equals('read')))
        .get();
    return countResult.length;
  }

  /// Get delivered count for a message
  Future<int> getDeliveredCount(String messageId) async {
    final countResult = await (select(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.status.equals('delivered')))
        .get();
    return countResult.length;
  }

  /// Get all receipts for messages in conversation
  Future<List<Receipt>> getReceiptsByConversation(String conversationId) async {
    return (select(receipts).join([
      innerJoin(messages, messages.id.equalsExp(receipts.messageId)),
    ])
      ..where(messages.conversationId.equals(conversationId)))
        .map((row) => row.readTable(receipts))
        .get();
  }

  /// Check if message is read by all participants
  Future<bool> isReadByAll(String messageId, int expectedCount) async {
    final readCount = await getReadCount(messageId);
    return readCount >= expectedCount;
  }

  /// Get unsynced receipt count
  Future<int> getUnsyncedReceiptCount() async {
    final countResult = await (select(receipts)
          ..where((r) => r.isSynced.equals(false)))
        .get();
    return countResult.length;
  }
}
</file>

<file path="frontend/lib/data/drift/entities/conversation.drift">
CREATE TABLE conversations (
  id TEXT PRIMARY KEY NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  is_group BOOLEAN NOT NULL DEFAULT 0,
  last_message_at INTEGER,
  is_synced BOOLEAN NOT NULL DEFAULT 0
) AS Conversation;

CREATE TABLE messages (
  id TEXT PRIMARY KEY NOT NULL,
  conversation_id TEXT NOT NULL,
  sender_id TEXT NOT NULL,
  body TEXT NOT NULL,
  media_url TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  is_synced BOOLEAN NOT NULL DEFAULT 0,
  FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
) AS Message;

CREATE TABLE participants (
  id TEXT PRIMARY KEY NOT NULL,
  conversation_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  joined_at INTEGER NOT NULL,
  is_admin BOOLEAN NOT NULL DEFAULT 0,
  is_synced BOOLEAN NOT NULL DEFAULT 0,
  FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE,
  UNIQUE(conversation_id, user_id)
) AS Participant;

CREATE TABLE receipts (
  id TEXT PRIMARY KEY NOT NULL,
  message_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  status TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  is_synced BOOLEAN NOT NULL DEFAULT 0,
  FOREIGN KEY(message_id) REFERENCES messages(id) ON DELETE CASCADE,
  UNIQUE(message_id, user_id)
) AS Receipt;

CREATE TABLE pending_outbox (
  id TEXT PRIMARY KEY NOT NULL,
  operation TEXT NOT NULL,
  payload TEXT NOT NULL,
  conversation_id TEXT,
  created_at INTEGER NOT NULL,
  retry_count INTEGER NOT NULL DEFAULT 0,
  last_error TEXT,
  FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
) AS PendingOutboxItem;
</file>

<file path="frontend/lib/data/remote/supabase_client.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/core/env.dart';

/// Singleton Supabase client for the application.
/// 
/// Initialize with [initializeSupabase] before accessing the client.
class SupabaseClientProvider {
  static late final Supabase _instance;

  /// Get the initialized Supabase client instance
  static Supabase get instance => _instance;

  /// Get the Supabase client for convenience
  static SupabaseClient get client => _instance.client;

  /// Initialize the Supabase client with environment config
  static Future<void> initialize() async {
    Env.validate();
    
    _instance = await Supabase.initialize(
      url: Env.supabaseUrl,
      anonKey: Env.supabaseAnonKey,
      // Enable realtime
      // Note: The underlying realtime_client has heartbeat enabled by default (30s)
      realtimeClientOptions: const RealtimeClientOptions(
        eventsPerSecond: 10,
        logLevel: RealtimeLogLevel.info, // Enable logging for diagnostics
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/auth/screens/auth_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/auth_service.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_ui.dart';

/// Authentication screen for login/signup
class AuthScreen extends StatefulWidget {
  final VoidCallback onAuthSuccess;

  const AuthScreen({
    Key? key,
    required this.onAuthSuccess,
  }) : super(key: key);

  @override
  State<AuthScreen> createState() => _AuthScreenState();
}

class _AuthScreenState extends State<AuthScreen> with ErrorHandlerMixin {
  late TextEditingController _emailController;
  late TextEditingController _passwordController;
  bool _isLoading = false;
  bool _isSignUp = false;
  final _authService = AuthService();

  @override
  void initState() {
    super.initState();
    _emailController = TextEditingController();
    _passwordController = TextEditingController();
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _handleSignIn() async {
    if (_emailController.text.isEmpty || _passwordController.text.isEmpty) {
      ErrorUI.showErrorSnackbar(
        context,
        AppError(
          category: ErrorCategory.validation,
          severity: ErrorSeverity.warning,
          code: 'VAL001',
          message: 'Please enter email and password',
          userMessage: 'Please enter both email and password',
        ),
      );
      return;
    }

    setState(() => _isLoading = true);

    try {
      await _authService.signIn(
        email: _emailController.text.trim(),
        password: _passwordController.text,
      );

      if (mounted) {
        widget.onAuthSuccess();
      }
    } on AppError catch (error) {
      if (mounted) {
        showError(error, onRetry: _handleSignIn);
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  Future<void> _handleSignUp() async {
    // Validation
    if (_emailController.text.isEmpty || _passwordController.text.isEmpty) {
      ErrorUI.showErrorSnackbar(
        context,
        AppError(
          category: ErrorCategory.validation,
          severity: ErrorSeverity.warning,
          code: 'VAL001',
          message: 'Please enter email and password',
          userMessage: 'Please enter both email and password',
        ),
      );
      return;
    }

    if (!_isValidEmail(_emailController.text.trim())) {
      ErrorUI.showErrorSnackbar(
        context,
        AuthError.invalidEmail(),
      );
      return;
    }

    if (_passwordController.text.length < 6) {
      ErrorUI.showErrorSnackbar(
        context,
        AuthError.weakPassword(),
      );
      return;
    }

    setState(() => _isLoading = true);

    try {
      await _authService.signUp(
        email: _emailController.text.trim(),
        password: _passwordController.text,
      );

      if (mounted) {
        // Show success message
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 12),
                Text('Sign up successful! Signing you in...'),
              ],
            ),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
        
        // Auto sign in after signup
        await Future.delayed(const Duration(seconds: 1));
        if (mounted) {
          await _handleSignIn();
        }
      }
    } on AppError catch (error) {
      if (mounted) {
        showError(error, onRetry: _handleSignUp);
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  /// Validate email format
  bool _isValidEmail(String email) {
    final emailRegex = RegExp(
      r'^[a-zA-Z0-9.]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+',
    );
    return emailRegex.hasMatch(email);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('MessageAI'),
        centerTitle: true,
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.chat_bubble,
                size: 64,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(height: 24),
              Text(
                _isSignUp ? 'Create Account' : 'Welcome to MessageAI',
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32),
              TextField(
                controller: _emailController,
                enabled: !_isLoading,
                decoration: InputDecoration(
                  hintText: 'Email',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  prefixIcon: const Icon(Icons.email),
                ),
                keyboardType: TextInputType.emailAddress,
              ),
              const SizedBox(height: 16),
              TextField(
                controller: _passwordController,
                enabled: !_isLoading,
                decoration: InputDecoration(
                  hintText: 'Password',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  prefixIcon: const Icon(Icons.lock),
                ),
                obscureText: true,
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _isLoading
                      ? null
                      : (_isSignUp ? _handleSignUp : _handleSignIn),
                  child: _isLoading
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : Text(_isSignUp ? 'Sign Up' : 'Sign In'),
                ),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(_isSignUp
                      ? 'Already have an account? '
                      : "Don't have an account? "),
                  TextButton(
                    onPressed: _isLoading
                        ? null
                        : () {
                            setState(() {
                              _isSignUp = !_isSignUp;
                              // Clear any previous error messages when switching modes
                              ScaffoldMessenger.of(context).hideCurrentSnackBar();
                            });
                          },
                    child: Text(_isSignUp ? 'Sign In' : 'Sign Up'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/settings/screens/settings_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/features/auth/screens/auth_screen.dart';
import 'package:messageai/services/avatar_service.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_ui.dart';

/// User settings and account management screen
class SettingsScreen extends StatefulWidget {
  const SettingsScreen({Key? key}) : super(key: key);

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> with ErrorHandlerMixin {
  final _supabase = SupabaseClientProvider.client;
  final _avatarService = AvatarService();
  bool _notificationsEnabled = true;
  bool _isLoading = false;
  bool _isUploadingAvatar = false;
  String? _avatarUrl;

  @override
  void initState() {
    super.initState();
    _loadProfile();
  }

  Future<void> _loadProfile() async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      final response = await _supabase
          .from('profiles')
          .select('avatar_url')
          .eq('user_id', userId)
          .maybeSingle();

      if (response != null && mounted) {
        setState(() {
          _avatarUrl = response['avatar_url'] as String?;
        });
      }
    } catch (e) {
      print('Error loading profile: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    final user = _supabase.auth.currentUser;
    final email = user?.email ?? 'Not logged in';
    final userId = user?.id ?? '';

    return Scaffold(
      appBar: AppBar(
        title: const Text('Settings'),
        elevation: 1,
      ),
      body: ListView(
        children: [
          // Profile Section
          Container(
            padding: const EdgeInsets.all(24),
            color: Theme.of(context).colorScheme.surfaceContainer,
            child: Column(
              children: [
                Stack(
                  children: [
                    _isUploadingAvatar
                        ? const CircleAvatar(
                            radius: 50,
                            child: CircularProgressIndicator(),
                          )
                        : CircleAvatar(
                            radius: 50,
                            backgroundColor: Theme.of(context).colorScheme.primary,
                            backgroundImage: _avatarUrl != null
                                ? NetworkImage(_avatarUrl!)
                                : null,
                            child: _avatarUrl == null
                                ? Text(
                                    email[0].toUpperCase(),
                                    style: const TextStyle(
                                      fontSize: 40,
                                      fontWeight: FontWeight.bold,
                                      color: Colors.white,
                                    ),
                                  )
                                : null,
                          ),
                    Positioned(
                      bottom: 0,
                      right: 0,
                      child: Container(
                        decoration: BoxDecoration(
                          color: Theme.of(context).colorScheme.primary,
                          shape: BoxShape.circle,
                        ),
                        child: IconButton(
                          icon: const Icon(Icons.camera_alt, color: Colors.white, size: 20),
                          onPressed: _isUploadingAvatar ? null : _showAvatarOptions,
                          padding: const EdgeInsets.all(8),
                          constraints: const BoxConstraints(),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                Text(
                  email,
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                const SizedBox(height: 4),
                Text(
                  'ID: ${userId.substring(0, 8)}...',
                  style: Theme.of(context).textTheme.bodySmall,
                ),
              ],
            ),
          ),

          const SizedBox(height: 8),

          // Account Settings
          _buildSectionTitle('Account'),
          _buildSettingsTile(
            icon: Icons.person,
            title: 'Display Name',
            subtitle: email.split('@')[0],
            onTap: () => _showEditDisplayNameDialog(),
          ),
          _buildSettingsTile(
            icon: Icons.email,
            title: 'Email',
            subtitle: email,
            onTap: () {},
          ),
          _buildSettingsTile(
            icon: Icons.lock,
            title: 'Change Password',
            onTap: () => _showComingSoonDialog('Change Password'),
          ),

          const Divider(height: 1),

          // Notifications
          _buildSectionTitle('Notifications'),
          SwitchListTile(
            secondary: const Icon(Icons.notifications),
            title: const Text('Push Notifications'),
            subtitle: const Text('Receive message notifications'),
            value: _notificationsEnabled,
            onChanged: (value) {
              setState(() => _notificationsEnabled = value);
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(
                    value ? 'Notifications enabled' : 'Notifications disabled',
                  ),
                ),
              );
            },
          ),
          _buildSettingsTile(
            icon: Icons.volume_up,
            title: 'Notification Sound',
            subtitle: 'Default',
            onTap: () => _showComingSoonDialog('Notification Sounds'),
          ),

          const Divider(height: 1),

          // Privacy & Security
          _buildSectionTitle('Privacy & Security'),
          _buildSettingsTile(
            icon: Icons.shield,
            title: 'Blocked Users',
            onTap: () => _showComingSoonDialog('Blocked Users'),
          ),
          _buildSettingsTile(
            icon: Icons.visibility,
            title: 'Online Status',
            subtitle: 'Visible to everyone',
            onTap: () => _showComingSoonDialog('Online Status Settings'),
          ),
          _buildSettingsTile(
            icon: Icons.check_circle,
            title: 'Read Receipts',
            subtitle: 'Enabled',
            onTap: () => _showComingSoonDialog('Read Receipts Settings'),
          ),

          const Divider(height: 1),

          // Storage
          _buildSectionTitle('Storage'),
          _buildSettingsTile(
            icon: Icons.storage,
            title: 'Storage Usage',
            subtitle: 'Calculate storage...',
            onTap: () => _showComingSoonDialog('Storage Management'),
          ),
          _buildSettingsTile(
            icon: Icons.delete_sweep,
            title: 'Clear Cache',
            onTap: () => _showClearCacheDialog(),
          ),

          const Divider(height: 1),

          // About
          _buildSectionTitle('About'),
          _buildSettingsTile(
            icon: Icons.info,
            title: 'App Version',
            subtitle: '1.0.0 (MVP)',
            onTap: () {},
          ),
          _buildSettingsTile(
            icon: Icons.privacy_tip,
            title: 'Privacy Policy',
            onTap: () => _showComingSoonDialog('Privacy Policy'),
          ),
          _buildSettingsTile(
            icon: Icons.description,
            title: 'Terms of Service',
            onTap: () => _showComingSoonDialog('Terms of Service'),
          ),

          const SizedBox(height: 16),

          // Logout Button
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: ElevatedButton.icon(
              onPressed: _isLoading ? null : _handleLogout,
              icon: _isLoading
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Icon(Icons.logout),
              label: const Text('Log Out'),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.red,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(vertical: 16),
              ),
            ),
          ),

          const SizedBox(height: 32),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 24, 16, 8),
      child: Text(
        title.toUpperCase(),
        style: TextStyle(
          fontSize: 12,
          fontWeight: FontWeight.w600,
          color: Theme.of(context).colorScheme.primary,
        ),
      ),
    );
  }

  Widget _buildSettingsTile({
    required IconData icon,
    required String title,
    String? subtitle,
    VoidCallback? onTap,
  }) {
    return ListTile(
      leading: Icon(icon),
      title: Text(title),
      subtitle: subtitle != null ? Text(subtitle) : null,
      trailing: const Icon(Icons.chevron_right),
      onTap: onTap,
    );
  }

  /// Show avatar options (Gallery, Camera, Delete)
  void _showAvatarOptions() {
    showModalBottomSheet(
      context: context,
      builder: (BuildContext context) {
        return SafeArea(
          child: Wrap(
            children: [
              ListTile(
                leading: const Icon(Icons.photo_library),
                title: const Text('Choose from Gallery'),
                onTap: () {
                  Navigator.pop(context);
                  _uploadAvatarFromGallery();
                },
              ),
              ListTile(
                leading: const Icon(Icons.camera_alt),
                title: const Text('Take Photo'),
                onTap: () {
                  Navigator.pop(context);
                  _uploadAvatarFromCamera();
                },
              ),
              if (_avatarUrl != null)
                ListTile(
                  leading: const Icon(Icons.delete, color: Colors.red),
                  title: const Text('Remove Photo', style: TextStyle(color: Colors.red)),
                  onTap: () {
                    Navigator.pop(context);
                    _deleteAvatar();
                  },
                ),
              ListTile(
                leading: const Icon(Icons.cancel),
                title: const Text('Cancel'),
                onTap: () => Navigator.pop(context),
              ),
            ],
          ),
        );
      },
    );
  }

  /// Upload avatar from gallery
  Future<void> _uploadAvatarFromGallery() async {
    try {
      final image = await _avatarService.pickImage();
      if (image == null) return;

      await _uploadAvatar(image);
    } on AppError catch (error) {
      if (mounted) {
        showError(error);
      }
    }
  }

  /// Upload avatar from camera
  Future<void> _uploadAvatarFromCamera() async {
    try {
      final image = await _avatarService.pickImageFromCamera();
      if (image == null) return;

      await _uploadAvatar(image);
    } on AppError catch (error) {
      if (mounted) {
        showError(error);
      }
    }
  }

  /// Upload avatar to server
  Future<void> _uploadAvatar(image) async {
    if (mounted) {
      setState(() => _isUploadingAvatar = true);
    }

    try {
      final url = await _avatarService.uploadAvatar(image);

      if (mounted) {
        setState(() {
          _avatarUrl = url;
          _isUploadingAvatar = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 12),
                Text('Profile picture updated successfully'),
              ],
            ),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
      }
    } on AppError catch (error) {
      if (mounted) {
        setState(() => _isUploadingAvatar = false);
        showError(error);
      }
    }
  }

  /// Delete avatar
  Future<void> _deleteAvatar() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Remove Photo'),
        content: const Text('Are you sure you want to remove your profile picture?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('Remove'),
          ),
        ],
      ),
    );

    if (confirm != true) return;

    setState(() => _isUploadingAvatar = true);

    try {
      await _avatarService.deleteAvatar();

      if (mounted) {
        setState(() {
          _avatarUrl = null;
          _isUploadingAvatar = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Profile picture removed')),
        );
      }
    } on AppError catch (error) {
      if (mounted) {
        setState(() => _isUploadingAvatar = false);
        showError(error);
      }
    }
  }

  void _showEditDisplayNameDialog() {
    final controller = TextEditingController();
    final user = _supabase.auth.currentUser;
    controller.text = user?.email?.split('@')[0] ?? '';

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Edit Display Name'),
        content: TextField(
          controller: controller,
          decoration: const InputDecoration(
            labelText: 'Display Name',
            border: OutlineInputBorder(),
          ),
          autofocus: true,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Display name updated')),
              );
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  void _showComingSoonDialog(String feature) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Coming Soon'),
        content: Text('$feature will be available in a future update.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  void _showClearCacheDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Clear Cache'),
        content: const Text(
          'This will clear all cached images and files. Your messages will not be affected.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Cache cleared')),
              );
            },
            child: const Text('Clear'),
          ),
        ],
      ),
    );
  }

  Future<void> _handleLogout() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Log Out'),
        content: const Text('Are you sure you want to log out?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('Log Out'),
          ),
        ],
      ),
    );

    if (confirm == true && mounted) {
      setState(() => _isLoading = true);
      
      try {
        await _supabase.auth.signOut();
        
        if (mounted) {
          Navigator.of(context).pushAndRemoveUntil(
            MaterialPageRoute(
              builder: (context) => AuthScreen(onAuthSuccess: () {}),
            ),
            (route) => false,
          );
        }
      } catch (e) {
        if (mounted) {
          setState(() => _isLoading = false);
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error logging out: $e')),
          );
        }
      }
    }
  }
}
</file>

<file path="frontend/lib/services/conversation_service.dart">
import 'package:uuid/uuid.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';

class ConversationService {
  static final ConversationService _instance =
      ConversationService._internal();

  factory ConversationService() {
    return _instance;
  }

  ConversationService._internal();

  final _db = AppDb.instance;
  final _supabase = SupabaseClientProvider.client;

  /// Create a new conversation
  Future<Conversation> createConversation({
    required String title,
    String? description,
    bool isGroup = false,
  }) async {
    final currentUser = _supabase.auth.currentUser;
    if (currentUser == null) {
      throw 'User not authenticated';
    }

    final now = DateTime.now();
    final timestamp = now.millisecondsSinceEpoch ~/ 1000;
    final conversationId = const Uuid().v4();
    
    final conversation = Conversation(
      id: conversationId,
      title: title,
      description: description,
      createdAt: timestamp,
      updatedAt: timestamp,
      isGroup: isGroup,
      lastMessageAt: timestamp,
      isSynced: false,
    );

    // Save to local database first (optimistic UI)
    await _db.conversationDao.upsertConversation(conversation);

    // Sync to backend
    try {
      // Create conversation in backend
      await _supabase.from('conversations').insert({
        'id': conversationId,
        'title': title,
        'description': description,
        'is_group': isGroup,
        'created_by': currentUser.id,
        'created_at': DateTime.fromMillisecondsSinceEpoch(timestamp * 1000).toIso8601String(),
        'updated_at': DateTime.fromMillisecondsSinceEpoch(timestamp * 1000).toIso8601String(),
      });

      // Add current user as participant
      final participantId = const Uuid().v4();
      await _supabase.from('conversation_participants').insert({
        'id': participantId,
        'conversation_id': conversationId,
        'user_id': currentUser.id,
        'joined_at': DateTime.fromMillisecondsSinceEpoch(timestamp * 1000).toIso8601String(),
      });

      // Save participant locally
      await _db.participantDao.addParticipant(Participant(
        id: participantId,
        conversationId: conversationId,
        userId: currentUser.id,
        joinedAt: timestamp,
        isAdmin: true,
        isSynced: true,
      ));

      // Mark conversation as synced
      await _db.conversationDao.markConversationAsSynced(conversationId);
      
      print('Conversation synced to backend: $conversationId');
    } catch (e) {
      print('Error syncing conversation to backend: $e');
      // Conversation stays in local DB with isSynced=false for retry later
    }

    return conversation;
  }

  /// Sync conversations from backend
  Future<void> syncConversations() async {
    try {
      print('🔄 Syncing conversations from backend...');
      
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        print('❌ User not authenticated, skipping sync');
        return;
      }

      // Fetch conversations where user is a participant
      final response = await _supabase
          .from('conversation_participants')
          .select('conversation_id')
          .eq('user_id', currentUser.id);

      final conversationIds = (response as List)
          .map((p) => p['conversation_id'] as String)
          .toList();

      if (conversationIds.isEmpty) {
        print('ℹ️  No conversations found for user');
        return;
      }

      // Fetch full conversation details
      final conversationsResponse = await _supabase
          .from('conversations')
          .select('*')
          .in_('id', conversationIds);

      print('📥 Fetched ${(conversationsResponse as List).length} conversations from backend');

      // Save to local database
      for (final convData in conversationsResponse) {
        final conversation = Conversation(
          id: convData['id'] as String,
          title: convData['title'] as String,
          description: convData['description'] as String?,
          createdAt: DateTime.parse(convData['created_at'] as String)
              .millisecondsSinceEpoch ~/
              1000,
          updatedAt: DateTime.parse(convData['updated_at'] as String)
              .millisecondsSinceEpoch ~/
              1000,
          isGroup: convData['is_group'] as bool? ?? false,
          lastMessageAt: convData['last_message_at'] != null
              ? DateTime.parse(convData['last_message_at'] as String)
                  .millisecondsSinceEpoch ~/
                  1000
              : DateTime.parse(convData['created_at'] as String)
                  .millisecondsSinceEpoch ~/
                  1000,
          isSynced: true,
        );

        await _db.conversationDao.upsertConversation(conversation);
      }

      print('✅ Conversations synced successfully');
    } catch (e) {
      print('❌ Error syncing conversations: $e');
    }
  }

  /// Get all conversations (with optional sync)
  Future<List<Conversation>> getAllConversations({bool syncFirst = true}) async {
    if (syncFirst) {
      await syncConversations();
    }
    return _db.conversationDao.getAllConversations();
  }

  /// Get recent conversations
  Future<List<Conversation>> getRecentConversations({int limit = 20}) async {
    return _db.conversationDao.getRecentConversations(limit: limit);
  }

  /// Get conversation by ID
  Future<Conversation?> getConversationById(String id) async {
    return _db.conversationDao.getConversationById(id);
  }

  /// Delete conversation (local and remote)
  Future<void> deleteConversation(String id) async {
    final currentUser = _supabase.auth.currentUser;
    print('━' * 60);
    print('🗑️ DELETING CONVERSATION');
    print('━' * 60);
    print('Conversation ID: $id');
    print('User ID: ${currentUser?.id}');
    
    // Delete from local database first
    await _db.conversationDao.deleteConversation(id);
    print('✅ Deleted from local database');
    
    // Try to delete from Supabase
    try {
      print('Attempting to delete from Supabase...');
      
      // Delete from Supabase (CASCADE will delete participants and messages)
      await _supabase
          .from('conversations')
          .delete()
          .eq('id', id);
      
      print('✅ Conversation deleted from backend: $id');
      print('━' * 60);
    } catch (e) {
      print('━' * 60);
      print('❌ ERROR DELETING FROM BACKEND');
      print('━' * 60);
      print('Error: $e');
      print('Error Type: ${e.runtimeType}');
      
      if (e.toString().contains('row-level security')) {
        print('🔒 RLS POLICY BLOCKING DELETE!');
        print('Solution: Run the SQL in FIX_DELETE_CONVERSATION.md');
      }
      
      print('━' * 60);
      // Already deleted locally, so this is non-critical
      // But we should rethrow so the UI can show the error
      rethrow;
    }
  }

  /// Update conversation title
  Future<void> updateConversationTitle(String id, String title) async {
    final conv = await getConversationById(id);
    if (conv != null) {
      final updated = conv.copyWith(
        title: title,
        updatedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );
      await _db.conversationDao.upsertConversation(updated);
    }
  }

  /// Count conversations
  Future<int> getConversationCount() async {
    return _db.conversationDao.getConversationCount();
  }

  /// Sync participants from backend
  Future<void> syncParticipants(String conversationId) async {
    try {
      print('🔄 Syncing participants for conversation: $conversationId');
      
      // Fetch participants from backend
      final response = await _supabase
          .from('conversation_participants')
          .select('*')
          .eq('conversation_id', conversationId);

      print('📥 Fetched ${(response as List).length} participants from backend');

      // Save participants to local database
      for (final partData in response) {
        final participant = Participant(
          id: partData['id'] as String,
          conversationId: partData['conversation_id'] as String,
          userId: partData['user_id'] as String,
          joinedAt: DateTime.parse(partData['joined_at'] as String)
              .millisecondsSinceEpoch ~/
              1000,
          isAdmin: partData['is_admin'] as bool? ?? false,
          isSynced: true,
        );
        
        await _db.participantDao.addParticipant(participant);
      }

      print('✅ Participants synced successfully');
    } catch (e) {
      print('❌ Error syncing participants: $e');
    }
  }

  /// Get participants in a conversation
  Future<List<Participant>> getParticipants(String conversationId, {bool syncFirst = true}) async {
    if (syncFirst) {
      await syncParticipants(conversationId);
    }
    return _db.participantDao.getParticipantsByConversation(conversationId);
  }
  
  /// Get participant profile from Supabase by user ID
  Future<Map<String, dynamic>?> getParticipantProfile(String userId) async {
    try {
      final response = await _supabase
          .from('profiles')
          .select('user_id, username, email, avatar_url, display_name')
          .eq('user_id', userId)
          .single();
      
      return response as Map<String, dynamic>;
    } catch (e) {
      print('Error fetching profile for $userId: $e');
      return null;
    }
  }

  /// Add participant to conversation
  Future<void> addParticipant({
    required String conversationId,
    required String userId,
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final participantId = const Uuid().v4();
    
    final participant = Participant(
      id: participantId,
      conversationId: conversationId,
      userId: userId,
      joinedAt: now,
      isAdmin: false,
      isSynced: false,
    );
    
    // Save to local database first (optimistic UI)
    await _db.participantDao.addParticipant(participant);
    
    // Sync to backend
    try {
      await _supabase.from('conversation_participants').insert({
        'id': participantId,
        'conversation_id': conversationId,
        'user_id': userId,
        'joined_at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
      });
      
      print('Participant added to backend: $userId');
    } catch (e) {
      print('Error syncing participant to backend: $e');
    }
  }

  /// Remove participant from conversation
  Future<void> removeParticipant(String conversationId, String userId) async {
    await _db.participantDao.removeParticipant(conversationId, userId);
  }

  /// Add current user as participant to conversation
  Future<void> addCurrentUserAsParticipant(String conversationId) async {
    // This would typically be called after creating a conversation
    // For now, we'll add the creator automatically in createConversation
  }

  /// Get the latest message for a conversation
  Future<Message?> getLatestMessage(String conversationId) async {
    return _db.messageDao.getLatestMessageForConversation(conversationId);
  }
}
</file>

<file path="frontend/lib/services/local_notification_service.dart">
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter/material.dart';

/// Local notification service for displaying notifications in foreground
class LocalNotificationService {
  static const String _channelId = 'messages';
  static const String _channelName = 'Message Notifications';
  
  final FlutterLocalNotificationsPlugin _plugin;

  LocalNotificationService({FlutterLocalNotificationsPlugin? plugin})
      : _plugin = plugin ?? FlutterLocalNotificationsPlugin();

  /// Initialize local notifications
  Future<void> initialize() async {
    try {
      // Android initialization
      const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');

      // iOS initialization
      const iosSettings = DarwinInitializationSettings(
        requestAlertPermission: true,
        requestBadgePermission: true,
        requestSoundPermission: true,
      );

      const settings = InitializationSettings(
        android: androidSettings,
        iOS: iosSettings,
      );

      await _plugin.initialize(settings);
      print('Local notifications initialized');
    } catch (e) {
      print('Error initializing local notifications: $e');
    }
  }

  /// Show a notification
  Future<void> showNotification({
    required int id,
    required String title,
    required String body,
    String? payload,
  }) async {
    try {
      // Android notification details
      const androidDetails = AndroidNotificationDetails(
        _channelId,
        _channelName,
        channelDescription: 'Notifications for incoming messages',
        importance: Importance.max,
        priority: Priority.high,
        showWhen: true,
        enableVibration: true,
        playSound: true,
        icon: '@mipmap/ic_launcher',
      );

      // iOS notification details
      const iosDetails = DarwinNotificationDetails(
        presentAlert: true,
        presentBadge: true,
        presentSound: true,
        badgeNumber: 1,
      );

      const details = NotificationDetails(
        android: androidDetails,
        iOS: iosDetails,
      );

      await _plugin.show(
        id,
        title,
        body,
        details,
        payload: payload,
      );

      print('Notification shown: $title - $body');
    } catch (e) {
      print('Error showing notification: $e');
    }
  }

  /// Show message notification
  Future<void> showMessageNotification({
    required String conversationId,
    required String senderName,
    required String messageBody,
  }) async {
    final id = conversationId.hashCode % 100000;
    await showNotification(
      id: id,
      title: senderName,
      body: messageBody,
      payload: conversationId,
    );
  }

  /// Cancel a notification
  Future<void> cancelNotification(int id) async {
    try {
      await _plugin.cancel(id);
    } catch (e) {
      print('Error canceling notification: $e');
    }
  }

  /// Cancel all notifications
  Future<void> cancelAllNotifications() async {
    try {
      await _plugin.cancelAll();
    } catch (e) {
      print('Error canceling all notifications: $e');
    }
  }

  /// Get pending notifications
  Future<List<PendingNotificationRequest>> getPendingNotifications() async {
    try {
      return await _plugin.pendingNotificationRequests();
    } catch (e) {
      print('Error getting pending notifications: $e');
      return [];
    }
  }

  /// Setup notification response handler
  void setupNotificationResponseHandler({
    required Function(String) onNotificationTapped,
  }) {
    _plugin.getNotificationAppLaunchDetails().then((details) {
      if (details?.didNotificationLaunchApp ?? false) {
        final payload = details?.notificationResponse?.payload;
        if (payload != null) {
          onNotificationTapped(payload);
        }
      }
    });

    // Listen for notification taps in foreground
  }

  /// Request notification permissions (Android 13+)
  Future<bool> requestPermissions() async {
    try {
      final result = await _plugin
          .resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin>()
          ?.requestNotificationsPermission();
      return result ?? false;
    } catch (e) {
      print('Error requesting permissions: $e');
      return false;
    }
  }
}
</file>

<file path="frontend/lib/services/media_service.dart">
import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path/path.dart' as p;
import 'package:uuid/uuid.dart';
import 'package:messageai/state/providers.dart';

/// Media upload progress
class MediaUploadProgress {
  final int bytesTransferred;
  final int totalBytes;
  
  MediaUploadProgress({
    required this.bytesTransferred,
    required this.totalBytes,
  });
  
  double get progress => totalBytes > 0 ? bytesTransferred / totalBytes : 0;
  double get percentage => progress * 100;
}

/// Media service for handling uploads
class MediaService {
  final Ref ref;
  
  static const String _mediaBucket = 'media';
  static const String _avatarBucket = 'avatars';
  
  MediaService({required this.ref});

  /// Pick image from gallery
  Future<XFile?> pickImageFromGallery() async {
    final picker = ImagePicker();
    return picker.pickImage(source: ImageSource.gallery);
  }

  /// Pick image from camera
  Future<XFile?> pickImageFromCamera() async {
    final picker = ImagePicker();
    return picker.pickImage(source: ImageSource.camera);
  }

  /// Upload image to Supabase Storage
  Future<String> uploadImage(XFile file, {String bucket = 'media'}) async {
    final supabase = ref.watch(supabaseClientProvider);
    final userId = supabase.auth.currentUser?.id;
    
    if (userId == null) {
      throw Exception('User not authenticated');
    }
    
    try {
      // Generate unique filename
      const uuid = Uuid();
      final fileName = '${uuid.v4()}_${p.basename(file.path)}';
      final path = '$userId/$fileName';
      
      // Read file bytes
      final fileBytes = await file.readAsBytes();
      
      // Upload to storage
      await supabase.storage
          .from(bucket)
          .uploadBinary(
            path,
            fileBytes,
            fileOptions: const FileOptions(cacheControl: '3600'),
          );
      
      // Get public URL
      final url = supabase.storage
          .from(bucket)
          .getPublicUrl(path);
      
      return url;
    } catch (e) {
      print('Error uploading image: $e');
      rethrow;
    }
  }
  
  /// Upload avatar image
  Future<String> uploadAvatar(XFile file) async {
    return uploadImage(file, bucket: _avatarBucket);
  }

  /// Upload image with progress tracking
  Future<String> uploadImageWithProgress(
    XFile file,
    Function(MediaUploadProgress) onProgress,
  ) async {
    final supabase = ref.watch(supabaseClientProvider);
    
    try {
      // Generate unique filename
      const uuid = Uuid();
      final fileName = '${uuid.v4()}_${p.basename(file.path)}';
      final path = 'conversations/$fileName';
      
      // Read file bytes
      final fileBytes = await file.readAsBytes();
      final totalBytes = fileBytes.length;
      
      // Simulate progress (Supabase doesn't provide built-in progress)
      // In production, use a dedicated upload library
      int bytesTransferred = 0;
      
      // Upload to storage
      await supabase.storage
          .from(_mediaBucket)
          .uploadBinary(
            path,
            fileBytes,
            fileOptions: const FileOptions(cacheControl: '3600'),
          );
      
      bytesTransferred = totalBytes;
      onProgress(MediaUploadProgress(
        bytesTransferred: bytesTransferred,
        totalBytes: totalBytes,
      ));
      
      // Get public URL
      final url = supabase.storage
          .from(_mediaBucket)
          .getPublicUrl(path);
      
      return url;
    } catch (e) {
      print('Error uploading image with progress: $e');
      rethrow;
    }
  }

  /// Delete image from storage
  Future<void> deleteImage(String url) async {
    final supabase = ref.watch(supabaseClientProvider);
    
    try {
      // Extract path from URL
      final uri = Uri.parse(url);
      final pathSegments = uri.pathSegments;
      final path = pathSegments.sublist(4).join('/'); // Skip storage, v1, object, public
      
      await supabase.storage.from(_mediaBucket).remove([path]);
    } catch (e) {
      print('Error deleting image: $e');
    }
  }

  /// Compress image before upload
  Future<File> compressImage(XFile file, {int quality = 85}) async {
    // TODO: Implement image compression using image package
    // For now, return original file
    return File(file.path);
  }
}

/// Provider for media service
final mediaServiceProvider = Provider<MediaService>((ref) {
  return MediaService(ref: ref);
});

/// State notifier for handling media uploads
class MediaUploadNotifier extends StateNotifier<AsyncValue<String>> {
  final Ref ref;

  MediaUploadNotifier({required this.ref}) : super(const AsyncValue.data(''));

  /// Upload image
  Future<String> uploadImage(XFile file) async {
    state = const AsyncValue.loading();
    
    try {
      final mediaService = ref.watch(mediaServiceProvider);
      final url = await mediaService.uploadImage(file);
      state = AsyncValue.data(url);
      return url;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }

  /// Upload image with progress
  Future<String> uploadImageWithProgress(
    XFile file,
    Function(MediaUploadProgress) onProgress,
  ) async {
    state = const AsyncValue.loading();
    
    try {
      final mediaService = ref.watch(mediaServiceProvider);
      final url = await mediaService.uploadImageWithProgress(file, onProgress);
      state = AsyncValue.data(url);
      return url;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }
}

/// State notifier provider for media uploads
final mediaUploadNotifierProvider =
    StateNotifierProvider<MediaUploadNotifier, AsyncValue<String>>((ref) {
  return MediaUploadNotifier(ref: ref);
});
</file>

<file path="frontend/lib/services/message_service.dart">
import 'package:uuid/uuid.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/core/errors/error_handler.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/services/ai_analysis_service.dart';

class MessageService {
  static final MessageService _instance = MessageService._internal();

  factory MessageService() {
    return _instance;
  }

  MessageService._internal();

  final _db = AppDb.instance;
  final _supabase = SupabaseClientProvider.client;
  final _errorHandler = ErrorHandler();
  final _aiAnalysis = AIAnalysisService();
  
  // Callback for when message is successfully sent (for triggering push notifications)
  void Function(String conversationId, String messageId)? onMessageSent;

  /// Send a new message
  Future<Message> sendMessage({
    required String conversationId,
    required String body,
    String? mediaUrl,
  }) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final messageId = const Uuid().v4();
      
      final message = Message(
        id: messageId,
        conversationId: conversationId,
        senderId: currentUser.id,
        body: body,
        mediaUrl: mediaUrl,
        createdAt: now,
        updatedAt: now,
        isSynced: false,
      );

      // Save to local database first (optimistic UI)
      try {
        await _db.messageDao.upsertMessage(message);
        await _db.conversationDao.updateLastMessageTime(conversationId);
      } catch (error, stackTrace) {
        // Critical: Can't even save locally
        throw _errorHandler.handleError(
          error, 
          stackTrace: stackTrace, 
          context: 'Save Message Locally',
        );
      }

      // Sync to backend
      try {
        final payload = {
          'id': messageId,
          'conversation_id': conversationId,
          'sender_id': currentUser.id,
          'body': body,
          'media_url': mediaUrl,
          'created_at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
          'updated_at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
        };
        
        await _supabase.from('messages').insert(payload);
        await _db.messageDao.markMessageAsSynced(messageId);
        
        // Trigger push notifications (don't wait for it)
        _sendPushNotification(conversationId, messageId, body).catchError((e) {
          print('⚠️ Push notification failed: $e');
        });
        
        // Trigger AI analysis for sent messages (don't wait for it)
        _triggerAIAnalysis(messageId, body).catchError((e) {
          print('⚠️ AI analysis failed: $e');
        });
      } catch (error, stackTrace) {
        // Convert to AppError
        final appError = _errorHandler.handleError(
          error, 
          stackTrace: stackTrace, 
          context: 'Send Message',
        );
        
        // If it's a network error, message is saved locally for retry
        if (_errorHandler.isNetworkError(appError)) {
          // Don't throw - message will sync later
        } else if (!appError.isRetryable) {
          // For non-retryable errors (like unauthorized), delete the local message
          await _db.messageDao.deleteMessage(messageId);
          throw appError;
        } else {
          // For other errors, throw so UI can handle
          throw appError;
        }
      }

      return message;
    } catch (error, stackTrace) {
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error, 
        stackTrace: stackTrace, 
        context: 'Send Message',
      );
    }
  }

  /// Sync messages from backend for a conversation
  Future<void> syncMessages(String conversationId) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      // Fetch messages from backend ordered by created_at
      final response = await _supabase
          .from('messages')
          .select('*')
          .eq('conversation_id', conversationId)
          .order('created_at', ascending: true);

      // Save to local database with proper timestamps
      for (final msgData in response as List) {
        final createdAt = DateTime.parse(msgData['created_at'] as String);
        final updatedAt = DateTime.parse(msgData['updated_at'] as String);
        
        final message = Message(
          id: msgData['id'] as String,
          conversationId: msgData['conversation_id'] as String,
          senderId: msgData['sender_id'] as String,
          body: msgData['body'] as String,
          mediaUrl: msgData['media_url'] as String?,
          createdAt: createdAt.millisecondsSinceEpoch ~/ 1000,
          updatedAt: updatedAt.millisecondsSinceEpoch ~/ 1000,
          isSynced: true,
        );

        // Use upsert to avoid duplicates
        await _db.messageDao.upsertMessage(message);
      }
    } catch (error, stackTrace) {
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error, 
        stackTrace: stackTrace, 
        context: 'Sync Messages',
      );
    }
  }

  /// Get messages for a conversation (with optional sync)
  Future<List<Message>> getMessagesByConversation(
    String conversationId, {
    bool syncFirst = false,
  }) async {
    if (syncFirst) {
      await syncMessages(conversationId);
    }
    return _db.messageDao.getMessagesByConversation(conversationId);
  }

  /// Get recent messages for a conversation
  Future<List<Message>> getRecentMessages(String conversationId, {int limit = 50}) async {
    return _db.messageDao.getRecentMessages(conversationId, limit: limit);
  }

  /// Get message by ID
  Future<Message?> getMessageById(String id) async {
    return _db.messageDao.getMessageById(id);
  }

  /// Delete message
  Future<void> deleteMessage(String id) async {
    await _db.messageDao.deleteMessage(id);
  }

  /// Get current user ID
  String? getCurrentUserId() {
    return _supabase.auth.currentUser?.id;
  }

  /// Send push notification for new message
  Future<void> _sendPushNotification(
    String conversationId,
    String messageId,
    String messageBody,
  ) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) return;

      // Get sender profile for notification (use maybeSingle to handle missing profile)
      final profile = await _supabase
          .from('profiles')
          .select('username, email')
          .eq('user_id', currentUser.id)
          .maybeSingle();

      final senderName = profile?['username'] as String? ?? 
                         profile?['email'] as String? ?? 
                         currentUser.email ?? 
                         'Someone';

      // Call push notification edge function with auth header
      final accessToken = _supabase.auth.currentSession?.accessToken;
      if (accessToken == null) return;
      
      print('🔔 Sending push notification for message: ${messageId.substring(0, 8)}');
      final response = await _supabase.functions.invoke(
        'push_notify',
        body: {
          'message_id': messageId,
          'conversation_id': conversationId,
          'sender_id': currentUser.id,
          'sender_name': senderName,
          'title': senderName,
          'body': messageBody,
        },
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      );
      print('✅ Push notification sent: ${response.data}');
    } catch (e) {
      print('❌ Failed to send push notification: $e');
    }
  }
  
  /// Trigger AI analysis for a message (non-blocking)
  Future<void> _triggerAIAnalysis(String messageId, String messageBody) async {
    try {
      final analysis = await _aiAnalysis.requestAnalysis(messageId, messageBody);
      if (analysis != null) {
        print('✨ AI analysis completed for ${messageId.substring(0, 8)}: ${analysis.tone}');
      }
    } catch (e) {
      print('⚠️ AI analysis failed for ${messageId.substring(0, 8)}: $e');
    }
  }
}
</file>

<file path="frontend/lib/services/notification_service.dart">
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/foundation.dart' show kIsWeb;

/// Notification payload model
class NotificationPayload {
  final String? title;
  final String? body;
  final Map<String, dynamic> data;
  final String? messageId;

  NotificationPayload({
    this.title,
    this.body,
    required this.data,
    this.messageId,
  });

  /// Extract conversation ID from payload
  String? get conversationId => data['conversation_id'] as String?;

  /// Extract sender ID from payload
  String? get senderId => data['sender_id'] as String?;

  /// Extract message ID from payload
  String? get messageIdFromPayload => data['message_id'] as String?;

  /// Extract message body from payload
  String? get messageBody => data['message_body'] as String?;
}

/// Firebase Cloud Messaging service
class NotificationService {
  final FirebaseMessaging _messaging = FirebaseMessaging.instance;
  
  static const String _channelId = 'messages';
  static const String _channelName = 'Message Notifications';

  /// Initialize Firebase Messaging
  Future<void> initialize({
    required Function(NotificationPayload) onMessageReceived,
    required Function(String) onTokenRefresh,
  }) async {
    print('🔔 ========================================');
    print('🔔 INITIALIZING FIREBASE MESSAGING');
    print('🔔 ========================================');
    
    // Skip Firebase Messaging on web due to compatibility issues
    if (kIsWeb) {
      print('⚠️  Firebase Messaging not supported on web platform');
      return;
    }
    
    print('📱 Platform: Mobile (FCM supported)');
    
    try {
      print('📝 Requesting notification permissions...');
      // Request notification permissions
      final settings = await _messaging.requestPermission(
        alert: true,
        announcement: false,
        badge: true,
        criticalAlert: false,
        provisional: false,
        sound: true,
      );

      print('✅ Permission status: ${settings.authorizationStatus}');

      // Get initial token
      print('📱 Getting FCM device token...');
      final token = await getDeviceToken();
      if (token != null) {
        print('✅ FCM Token obtained: ${token.substring(0, 50)}...');
        print('   Full token: $token');
      } else {
        print('⚠️  No FCM token obtained');
      }

      // Listen for token refresh
      FirebaseMessaging.instance.onTokenRefresh.listen((newToken) {
        print('FCM Token refreshed: $newToken');
        onTokenRefresh(newToken);
      });

      // Listen for foreground messages
      FirebaseMessaging.onMessage.listen((RemoteMessage message) {
        print('Got a message whilst in the foreground!');
        print('Message data: ${message.data}');

        final payload = NotificationPayload(
          title: message.notification?.title,
          body: message.notification?.body,
          data: message.data,
          messageId: message.messageId,
        );

        onMessageReceived(payload);
      });

      // Handle background message (top-level function)
      // This should be registered before the app starts
    } catch (e, stackTrace) {
      print('❌ ========================================');
      print('❌ ERROR INITIALIZING FIREBASE MESSAGING');
      print('❌ ========================================');
      print('Error: $e');
      print('Stack trace: $stackTrace');
      print('❌ ========================================');
    }
  }

  /// Get device token for sending notifications
  Future<String?> getDeviceToken() async {
    if (kIsWeb) return null;
    
    try {
      final token = await _messaging.getToken();
      return token;
    } catch (e) {
      print('Error getting device token: $e');
      return null;
    }
  }

  /// Subscribe to a topic
  Future<void> subscribeToTopic(String topic) async {
    if (kIsWeb) return;
    
    try {
      await _messaging.subscribeToTopic(topic);
      print('Subscribed to topic: $topic');
    } catch (e) {
      print('Error subscribing to topic: $e');
    }
  }

  /// Unsubscribe from a topic
  Future<void> unsubscribeFromTopic(String topic) async {
    if (kIsWeb) return;
    
    try {
      await _messaging.unsubscribeFromTopic(topic);
      print('Unsubscribed from topic: $topic');
    } catch (e) {
      print('Error unsubscribing from topic: $e');
    }
  }

  /// Check if notifications are enabled
  Future<bool> areNotificationsEnabled() async {
    if (kIsWeb) return false;
    
    try {
      final settings = await _messaging.getNotificationSettings();
      return settings.authorizationStatus == AuthorizationStatus.authorized;
    } catch (e) {
      print('Error checking notification settings: $e');
      return false;
    }
  }

  /// Handle notification tap
  Future<void> setupNotificationTapHandler({
    required Function(String) onNotificationTapped,
  }) async {
    if (kIsWeb) return;
    
    try {
      // When the app is in foreground and user taps notification
      FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
        print('Notification tapped: ${message.data}');
        final conversationId = message.data['conversation_id'] as String?;
        if (conversationId != null) {
          onNotificationTapped(conversationId);
        }
      });

      // Check if app was opened from a notification when app was terminated
      final initialMessage = await _messaging.getInitialMessage();
      if (initialMessage != null) {
        print('App opened from notification: ${initialMessage.data}');
        final conversationId = initialMessage.data['conversation_id'] as String?;
        if (conversationId != null) {
          onNotificationTapped(conversationId);
        }
      }
    } catch (e) {
      print('Error setting up notification tap handler: $e');
    }
  }
}

/// Provider for notification service
final notificationServiceProvider = Provider<NotificationService>((ref) {
  return NotificationService();
});

/// Store device token
final deviceTokenProvider = StateProvider<String?>((ref) {
  return null;
});

/// Handle notification reception
final notificationHandlerProvider = FutureProvider<void>((ref) async {
  final service = ref.watch(notificationServiceProvider);
  
  // This would be called after the service is initialized
  // Placeholder for notification setup
});
</file>

<file path="frontend/lib/services/presence_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Service for tracking user presence and online status
class PresenceService {
  static final PresenceService _instance = PresenceService._internal();

  factory PresenceService() {
    return _instance;
  }

  PresenceService._internal();

  final _supabase = SupabaseClientProvider.client;
  final Map<String, RealtimeChannel> _channels = {};
  final Map<String, Set<String>> _onlineUsers = {};

  /// Subscribe to presence updates for a conversation
  Future<void> subscribeToPresence(String conversationId) async {
    if (_channels.containsKey(conversationId)) {
      return; // Already subscribed
    }

    final channel = _supabase.realtime.channel('presence:$conversationId');

    // Listen for presence events using the 'on' method
    channel.on(RealtimeListenTypes.presence, ChannelFilter(event: 'sync'), (payload, [ref]) {
      print('👥 Presence sync for $conversationId');
      _updateOnlineUsers(conversationId, channel);
    });

    channel.on(RealtimeListenTypes.presence, ChannelFilter(event: 'join'), (payload, [ref]) {
      print('👋 User joined: ${payload['user_id'] ?? 'unknown'}');
      _updateOnlineUsers(conversationId, channel);
    });

    channel.on(RealtimeListenTypes.presence, ChannelFilter(event: 'leave'), (payload, [ref]) {
      print('👋 User left: ${payload['user_id'] ?? 'unknown'}');
      _updateOnlineUsers(conversationId, channel);
    });

    // Subscribe with extended timeout for slower connections
    channel.subscribe(
      (status, [err]) {
        print('Presence subscription status: $status');
        if (status == 'SUBSCRIBED') {
          _updateOnlineUsers(conversationId, channel);
          // Periodically update to catch any missed events
          Future.delayed(const Duration(seconds: 1), () {
            _updateOnlineUsers(conversationId, channel);
          });
        }
        if (err != null) {
          print('Error subscribing to presence: $err');
        }
      },
      const Duration(seconds: 30), // Increased timeout for mobile networks
    );

    _channels[conversationId] = channel;
  }

  /// Unsubscribe from presence updates
  Future<void> unsubscribeFromPresence(String conversationId) async {
    final channel = _channels.remove(conversationId);
    if (channel != null) {
      await channel.unsubscribe();
    }
    _onlineUsers.remove(conversationId);
  }

  /// Broadcast user presence
  Future<void> setPresenceStatus(String conversationId, bool isOnline) async {
    final channel = _channels[conversationId];
    if (channel == null) return;

    final currentUser = _supabase.auth.currentUser;
    if (currentUser == null) return;

    try {
      await channel.track({
        'user_id': currentUser.id,
        'online': isOnline,
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('Error setting presence: $e');
    }
  }

  /// Get online users for a conversation
  Set<String> getOnlineUsers(String conversationId) {
    return _onlineUsers[conversationId] ?? {};
  }

  /// Check if a user is online
  bool isUserOnline(String conversationId, String userId) {
    return _onlineUsers[conversationId]?.contains(userId) ?? false;
  }

  void _updateOnlineUsers(String conversationId, RealtimeChannel channel) {
    try {
      final presenceState = channel.presenceState();
      final onlineSet = <String>{};

      // Iterate through all presence states
      for (final entry in presenceState.entries) {
        for (final presence in entry.value) {
          // Access the payload property which contains the tracked data
          final payload = presence.payload;
          if (payload is Map<String, dynamic>) {
            if (payload['online'] == true) {
              final userId = payload['user_id'] as String?;
              if (userId != null) {
                onlineSet.add(userId);
              }
            }
          }
        }
      }

      _onlineUsers[conversationId] = onlineSet;
      print('📊 Online users updated: ${onlineSet.length} users online');
    } catch (e) {
      print('Error updating online users: $e');
    }
  }

  /// Clean up all subscriptions
  Future<void> dispose() async {
    for (final channel in _channels.values) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        print('Error unsubscribing: $e');
      }
    }
    _channels.clear();
    _onlineUsers.clear();
  }
}
</file>

<file path="frontend/lib/services/realtime_message_service.dart">
import 'dart:async';
import 'package:uuid/uuid.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/services/realtime_diagnostic_service.dart';
import 'package:messageai/services/ai_analysis_service.dart';

/// Service for real-time message synchronization
class RealTimeMessageService {
  static final RealTimeMessageService _instance =
      RealTimeMessageService._internal();

  factory RealTimeMessageService() {
    return _instance;
  }

  RealTimeMessageService._internal();

  final _supabase = SupabaseClientProvider.client;
  final _db = AppDb.instance;
  final _diagnostics = RealtimeDiagnosticService();
  final _aiAnalysis = AIAnalysisService();
  final Map<String, RealtimeChannel> _channels = {};
  final Map<String, RealtimeChannel> _receiptChannels = {};
  final Map<String, StreamController<List<Message>>> _messageControllers = {};
  final Map<String, StreamController<List<Receipt>>> _receiptControllers = {};

  /// Subscribe to real-time messages for a conversation
  Stream<List<Message>> subscribeToMessages(String conversationId) {
    if (_messageControllers.containsKey(conversationId)) {
      return _messageControllers[conversationId]!.stream;
    }

    final controller = StreamController<List<Message>>.broadcast();
    _messageControllers[conversationId] = controller;

    _setupRealtimeListener(conversationId, controller);

    return controller.stream;
  }

  void _setupRealtimeListener(
    String conversationId,
    StreamController<List<Message>> controller,
  ) {
    try {
      final channelName = 'messages:$conversationId';
      final channel = _supabase.realtime.channel(channelName);
      
      // Register channel for diagnostics
      _diagnostics.registerChannel(channelName, channel);
      
      // Listen for postgres changes using the correct API
      channel.on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          filter: 'conversation_id=eq.$conversationId',
        ),
        (payload, [ref]) async {
          _diagnostics.recordMessageReceived(channelName);
          print('📨 Realtime message received');
          
          try {
            final data = payload['new'] as Map<String, dynamic>;
            final timestamp = DateTime.parse(data['created_at'] as String)
                .millisecondsSinceEpoch ~/
                1000;
            
            final message = Message(
              id: data['id'] as String,
              conversationId: data['conversation_id'] as String,
              senderId: data['sender_id'] as String,
              body: data['body'] as String,
              mediaUrl: data['media_url'] as String?,
              createdAt: timestamp,
              updatedAt: DateTime.parse(data['updated_at'] as String)
                  .millisecondsSinceEpoch ~/
                  1000,
              isSynced: true,
            );
            
            await _db.messageDao.upsertMessage(message);
            
            // Refresh the stream
            final messages =
                await _db.messageDao.getMessagesByConversation(conversationId);
            controller.add(messages);
            print('✅ UI updated with ${messages.length} messages');
            
            // Create delivery receipt for received message
            final currentUser = _supabase.auth.currentUser;
            if (currentUser != null && message.senderId != currentUser.id) {
              await _createReceipt(message.id, currentUser.id, 'delivered');
              
              // Trigger AI analysis for received messages (non-blocking)
              _triggerAIAnalysis(message);
            }
          } catch (e) {
            print('❌ Error processing message: $e');
          }
        },
      );

      // Subscribe with extended timeout for slower connections
      channel.subscribe(
        (status, [err]) {
          _diagnostics.updateChannelStatus(channelName, status);
          
          // Log all status changes for debugging
          print('📡 Realtime [$conversationId]: $status');
          
          if (status == 'CHANNEL_ERROR' || status == 'TIMED_OUT' || err != null) {
            print('❌ Realtime error for $conversationId: $status ${err ?? ""}');
            if (err != null) {
              _diagnostics.recordError(channelName, err.toString());
              controller.addError(err);
            }
          }
        },
        const Duration(seconds: 30), // Increased timeout for mobile networks
      );

      _channels[conversationId] = channel;
      
      // Load initial messages
      Future.delayed(Duration.zero, () async {
        try {
          final messages =
              await _db.messageDao.getMessagesByConversation(conversationId);
          controller.add(messages);
        } catch (e) {
          controller.addError(e);
        }
      });
    } catch (e) {
      print('Error setting up realtime listener: $e');
      controller.addError(e);
    }
  }

  /// Trigger AI analysis for a message (non-blocking)
  void _triggerAIAnalysis(Message message) {
    // Run in background, don't await
    _aiAnalysis.requestAnalysis(message.id, message.body).then((analysis) {
      if (analysis != null) {
        print('✨ AI analysis completed for ${message.id.substring(0, 8)}: ${analysis.tone}');
      }
    }).catchError((error) {
      print('⚠️ AI analysis failed for ${message.id.substring(0, 8)}: $error');
    });
  }

  Future<void> _createReceipt(String messageId, String userId, String status) async {
    try {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final receiptId = const Uuid().v4();
      
      await _db.receiptDao.addReceipt(Receipt(
        id: receiptId,
        messageId: messageId,
        userId: userId,
        status: status,
        createdAt: now,
        updatedAt: now,
        isSynced: false,
      ));
      
      // Note: message_receipts table uses 'at' column, not 'created_at'
      await _supabase.from('message_receipts').insert({
        'id': receiptId,
        'message_id': messageId,
        'user_id': userId,
        'status': status,
        'at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
      });
      
      await _db.receiptDao.markReceiptAsSynced(receiptId);
    } catch (e) {
      // Silently fail - receipts are not critical
    }
  }

  /// Subscribe to real-time receipts for a conversation
  Stream<List<Receipt>> subscribeToReceipts(String conversationId) {
    if (_receiptControllers.containsKey(conversationId)) {
      return _receiptControllers[conversationId]!.stream;
    }

    final controller = StreamController<List<Receipt>>.broadcast();
    _receiptControllers[conversationId] = controller;

    _setupReceiptListener(conversationId, controller);

    return controller.stream;
  }

  void _setupReceiptListener(
    String conversationId,
    StreamController<List<Receipt>> controller,
  ) {
    try {
      final channelName = 'receipts:$conversationId';
      final channel = _supabase.realtime.channel(channelName);
      
      // Listen for receipt changes
      channel.on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: '*',  // All events (INSERT, UPDATE)
          schema: 'public',
          table: 'message_receipts',
        ),
        (payload, [ref]) async {
          print('📨 Receipt change received');
          
          try {
            // Reload all receipts for this conversation
            final receipts = await _db.receiptDao.getReceiptsByConversation(conversationId);
            controller.add(receipts);
          } catch (e) {
            print('❌ Error processing receipt: $e');
          }
        },
      );

      channel.subscribe(
        (status, [err]) {
          print('📡 Receipts [$conversationId]: $status');
          if (err != null) {
            controller.addError(err);
          }
        },
        const Duration(seconds: 30),
      );

      _receiptChannels[conversationId] = channel;
      
      // Load initial receipts
      Future.delayed(Duration.zero, () async {
        try {
          final receipts = await _db.receiptDao.getReceiptsByConversation(conversationId);
          controller.add(receipts);
        } catch (e) {
          controller.addError(e);
        }
      });
    } catch (e) {
      print('Error setting up receipt listener: $e');
      controller.addError(e);
    }
  }

  /// Unsubscribe from real-time messages
  Future<void> unsubscribeFromMessages(String conversationId) async {
    final controller = _messageControllers.remove(conversationId);
    controller?.close();

    final channel = _channels.remove(conversationId);
    if (channel != null) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
  }

  /// Unsubscribe from real-time receipts
  Future<void> unsubscribeFromReceipts(String conversationId) async {
    final controller = _receiptControllers.remove(conversationId);
    controller?.close();

    final channel = _receiptChannels.remove(conversationId);
    if (channel != null) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
  }

  /// Clean up all subscriptions
  Future<void> dispose() async {
    for (final controller in _messageControllers.values) {
      controller.close();
    }
    _messageControllers.clear();

    for (final controller in _receiptControllers.values) {
      controller.close();
    }
    _receiptControllers.clear();

    for (final channel in _channels.values) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
    _channels.clear();

    for (final channel in _receiptChannels.values) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
    _receiptChannels.clear();
    
    _diagnostics.dispose();
  }

  /// Get diagnostic report
  String getDiagnosticsReport() {
    return _diagnostics.generateReport();
  }

  /// Start diagnostic monitoring
  void startDiagnostics() {
    _diagnostics.startMonitoring();
  }

  /// Stop diagnostic monitoring
  void stopDiagnostics() {
    _diagnostics.stopMonitoring();
  }

  /// Test Realtime connection
  Future<RealtimeTestResult> testConnection() {
    return _diagnostics.testConnection();
  }
}
</file>

<file path="frontend/lib/services/typing_indicator_service.dart">
import 'dart:async';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Service to handle typing indicators using Supabase Realtime
class TypingIndicatorService {
  static final TypingIndicatorService _instance = TypingIndicatorService._internal();
  factory TypingIndicatorService() => _instance;
  TypingIndicatorService._internal();

  final _supabase = SupabaseClientProvider.client;
  final Map<String, RealtimeChannel> _channels = {};
  final Map<String, Set<String>> _typingUsers = {}; // conversationId -> Set of userIds
  final Map<String, StreamController<Set<String>>> _typingControllers = {};
  final Map<String, Timer?> _typingTimeouts = {}; // userId -> Timer

  static const _typingTimeout = Duration(seconds: 3);

  /// Subscribe to typing events for a conversation
  Stream<Set<String>> subscribeToTyping(String conversationId) {
    // Return existing stream if already subscribed
    if (_typingControllers.containsKey(conversationId)) {
      return _typingControllers[conversationId]!.stream;
    }

    // Create new stream controller
    final controller = StreamController<Set<String>>.broadcast();
    _typingControllers[conversationId] = controller;
    _typingUsers[conversationId] = {};

    // Create channel for this conversation
    final channel = _supabase.channel('typing:$conversationId');
    _channels[conversationId] = channel;

    // Listen for typing events using on() method
    channel.on(
      RealtimeListenTypes.broadcast,
      ChannelFilter(event: 'typing'),
      (payload, [ref]) {
        final data = payload as Map<String, dynamic>;
        final userId = data['user_id'] as String?;
        final isTyping = data['is_typing'] as bool? ?? false;
        final currentUserId = _supabase.auth.currentUser?.id;

        // Ignore own typing events
        if (userId == null || userId == currentUserId) return;

        final typingSet = _typingUsers[conversationId] ?? {};

        if (isTyping) {
          typingSet.add(userId);
          
          // Clear existing timeout for this user
          _typingTimeouts['$conversationId:$userId']?.cancel();
          
          // Set timeout to remove user from typing after inactivity
          _typingTimeouts['$conversationId:$userId'] = Timer(_typingTimeout, () {
            typingSet.remove(userId);
            _typingUsers[conversationId] = typingSet;
            if (!controller.isClosed) {
              controller.add(Set.from(typingSet));
            }
          });
        } else {
          typingSet.remove(userId);
          _typingTimeouts['$conversationId:$userId']?.cancel();
        }

        _typingUsers[conversationId] = typingSet;
        if (!controller.isClosed) {
          controller.add(Set.from(typingSet));
        }
      },
    );

    // Subscribe to channel with extended timeout
    channel.subscribe(
      (status, [err]) {
        print('Typing indicator subscription status: $status');
        if (err != null) {
          print('Error subscribing to typing indicator: $err');
        }
      },
      const Duration(seconds: 30), // Increased timeout for mobile networks
    );

    return controller.stream;
  }

  /// Send typing indicator
  Future<void> sendTypingIndicator(String conversationId, bool isTyping) async {
    final channel = _channels[conversationId];
    if (channel == null) return;

    final currentUserId = _supabase.auth.currentUser?.id;
    if (currentUserId == null) return;

    try {
      channel.send(
        type: RealtimeListenTypes.broadcast,
        event: 'typing',
        payload: {
          'user_id': currentUserId,
          'is_typing': isTyping,
        },
      );
    } catch (e) {
      print('Error sending typing indicator: $e');
    }
  }

  /// Unsubscribe from typing events for a conversation
  Future<void> unsubscribeFromTyping(String conversationId) async {
    final channel = _channels[conversationId];
    if (channel != null) {
      await channel.unsubscribe();
      _channels.remove(conversationId);
    }

    final controller = _typingControllers[conversationId];
    if (controller != null && !controller.isClosed) {
      await controller.close();
    }
    _typingControllers.remove(conversationId);
    _typingUsers.remove(conversationId);

    // Clear all timeouts for this conversation
    final keysToRemove = _typingTimeouts.keys
        .where((key) => key.startsWith('$conversationId:'))
        .toList();
    for (final key in keysToRemove) {
      _typingTimeouts[key]?.cancel();
      _typingTimeouts.remove(key);
    }
  }

  /// Get current typing users for a conversation
  Set<String> getTypingUsers(String conversationId) {
    return Set.from(_typingUsers[conversationId] ?? {});
  }

  /// Clean up all subscriptions
  Future<void> dispose() async {
    for (final channel in _channels.values) {
      await channel.unsubscribe();
    }
    _channels.clear();

    for (final controller in _typingControllers.values) {
      if (!controller.isClosed) {
        await controller.close();
      }
    }
    _typingControllers.clear();
    _typingUsers.clear();

    for (final timer in _typingTimeouts.values) {
      timer?.cancel();
    }
    _typingTimeouts.clear();
  }
}
</file>

<file path="frontend/lib/state/database_provider.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/conversation_dao.dart';
import 'package:messageai/data/drift/daos/message_dao.dart';
import 'package:messageai/data/drift/daos/participant_dao.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';

/// Provides the main database instance
final appDbProvider = Provider<AppDb>((ref) {
  return AppDb.instance;
});

/// Provides the ConversationDao
final conversationDaoProvider = Provider<ConversationDao>((ref) {
  final db = ref.watch(appDbProvider);
  return ConversationDao(db);
});

/// Provides the MessageDao
final messageDaoProvider = Provider<MessageDao>((ref) {
  final db = ref.watch(appDbProvider);
  return MessageDao(db);
});

/// Provides the ParticipantDao
final participantDaoProvider = Provider<ParticipantDao>((ref) {
  final db = ref.watch(appDbProvider);
  return ParticipantDao(db);
});

/// Provides the ReceiptDao
final receiptDaoProvider = Provider<ReceiptDao>((ref) {
  final db = ref.watch(appDbProvider);
  return ReceiptDao(db);
});

/// Provides the PendingOutboxDao
final pendingOutboxDaoProvider = Provider<PendingOutboxDao>((ref) {
  final db = ref.watch(appDbProvider);
  return PendingOutboxDao(db);
});

/// Stream of all conversations (watching for changes)
final conversationsStreamProvider = StreamProvider<List<Conversation>>((ref) async* {
  final dao = ref.watch(conversationDaoProvider);
  
  // Initial load
  yield await dao.getAllConversations();
  
  // TODO: Set up watch stream for real-time updates
  // For now, update every time this is accessed
});

/// Stream of messages for a specific conversation
final messagesStreamProvider = StreamProvider.family<List<Message>, String>((ref, conversationId) async* {
  final dao = ref.watch(messageDaoProvider);
  
  // Initial load
  yield await dao.getMessagesByConversation(conversationId);
  
  // TODO: Set up watch stream for real-time updates
});

/// Stream of pending operations count (for UI indicators)
final pendingOperationsCountProvider = StreamProvider<int>((ref) async* {
  final dao = ref.watch(pendingOutboxDaoProvider);
  
  // Initial load
  yield await dao.getPendingOperationCount();
  
  // TODO: Set up periodic check or subscription
});

/// Check if there are any pending operations
final hasPendingOperationsProvider = FutureProvider<bool>((ref) async {
  final dao = ref.watch(pendingOutboxDaoProvider);
  return dao.hasPendingOperations();
});
</file>

<file path="frontend/lib/state/providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart' as fpr;
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:dio/dio.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/gen/api/clients/messages_api.dart';
import 'package:messageai/gen/api/clients/receipts_api.dart';

/// Provides the Supabase client instance
final supabaseClientProvider = fpr.Provider<SupabaseClient>((ref) {
  return SupabaseClientProvider.client;
});

/// Provides the Supabase auth client
final authProvider = fpr.Provider((ref) {
  return ref.watch(supabaseClientProvider).auth;
});

/// Provides the current authenticated user
final currentUserProvider = fpr.StreamProvider((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  return supabase.auth.onAuthStateChange.map((data) => data.session?.user);
});

/// Provides a Dio HTTP client configured for the API
final dioProvider = fpr.Provider<Dio>((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  final dio = Dio(
    BaseOptions(
      baseUrl: supabase.restUrl,
      headers: {
        'Authorization': 'Bearer ${supabase.auth.currentSession?.accessToken}',
        'apikey': supabase.auth.currentSession?.user.id ?? '',
      },
    ),
  );
  return dio;
});

/// Provides the Messages API client
final messagesApiProvider = fpr.Provider<MessagesApi>((ref) {
  final dio = ref.watch(dioProvider);
  final supabase = ref.watch(supabaseClientProvider);
  return MessagesApi(
    dio: dio,
    baseUrl: supabase.restUrl,
  );
});

/// Provides the Receipts API client
final receiptsApiProvider = fpr.Provider<ReceiptsApi>((ref) {
  final dio = ref.watch(dioProvider);
  final supabase = ref.watch(supabaseClientProvider);
  return ReceiptsApi(
    dio: dio,
    baseUrl: supabase.restUrl,
  );
});

/// Indicates whether the user is currently authenticated
final isAuthenticatedProvider = fpr.StreamProvider<bool>((ref) async* {
  final authState = ref.watch(currentUserProvider);
  yield* authState.when(
    data: (user) async* {
      yield user != null;
    },
    loading: () async* {
      yield false;
    },
    error: (err, st) async* {
      yield false;
    },
  );
});
</file>

<file path="contracts/openapi.yaml">
openapi: 3.1.0
info: 
  title: MessageAI API
  version: 1.0.0
  description: Real-time messaging API with end-to-end encrypted conversations and media support
  contact:
    name: MessageAI Team
  license:
    name: Proprietary
servers:
  - url: http://localhost:54321/rest/v1
    description: Local Supabase development
  - url: https://api.messageai.app/rest/v1
    description: Production API

paths:
  /v1/messages.send:
    post:
      summary: Send a message to a conversation
      description: Creates a new message in a conversation with optional media attachment. Idempotent operation using message ID.
      tags:
        - Messages
      operationId: sendMessage
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MessagePayload'
      responses:
        '200':
          description: Message sent successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MessageResponse'
        '400':
          description: Invalid request
        '401':
          description: Unauthorized
        '409':
          description: Message already exists (idempotent)

  /v1/receipts.ack:
    post:
      summary: Acknowledge message receipts
      description: Batch update receipt status (delivered/read) for multiple messages
      tags:
        - Receipts
      operationId: acknowledgeReceipts
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ReceiptPayload'
      responses:
        '200':
          description: Receipts acknowledged successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                  count:
                    type: integer
                    description: Number of receipts updated
        '400':
          description: Invalid request
        '401':
          description: Unauthorized

  /v1/create_group:
    post:
      summary: Create a group conversation
      description: Create a group conversation with multiple members
      tags:
        - Groups
      operationId: createGroup
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateGroupPayload'
      responses:
        '200':
          description: Group created successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GroupResponse'
        '400':
          description: Invalid request
        '401':
          description: Unauthorized

  /v1/push_notify:
    post:
      summary: Send push notifications
      description: Send push notifications to inactive participants
      tags:
        - Notifications
      operationId: pushNotify
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PushNotifyPayload'
      responses:
        '200':
          description: Notifications sent
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PushNotifyResponse'
        '400':
          description: Invalid request
        '401':
          description: Unauthorized

components:
  schemas:
    # ========================================================================
    # Message Schemas
    # ========================================================================
    MessagePayload:
      type: object
      description: Request payload for sending a message
      properties:
        id:
          type: string
          format: uuid
          description: Unique message ID (client-generated for idempotency)
        conversation_id:
          type: string
          format: uuid
          description: ID of the target conversation
        body:
          type: string
          description: Message content (text)
          minLength: 1
        media_url:
          type: string
          format: uri
          nullable: true
          description: Optional URL to attached media (image, video, file)
      required:
        - id
        - conversation_id
        - body

    MessageResponse:
      type: object
      description: Server response after sending a message
      properties:
        id:
          type: string
          format: uuid
          description: Message ID
        conversation_id:
          type: string
          format: uuid
          description: Conversation ID
        sender_id:
          type: string
          format: uuid
          description: ID of message sender
        body:
          type: string
          description: Message content
        media_url:
          type: string
          format: uri
          nullable: true
          description: Media attachment URL if present
        created_at:
          type: string
          format: date-time
          description: Timestamp when message was created
        server_time:
          type: string
          format: date-time
          description: Server timestamp for synchronization
      required:
        - id
        - conversation_id
        - sender_id
        - body
        - created_at
        - server_time

    # ========================================================================
    # Receipt Schemas
    # ========================================================================
    ReceiptPayload:
      type: object
      description: Request payload for acknowledging message receipts
      properties:
        message_ids:
          type: array
          items:
            type: string
            format: uuid
          description: List of message IDs to acknowledge
          minItems: 1
        status:
          type: string
          enum:
            - delivered
            - read
          description: Status to mark messages as
      required:
        - message_ids
        - status

    MessageReceipt:
      type: object
      description: Message receipt status
      properties:
        id:
          type: string
          format: uuid
          description: Receipt ID
        message_id:
          type: string
          format: uuid
          description: Message ID
        user_id:
          type: string
          format: uuid
          description: User who received/read the message
        status:
          type: string
          enum:
            - delivered
            - read
          description: Receipt status
        at:
          type: string
          format: date-time
          description: Timestamp of the receipt
      required:
        - id
        - message_id
        - user_id
        - status
        - at

    # ========================================================================
    # Group Schemas
    # ========================================================================
    CreateGroupPayload:
      type: object
      description: Request payload for creating a group
      properties:
        title:
          type: string
          description: Group name (1-255 characters)
          minLength: 1
          maxLength: 255
        description:
          type: string
          nullable: true
          description: Group description
        member_ids:
          type: array
          items:
            type: string
            format: uuid
          description: User IDs to add (1-500)
          minItems: 1
      required:
        - title
        - member_ids

    GroupResponse:
      type: object
      description: Group creation response
      properties:
        id:
          type: string
          format: uuid
        title:
          type: string
        description:
          type: string
          nullable: true
        is_group:
          type: boolean
        created_by:
          type: string
          format: uuid
        created_at:
          type: string
          format: date-time
        member_count:
          type: integer
        members:
          type: array
          items:
            type: object
            properties:
              user_id:
                type: string
                format: uuid
              joined_at:
                type: string
                format: date-time
      required:
        - id
        - title
        - is_group
        - created_by
        - created_at
        - member_count

    # ========================================================================
    # Notification Schemas
    # ========================================================================
    PushNotifyPayload:
      type: object
      description: Request payload for push notifications
      properties:
        conversation_id:
          type: string
          format: uuid
          description: Target conversation
        message_id:
          type: string
          format: uuid
          description: Message being notified
        sender_id:
          type: string
          format: uuid
          description: Message sender
        sender_name:
          type: string
          description: Display name of sender
        title:
          type: string
          nullable: true
          description: Notification title
        body:
          type: string
          nullable: true
          description: Notification body
      required:
        - conversation_id
        - message_id
        - sender_id
        - sender_name

    PushNotifyResponse:
      type: object
      description: Push notification response
      properties:
        success:
          type: boolean
        message_id:
          type: string
          format: uuid
        notifications_sent:
          type: integer
        recipients:
          type: array
          items:
            type: object
            properties:
              user_id:
                type: string
                format: uuid
              device_count:
                type: integer
      required:
        - success
        - message_id
        - notifications_sent

    # ========================================================================
    # Conversation Schemas
    # ========================================================================
    Conversation:
      type: object
      description: Messaging conversation (1:1 or group)
      properties:
        id:
          type: string
          format: uuid
          description: Conversation ID
        title:
          type: string
          nullable: true
          description: Conversation title (for groups)
        description:
          type: string
          nullable: true
          description: Conversation description
        is_group:
          type: boolean
          description: Whether this is a group conversation
        created_by:
          type: string
          format: uuid
          description: User ID who created the conversation
        created_at:
          type: string
          format: date-time
          description: Creation timestamp
        updated_at:
          type: string
          format: date-time
          description: Last update timestamp
      required:
        - id
        - is_group
        - created_by
        - created_at
        - updated_at

    ConversationParticipant:
      type: object
      description: User participation in a conversation
      properties:
        id:
          type: string
          format: uuid
        conversation_id:
          type: string
          format: uuid
        user_id:
          type: string
          format: uuid
        joined_at:
          type: string
          format: date-time
        last_read_at:
          type: string
          format: date-time
          nullable: true
      required:
        - id
        - conversation_id
        - user_id
        - joined_at

    # ========================================================================
    # Profile Schemas
    # ========================================================================
    Profile:
      type: object
      description: User profile
      properties:
        id:
          type: string
          format: uuid
        user_id:
          type: string
          format: uuid
        username:
          type: string
          description: Unique username
        display_name:
          type: string
          nullable: true
          description: Display name
        avatar_url:
          type: string
          format: uri
          nullable: true
          description: Avatar image URL
        bio:
          type: string
          nullable: true
          description: User bio
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time
      required:
        - id
        - user_id
        - username
        - created_at
        - updated_at

    Device:
      type: object
      description: User device for push notifications
      properties:
        id:
          type: string
          format: uuid
        user_id:
          type: string
          format: uuid
        fcm_token:
          type: string
          description: Firebase Cloud Messaging token
        platform:
          type: string
          enum:
            - ios
            - android
            - web
          description: Device platform
        last_seen:
          type: string
          format: date-time
          description: Last activity timestamp
        created_at:
          type: string
          format: date-time
      required:
        - id
        - user_id
        - fcm_token
        - platform
        - created_at
</file>

<file path="frontend/lib/app.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/features/auth/screens/auth_screen.dart';
import 'package:messageai/features/conversations/screens/conversations_list_screen.dart';
import 'package:messageai/features/messages/screens/message_screen.dart';
import 'package:messageai/state/providers.dart';
import 'package:messageai/services/device_registration_service.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

/// Global navigator key for deep linking and navigation from notifications
final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

/// Main application widget with lifecycle monitoring
class MessageAIApp extends ConsumerStatefulWidget {
  const MessageAIApp({Key? key}) : super(key: key);

  @override
  ConsumerState<MessageAIApp> createState() => _MessageAIAppState();
}

class _MessageAIAppState extends ConsumerState<MessageAIApp> with WidgetsBindingObserver {
  final _deviceRegistration = DeviceRegistrationService();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    // Update last_seen on app launch
    _updateLastSeen();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      // App came to foreground - update last_seen
      _updateLastSeen();
    }
  }

  Future<void> _updateLastSeen() async {
    try {
      print('⏰ Updating device last_seen...');
      final token = await FirebaseMessaging.instance.getToken();
      if (token != null) {
        await _deviceRegistration.updateDeviceLastSeen(token);
        print('✅ Device last_seen updated');
      } else {
        print('⚠️ No FCM token available');
      }
    } catch (e) {
      print('❌ Failed to update last_seen: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'MessageAI',
      navigatorKey: navigatorKey,
      theme: AppTheme.lightTheme,
      darkTheme: AppTheme.darkTheme,
      themeMode: ThemeMode.system,
      home: const AuthGate(),
      routes: {
        '/auth': (_) => AuthScreen(onAuthSuccess: () {}),
        '/conversations': (_) => const ConversationsListScreen(),
      },
      // ✅ Handle dynamic routes for deep linking (e.g., /conversation/:id)
      onGenerateRoute: (settings) {
        // Handle conversation deep links
        if (settings.name?.startsWith('/conversation/') ?? false) {
          final conversationId = settings.name!.split('/').last;
          
          print('🔗 Deep link: navigating to conversation $conversationId');
          
          return MaterialPageRoute(
            builder: (_) => MessageScreen(
              conversationId: conversationId,
              conversationTitle: 'Chat', // Will be loaded by screen
            ),
            settings: settings,
          );
        }
        
        // Return null for unknown routes (will show error page)
        return null;
      },
    );
  }
}

/// Widget that routes between auth and main screens based on session
class AuthGate extends ConsumerWidget {
  const AuthGate({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isAuthenticated = ref.watch(isAuthenticatedProvider);

    return isAuthenticated.when(
      data: (authenticated) {
        if (authenticated) {
          return const ConversationsListScreen();
        } else {
          return AuthScreen(
            onAuthSuccess: () {
              // Refresh auth state - this will trigger a rebuild
              ref.refresh(isAuthenticatedProvider);
            },
          );
        }
      },
      loading: () {
        return Scaffold(
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.chat_bubble,
                  size: 64,
                  color: Theme.of(context).colorScheme.primary,
                ),
                const SizedBox(height: 24),
                Text(
                  'MessageAI',
                  style: Theme.of(context).textTheme.headlineSmall,
                ),
                const SizedBox(height: 32),
                const CircularProgressIndicator(),
              ],
            ),
          ),
        );
      },
      error: (error, stackTrace) {
        return Scaffold(
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.error_outline,
                  size: 64,
                  color: Theme.of(context).colorScheme.error,
                ),
                const SizedBox(height: 24),
                Text(
                  'Error',
                  style: Theme.of(context).textTheme.headlineSmall,
                ),
                const SizedBox(height: 16),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 24),
                  child: Text(
                    error.toString(),
                    textAlign: TextAlign.center,
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}
</file>

<file path="frontend/lib/data/drift/daos/message_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'message_dao.g.dart';

@DriftAccessor(tables: [Messages])
class MessageDao extends DatabaseAccessor<AppDb> with _$MessageDaoMixin {
  MessageDao(AppDb db) : super(db);

  /// Get all messages for a conversation ordered by creation time (oldest first)
  Future<List<Message>> getMessagesByConversation(String conversationId) async {
    final results = await (select(messages)
          ..where((m) => m.conversationId.equals(conversationId))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.asc)]))
        .get();
    
    // Debug: Print message order
    if (results.isNotEmpty) {
      print('📊 Messages loaded: ${results.length} total');
      final firstBody = results.first.body.length > 20 
          ? '${results.first.body.substring(0, 20)}...' 
          : results.first.body;
      final lastBody = results.last.body.length > 20 
          ? '${results.last.body.substring(0, 20)}...' 
          : results.last.body;
      print('   First message: "$firstBody" at timestamp ${results.first.createdAt}');
      print('   Last message: "$lastBody" at timestamp ${results.last.createdAt}');
    }
    
    return results;
  }

  /// Get recent messages for a conversation
  Future<List<Message>> getRecentMessages(String conversationId, {int limit = 50}) async {
    return (select(messages)
          ..where((m) => m.conversationId.equals(conversationId))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.desc)])
          ..limit(limit))
        .get();
  }

  /// Insert a new message
  Future<void> insertMessage(Message message) async {
    await into(messages).insert(message);
  }

  /// Update message sync status
  Future<void> markMessageAsSynced(String messageId) async {
    await (update(messages)..where((m) => m.id.equals(messageId)))
        .write(const MessagesCompanion(isSynced: Value(true)));
  }

  /// Get unsynced messages
  Future<List<Message>> getUnsyncedMessages() async {
    return (select(messages)..where((m) => m.isSynced.equals(false)))
        .get();
  }

  /// Delete message by ID
  Future<int> deleteMessage(String id) async {
    return (delete(messages)..where((m) => m.id.equals(id))).go();
  }

  /// Get message by ID
  Future<Message?> getMessageById(String id) async {
    return (select(messages)..where((m) => m.id.equals(id)))
        .getSingleOrNull();
  }

  /// Get the most recent message for a conversation
  Future<Message?> getLatestMessageForConversation(String conversationId) async {
    return (select(messages)
          ..where((m) => m.conversationId.equals(conversationId))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.desc)])
          ..limit(1))
        .getSingleOrNull();
  }

  /// Get unsynced message count
  Future<int> getUnsyncedMessageCount() async {
    final result = await (select(messages)..where((m) => m.isSynced.equals(false))).get();
    return result.length;
  }

  /// Search messages in a conversation
  Future<List<Message>> searchMessages(String conversationId, String query) async {
    return (select(messages)
          ..where((m) => m.conversationId.equals(conversationId) & m.body.contains(query))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.desc)]))
        .get();
  }

  /// Insert multiple messages
  Future<void> insertMessages(List<Message> messageList) async {
    await batch((batch) {
      batch.insertAll(messages, messageList);
    });
  }

  /// Upsert a message (insert or update)
  Future<void> upsertMessage(Message message) async {
    await into(messages).insertOnConflictUpdate(message);
  }
}
</file>

<file path="frontend/lib/data/drift/daos/participant_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'participant_dao.g.dart';

@DriftAccessor(tables: [Participants])
class ParticipantDao extends DatabaseAccessor<AppDb> with _$ParticipantDaoMixin {
  ParticipantDao(AppDb db) : super(db);

  /// Get all participants in a conversation
  Future<List<Participant>> getParticipantsByConversation(String conversationId) async {
    return (select(participants)
          ..where((p) => p.conversationId.equals(conversationId)))
        .get();
  }

  /// Get participant by ID
  Future<Participant?> getParticipantById(String id) async {
    return (select(participants)..where((p) => p.id.equals(id)))
        .getSingleOrNull();
  }

  /// Get participant by conversation ID and user ID
  Future<Participant?> getParticipant(String conversationId, String userId) async {
    return (select(participants)
          ..where((p) =>
              p.conversationId.equals(conversationId) & p.userId.equals(userId)))
        .getSingleOrNull();
  }

  /// Add participant to conversation (upsert to avoid duplicates)
  Future<void> addParticipant(Participant participant) async {
    await into(participants).insertOnConflictUpdate(participant);
  }

  /// Batch add participants
  Future<void> addParticipants(List<Participant> parts) async {
    await batch((batch) {
      batch.insertAll(participants, parts, mode: InsertMode.insertOrReplace);
    });
  }

  /// Remove participant from conversation
  Future<int> removeParticipant(String conversationId, String userId) async {
    return (delete(participants)
          ..where((p) =>
              p.conversationId.equals(conversationId) & p.userId.equals(userId)))
        .go();
  }

  /// Remove participant by ID
  Future<int> removeParticipantById(String id) async {
    return (delete(participants)..where((p) => p.id.equals(id))).go();
  }

  /// Remove all participants from conversation
  Future<int> removeConversationParticipants(String conversationId) async {
    return (delete(participants)..where((p) => p.conversationId.equals(conversationId)))
        .go();
  }

  /// Promote participant to admin
  Future<void> promoteToAdmin(String id) async {
    await (update(participants)..where((p) => p.id.equals(id)))
        .write(const ParticipantsCompanion(isAdmin: Value(true)));
  }

  /// Demote participant from admin
  Future<void> demoteFromAdmin(String id) async {
    await (update(participants)..where((p) => p.id.equals(id)))
        .write(const ParticipantsCompanion(isAdmin: Value(false)));
  }

  /// Get admin count for conversation
  Future<int> getAdminCount(String conversationId) async {
    final result = await (select(participants)
          ..where((p) =>
              p.conversationId.equals(conversationId) & p.isAdmin.equals(true)))
        .get();
    return result.length;
  }

  /// Get participant count for a conversation
  Future<int> getParticipantCount(String conversationId) async {
    final result = await (select(participants)
          ..where((p) => p.conversationId.equals(conversationId)))
        .get();
    return result.length;
  }

  /// Check if user is participant in conversation
  Future<bool> isParticipant(String conversationId, String userId) async {
    final participant = await getParticipant(conversationId, userId);
    return participant != null;
  }

  /// Check if user is admin in conversation
  Future<bool> isAdmin(String conversationId, String userId) async {
    final participant = await getParticipant(conversationId, userId);
    return participant?.isAdmin ?? false;
  }

  /// Mark participants as synced
  Future<void> markParticipantsAsSynced(List<String> ids) async {
    await batch((batch) {
      for (final id in ids) {
        batch.update(participants, const ParticipantsCompanion(isSynced: Value(true)),
            where: (p) => p.id.equals(id));
      }
    });
  }
}
</file>

<file path="frontend/lib/features/messages/screens/message_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/message_service.dart';
import 'package:messageai/services/conversation_service.dart';
import 'package:messageai/services/presence_service.dart';
import 'package:messageai/services/realtime_message_service.dart';
import 'package:messageai/services/typing_indicator_service.dart';
import 'package:messageai/services/context_preloader_service.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/widgets/user_avatar.dart';
import 'package:messageai/widgets/sliding_panel.dart';
import 'package:messageai/features/messages/widgets/message_list_panel.dart';
import 'package:messageai/features/messages/widgets/ai_insights_panel.dart';
import 'package:messageai/features/conversations/widgets/context_preview_card.dart';
import 'package:messageai/features/conversations/widgets/who_is_this_button.dart';
import 'package:messageai/models/conversation_context.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:image_picker/image_picker.dart';
import 'package:uuid/uuid.dart';
import 'dart:async';
import 'dart:io';

class MessageScreen extends StatefulWidget {
  final String conversationId;
  final String conversationTitle;

  const MessageScreen({
    Key? key,
    required this.conversationId,
    required this.conversationTitle,
  }) : super(key: key);

  @override
  State<MessageScreen> createState() => _MessageScreenState();
}

class _MessageScreenState extends State<MessageScreen> {
  final _messageService = MessageService();
  final _conversationService = ConversationService();
  final _presenceService = PresenceService();
  final _realtimeService = RealTimeMessageService();
  final _typingService = TypingIndicatorService();
  final _contextService = ContextPreloaderService();
  final _receiptDao = AppDb.instance.receiptDao;
  final _messageController = TextEditingController();
  final _imagePicker = ImagePicker();
  late Future<List<Message>> _messagesFuture;
  late Future<List<Participant>> _participantsFuture;
  bool _isSending = false;
  bool _isUploadingImage = false;
  String? _currentUserId;
  Map<String, List<Receipt>> _receiptsCache = {};
  Set<String> _typingUsers = {};
  Timer? _typingTimer;
  XFile? _selectedImage;
  Set<String> _onlineUsers = {};
  double _panelPosition = 0.8; // Track sliding panel position (0.0 = down, 1.0 = up)
  ConversationContext? _conversationContext;

  @override
  void initState() {
    super.initState();
    _currentUserId = _messageService.getCurrentUserId();
    
    // Sync messages from backend first, then load
    _messagesFuture = _messageService.getMessagesByConversation(
      widget.conversationId,
      syncFirst: true,
    );
    _participantsFuture = _conversationService.getParticipants(widget.conversationId);
    
    // Initialize real-time features
    _initializeRealtime();
    
    // Load receipts
    _loadReceipts();
    
    // Load conversation context
    _loadContext();
    
    // Mark messages as read when opening conversation
    _messagesFuture.then((_) => _markMessagesAsRead());
    
    // Listen for text changes to send typing indicators
    _messageController.addListener(_onTextChanged);
  }

  Future<void> _loadContext() async {
    try {
      final context = await _contextService.loadContext(widget.conversationId);
      if (mounted) {
        setState(() {
          _conversationContext = context;
        });
      }
    } catch (e) {
      print('Error loading context: $e');
    }
  }

  Future<void> _loadReceipts() async {
    try {
      final receipts = await _receiptDao.getReceiptsByConversation(widget.conversationId);
      setState(() {
        _receiptsCache.clear();
        for (final receipt in receipts) {
          if (!_receiptsCache.containsKey(receipt.messageId)) {
            _receiptsCache[receipt.messageId] = [];
          }
          _receiptsCache[receipt.messageId]!.add(receipt);
        }
      });
    } catch (e) {
      print('Error loading receipts: $e');
    }
  }

  Future<void> _markMessagesAsRead() async {
    try {
      if (_currentUserId == null) return;
      
      // Get all messages
      final messages = await _messagesFuture;
      
      // Find unread messages from others
      for (final message in messages) {
        // Skip own messages
        if (message.senderId == _currentUserId) continue;
        
        // Check if we already have a read receipt
        final existingReceipts = _receiptsCache[message.id] ?? [];
        final hasReadReceipt = existingReceipts.any((r) => 
          r.userId == _currentUserId && r.status == 'read'
        );
        
        if (!hasReadReceipt) {
          await _createReadReceipt(message.id);
        }
      }
    } catch (e) {
      print('Error marking messages as read: $e');
    }
  }

  Future<void> _createReadReceipt(String messageId) async {
    try {
      if (_currentUserId == null) return;
      
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      
      // Check if receipt already exists
      final existingReceipt = await _receiptDao.getReceipt(messageId, _currentUserId!);
      
      if (existingReceipt != null) {
        // Update existing receipt to "read"
        await _receiptDao.updateReceiptStatus(messageId, _currentUserId!, 'read');
        
        // Sync to backend
        final supabase = SupabaseClientProvider.client;
        await supabase.from('message_receipts')
          .update({
            'status': 'read',
            'at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
          })
          .eq('message_id', messageId)
          .eq('user_id', _currentUserId!);
      } else {
        // Create new receipt
        final receiptId = const Uuid().v4();
        final receipt = Receipt(
          id: receiptId,
          messageId: messageId,
          userId: _currentUserId!,
          status: 'read',
          createdAt: now,
          updatedAt: now,
          isSynced: false,
        );
        
        await _receiptDao.addReceipt(receipt);
        
        final supabase = SupabaseClientProvider.client;
        await supabase.from('message_receipts').insert({
          'id': receiptId,
          'message_id': messageId,
          'user_id': _currentUserId,
          'status': 'read',
          'at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
        });
        
        await _receiptDao.markReceiptAsSynced(receiptId);
      }
    } catch (e) {
      print('Error creating read receipt: $e');
    }
  }

  Timer? _pollTimer;
  Timer? _presenceCheckTimer;

  Future<void> _initializeRealtime() async {
    try {
      // Subscribe to presence updates
      await _presenceService.subscribeToPresence(widget.conversationId);
      // Set current user as online
      await _presenceService.setPresenceStatus(widget.conversationId, true);
      
      // Poll presence status every 2 seconds to update UI
      _presenceCheckTimer = Timer.periodic(const Duration(seconds: 2), (timer) {
        if (mounted) {
          setState(() {
            _onlineUsers = _presenceService.getOnlineUsers(widget.conversationId);
          });
        }
      });
      
      // Subscribe to real-time messages
      _realtimeService.subscribeToMessages(widget.conversationId).listen((messages) {
        setState(() {
          _messagesFuture = Future.value(messages);
        });
        _loadReceipts();
        _markMessagesAsRead(); // Mark new messages as read
      });
      
      // Subscribe to real-time receipts
      _realtimeService.subscribeToReceipts(widget.conversationId).listen((receipts) {
        print('📬 Receipt update: ${receipts.length} total receipts');
        setState(() {
          _receiptsCache.clear();
          for (final receipt in receipts) {
            if (!_receiptsCache.containsKey(receipt.messageId)) {
              _receiptsCache[receipt.messageId] = [];
            }
            _receiptsCache[receipt.messageId]!.add(receipt);
            print('   - Message ${receipt.messageId.substring(0, 8)}: ${receipt.status} by ${receipt.userId.substring(0, 8)}');
          }
        });
      });
      
      // Subscribe to typing indicators
      _typingService.subscribeToTyping(widget.conversationId).listen((typingUserIds) {
        setState(() {
          _typingUsers = typingUserIds;
        });
      });
    } catch (e) {
      print('❌ Realtime init failed: $e');
    }
  }

  @override
  void dispose() {
    _messageController.removeListener(_onTextChanged);
    _messageController.dispose();
    _typingTimer?.cancel();
    _pollTimer?.cancel();
    _presenceCheckTimer?.cancel();
    // Set user as offline before leaving
    _presenceService.setPresenceStatus(widget.conversationId, false);
    // Clean up realtime subscriptions
    _presenceService.unsubscribeFromPresence(widget.conversationId);
    _realtimeService.unsubscribeFromMessages(widget.conversationId);
    _realtimeService.unsubscribeFromReceipts(widget.conversationId);
    _typingService.unsubscribeFromTyping(widget.conversationId);
    super.dispose();
  }

  void _onTextChanged() {
    if (_messageController.text.isNotEmpty) {
      // User is typing
      _typingService.sendTypingIndicator(widget.conversationId, true);
      
      // Reset the timer
      _typingTimer?.cancel();
      _typingTimer = Timer(const Duration(seconds: 2), () {
        // Stop typing after 2 seconds of inactivity
        _typingService.sendTypingIndicator(widget.conversationId, false);
      });
    } else {
      // User cleared text, stop typing
      _typingTimer?.cancel();
      _typingService.sendTypingIndicator(widget.conversationId, false);
    }
  }

  Future<void> _pickImage() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 1920,
        maxHeight: 1920,
        imageQuality: 85,
      );
      
      if (image != null) {
        setState(() {
          _selectedImage = image;
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error picking image: $e')),
        );
      }
    }
  }

  Future<String?> _uploadImage(XFile image) async {
    setState(() => _isUploadingImage = true);
    
    try {
      final userId = SupabaseClientProvider.client.auth.currentUser?.id;
      if (userId == null) throw Exception('User not authenticated');
      
      final fileBytes = await image.readAsBytes();
      final fileName = '${DateTime.now().millisecondsSinceEpoch}_${image.name}';
      final path = '$userId/$fileName';
      
      await SupabaseClientProvider.client.storage
          .from('media')
          .uploadBinary(path, fileBytes);
      
      final url = SupabaseClientProvider.client.storage
          .from('media')
          .getPublicUrl(path);
      
      return url;
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error uploading image: $e')),
        );
      }
      return null;
    } finally {
      if (mounted) {
        setState(() => _isUploadingImage = false);
      }
    }
  }

  Future<void> _sendMessage() async {
    final messageText = _messageController.text.trim();
    final hasText = messageText.isNotEmpty;
    final hasImage = _selectedImage != null;
    
    if (!hasText && !hasImage) return;
    if (_isSending || _isUploadingImage) return;

    // Clear input immediately for better UX
    _messageController.clear();
    final imageToSend = _selectedImage;
    setState(() {
      _selectedImage = null;
    });
    
    // Stop typing indicator when message is sent
    _typingTimer?.cancel();
    _typingService.sendTypingIndicator(widget.conversationId, false);

    setState(() => _isSending = true);

    try {
      String? mediaUrl;
      
      // Upload image if present
      if (imageToSend != null) {
        mediaUrl = await _uploadImage(imageToSend);
        if (mediaUrl == null) {
          throw Exception('Failed to upload image');
        }
      }
      
      await _messageService.sendMessage(
        conversationId: widget.conversationId,
        body: hasText ? messageText : '📷 Photo',
        mediaUrl: mediaUrl,
      );

      setState(() {
        _messagesFuture = _messageService.getMessagesByConversation(widget.conversationId);
      });
      
      // Reload receipts to update delivery status
      _loadReceipts();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
        _messageController.text = messageText;
        if (imageToSend != null) {
          setState(() {
            _selectedImage = imageToSend;
          });
        }
      }
    } finally {
      if (mounted) {
        setState(() => _isSending = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    return Scaffold(
      backgroundColor: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
      appBar: AppBar(
        title: Row(
          children: [
            Stack(
              children: [
                CircleAvatar(
                  radius: 18,
                  backgroundColor: Colors.grey[300],
                  child: Icon(
                    Icons.group,
                    size: 20,
                    color: Colors.grey[700],
                  ),
                ),
                if (_onlineUsers.isNotEmpty)
                  Positioned(
                    right: 0,
                    bottom: 0,
                    child: Container(
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(
                        color: Colors.green,
                        shape: BoxShape.circle,
                        border: Border.all(color: Colors.white, width: 2),
                      ),
                      child: Text(
                        '${_onlineUsers.length}',
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
              ],
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    widget.conversationTitle,
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  if (_onlineUsers.isNotEmpty)
                    Text(
                      '${_onlineUsers.length} online',
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.white.withOpacity(0.8),
                      ),
                    ),
                ],
              ),
            ),
          ],
        ),
        elevation: 1,
        actions: [
          WhoIsThisButton(
            conversationId: widget.conversationId,
            compact: true,
          ),
          IconButton(
            icon: const Icon(Icons.person_add),
            onPressed: _showAddParticipantsDialog,
            tooltip: 'Add participants',
          ),
          IconButton(
            icon: const Icon(Icons.more_vert),
            onPressed: () => _showParticipantsInfo(context),
            tooltip: 'Options',
          ),
        ],
      ),
      body: FutureBuilder<List<Message>>(
        future: _messagesFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(
              child: Text(
                'Error: ${snapshot.error}',
                style: theme.textTheme.bodyMedium,
              ),
            );
          }

          final messages = snapshot.data ?? [];

          return Column(
            children: [
              // Context Preview at top
              if (_conversationContext != null)
                ContextPreviewCard(
                  context: _conversationContext!,
                  onTap: () {
                    // Could expand to show more details or scroll
                  },
                ),
              
              // Main message area
              Expanded(
                child: Stack(
                  children: [
                    // Background: AI Insights Panel
                    AIInsightsPanel(
                      conversationId: widget.conversationId,
                      messages: messages,
                      panelPosition: _panelPosition,
                    ),
                    
                    // Foreground: Sliding Message Panel
                    SlidingPanel(
                      onSlide: (position) {
                        setState(() {
                          _panelPosition = position;
                        });
                      },
                      child: MessageListPanel(
                        messages: messages,
                        currentUserId: _currentUserId,
                        receiptsCache: _receiptsCache,
                        typingUsers: _typingUsers,
                        onlineUsers: _onlineUsers,
                        messageController: _messageController,
                        isSending: _isSending,
                        isUploadingImage: _isUploadingImage,
                        selectedImage: _selectedImage,
                        onSendMessage: _sendMessage,
                        onPickImage: _pickImage,
                        onClearImage: () {
                          setState(() {
                            _selectedImage = null;
                          });
                        },
                      ),
                    ),
                  ],
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  void _showAddParticipantsDialog() {
    final emailController = TextEditingController();
    bool isSearching = false;
    
    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: const Text('Add Participant'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                controller: emailController,
                decoration: InputDecoration(
                  hintText: 'Enter email address',
                  helperText: 'Example: user@example.com',
                  prefixIcon: const Icon(Icons.email),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
                keyboardType: TextInputType.emailAddress,
                autofocus: true,
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: isSearching ? null : () async {
                final email = emailController.text.trim();
                if (email.isEmpty) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Please enter an email')),
                  );
                  return;
                }

                setState(() => isSearching = true);

                try {
                  // Add participant by email using database function
                  final response = await SupabaseClientProvider.client
                      .rpc('add_participant_by_email', params: {
                    'p_conversation_id': widget.conversationId,
                    'p_email': email,
                  });

                  final result = response as Map<String, dynamic>;
                  
                  if (result['success'] == false) {
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text(result['error'] ?? 'Failed to add participant')),
                      );
                    }
                    setState(() => isSearching = false);
                    return;
                  }
                  
                  if (mounted) {
                    Navigator.pop(context);
                    // Force refresh participants from backend
                    this.setState(() {
                      _participantsFuture = _conversationService.getParticipants(
                        widget.conversationId, 
                        syncFirst: true,  // Force sync from backend
                      );
                    });
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Added $email to conversation')),
                    );
                  }
                } catch (e) {
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Error: $e')),
                    );
                  }
                  setState(() => isSearching = false);
                }
              },
              child: isSearching 
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Text('Add'),
            ),
          ],
        ),
      ),
    );
  }

  void _showParticipantsInfo(BuildContext context) {
    showModalBottomSheet(
      context: context,
      builder: (context) => FutureBuilder<List<Participant>>(
        future: _participantsFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(child: Text('Error: ${snapshot.error}'));
          }

          final participants = snapshot.data ?? [];

          return SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Participants (${participants.length})',
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                  const SizedBox(height: 16),
                  if (participants.isEmpty)
                    const Center(
                      child: Padding(
                        padding: EdgeInsets.all(16),
                        child: Text('No participants yet'),
                      ),
                    )
                  else
                    ListView.builder(
                      shrinkWrap: true,
                      physics: const NeverScrollableScrollPhysics(),
                      itemCount: participants.length,
                      itemBuilder: (context, index) {
                        final participant = participants[index];
                        final isOnline = _presenceService.isUserOnline(
                          widget.conversationId,
                          participant.userId,
                        );
                        
                        return FutureBuilder<Map<String, dynamic>?>(
                          future: _conversationService.getParticipantProfile(participant.userId),
                          builder: (context, profileSnapshot) {
                            final profile = profileSnapshot.data;
                            final displayName = profile?['email'] as String? ?? 
                                              profile?['username'] as String? ?? 
                                              profile?['display_name'] as String? ??
                                              participant.userId.substring(0, 8);
                            final avatarUrl = profile?['avatar_url'] as String?;
                            final initial = displayName.isNotEmpty 
                                ? displayName[0].toUpperCase() 
                                : 'U';
                            
                            return ListTile(
                              leading: Stack(
                                children: [
                                  CircleAvatar(
                                    backgroundImage: avatarUrl != null
                                        ? NetworkImage(avatarUrl)
                                        : null,
                                    child: avatarUrl == null
                                        ? Text(initial)
                                        : null,
                                  ),
                                  Positioned(
                                    right: 0,
                                    bottom: 0,
                                    child: Container(
                                      width: 12,
                                      height: 12,
                                      decoration: BoxDecoration(
                                        color: isOnline ? Colors.green : Colors.grey,
                                        shape: BoxShape.circle,
                                        border: Border.all(
                                          color: Colors.white,
                                          width: 2,
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                              title: Text(displayName),
                              subtitle: Text(
                                isOnline
                                    ? (participant.isAdmin ? 'Admin • Online' : 'Member • Online')
                                    : (participant.isAdmin ? 'Admin • Offline' : 'Member • Offline'),
                              ),
                              trailing: participant.userId != _currentUserId
                                  ? IconButton(
                                      icon: const Icon(Icons.remove_circle),
                                      onPressed: () {
                                        Navigator.pop(context);
                                        _removeParticipant(participant.userId);
                                      },
                                    )
                                  : null,
                            );
                          },
                        );
                      },
                    ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Future<void> _removeParticipant(String userId) async {
    try {
      await _conversationService.removeParticipant(
        widget.conversationId,
        userId,
      );
      setState(() {
        _participantsFuture = _conversationService.getParticipants(widget.conversationId);
      });
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Participant removed')),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    }
  }

}
</file>

<file path="frontend/lib/features/conversations/screens/conversations_list_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/conversation_service.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/features/messages/screens/message_screen.dart';
import 'package:messageai/features/settings/screens/settings_screen.dart';
import 'package:messageai/widgets/network_status_banner.dart';
import 'package:messageai/widgets/user_avatar.dart';

/// Screen showing list of conversations
class ConversationsListScreen extends StatefulWidget {
  const ConversationsListScreen({Key? key}) : super(key: key);

  @override
  State<ConversationsListScreen> createState() =>
      _ConversationsListScreenState();
}

class _ConversationsListScreenState extends State<ConversationsListScreen> {
  final _conversationService = ConversationService();
  late Future<List<Conversation>> _conversationsFuture;

  @override
  void initState() {
    super.initState();
    _conversationsFuture = _conversationService.getAllConversations();
  }
  
  // Add pull-to-refresh
  Future<void> _refreshConversations() async {
    setState(() {
      _conversationsFuture = _conversationService.getAllConversations(syncFirst: true);
    });
  }

  void _showNewConversationDialog() {
    final titleController = TextEditingController();
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('New Conversation'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: titleController,
              decoration: InputDecoration(
                hintText: 'Conversation title',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
              autofocus: true,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () async {
              if (titleController.text.isEmpty) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Please enter a title')),
                );
                return;
              }

              try {
                await _conversationService.createConversation(
                  title: titleController.text,
                );
                if (mounted) {
                  Navigator.pop(context);
                  setState(() {
                    // Don't re-sync from backend (keeps deleted convos deleted)
                    _conversationsFuture =
                        _conversationService.getAllConversations(syncFirst: false);
                  });
                }
              } catch (e) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Error: $e')),
                  );
                }
              }
            },
            child: const Text('Create'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('MessageAI'),
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.settings),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const SettingsScreen(),
                ),
              );
            },
            tooltip: 'Settings',
          ),
        ],
      ),
      body: Column(
        children: [
          const NetworkStatusBanner(),
          Expanded(
            child: RefreshIndicator(
              onRefresh: _refreshConversations,
              child: FutureBuilder<List<Conversation>>(
          future: _conversationsFuture,
          builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.error_outline,
                    size: 64,
                    color: Theme.of(context).colorScheme.error,
                  ),
                  const SizedBox(height: 16),
                  Text('Error: ${snapshot.error}'),
                ],
              ),
            );
          }

          final conversations = snapshot.data ?? [];

          if (conversations.isEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.chat_outlined,
                    size: 80,
                    color: Theme.of(context)
                        .colorScheme
                        .primary
                        .withOpacity(0.3),
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'No conversations yet',
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Start a new conversation to begin messaging',
                    style: Theme.of(context).textTheme.bodyMedium,
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 32),
                  ElevatedButton.icon(
                    onPressed: _showNewConversationDialog,
                    icon: const Icon(Icons.add),
                    label: const Text('New Conversation'),
                  ),
                ],
              ),
            );
          }

          return ListView.separated(
            itemCount: conversations.length,
            separatorBuilder: (context, index) => Divider(
              height: 1,
              indent: 72,
              color: Colors.grey[300],
            ),
            itemBuilder: (context, index) {
              final conv = conversations[index];
              return Dismissible(
                key: Key(conv.id),
                direction: DismissDirection.endToStart,
                background: Container(
                  alignment: Alignment.centerRight,
                  padding: const EdgeInsets.only(right: 20),
                  color: Colors.red,
                  child: const Icon(
                    Icons.delete,
                    color: Colors.white,
                  ),
                ),
                confirmDismiss: (direction) async {
                  return await showDialog(
                    context: context,
                    builder: (BuildContext context) {
                      return AlertDialog(
                        title: const Text('Delete Conversation'),
                        content: Text(
                          'Are you sure you want to delete "${conv.title}"? This cannot be undone.',
                        ),
                        actions: [
                          TextButton(
                            onPressed: () => Navigator.of(context).pop(false),
                            child: const Text('Cancel'),
                          ),
                          TextButton(
                            onPressed: () => Navigator.of(context).pop(true),
                            style: TextButton.styleFrom(
                              foregroundColor: Colors.red,
                            ),
                            child: const Text('Delete'),
                          ),
                        ],
                      );
                    },
                  );
                },
                onDismissed: (direction) async {
                  try {
                    await _conversationService.deleteConversation(conv.id);
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text('Deleted "${conv.title}"')),
                      );
                      setState(() {
                        // Refresh from local DB only (don't re-sync from backend)
                        _conversationsFuture = _conversationService.getAllConversations(syncFirst: false);
                      });
                    }
                  } catch (e) {
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text('Error deleting conversation: $e')),
                      );
                      setState(() {
                        // Re-sync to refresh the list
                        _conversationsFuture = _conversationService.getAllConversations(syncFirst: true);
                      });
                    }
                  }
                },
                child: InkWell(
                  onTap: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => MessageScreen(
                          conversationId: conv.id,
                          conversationTitle: conv.title,
                        ),
                      ),
                    );
                  },
                  child: Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                    child: Row(
                      children: [
                        UserAvatar(
                          fallbackText: conv.title,
                          radius: 28,
                          isGroup: conv.isGroup,
                          // Note: We don't have userId for conversation participant here
                          // In a full implementation, we'd fetch the other user's ID
                          // For now, fallback to initials
                        ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              conv.title,
                              style: const TextStyle(
                                fontSize: 16,
                                fontWeight: FontWeight.w600,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                            const SizedBox(height: 4),
                            FutureBuilder<Message?>(
                              future: _conversationService.getLatestMessage(conv.id),
                              builder: (context, snapshot) {
                                String previewText = 'Tap to start messaging';
                                
                                if (snapshot.hasData && snapshot.data != null) {
                                  final message = snapshot.data!;
                                  if (message.mediaUrl != null && message.mediaUrl!.isNotEmpty) {
                                    previewText = '📷 ${message.body}';
                                  } else {
                                    previewText = message.body;
                                  }
                                }
                                
                                return Text(
                                  previewText,
                                  style: TextStyle(
                                    fontSize: 14,
                                    color: Colors.grey[600],
                                  ),
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis,
                                );
                              },
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(width: 8),
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.end,
                        children: [
                          Text(
                            _formatTime(conv.lastMessageAt),
                            style: TextStyle(
                              fontSize: 12,
                              color: Theme.of(context).colorScheme.primary,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                ),
              );
            },
          );
          },
              ),
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _showNewConversationDialog,
        child: const Icon(Icons.add),
      ),
    );
  }

  String _formatTime(int? timestamp) {
    if (timestamp == null) return '';
    final dateTime = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inMinutes < 1) {
      return 'now';
    } else if (difference.inHours < 1) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inDays < 1) {
      return '${difference.inHours}h ago';
    } else if (difference.inDays < 7) {
      return '${difference.inDays}d ago';
    } else {
      return '${dateTime.month}/${dateTime.day}';
    }
  }
}
</file>

<file path="frontend/lib/main.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:messageai/core/env.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/state/notification_providers.dart';
import 'package:messageai/services/network_connectivity_service.dart';
import 'package:messageai/services/offline_queue_service.dart';
import 'package:messageai/app.dart';
import 'firebase_options.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

/// Background message handler for Firebase Cloud Messaging
/// This MUST be a top-level function (not inside a class)
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // Initialize Firebase if not already done
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  
  print('🔔 Background message received!');
  print('   Title: ${message.notification?.title}');
  print('   Body: ${message.notification?.body}');
  print('   Data: ${message.data}');
  
  // Handle the background message here if needed
  // For now, just log it - the system notification will still appear
}

void main() async {
  // Ensure Flutter bindings are initialized
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase (required before any Firebase services)
  try {
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    print('✅ Firebase initialized successfully');
    
    // Register background message handler (must be done after Firebase init)
    FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
    print('✅ Background message handler registered');
  } catch (e) {
    print('❌ Firebase initialization error: $e');
    print('Push notifications will not work. Run "flutterfire configure" to set up Firebase.');
  }

  // Validate environment configuration
  Env.validate();

  // Initialize Supabase client
  await SupabaseClientProvider.initialize();

  // Initialize Drift database
  final db = AppDb.instance;
  
  // Initialize network services
  final connectivityService = NetworkConnectivityService();
  connectivityService.startMonitoring();
  
  final offlineQueueService = OfflineQueueService();
  offlineQueueService.startMonitoring();
  
  print('✅ Network services initialized');
  
  // Run the app with Riverpod provider scope
  runApp(
    ProviderScope(
      child: _AppWithNotifications(),
    ),
  );
}

/// Wrapper widget to initialize notifications after ProviderScope
class _AppWithNotifications extends ConsumerWidget {
  const _AppWithNotifications();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Initialize notifications on app start
    final notificationInit = ref.watch(notificationInitializerProvider);
    
    notificationInit.when(
      data: (_) {
        print('🔔 Notifications fully initialized!');
      },
      loading: () {
        print('🔄 Initializing notifications...');
      },
      error: (error, stack) {
        print('❌ Notification initialization error: $error');
        print('Stack trace: $stack');
      },
    );

    return const MessageAIApp();
  }
}
</file>

<file path="frontend/pubspec.yaml">
name: messageai
description: MessageAI - Cross-platform messaging app with Flutter
version: 0.1.0+1
publish_to: none

environment:
  sdk: ^3.0.0
  flutter: ">=3.10.0"

dependencies:
  flutter:
    sdk: flutter

  # Network & API
  supabase_flutter: ^1.10.0
  dio: ^5.3.0

  # State management
  riverpod: ^2.4.0
  flutter_riverpod: ^2.4.0

  # Local database
  drift: ^2.14.0
  drift_flutter: ^0.2.7
  sqlite3_flutter_libs: ^0.5.16

  # Firebase
  firebase_core: ^2.27.0
  firebase_messaging: ^14.6.0

  # Local notifications (Phase 06)
  flutter_local_notifications: ^19.0.0

  # UI
  cupertino_icons: ^1.0.2

  # Utilities
  uuid: ^4.0.0
  image_picker: ^1.0.4
  path: ^1.8.3
  http: ^1.2.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter

  flutter_lints: ^3.0.0

  # Code generation
  build_runner: ^2.4.0
  drift_dev: ^2.14.0

flutter:
  uses-material-design: true

dependency_overrides:
  # Completely exclude sign_in_with_apple (uses deprecated Flutter APIs incompatible with latest Android)
  sign_in_with_apple:
  sign_in_with_apple_platform_interface:
  sign_in_with_apple_web:
</file>

</files>
