This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursor/plans/ui-overhaul---tone-interpreter-7b37f7a4.plan.md
.cursorignore
.gitignore
backend/firebase.env
backend/get-function-logs.sh
backend/Makefile
backend/package.json
backend/start_log.txt
backend/supabase/.gitignore
backend/supabase/config.toml
backend/supabase/db/test/.gitkeep
backend/supabase/db/test/rls_messages_tap.sql
backend/supabase/db/test/rls_participants_tap.sql
backend/supabase/db/triggers/.gitkeep
backend/supabase/db/triggers/messages_notify.sql
backend/supabase/db/triggers/receipts_notify.sql
backend/supabase/functions/_shared/nlp/action-item-extractor.ts
backend/supabase/functions/_shared/nlp/question-detector.ts
backend/supabase/functions/_shared/openai-client.ts
backend/supabase/functions/_shared/prompts/__tests__/alternative-interpretations.test.ts
backend/supabase/functions/_shared/prompts/__tests__/enhanced-tone-analysis.test.ts
backend/supabase/functions/_shared/prompts/__tests__/evidence-extractor.test.ts
backend/supabase/functions/_shared/prompts/__tests__/rsd-detection.test.ts
backend/supabase/functions/_shared/prompts/alternative-interpretations.ts
backend/supabase/functions/_shared/prompts/boundary-analysis.ts
backend/supabase/functions/_shared/prompts/draft_analysis.ts
backend/supabase/functions/_shared/prompts/enhanced-tone-analysis.ts
backend/supabase/functions/_shared/prompts/evidence-extractor.ts
backend/supabase/functions/_shared/prompts/message-formatter.ts
backend/supabase/functions/_shared/prompts/rsd-detection.ts
backend/supabase/functions/_shared/prompts/situation-detector.ts
backend/supabase/functions/_shared/rag/embedding-generator.ts
backend/supabase/functions/_shared/rag/relationship-builder.ts
backend/supabase/functions/_shared/rag/vector-search.ts
backend/supabase/functions/_shared/templates/apologizing-templates.ts
backend/supabase/functions/_shared/templates/boundary-templates.ts
backend/supabase/functions/_shared/templates/clarifying-templates.ts
backend/supabase/functions/_shared/templates/declining-templates.ts
backend/supabase/functions/_shared/templates/index.ts
backend/supabase/functions/_shared/templates/info-dump-templates.ts
backend/supabase/functions/ai_analyze_draft/index.ts
backend/supabase/functions/ai_analyze_tone/index.ts
backend/supabase/functions/ai-context-preloader/index.ts
backend/supabase/functions/ai-extract-followups/index.ts
backend/supabase/functions/ai-format-message/index.ts
backend/supabase/functions/ai-generate-embeddings/index.ts
backend/supabase/functions/ai-interpret-message/index.ts
backend/supabase/functions/ai-relationship-summary/index.ts
backend/supabase/functions/create_group/index.ts
backend/supabase/functions/messages_send/index.ts
backend/supabase/functions/push_notify/index.ts
backend/supabase/functions/receipts_ack/index.ts
backend/supabase/migrations/.gitkeep
backend/supabase/migrations/20251231_000001_smart_interpreter.sql
backend/supabase/migrations/20260101_000001_response_assistant.sql
backend/supabase/migrations/20260102_000001_context_system.sql
backend/supabase/migrations/20260103_000001_followup_system.sql
backend/supabase/migrations/20260104_000001_fix_followup_fk.sql
backend/supabase/migrations/20260106_000001_add_profile_devices_rls.sql
backend/supabase/migrations/20260108_000001_comprehensive_schema_fixes.sql
backend/supabase/policies/conversations.sql
backend/supabase/policies/messages.sql
backend/supabase/policies/participants.sql
backend/supabase/policies/profile_devices.sql
backend/supabase/policies/receipts.sql
backend/supabase/seed_showcase_data.sql
backend/supabase/storage/buckets.sql
backend/test_message_insert.js
contracts/events/message_inserted.schema.json
contracts/events/receipt_inserted.schema.json
contracts/openapi.yaml
contracts/openapitools.json
contracts/package.json
contracts/scripts/generate_dart.sh
docs/Architecture.puml
docs/ERD.puml
frontend/.gitignore
frontend/.metadata
frontend/analysis_options.yaml
frontend/android/.gitignore
frontend/android/app/build.gradle.kts
frontend/android/app/src/debug/AndroidManifest.xml
frontend/android/app/src/main/AndroidManifest.xml
frontend/android/app/src/main/kotlin/com/example/messageai/MainActivity.kt
frontend/android/app/src/main/res/drawable-v21/launch_background.xml
frontend/android/app/src/main/res/drawable/launch_background.xml
frontend/android/app/src/main/res/mipmap-hdpi/ic_launcher.png
frontend/android/app/src/main/res/mipmap-mdpi/ic_launcher.png
frontend/android/app/src/main/res/mipmap-xhdpi/ic_launcher.png
frontend/android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png
frontend/android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
frontend/android/app/src/main/res/values-night/styles.xml
frontend/android/app/src/main/res/values/styles.xml
frontend/android/build.gradle.kts
frontend/android/gradle.properties
frontend/android/settings.gradle.kts
frontend/devtools_options.yaml
frontend/firebase.json
frontend/integration_test/ai_flow_test.dart
frontend/integration_test/all_phases_comprehensive_test.dart
frontend/integration_test/context_system_test.dart
frontend/integration_test/enhanced_tone_analysis_test.dart
frontend/integration_test/phase1_smart_interpreter_test.dart
frontend/integration_test/phase2_response_assistant_test.dart
frontend/integration_test/phase3_context_system_test.dart
frontend/integration_test/phase4_followup_system_test.dart
frontend/lib/app.dart
frontend/lib/core/env.dart
frontend/lib/core/errors/app_error.dart
frontend/lib/core/errors/error_handler.dart
frontend/lib/core/errors/error_ui.dart
frontend/lib/core/theme/app_theme.dart
frontend/lib/data/drift/app_db.dart
frontend/lib/data/drift/daos/conversation_dao.dart
frontend/lib/data/drift/daos/message_dao.dart
frontend/lib/data/drift/daos/participant_dao.dart
frontend/lib/data/drift/daos/pending_outbox_dao.dart
frontend/lib/data/drift/daos/receipt_dao.dart
frontend/lib/data/drift/entities/conversation.drift
frontend/lib/data/remote/supabase_client.dart
frontend/lib/data/repositories/group_repository.dart
frontend/lib/data/repositories/message_repository.dart
frontend/lib/data/repositories/receipt_repository.dart
frontend/lib/features/auth/screens/auth_screen.dart
frontend/lib/features/conversations/screens/conversations_list_screen.dart
frontend/lib/features/conversations/widgets/conversation_filter_chips.dart
frontend/lib/features/conversations/widgets/message_bubble.dart
frontend/lib/features/conversations/widgets/relationship_summary_sheet.dart
frontend/lib/features/follow_ups/widgets/follow_up_badge.dart
frontend/lib/features/messages/screens/message_screen.dart
frontend/lib/features/messages/widgets/ai_insights_background.dart
frontend/lib/features/messages/widgets/context_panel.dart
frontend/lib/features/messages/widgets/draft_feedback_panel.dart
frontend/lib/features/messages/widgets/evidence_viewer.dart
frontend/lib/features/messages/widgets/interpretation_options.dart
frontend/lib/features/messages/widgets/message_bubble.dart
frontend/lib/features/messages/widgets/message_formatter_panel.dart
frontend/lib/features/messages/widgets/message_list_panel.dart
frontend/lib/features/messages/widgets/relationship_type_selector.dart
frontend/lib/features/messages/widgets/rsd_alert_card.dart
frontend/lib/features/messages/widgets/template_picker.dart
frontend/lib/features/messages/widgets/tone_badge.dart
frontend/lib/features/messages/widgets/tone_detail_sheet_simplified.dart
frontend/lib/features/messages/widgets/tone_detail_sheet.dart
frontend/lib/features/notifications/widgets/notification_widgets.dart
frontend/lib/features/settings/screens/settings_screen.dart
frontend/lib/features/settings/widgets/ai_feature_tile.dart
frontend/lib/firebase_options.dart
frontend/lib/gen/api/api.dart
frontend/lib/gen/api/clients/messages_api.dart
frontend/lib/gen/api/clients/receipts_api.dart
frontend/lib/gen/api/models/message_payload.dart
frontend/lib/gen/api/models/receipt_payload.dart
frontend/lib/main.dart
frontend/lib/models/action_item.dart
frontend/lib/models/ai_analysis.dart
frontend/lib/models/ai_feature.dart
frontend/lib/models/context_trigger.dart
frontend/lib/models/conversation_context.dart
frontend/lib/models/conversation_filter.dart
frontend/lib/models/conversation_with_metadata.dart
frontend/lib/models/draft_analysis.dart
frontend/lib/models/draft_confidence.dart
frontend/lib/models/follow_up_item.dart
frontend/lib/models/formatted_message.dart
frontend/lib/models/relationship_profile.dart
frontend/lib/models/response_template.dart
frontend/lib/models/safe_topic.dart
frontend/lib/models/situation_type.dart
frontend/lib/services/ai_analysis_service.dart
frontend/lib/services/auth_service.dart
frontend/lib/services/avatar_service.dart
frontend/lib/services/context_preloader_service.dart
frontend/lib/services/conversation_filter_service.dart
frontend/lib/services/conversation_service.dart
frontend/lib/services/deep_link_handler.dart
frontend/lib/services/device_registration_service.dart
frontend/lib/services/draft_analysis_service.dart
frontend/lib/services/draft_confidence_service.dart
frontend/lib/services/follow_up_service.dart
frontend/lib/services/local_notification_service.dart
frontend/lib/services/media_service.dart
frontend/lib/services/message_formatter_service.dart
frontend/lib/services/message_interpreter_service.dart
frontend/lib/services/message_service.dart
frontend/lib/services/network_connectivity_service.dart
frontend/lib/services/notification_service.dart
frontend/lib/services/offline_queue_service.dart
frontend/lib/services/presence_service.dart
frontend/lib/services/realtime_diagnostic_service.dart
frontend/lib/services/realtime_message_service.dart
frontend/lib/services/relationship_service.dart
frontend/lib/services/relationship_summary_service.dart
frontend/lib/services/response_template_service.dart
frontend/lib/services/retry_service.dart
frontend/lib/services/typing_indicator_service.dart
frontend/lib/state/ai_providers.dart
frontend/lib/state/database_provider.dart
frontend/lib/state/notification_providers.dart
frontend/lib/state/presence_providers.dart
frontend/lib/state/providers.dart
frontend/lib/state/realtime_providers.dart
frontend/lib/state/repository_providers.dart
frontend/lib/state/send_queue.dart
frontend/lib/state/typing_providers.dart
frontend/lib/widgets/network_status_banner.dart
frontend/lib/widgets/sliding_panel.dart
frontend/lib/widgets/user_avatar.dart
frontend/Makefile
frontend/pubspec.yaml
frontend/test/models/action_item_test.dart
frontend/test/models/ai_analysis_enhanced_test.dart
frontend/test/models/ai_analysis_phase1_test.dart
frontend/test/models/ai_analysis_test.dart
frontend/test/models/conversation_context_test.dart
frontend/test/models/evidence_test.dart
frontend/test/models/follow_up_item_test.dart
frontend/test/models/message_interpretation_test.dart
frontend/test/models/relationship_profile_test.dart
frontend/test/models/rsd_trigger_test.dart
frontend/test/models/safe_topic_test.dart
frontend/test/offline_queue_test.dart
frontend/test/realtime_diagnostic_test.dart
frontend/test/services/ai_analysis_service_test.dart
frontend/test/services/context_preloader_service_test.dart
frontend/test/services/follow_up_service_test.dart
frontend/test/services/message_formatter_service_test.dart
frontend/test/services/relationship_service_test.dart
frontend/test/widget_test.dart
frontend/test/widgets/context_preview_card_test.dart
frontend/test/widgets/follow_up_card_test.dart
frontend/test/widgets/tone_badge_enhanced_test.dart
frontend/test/widgets/tone_badge_test.dart
frontend/test/widgets/who_is_this_button_test.dart
frontend/web/favicon.png
frontend/web/icons/Icon-192.png
frontend/web/icons/Icon-512.png
frontend/web/icons/Icon-maskable-192.png
frontend/web/icons/Icon-maskable-512.png
frontend/web/index.html
frontend/web/manifest.json
frontend/windows/.gitignore
frontend/windows/CMakeLists.txt
frontend/windows/flutter/CMakeLists.txt
frontend/windows/runner/CMakeLists.txt
frontend/windows/runner/flutter_window.cpp
frontend/windows/runner/flutter_window.h
frontend/windows/runner/main.cpp
frontend/windows/runner/resource.h
frontend/windows/runner/resources/app_icon.ico
frontend/windows/runner/runner.exe.manifest
frontend/windows/runner/Runner.rc
frontend/windows/runner/utils.cpp
frontend/windows/runner/utils.h
frontend/windows/runner/win32_window.cpp
frontend/windows/runner/win32_window.h
package.json
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/plans/ui-overhaul---tone-interpreter-7b37f7a4.plan.md">
<!-- 7b37f7a4-3027-4e7b-9964-6637b59b8d85 21469e5d-48e5-4034-9f64-a4f84a3ddc1c -->
# UI Overhaul + Tone Interpreter Implementation

## Architecture Vision

The message screen becomes a layered interface:

- **Background Layer**: AI insights, tone analysis, suggestions (always present)
- **Foreground Layer**: Message list in a sliding panel that slides up/down
- **Default State**: Message panel slides up (80% height), showing peek of AI content
- **AI View**: User swipes down to reveal full AI analysis behind messages

## Phase 1: Theme System Overhaul

### Update Theme to Black/White Minimal

- Replace burnt orange theme with monochrome palette
- Use `theme_guide.md` as reference but implement black/white/gray only
- Accent colors only for critical actions (send button, online status)
- Remove all color gradients, use sharp shadows and clean lines

**Files to modify:**

- `frontend/lib/app.dart` - Replace entire `ThemeData` configuration
  - Light theme: White backgrounds (#FFFFFF), black text (#000000), gray surfaces (#F5F5F5)
  - Dark theme: True black backgrounds (#000000), white text (#FFFFFF), dark gray surfaces (#1A1A1A)
  - Minimal accent: Single green for online, single blue for actions

### Update existing screens with new theme

- `frontend/lib/features/conversations/screens/conversations_list_screen.dart`
  - Cleaner list items, sharper dividers
  - Remove colored avatars, use monochrome initials
  - Flat design with subtle shadows

- `frontend/lib/features/auth/screens/auth_screen.dart`
  - Minimal input fields with black borders
  - Clean button design

- `frontend/lib/features/settings/screens/settings_screen.dart`
  - Flat list design matching new aesthetic

### Create shared theme constants

**New file:** `frontend/lib/core/theme/app_theme.dart`

- Define color constants from theme guide (Gray scale only)
- Typography system (sizes, weights)
- Spacing constants
- Border radius constants
- Shadow definitions

## Phase 2: Sliding Panel Architecture

### Build sliding panel widget system

**New file:** `frontend/lib/widgets/sliding_panel.dart`

- `SlidingPanel` widget using `DraggableScrollableSheet`
- Min height: 0.2 (20% - peek view)
- Max height: 0.95 (95% - nearly full screen)
- Initial height: 0.8 (80% - standard messaging view)
- Snap positions at 0.2, 0.5, 0.8, 0.95
- Smooth animations with custom curves
- Handle decorations: Rounded top corners, drag handle indicator

### Redesign Message Screen with layers

**Modify:** `frontend/lib/features/messages/screens/message_screen.dart`

- Restructure layout:
  ```dart
  Stack(
    children: [
      // Background: AI Insights Panel
      _buildAIInsightsBackground(),
      
      // Foreground: Sliding Message Panel
      SlidingPanel(
        child: MessageListView(),
        onSlide: (position) => setState(() => _panelPosition = position),
      ),
    ],
  )
  ```

- Extract message list into separate widget
- Create AI background placeholder (will populate with tone analysis)

**New file:** `frontend/lib/features/messages/widgets/message_list_panel.dart`

- Extract current message list building logic
- Include compose bar at bottom of panel
- Maintain all existing functionality (typing indicators, receipts, etc.)

**New file:** `frontend/lib/features/messages/widgets/ai_insights_background.dart`

- Background container for AI features
- Initially shows: "Pull down to see AI insights"
- Will display tone analysis when implemented

## Phase 3: Tone Interpreter Backend

### Database Schema

**New file:** `backend/supabase/migrations/20251024_000002_ai_analysis.sql`

```sql
CREATE TABLE message_ai_analysis (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  message_id UUID REFERENCES messages(id) ON DELETE CASCADE,
  tone TEXT NOT NULL,
  urgency_level TEXT,
  intent TEXT,
  confidence_score FLOAT,
  analysis_timestamp BIGINT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_ai_analysis_message ON message_ai_analysis(message_id);
CREATE INDEX idx_ai_analysis_timestamp ON message_ai_analysis(analysis_timestamp);
```

### Anthropic Client Setup

**New file:** `backend/supabase/functions/_shared/anthropic-client.ts`

- Wrapper for Anthropic API using Claude Sonnet 4
- Type-safe message formatting
- Error handling and retries
- Rate limiting considerations

**New file:** `backend/supabase/functions/_shared/prompts/tone-analysis.ts`

- Prompt engineering for tone detection
- System prompt defining tone categories
- Context inclusion strategy
- JSON response formatting

### Edge Function for Analysis

**New file:** `backend/supabase/functions/ai_analyze_tone/index.ts`

- Accept: `{ message_id, message_body, conversation_context? }`
- Call Anthropic API with message + context
- Parse response into structured data
- Store analysis in `message_ai_analysis` table
- Return: `{ tone, urgency_level, intent, confidence_score }`

Tone categories:

- Friendly, Professional, Urgent, Casual, Formal, Concerned, Excited, Neutral

Urgency levels:

- Low, Medium, High, Critical

**Modify:** `backend/supabase/config.toml`

- Add new Edge Function configuration
- Set environment variables for Anthropic API key

### RPC Function for Bulk Analysis

**Add to migration:** `backend/supabase/migrations/20251024_000002_ai_analysis.sql`

```sql
CREATE OR REPLACE FUNCTION get_conversation_ai_analysis(p_conversation_id UUID)
RETURNS TABLE (
  message_id UUID,
  tone TEXT,
  urgency_level TEXT,
  intent TEXT,
  confidence_score FLOAT
) AS $$
BEGIN
  RETURN QUERY
  SELECT a.message_id, a.tone, a.urgency_level, a.intent, a.confidence_score
  FROM message_ai_analysis a
  JOIN messages m ON a.message_id = m.id
  WHERE m.conversation_id = p_conversation_id
  ORDER BY m.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## Phase 4: Tone Interpreter Frontend (Remote-Only, No Local Cache)

### AI Service Layer - Simplified

**New file:** `frontend/lib/services/ai_analysis_service.dart`

- Request analysis for a message (calls Edge Function)
- Fetch analysis directly from Supabase (no local cache)
- Debounce requests to avoid spam
- Simple in-memory caching for current session only
- Returns data directly from API calls

### State Management

**New file:** `frontend/lib/state/ai_providers.dart`

```dart
// Provider for conversation-wide AI analysis
final conversationAIAnalysisProvider = FutureProvider.family<Map<String, AIAnalysis>, String>(
  (ref, conversationId) async {
    final service = AIAnalysisService();
    return await service.getConversationAnalysis(conversationId);
  },
);

// Provider for triggering analysis
final requestAnalysisProvider = Provider((ref) => AIAnalysisService());
```

### UI Components for Tone Display

**New file:** `frontend/lib/features/messages/widgets/tone_badge.dart`

- Small badge showing tone emoji + label
- Color coding: Urgent=red, Professional=blue, Friendly=green, etc.
- Tap to expand details
- Position: Bottom-right of message bubble (subtle, non-intrusive)

**New file:** `frontend/lib/features/messages/widgets/ai_insights_panel.dart`

- Replaces `ai_insights_background.dart` placeholder
- Shows conversation-level insights:
  - Overall tone of conversation
  - Most recent message analysis
  - Urgency indicators
  - Detected intents
- Visual design: Cards with minimal shadows, clean typography
- "Analyze Message" button for manual triggers

**Modify:** `frontend/lib/features/messages/widgets/message_list_panel.dart`

- Add tone badges to message bubbles
- Wire up tap handlers to show detail sheet

**New file:** `frontend/lib/features/messages/widgets/tone_detail_sheet.dart`

- Bottom sheet showing full analysis
- Display: Tone, urgency, intent, confidence score
- Feedback mechanism: "Was this helpful?" thumbs up/down
- Future: User corrections to improve model

### Integration with Message Flow

**Modify:** `frontend/lib/services/message_service.dart`

- After sending message, trigger tone analysis asynchronously
- Don't block message send on analysis
- Store message ID for later analysis result

**Modify:** `frontend/lib/features/messages/screens/message_screen.dart`

- Pass AI analysis data to `AIInsightsPanel`
- Show loading state while analysis pending
- Update UI when analysis completes via Riverpod listener

## Phase 5: Polish & Testing

### Update Documentation

- Update `theme_guide.md` with implemented black/white palette
- Update `technical_implementation (1).md` with completed PR #1-2
- Add comments explaining sliding panel architecture

### Settings Integration

**Modify:** `frontend/lib/features/settings/screens/settings_screen.dart`

- Add "AI Features" section
- Toggle: Enable/disable tone analysis
- Option: Auto-analyze all messages vs manual trigger
- Privacy notice about AI processing

### Testing Checklist

- Sliding panel smooth on various devices
- Tone analysis works for different message types
- Theme consistent across light/dark modes
- No performance issues with analysis
- Graceful error handling when API fails
- Works offline (shows cached analysis only)

## Implementation Order

1. Theme system first (provides foundation)
2. Sliding panel architecture (core UX pattern)
3. Backend tone analysis (can test independently)
4. Frontend AI display (brings it all together)
5. Integration and polish

### To-dos

- [ ] Create black/white theme system and update app.dart with new ThemeData
- [ ] Update existing screens (conversations list, auth, settings) with minimal design
- [ ] Build SlidingPanel widget with DraggableScrollableSheet
- [ ] Restructure message screen with Stack layout (background + sliding panel)
- [ ] Create migration for message_ai_analysis table
- [ ] Create Anthropic client wrapper and tone analysis prompts
- [ ] Implement ai_analyze_tone Edge Function
- [ ] Add ai_analysis Drift table and DAO
- [ ] Create AIAnalysisService and state providers
- [ ] Build tone badge, insights panel, and detail sheet widgets
- [ ] Wire up message flow with AI analysis and test end-to-end
- [ ] Add AI settings toggles and update documentation
</file>

<file path=".cursorignore">
# Add directories or file patterns to ignore during indexing (e.g. foo/ or *.csv)
</file>

<file path=".gitignore">
# Environment files
.env
.env.local
.env.*.local
.env.dev.json
.env.prod.json

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
*.iml
*.ipr
*.iws
*.sublime-workspace

# OS
.DS_Store
Thumbs.db
.~*

# Build outputs
build/
dist/
node_modules/

# Node/NPM
package-lock.json
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Dart/Flutter
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.packages
pubspec.lock
coverage/

# Generated files
*.g.dart
*.config.dart
*.freezed.dart
*.chopper.dart

# Backend (if Node/Express)
node_modules/
dist/
.env

# Firebase
google-services.json
GoogleService-Info.plist
ServiceAccount.json

# Logs
*.log
logs/

# Temporary
*.tmp
.cache/

# Compiled
*.app/
*.framework/
*.so

# Archives
*.zip
*.tar.gz

# OS temp files
.DS_Store
.AppleDouble
.LSOverride

# Windows
Thumbs.db
ehthumbs.db

# Android
.gradle/
local.properties
*.apk
*.ap_
*.aab

# iOS
Pods/
Podfile.lock
</file>

<file path="backend/get-function-logs.sh">
#!/bin/bash

# Supabase Function Logs Debugging Script
# Usage: ./get-function-logs.sh [execution_id]

EXECUTION_ID="${1:-5888a6d9-0e81-4c1f-bb45-8324a65eb7c6}"
FUNCTION_NAME="ai_analyze_tone"

echo "üîç Fetching logs for $FUNCTION_NAME"
echo "Execution ID: $EXECUTION_ID"
echo "================================"
echo ""

# Try Method 1: Direct supabase CLI
if command -v supabase &> /dev/null; then
  echo "üìã Using Supabase CLI..."
  supabase functions fetch $FUNCTION_NAME --logs 2>/dev/null | grep -A 20 "$EXECUTION_ID"
else
  echo "‚ö†Ô∏è  Supabase CLI not found. Using browser-based method:"
fi

echo ""
echo "üìä To view logs in Supabase Dashboard:"
echo "================================"
echo "1. Go to: https://supabase.com/dashboard"
echo "2. Select your project"
echo "3. Navigate to: Functions ‚Üí $FUNCTION_NAME"
echo "4. Click 'Logs' tab"
echo "5. Search for execution ID: $EXECUTION_ID"
echo ""
echo "üîë Look for these log markers:"
echo "   ‚úÖ Success indicators:"
echo "      - 'üì§ Preparing JSON request'"
echo "      - 'üì• Received response from OpenAI'"
echo "      - '‚úÖ JSON parsed successfully'"
echo "      - '‚úÖ Validation passed!'"
echo ""
echo "   ‚ùå Failure indicators:"
echo "      - '‚ùå JSON parsing failed!'"
echo "      - '‚ùå Invalid tone'"
echo "      - '‚ùå Invalid urgency level'"
echo "      - 'üí• Failed to get JSON response'"
echo ""
</file>

<file path="backend/supabase/.gitignore">
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local
</file>

<file path="backend/supabase/db/test/rls_messages_tap.sql">
-- RLS Tests for messages table using pgTAP
-- Tests verify that users can only access messages in conversations they participate in

BEGIN;
SELECT plan(8);

-- Setup test data
-- Create test profiles
INSERT INTO profiles (user_id, username) VALUES 
  ('11111111-1111-1111-1111-111111111111'::uuid, 'user1'),
  ('22222222-2222-2222-2222-222222222222'::uuid, 'user2'),
  ('33333333-3333-3333-3333-333333333333'::uuid, 'user3');

-- Create test conversation
INSERT INTO conversations (id, title, is_group, created_by) VALUES 
  ('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, 'Test Conv 1', false, '11111111-1111-1111-1111-111111111111'::uuid);

-- Add participants
INSERT INTO conversation_participants (conversation_id, user_id) VALUES 
  ('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, '11111111-1111-1111-1111-111111111111'::uuid),
  ('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, '22222222-2222-2222-2222-222222222222'::uuid);

-- Insert test messages
INSERT INTO messages (id, conversation_id, sender_id, body) VALUES 
  ('cccccccc-cccc-cccc-cccc-cccccccccccc'::uuid, 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, '11111111-1111-1111-1111-111111111111'::uuid, 'Hello from user1'),
  ('dddddddd-dddd-dddd-dddd-dddddddddddd'::uuid, 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, '22222222-2222-2222-2222-222222222222'::uuid, 'Hello from user2');

-- Test: User1 (member) can read messages
SELECT is(
  (SELECT COUNT(*) FROM messages 
   WHERE conversation_id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid),
  2,
  'User1 can read messages in their conversation'
);

-- Test: User1 (member) can send messages
SELECT is(
  (SELECT COUNT(*) FROM messages 
   WHERE sender_id = '11111111-1111-1111-1111-111111111111'::uuid),
  1,
  'User1 can send messages to their conversation'
);

-- Test: User2 (member) can read messages
SELECT is(
  (SELECT COUNT(*) FROM messages 
   WHERE conversation_id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid),
  2,
  'User2 can read messages in their conversation'
);

-- Test: User3 (non-member) cannot read messages
-- Note: In production with RLS enforced, this would return 0
-- This test verifies policy definition exists
SELECT is(
  (SELECT COUNT(*) FROM pg_policies 
   WHERE tablename = 'messages' 
   AND policyname = 'Users can read messages in their conversations'),
  1,
  'Message read policy exists'
);

-- Test: Message send policy exists
SELECT is(
  (SELECT COUNT(*) FROM pg_policies 
   WHERE tablename = 'messages' 
   AND policyname = 'Users can send messages to their conversations'),
  1,
  'Message send policy exists'
);

-- Test: Message update policy exists
SELECT is(
  (SELECT COUNT(*) FROM pg_policies 
   WHERE tablename = 'messages' 
   AND policyname = 'Users can edit their own messages'),
  1,
  'Message update policy exists'
);

-- Test: Message delete policy exists
SELECT is(
  (SELECT COUNT(*) FROM pg_policies 
   WHERE tablename = 'messages' 
   AND policyname = 'Users can delete their own messages'),
  1,
  'Message delete policy exists'
);

-- Test: RLS is enabled on messages table
SELECT is(
  (SELECT COUNT(*) FROM pg_tables 
   WHERE tablename = 'messages' AND rowsecurity = true),
  1,
  'RLS is enabled on messages table'
);

-- Cleanup
DELETE FROM message_receipts;
DELETE FROM messages;
DELETE FROM conversation_participants;
DELETE FROM conversations;
DELETE FROM profiles;

SELECT * FROM finish();
ROLLBACK;
</file>

<file path="backend/supabase/db/test/rls_participants_tap.sql">
-- RLS Tests for conversation_participants table using pgTAP
-- Tests verify that users can only manage their own participation

BEGIN;
SELECT plan(7);

-- Setup test data
INSERT INTO profiles (user_id, username) VALUES 
  ('11111111-1111-1111-1111-111111111111'::uuid, 'user1'),
  ('22222222-2222-2222-2222-222222222222'::uuid, 'user2'),
  ('33333333-3333-3333-3333-333333333333'::uuid, 'user3');

INSERT INTO conversations (id, title, is_group, created_by) VALUES 
  ('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, 'Test Conv 1', false, '11111111-1111-1111-1111-111111111111'::uuid);

INSERT INTO conversation_participants (conversation_id, user_id) VALUES 
  ('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, '11111111-1111-1111-1111-111111111111'::uuid),
  ('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid, '22222222-2222-2222-2222-222222222222'::uuid);

-- Test: Participant count is correct
SELECT is(
  (SELECT COUNT(*) FROM conversation_participants 
   WHERE conversation_id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid),
  2,
  'Conversation has 2 participants'
);

-- Test: User1 is in the conversation
SELECT is(
  (SELECT COUNT(*) FROM conversation_participants 
   WHERE conversation_id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid 
   AND user_id = '11111111-1111-1111-1111-111111111111'::uuid),
  1,
  'User1 is in the conversation'
);

-- Test: User2 is in the conversation
SELECT is(
  (SELECT COUNT(*) FROM conversation_participants 
   WHERE conversation_id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid 
   AND user_id = '22222222-2222-2222-2222-222222222222'::uuid),
  1,
  'User2 is in the conversation'
);

-- Test: User3 is not in the conversation
SELECT is(
  (SELECT COUNT(*) FROM conversation_participants 
   WHERE conversation_id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'::uuid 
   AND user_id = '33333333-3333-3333-3333-333333333333'::uuid),
  0,
  'User3 is not in the conversation'
);

-- Test: SELECT policy exists for participants
SELECT is(
  (SELECT COUNT(*) FROM pg_policies 
   WHERE tablename = 'conversation_participants' 
   AND policyname = 'Participants viewable by conversation members'),
  1,
  'Participant view policy exists'
);

-- Test: INSERT policy exists for participants
SELECT is(
  (SELECT COUNT(*) FROM pg_policies 
   WHERE tablename = 'conversation_participants' 
   AND policyname = 'Users can join conversations'),
  1,
  'Participant join policy exists'
);

-- Test: RLS is enabled on conversation_participants table
SELECT is(
  (SELECT COUNT(*) FROM pg_tables 
   WHERE tablename = 'conversation_participants' AND rowsecurity = true),
  1,
  'RLS is enabled on conversation_participants table'
);

-- Cleanup
DELETE FROM message_receipts;
DELETE FROM messages;
DELETE FROM conversation_participants;
DELETE FROM conversations;
DELETE FROM profiles;

SELECT * FROM finish();
ROLLBACK;
</file>

<file path="backend/supabase/db/triggers/messages_notify.sql">
-- Trigger: messages_notify
-- Broadcasts realtime event when a message is inserted
-- Usage: Subscribe to `realtime:messages` channel to receive events

-- Create function to broadcast message events
CREATE OR REPLACE FUNCTION public.messages_notify()
RETURNS trigger AS $$
BEGIN
  -- Perform the realtime broadcast
  PERFORM pg_notify(
    'realtime:messages',
    json_build_object(
      'type', TG_OP,
      'record', row_to_json(NEW),
      'schema', TG_TABLE_SCHEMA,
      'table', TG_TABLE_NAME,
      'timestamp', now()
    )::text
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for INSERT events on messages table
DROP TRIGGER IF EXISTS messages_notify_insert ON messages;
CREATE TRIGGER messages_notify_insert
  AFTER INSERT ON messages
  FOR EACH ROW
  EXECUTE FUNCTION public.messages_notify();

-- Create trigger for UPDATE events on messages table
DROP TRIGGER IF EXISTS messages_notify_update ON messages;
CREATE TRIGGER messages_notify_update
  AFTER UPDATE ON messages
  FOR EACH ROW
  EXECUTE FUNCTION public.messages_notify();
</file>

<file path="backend/supabase/db/triggers/receipts_notify.sql">
-- Trigger: receipts_notify
-- Broadcasts realtime event when a message receipt is inserted
-- Usage: Subscribe to `realtime:receipts` channel to receive events

-- Create function to broadcast receipt events
CREATE OR REPLACE FUNCTION public.receipts_notify()
RETURNS trigger AS $$
BEGIN
  -- Perform the realtime broadcast
  PERFORM pg_notify(
    'realtime:receipts',
    json_build_object(
      'type', TG_OP,
      'record', row_to_json(NEW),
      'schema', TG_TABLE_SCHEMA,
      'table', TG_TABLE_NAME,
      'timestamp', now()
    )::text
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for INSERT events on message_receipts table
DROP TRIGGER IF EXISTS receipts_notify_insert ON message_receipts;
CREATE TRIGGER receipts_notify_insert
  AFTER INSERT ON message_receipts
  FOR EACH ROW
  EXECUTE FUNCTION public.receipts_notify();

-- Create trigger for UPDATE events on message_receipts table
DROP TRIGGER IF EXISTS receipts_notify_update ON message_receipts;
CREATE TRIGGER receipts_notify_update
  AFTER UPDATE ON message_receipts
  FOR EACH ROW
  EXECUTE FUNCTION public.receipts_notify();
</file>

<file path="backend/supabase/functions/_shared/nlp/action-item-extractor.ts">
/**
 * Extracts action items from messages
 * Detects implicit commitments like "I'll send you..."
 */

import { OpenAIClient } from '../openai-client.ts';

export interface ActionItem {
  action_type: string; // send, call, meet, review, etc.
  action_target: string; // What/who
  commitment_text: string; // Original text
  mentioned_deadline?: string; // "this afternoon"
  confidence: number; // 0.0-1.0
}

export const ACTION_ITEM_EXTRACTION_PROMPT = `You are an expert at identifying commitments and action items in conversations.

**Your task:** Extract action items from messages where someone commits to doing something.

**Action Types:**
- **send**: Sending something (email, file, link, message)
- **call**: Making a phone call
- **meet**: Meeting in person or video
- **review**: Reviewing/reading something
- **decide**: Making a decision
- **follow_up**: Following up later
- **check**: Checking on something
- **schedule**: Scheduling something
- **other**: Other commitment

**Examples:**

Input: "I'll send you the report this afternoon"
Output:
{
  "action_type": "send",
  "action_target": "report",
  "commitment_text": "I'll send you the report this afternoon",
  "mentioned_deadline": "this afternoon",
  "confidence": 0.95
}

Input: "Let me check and get back to you tomorrow"
Output:
{
  "action_type": "follow_up",
  "action_target": "answer to question",
  "commitment_text": "Let me check and get back to you tomorrow",
  "mentioned_deadline": "tomorrow",
  "confidence": 0.90
}

Input: "We should grab coffee sometime"
Output:
{
  "action_type": "meet",
  "action_target": "coffee meeting",
  "commitment_text": "We should grab coffee sometime",
  "mentioned_deadline": null,
  "confidence": 0.70
}

**Commitment Indicators:**
- "I'll", "I will"
- "Let me"
- "I can"
- "I'm going to"
- "I need to"
- "I should"
- "We should"

**Response Format:**
Return array of action items. If no commitments found, return empty array: []`;

export class ActionItemExtractor {
  private openai: OpenAIClient;

  constructor() {
    this.openai = new OpenAIClient();
  }

  /**
   * Extract action items from message
   */
  async extractActionItems(
    messageBody: string,
    senderId: string,
    currentUserId: string
  ): Promise<ActionItem[]> {
    // Only extract from user's own messages
    if (senderId !== currentUserId) {
      return [];
    }

    // Quick check for commitment indicators
    const hasCommitment = [
      "i'll", "i will", "let me", "i can", "i'm going to",
      "i need to", "i should", "we should"
    ].some(indicator => messageBody.toLowerCase().includes(indicator));

    if (!hasCommitment) {
      return [];
    }

    try {
      const userPrompt = `Extract action items from this message:\n\n"${messageBody}"`;
      
      const result = await this.openai.sendMessageForJSON<ActionItem[]>(
        userPrompt,
        ACTION_ITEM_EXTRACTION_PROMPT,
        { temperature: 0.2, max_tokens: 500 }
      );

      // Filter by confidence threshold
      return (Array.isArray(result) ? result : [])
        .filter(item => item.confidence >= 0.7);
    } catch (error) {
      console.error('Error extracting action items:', error);
      return [];
    }
  }

  /**
   * Parse deadline from natural language
   */
  parseDeadline(deadlineText: string): number | null {
    const now = Math.floor(Date.now() / 1000);
    const lowerText = deadlineText.toLowerCase();

    // Today
    if (lowerText.includes('today') || lowerText.includes('this afternoon')) {
      return now + 6 * 3600; // 6 hours from now
    }

    // Tomorrow
    if (lowerText.includes('tomorrow')) {
      return now + 24 * 3600;
    }

    // This week
    if (lowerText.includes('this week') || lowerText.includes('by friday')) {
      return now + 5 * 24 * 3600; // 5 days
    }

    // Next week
    if (lowerText.includes('next week')) {
      return now + 7 * 24 * 3600;
    }

    // Fallback: 2 days
    return now + 2 * 24 * 3600;
  }
}
</file>

<file path="backend/supabase/functions/_shared/nlp/question-detector.ts">
/**
 * Detects unanswered questions in conversations
 */

export interface UnansweredQuestion {
  message_id: string;
  question_text: string;
  question_type: string; // when, where, what, who, why, how, yes/no
  context: string;
  asked_at: number;
  confidence: number;
}

export class QuestionDetector {
  /**
   * Find unanswered questions in conversation
   */
  async findUnansweredQuestions(
    messages: Array<{ id: string; body: string; sender_id: string; created_at: number }>,
    currentUserId: string
  ): Promise<UnansweredQuestion[]> {
    const unanswered: UnansweredQuestion[] = [];

    for (let i = messages.length - 1; i >= 0; i--) {
      const message = messages[i];
      
      // Only check questions FROM others TO user
      if (message.sender_id === currentUserId) {
        continue;
      }

      // Check if message contains question
      if (!message.body.includes('?')) {
        continue;
      }

      // Check if user responded after this question
      const hasResponse = messages
        .slice(i + 1)
        .some(m => m.sender_id === currentUserId);

      if (!hasResponse) {
        // Extract question type
        const questionType = this.detectQuestionType(message.body);
        
        unanswered.push({
          message_id: message.id,
          question_text: message.body,
          question_type: questionType,
          context: this.extractContext(messages, i),
          asked_at: message.created_at,
          confidence: 0.9,
        });
      }
    }

    return unanswered;
  }

  /**
   * Detect question type
   */
  private detectQuestionType(text: string): string {
    const lowerText = text.toLowerCase();

    if (lowerText.startsWith('when ')) return 'when';
    if (lowerText.startsWith('where ')) return 'where';
    if (lowerText.startsWith('what ')) return 'what';
    if (lowerText.startsWith('who ')) return 'who';
    if (lowerText.startsWith('why ')) return 'why';
    if (lowerText.startsWith('how ')) return 'how';
    
    // Check for yes/no questions
    const yesNoIndicators = ['can you', 'could you', 'would you', 'will you', 'do you', 'are you'];
    if (yesNoIndicators.some(indicator => lowerText.includes(indicator))) {
      return 'yes/no';
    }

    return 'other';
  }

  /**
   * Extract context around question
   */
  private extractContext(
    messages: Array<{ body: string }>,
    questionIndex: number
  ): string {
    const contextRange = 2;
    const start = Math.max(0, questionIndex - contextRange);
    const contextMessages = messages.slice(start, questionIndex);
    
    return contextMessages.map(m => m.body).join(' ');
  }
}
</file>

<file path="backend/supabase/functions/_shared/prompts/__tests__/alternative-interpretations.test.ts">
import { assertEquals } from 'https://deno.land/std@0.168.0/testing/asserts.ts';
import { shouldGenerateAlternatives } from '../alternative-interpretations.ts';

Deno.test('shouldGenerateAlternatives - with RSD triggers', () => {
  const result = shouldGenerateAlternatives('ok', 1, 0.85);
  assertEquals(result, true, 'Should generate alternatives when RSD triggers detected');
});

Deno.test('shouldGenerateAlternatives - low confidence', () => {
  const result = shouldGenerateAlternatives('maybe...', 0, 0.5);
  assertEquals(result, true, 'Should generate alternatives when confidence < 0.7');
});

Deno.test('shouldGenerateAlternatives - short message', () => {
  const result = shouldGenerateAlternatives('ok', 0, 0.85);
  assertEquals(result, true, 'Should generate alternatives for short messages (‚â§3 words)');
});

Deno.test('shouldGenerateAlternatives - normal message, high confidence', () => {
  const result = shouldGenerateAlternatives('Hey! How are you doing today?', 0, 0.9);
  assertEquals(result, false, 'Should NOT generate alternatives for normal messages with high confidence');
});

Deno.test('shouldGenerateAlternatives - edge case 3 words', () => {
  const result = shouldGenerateAlternatives('I am good', 0, 0.85);
  assertEquals(result, true, 'Should generate alternatives for exactly 3 words');
});

Deno.test('shouldGenerateAlternatives - edge case 4 words', () => {
  const result = shouldGenerateAlternatives('I am doing good', 0, 0.85);
  assertEquals(result, false, 'Should NOT generate alternatives for 4 words with high confidence');
});
</file>

<file path="backend/supabase/functions/_shared/prompts/__tests__/enhanced-tone-analysis.test.ts">
import { assertEquals, assertExists } from "https://deno.land/std@0.168.0/testing/asserts.ts";
import {
  validateToneAnalysis,
  extractToneIndicators,
  detectFigurativeLanguage,
  assessResponseAnxietyRisk,
  generateAnalysisPrompt,
  VALID_TONES,
  type ToneAnalysisResult,
} from "../enhanced-tone-analysis.ts";

// ============================================================================
// UNIT TESTS: Tone Indicator Extraction
// ============================================================================

Deno.test("extractToneIndicators - detects single tone indicator", () => {
  const message = "I'm just joking /j";
  const indicators = extractToneIndicators(message);
  assertEquals(indicators.length, 1);
  assertEquals(indicators[0], "/j");
});

Deno.test("extractToneIndicators - detects multiple tone indicators", () => {
  const message = "I'm serious about this /srs and not mad /nm";
  const indicators = extractToneIndicators(message);
  assertEquals(indicators.length, 2);
  assertEquals(indicators, ["/srs", "/nm"]);
});

Deno.test("extractToneIndicators - handles message with no indicators", () => {
  const message = "This is a normal message";
  const indicators = extractToneIndicators(message);
  assertEquals(indicators.length, 0);
});

Deno.test("extractToneIndicators - detects sarcasm indicator", () => {
  const message = "Oh great, another meeting /s";
  const indicators = extractToneIndicators(message);
  assertEquals(indicators, ["/s"]);
});

// ============================================================================
// UNIT TESTS: Figurative Language Detection
// ============================================================================

Deno.test("detectFigurativeLanguage - detects common idiom", () => {
  const message = "Let's break the ice with introductions";
  const result = detectFigurativeLanguage(message);
  assertEquals(result.has_figurative_language, true);
  assertEquals(result.examples.length, 1);
  assertEquals(result.examples[0], 'Idiom: "break the ice"');
});

Deno.test("detectFigurativeLanguage - detects multiple idioms", () => {
  const message = "This project is a piece of cake, I'm not under the weather";
  const result = detectFigurativeLanguage(message);
  assertEquals(result.has_figurative_language, true);
  assertEquals(result.examples.length, 2);
});

Deno.test("detectFigurativeLanguage - handles message with no idioms", () => {
  const message = "I will complete the task today";
  const result = detectFigurativeLanguage(message);
  assertEquals(result.has_figurative_language, false);
  assertEquals(result.examples.length, 0);
});

// ============================================================================
// UNIT TESTS: Validation
// ============================================================================

Deno.test("validateToneAnalysis - accepts valid result", () => {
  const validResult = {
    tone: "Friendly",
    intensity: "medium",
    urgency_level: "Low",
    intent: "greeting and checking in",
    confidence_score: 0.85,
    context_flags: {
      sarcasm_detected: false,
      tone_indicator_present: false,
    },
  };

  const validated = validateToneAnalysis(validResult);
  assertEquals(validated.tone, "Friendly");
  assertEquals(validated.intensity, "medium");
  assertEquals(validated.urgency_level, "Low");
});

Deno.test("validateToneAnalysis - accepts all 23 valid tones", () => {
  const testTones = [
    "Friendly", "Professional", "Urgent", "Casual", "Formal", "Concerned",
    "Excited", "Neutral", "Apologetic", "Appreciative", "Frustrated", "Playful",
    "Sarcastic", "Empathetic", "Inquisitive", "Assertive", "Tentative", "Defensive",
    "Encouraging", "Disappointed", "Overwhelmed", "Relieved", "Confused"
  ];

  testTones.forEach(tone => {
    const result = {
      tone,
      urgency_level: "Low",
      intent: "test intent",
      confidence_score: 0.8,
    };
    const validated = validateToneAnalysis(result);
    assertEquals(validated.tone, tone);
  });
});

Deno.test("validateToneAnalysis - rejects invalid tone", () => {
  const invalidResult = {
    tone: "InvalidTone",
    urgency_level: "Low",
    intent: "test",
    confidence_score: 0.8,
  };

  let errorThrown = false;
  try {
    validateToneAnalysis(invalidResult);
  } catch (e) {
    errorThrown = true;
    assertEquals(e.message.includes("Invalid tone"), true);
  }
  assertEquals(errorThrown, true);
});

Deno.test("validateToneAnalysis - rejects invalid intensity", () => {
  const invalidResult = {
    tone: "Friendly",
    intensity: "super_high",
    urgency_level: "Low",
    intent: "test",
    confidence_score: 0.8,
  };

  let errorThrown = false;
  try {
    validateToneAnalysis(invalidResult);
  } catch (e) {
    errorThrown = true;
    assertEquals(e.message.includes("Invalid intensity"), true);
  }
  assertEquals(errorThrown, true);
});

Deno.test("validateToneAnalysis - rejects invalid urgency", () => {
  const invalidResult = {
    tone: "Friendly",
    urgency_level: "SuperUrgent",
    intent: "test",
    confidence_score: 0.8,
  };

  let errorThrown = false;
  try {
    validateToneAnalysis(invalidResult);
  } catch (e) {
    errorThrown = true;
    assertEquals(e.message.includes("Invalid urgency level"), true);
  }
  assertEquals(errorThrown, true);
});

Deno.test("validateToneAnalysis - rejects invalid confidence score", () => {
  const invalidResult = {
    tone: "Friendly",
    urgency_level: "Low",
    intent: "test",
    confidence_score: 1.5, // > 1
  };

  let errorThrown = false;
  try {
    validateToneAnalysis(invalidResult);
  } catch (e) {
    errorThrown = true;
    assertEquals(e.message.includes("Confidence score"), true);
  }
  assertEquals(errorThrown, true);
});

// ============================================================================
// UNIT TESTS: Anxiety Assessment
// ============================================================================

Deno.test("assessResponseAnxietyRisk - high urgency triggers high risk", () => {
  const analysis: ToneAnalysisResult = {
    tone: "Urgent",
    urgency_level: "Critical",
    intent: "needs immediate response",
    confidence_score: 0.9,
  };

  const assessment = assessResponseAnxietyRisk(analysis);
  assertEquals(assessment.risk_level, "high");
  assertEquals(assessment.mitigation_suggestions.length > 0, true);
});

Deno.test("assessResponseAnxietyRisk - sarcasm triggers medium risk", () => {
  const analysis: ToneAnalysisResult = {
    tone: "Sarcastic",
    urgency_level: "Low",
    intent: "making a joke",
    confidence_score: 0.85,
    context_flags: {
      sarcasm_detected: true,
    },
  };

  const assessment = assessResponseAnxietyRisk(analysis);
  assertEquals(assessment.risk_level, "medium");
  assertEquals(assessment.mitigation_suggestions.length > 0, true);
});

Deno.test("assessResponseAnxietyRisk - friendly message is low risk", () => {
  const analysis: ToneAnalysisResult = {
    tone: "Friendly",
    urgency_level: "Low",
    intent: "casual greeting",
    confidence_score: 0.9,
  };

  const assessment = assessResponseAnxietyRisk(analysis);
  assertEquals(assessment.risk_level, "low");
});

// ============================================================================
// UNIT TESTS: Prompt Generation
// ============================================================================

Deno.test("generateAnalysisPrompt - creates prompt without context", () => {
  const message = "Hello, how are you?";
  const prompt = generateAnalysisPrompt(message);
  
  assertEquals(prompt.includes(message), true);
  assertEquals(prompt.includes("Analyze the following message"), true);
});

Deno.test("generateAnalysisPrompt - includes conversation context", () => {
  const message = "That sounds great!";
  const context = ["Want to get coffee?", "I'm free at 3pm"];
  const prompt = generateAnalysisPrompt(message, context);
  
  assertEquals(prompt.includes(message), true);
  assertEquals(prompt.includes("Conversation Context"), true);
  assertEquals(prompt.includes("Want to get coffee?"), true);
  assertEquals(prompt.includes("I'm free at 3pm"), true);
});

// ============================================================================
// INTEGRATION TESTS: Full Analysis Flow
// ============================================================================

Deno.test("INTEGRATION - analyze playful message with tone indicator", () => {
  const message = "Oh sure, that's a great idea /j";
  
  // Extract indicators
  const indicators = extractToneIndicators(message);
  assertEquals(indicators, ["/j"]);
  
  // Check figurative language
  const figurative = detectFigurativeLanguage(message);
  assertEquals(figurative.has_figurative_language, false);
  
  // Validate mock analysis result
  const mockResult = {
    tone: "Playful",
    intensity: "medium",
    urgency_level: "Low",
    intent: "joking about suggestion",
    confidence_score: 0.92,
    context_flags: {
      tone_indicator_present: true,
      sarcasm_detected: false,
    },
  };
  
  const validated = validateToneAnalysis(mockResult);
  assertEquals(validated.tone, "Playful");
  assertEquals(validated.context_flags?.tone_indicator_present, true);
  
  // Assess anxiety
  const anxiety = assessResponseAnxietyRisk(validated);
  assertEquals(anxiety.risk_level, "low");
});

Deno.test("INTEGRATION - analyze overwhelmed message", () => {
  const message = "I'm SO stressed about this deadline /srs";
  
  // Extract indicators
  const indicators = extractToneIndicators(message);
  assertEquals(indicators, ["/srs"]);
  
  // Validate mock analysis
  const mockResult = {
    tone: "Overwhelmed",
    intensity: "very_high",
    urgency_level: "High",
    intent: "expressing severe stress",
    confidence_score: 0.95,
    context_flags: {
      tone_indicator_present: true,
    },
  };
  
  const validated = validateToneAnalysis(mockResult);
  assertEquals(validated.tone, "Overwhelmed");
  assertEquals(validated.intensity, "very_high");
  
  // High urgency should trigger anxiety warning
  const anxiety = assessResponseAnxietyRisk(validated);
  assertEquals(anxiety.risk_level, "high");
});

console.log("‚úÖ All enhanced tone analysis tests passed!");
</file>

<file path="backend/supabase/functions/_shared/prompts/__tests__/evidence-extractor.test.ts">
import { assertEquals } from 'https://deno.land/std@0.168.0/testing/asserts.ts';
import { formatEvidence, type Evidence } from '../evidence-extractor.ts';

Deno.test('formatEvidence - with evidence', () => {
  const evidence: Evidence[] = [
    {
      type: 'keyword',
      quote: 'ASAP',
      supports: 'urgency',
      reasoning: 'Explicit urgency marker'
    },
    {
      type: 'punctuation',
      quote: '!!!',
      supports: 'high intensity',
      reasoning: 'Multiple exclamation marks show strong emotion'
    }
  ];
  
  const formatted = formatEvidence(evidence);
  
  assertEquals(formatted.includes('ASAP'), true, 'Should include the quote');
  assertEquals(formatted.includes('keyword'), true, 'Should include the type');
  assertEquals(formatted.includes('urgency'), true, 'Should include what it supports');
});

Deno.test('formatEvidence - empty evidence', () => {
  const evidence: Evidence[] = [];
  const formatted = formatEvidence(evidence);
  
  assertEquals(formatted, 'No specific evidence found in message');
});

Deno.test('formatEvidence - multiple evidence types', () => {
  const evidence: Evidence[] = [
    {
      type: 'emoji',
      quote: 'üòä',
      supports: 'friendly tone',
      reasoning: 'Smiling emoji indicates friendliness'
    },
    {
      type: 'length',
      quote: 'very short',
      supports: 'brevity',
      reasoning: 'Message is only 2 words'
    }
  ];
  
  const formatted = formatEvidence(evidence);
  
  assertEquals(formatted.includes('üòä'), true);
  assertEquals(formatted.includes('emoji'), true);
  assertEquals(formatted.includes('length'), true);
});
</file>

<file path="backend/supabase/functions/_shared/prompts/__tests__/rsd-detection.test.ts">
import { assertEquals } from 'https://deno.land/std@0.168.0/testing/asserts.ts';
import { detectRSDTriggers, generateRSDPromptAddition } from '../rsd-detection.ts';

Deno.test('RSD Detection - "ok" message', () => {
  const triggers = detectRSDTriggers('ok');
  
  assertEquals(triggers.length, 2, 'Should detect 2 triggers: "ok" pattern + short_response');
  assertEquals(triggers[0].pattern, 'ok');
  assertEquals(triggers[0].severity, 'high');
  assertEquals(triggers[1].pattern, 'short_response');
});

Deno.test('RSD Detection - "fine" message', () => {
  const triggers = detectRSDTriggers('fine');
  
  assertEquals(triggers.length, 2, 'Should detect "fine" pattern + short_response');
  assertEquals(triggers[0].pattern, 'fine');
  assertEquals(triggers[0].severity, 'high');
});

Deno.test('RSD Detection - "k" message', () => {
  const triggers = detectRSDTriggers('k');
  
  assertEquals(triggers.length, 2, 'Should detect "k" pattern + short_response');
  assertEquals(triggers[0].pattern, 'k');
  assertEquals(triggers[0].severity, 'high');
});

Deno.test('RSD Detection - "we need to talk" message', () => {
  const triggers = detectRSDTriggers('we need to talk');
  
  assertEquals(triggers.length, 1, 'Should only detect "we need to talk" pattern, not short_response');
  assertEquals(triggers[0].pattern, 'we need to talk');
  assertEquals(triggers[0].severity, 'high');
});

Deno.test('RSD Detection - "sure" message', () => {
  const triggers = detectRSDTriggers('sure');
  
  assertEquals(triggers.length, 2, 'Should detect "sure" pattern + short_response');
  assertEquals(triggers[0].pattern, 'sure');
  assertEquals(triggers[0].severity, 'medium');
});

Deno.test('RSD Detection - message with warmth indicators', () => {
  const triggers1 = detectRSDTriggers('ok!');
  const triggers2 = detectRSDTriggers('ok üòä');
  const triggers3 = detectRSDTriggers('ok ‚ù§Ô∏è');
  
  assertEquals(triggers1.length, 1, 'Should only detect "ok", not short_response (has !)');
  assertEquals(triggers2.length, 1, 'Should only detect "ok", not short_response (has emoji)');
  assertEquals(triggers3.length, 1, 'Should only detect "ok", not short_response (has emoji)');
});

Deno.test('RSD Detection - normal message', () => {
  const triggers = detectRSDTriggers('Hey! How are you doing today?');
  
  assertEquals(triggers.length, 0, 'Should not detect any triggers in normal message');
});

Deno.test('RSD Detection - longer message with "ok" in it', () => {
  const triggers = detectRSDTriggers('That sounds ok to me, let me know when you want to meet');
  
  assertEquals(triggers.length, 1, 'Should detect "ok" pattern but not short_response');
  assertEquals(triggers[0].pattern, 'ok');
});

Deno.test('generateRSDPromptAddition - with triggers', () => {
  const triggers = detectRSDTriggers('ok');
  const prompt = generateRSDPromptAddition(triggers);
  
  assertEquals(prompt.includes('RSD ALERT'), true, 'Should include RSD ALERT header');
  assertEquals(prompt.includes('ok'), true, 'Should mention the "ok" pattern');
  assertEquals(prompt.includes('high severity'), true, 'Should mention severity');
});

Deno.test('generateRSDPromptAddition - no triggers', () => {
  const triggers = detectRSDTriggers('Hey there!');
  const prompt = generateRSDPromptAddition(triggers);
  
  assertEquals(prompt, '', 'Should return empty string when no triggers');
});
</file>

<file path="backend/supabase/functions/_shared/prompts/alternative-interpretations.ts">
/**
 * Generates multiple possible interpretations of a message
 * Helps with ambiguity and reduces anxiety from uncertainty
 */

export interface MessageInterpretation {
  interpretation: string;
  tone: string;
  likelihood: number; // 0-100
  reasoning: string;
  context_clues: string[];
}

export const ALTERNATIVE_INTERPRETATIONS_PROMPT = `
**CRITICAL:** For messages that could be interpreted multiple ways, provide 2-3 alternative interpretations ranked by likelihood.

Consider:
1. **Literal interpretation:** What do the exact words mean?
2. **Positive interpretation:** Best-case scenario
3. **Neutral interpretation:** No hidden meaning
4. **Negative interpretation:** Worst-case (if genuinely possible)

For each interpretation, provide:
- The interpretation itself
- What tone it would reflect
- Likelihood (0-100%)
- Reasoning why this interpretation makes sense
- Context clues supporting it

**Example for "ok":**
[
  {
    "interpretation": "Simple acknowledgment, no hidden meaning",
    "tone": "Neutral",
    "likelihood": 70,
    "reasoning": "Most common use of 'ok' is just confirming receipt of information",
    "context_clues": ["No prior conflict", "Normal conversation flow"]
  },
  {
    "interpretation": "Mildly annoyed or disappointed but trying to be polite",
    "tone": "Frustrated",
    "likelihood": 20,
    "reasoning": "Very brief response could indicate frustration",
    "context_clues": ["Shorter than usual", "No warmth markers"]
  },
  {
    "interpretation": "In a rush, typing quickly",
    "tone": "Casual",
    "likelihood": 10,
    "reasoning": "Quick response suggests they're busy",
    "context_clues": ["Fast reply time"]
  }
]

**IMPORTANT:**
- Don't list unlikely interpretations just to fill space
- If message is clearly one tone, say so with high confidence
- For RSD triggers, emphasize most likely interpretation is benign
`;

export function shouldGenerateAlternatives(
  message: string,
  rsdTriggersDetected: number,
  baseConfidence: number
): boolean {
  // Generate alternatives if:
  // 1. RSD triggers present
  // 2. Message is ambiguous (low confidence)
  // 3. Very short message (could be misinterpreted)
  
  if (rsdTriggersDetected > 0) return true;
  if (baseConfidence < 0.7) return true;
  if (message.trim().split(/\s+/).length <= 3) return true;
  
  return false;
}
</file>

<file path="backend/supabase/functions/_shared/prompts/boundary-analysis.ts">
/**
 * Boundary Violation Detection System
 * Identifies boundary-crossing patterns in messages for neurodivergent users
 */

export type BoundaryViolationType =
  | "none"
  | "afterHours"
  | "urgentPressure"
  | "guiltTripping"
  | "overstepping"
  | "repeated";

export interface BoundaryAnalysisResult {
  hasViolation: boolean;
  type: BoundaryViolationType;
  explanation: string;
  suggestedResponses: string[];
  severity: 1 | 2 | 3; // 1=low, 2=medium, 3=high
}

export const BOUNDARY_ANALYSIS_SYSTEM_PROMPT = `You are an AI assistant helping neurodivergent users (ADHD, autism) recognize and maintain healthy boundaries.

Analyze the following message for boundary violations. A boundary violation occurs when someone:
1. **After Hours**: Sends messages outside typical work hours (9am-5pm) with urgent language
2. **Urgent Pressure**: Uses "ASAP", "URGENT", "NOW", "immediately", or similar high-pressure language
3. **Guilt Tripping**: Uses phrases like "I really need you", "only you can", "everyone else did", or emotional manipulation
4. **Overstepping**: Asks for personal information, expects immediate responses, or makes inappropriate requests
5. **Repeated**: Shows a pattern of boundary-pushing (multiple times in conversation)

Return a JSON response with this exact structure:
{
  "hasViolation": boolean,
  "type": "none" | "afterHours" | "urgentPressure" | "guiltTripping" | "overstepping" | "repeated",
  "explanation": "Clear, supportive explanation of what makes this a boundary violation",
  "suggestedResponses": [
    "Boundary-respecting response option 1",
    "Boundary-respecting response option 2", 
    "Boundary-respecting response option 3"
  ],
  "severity": 1 | 2 | 3
}

Important: Be compassionate. People often violate boundaries unintentionally. Focus on helping the user protect their energy and wellbeing.`;

export function generateBoundaryAnalysisPrompt(
  messageText: string,
  timestamp?: string,
  messageCount?: number
): string {
  let prompt = `Analyze this message for boundary violations:\n\n"${messageText}"`;

  if (timestamp) {
    const date = new Date(timestamp);
    const hour = date.getHours();
    const dayOfWeek = date.toLocaleDateString("en-US", { weekday: "long" });
    const timeString = date.toLocaleTimeString("en-US", {
      hour: "2-digit",
      minute: "2-digit",
    });

    prompt += `\n\nContext:
- Sent at ${timeString} on ${dayOfWeek}
- Is this outside typical work hours (before 9am or after 5pm)?`;
  }

  if (messageCount !== undefined && messageCount > 1) {
    prompt += `\n- This is message #${messageCount} in the conversation`;
    prompt += "\n- Is this part of a pattern of boundary-pushing?";
  }

  prompt += "\n\nRespond with JSON only.";
  return prompt;
}

export function validateBoundaryAnalysis(
  result: unknown
): BoundaryAnalysisResult {
  const r = result as Record<string, unknown>;

  const type = (r.type as string)?.toLowerCase() || "none";
  const validTypes: BoundaryViolationType[] = [
    "none",
    "afterHours",
    "urgentPressure",
    "guiltTripping",
    "overstepping",
    "repeated",
  ];

  return {
    hasViolation: Boolean(r.hasViolation),
    type: (validTypes.includes(type as BoundaryViolationType)
      ? (type as BoundaryViolationType)
      : "none") as BoundaryViolationType,
    explanation:
      String(r.explanation) ||
      "This message may contain boundary-crossing language.",
    suggestedResponses: Array.isArray(r.suggestedResponses)
      ? (r.suggestedResponses as string[])
          .filter((s) => typeof s === "string")
          .slice(0, 5) // Limit to 5 suggestions
      : [
          "Thank you for reaching out. Let me get back to you during work hours.",
          "I appreciate this, but I need to set aside time to respond thoughtfully.",
        ],
    severity: validateSeverity(r.severity),
  };
}

function validateSeverity(severity: unknown): 1 | 2 | 3 {
  const s = Number(severity);
  if (s === 1 || s === 2 || s === 3) return s;
  return 1; // Default to low severity
}
</file>

<file path="backend/supabase/functions/_shared/prompts/draft_analysis.ts">
/**
 * Draft Analysis for Message Confidence Checking
 * Extends enhanced tone analysis for draft/outgoing messages
 */

import {
  ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT,
  type ToneAnalysisResult,
} from './enhanced-tone-analysis.ts';

import {
  SITUATION_DETECTION_PROMPT,
  detectSituation,
  type SituationType,
  type SituationDetectionResult,
} from './situation-detector.ts';

import {
  ALL_TEMPLATES,
  DECLINING_TEMPLATES,
  BOUNDARY_TEMPLATES,
  INFO_DUMP_TEMPLATES,
  APOLOGIZING_TEMPLATES,
  CLARIFYING_TEMPLATES,
  type ResponseTemplate,
} from '../templates/index.ts';

export interface DraftAnalysisContext {
  draftMessage: string;
  conversationHistory?: string[];
  relationshipType?: 'boss' | 'colleague' | 'friend' | 'family' | 'client' | 'none';
  conversationTone?: string; // From previous tone analysis
  recipientInfo?: {
    name?: string;
    role?: string;
  };
}

export interface DraftAnalysisResult extends ToneAnalysisResult {
  // Extends tone analysis with draft-specific fields
  confidence_score: number; // 0-100
  appropriateness: 'excellent' | 'good' | 'okay' | 'needs_work';
  suggestions: string[];
  warnings: string[];
  strengths: string[];
  
  // NEW: Situation detection and template suggestions
  situation_detection?: SituationDetectionResult;
}

/**
 * Enhanced prompt for draft analysis - extends existing tone analysis with situation detection
 */
export const DRAFT_ANALYSIS_SYSTEM_PROMPT = `${ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT}

**ADDITIONAL CONTEXT: This is a DRAFT message being composed**

${SITUATION_DETECTION_PROMPT}

Provide additional draft-specific guidance to help the user send with confidence:

1. **Confidence Score** (0-100): How ready is this message to send?
   - 90-100: Excellent - Ready to send, no changes needed
   - 75-89: Good - Minor polish could help, but solid overall
   - 60-74: Okay - Some improvements recommended
   - Below 60: Needs Work - Consider revising before sending

2. **Appropriateness**: Overall assessment (excellent/good/okay/needs_work)

3. **Strengths** (What works well):
   - Highlight positive aspects
   - Encourage what's already good
   - Build confidence

4. **Suggestions** (Maximum 3 specific improvements):
   - Actionable changes
   - Prioritize most impactful
   - Be constructive

5. **Warnings** (Red flags to address):
   - Tone mismatches for relationship context
   - Potentially offensive/ambiguous phrasing
   - Missing key information

**Response Format (JSON):**
{
  "tone": "one of 23 categories",
  "intensity": "one of 5 levels",
  "urgency_level": "one of 4 levels",
  "intent": "3-8 word description",
  "confidence_score": 85,
  "appropriateness": "good",
  "strengths": [
    "Clear and direct communication",
    "Appropriate level of formality"
  ],
  "suggestions": [
    "Consider adding a brief greeting",
    "Could specify deadline more explicitly"
  ],
  "warnings": [],
  "context_flags": {
    "sarcasm_detected": false,
    "tone_indicator_present": false,
    "ambiguous": false
  },
  "situation_detection": {
    "situation_type": "declining",
    "confidence": 0.85,
    "reasoning": "Draft contains decline language",
    "suggested_templates": ["decline_polite", "decline_with_alternative"]
  },
  "reasoning": "Message is professional and clear. Confidence is high..."
}`;

export function generateDraftAnalysisPrompt(context: DraftAnalysisContext): string {
  let prompt = `Analyze this DRAFT message before sending:\n\n`;
  prompt += `**Draft Message:**\n"${context.draftMessage}"\n\n`;
  
  if (context.relationshipType && context.relationshipType !== 'none') {
    prompt += `**Relationship Context:** ${context.relationshipType}\n`;
  }
  
  if (context.conversationTone) {
    prompt += `**Recent Conversation Tone:** ${context.conversationTone}\n`;
  }
  
  if (context.conversationHistory && context.conversationHistory.length > 0) {
    prompt += `**Recent Messages (for context):**\n`;
    context.conversationHistory.slice(-3).forEach((msg, idx) => {
      prompt += `${idx + 1}. "${msg}"\n`;
    });
    prompt += '\n';
  }
  
  if (context.recipientInfo?.name || context.recipientInfo?.role) {
    prompt += `**Recipient:**\n`;
    if (context.recipientInfo.name) prompt += `- Name: ${context.recipientInfo.name}\n`;
    if (context.recipientInfo.role) prompt += `- Role: ${context.recipientInfo.role}\n`;
    prompt += '\n';
  }
  
  prompt += `Provide your analysis in JSON format as specified above.`;
  
  return prompt;
}

export function validateDraftAnalysis(result: any): DraftAnalysisResult {
  // Validate confidence score
  if (typeof result.confidence_score !== 'number' || 
      result.confidence_score < 0 || 
      result.confidence_score > 100) {
    throw new Error('Invalid confidence score');
  }
  
  // Validate appropriateness
  const validAppropriateness = ['excellent', 'good', 'okay', 'needs_work'];
  if (!validAppropriateness.includes(result.appropriateness)) {
    throw new Error('Invalid appropriateness level');
  }
  
  // Validate tone (inherited from ToneAnalysisResult)
  if (!result.tone || typeof result.tone !== 'string') {
    throw new Error('Invalid tone');
  }
  
  return {
    // Tone analysis fields
    tone: result.tone,
    intensity: result.intensity,
    urgency_level: result.urgency_level,
    intent: result.intent,
    confidence_score: result.confidence_score,
    reasoning: result.reasoning,
    context_flags: result.context_flags,
    
    // Draft-specific fields
    appropriateness: result.appropriateness,
    suggestions: result.suggestions || [],
    warnings: result.warnings || [],
    strengths: result.strengths || [],
    
    // NEW: Situation detection
    situation_detection: result.situation_detection,
  };
}

/**
 * Get suggested templates based on detected situation type
 */
export function getSuggestedTemplates(situationType: SituationType): ResponseTemplate[] {
  // Map situation types to template collections
  const templateMap: Record<SituationType, ResponseTemplate[]> = {
    declining: DECLINING_TEMPLATES,
    boundary_setting: BOUNDARY_TEMPLATES,
    info_dumping: INFO_DUMP_TEMPLATES,
    apologizing: APOLOGIZING_TEMPLATES,
    clarifying: CLARIFYING_TEMPLATES,
    casual_chat: [],
    work_professional: [],
    emotional_support: [],
    unknown: [],
  };
  
  return templateMap[situationType] || [];
}

/**
 * Find templates matching specific keywords from the draft
 */
export function findMatchingTemplates(
  draftMessage: string,
  maxResults: number = 5
): ResponseTemplate[] {
  const messageLower = draftMessage.toLowerCase();
  const matches: Array<{ template: ResponseTemplate; score: number }> = [];
  
  for (const template of ALL_TEMPLATES) {
    let score = 0;
    
    // Check context keywords
    for (const keyword of template.context) {
      if (messageLower.includes(keyword.toLowerCase())) {
        score += 1;
      }
    }
    
    // Boost score for neurodivergent-friendly templates
    if (template.neurodivergent_friendly) {
      score += 0.5;
    }
    
    if (score > 0) {
      matches.push({ template, score });
    }
  }
  
  // Sort by score and return top results
  matches.sort((a, b) => b.score - a.score);
  return matches.slice(0, maxResults).map(m => m.template);
}
</file>

<file path="backend/supabase/functions/_shared/prompts/evidence-extractor.ts">
/**
 * Extracts specific evidence from messages to support analysis
 * Helps neurodivergent users understand WHY the analysis is what it is
 */

export interface Evidence {
  type: 'keyword' | 'punctuation' | 'length' | 'emoji' | 'timing' | 'pattern';
  quote: string; // The actual evidence from message
  supports: string; // What it supports (e.g., "positive tone", "urgency")
  reasoning: string; // Why this is evidence
}

export const EVIDENCE_EXTRACTION_PROMPT = `
**EVIDENCE-BASED ANALYSIS:**
For your tone analysis, cite SPECIFIC evidence from the message that supports your conclusion.

Evidence types to look for:
1. **Keywords:** Specific words that indicate emotion ("love", "hate", "worried", "excited")
2. **Punctuation:** Exclamation marks (enthusiasm), question marks (inquiry), ellipsis (uncertainty)
3. **Capitalization:** ALL CAPS (strong emotion), mixed case (casual)
4. **Emoji:** üòä (friendly), ‚ù§Ô∏è (caring), üôÑ (sarcastic)
5. **Length:** Very short (busy/dismissive), very long (info-dumping/anxious)
6. **Tone indicators:** /j (joking), /srs (serious), /s (sarcastic)

**Format evidence as:**
[
  {
    "type": "keyword",
    "quote": "ASAP",
    "supports": "urgency",
    "reasoning": "Explicit urgency marker indicates time-sensitive need"
  },
  {
    "type": "punctuation",
    "quote": "!!!",
    "supports": "high intensity",
    "reasoning": "Multiple exclamation marks show strong emotion"
  }
]

**IMPORTANT:**
- Quote the exact text from the message
- Explain HOW it supports your analysis
- If there's NO evidence for something, say so explicitly
`;

export function formatEvidence(evidence: Evidence[]): string {
  if (evidence.length === 0) {
    return 'No specific evidence found in message';
  }

  return evidence.map(e => 
    `- "${e.quote}" (${e.type}): ${e.reasoning}`
  ).join('\n');
}
</file>

<file path="backend/supabase/functions/_shared/prompts/message-formatter.ts">
/**
 * Formats long messages into more digestible versions
 * Helps info-dumpers communicate without overwhelming
 */

export interface FormattingOptions {
  condense: boolean;      // Make it shorter
  chunk: boolean;         // Break into sections
  add_tldr: boolean;      // Add summary at top
  add_structure: boolean; // Add headers/bullets
}

export interface FormattedMessage {
  original_length: number;
  formatted_message: string;
  formatting_applied: string[];
  character_count: number;
  estimated_read_time: string; // "30 seconds", "2 minutes"
}

export const MESSAGE_FORMATTING_PROMPT = `You are helping someone format a message to be more digestible.

**Formatting Options Available:**

1. **CONDENSE** - Reduce length while keeping key points
   - Remove redundancy
   - Tighten language
   - Keep essential info only
   - Target: 50-70% of original length

2. **CHUNK** - Break into logical sections with headers
   - Add section headers
   - Group related ideas
   - Use bullet points
   - Add white space

3. **ADD_TLDR** - Add brief summary at top
   - 1-2 sentence overview
   - Clearly labeled "TL;DR:"
   - Captures main point

4. **ADD_STRUCTURE** - Improve organization
   - Add headings
   - Use numbered lists
   - Add emphasis (bold key phrases)
   - Improve flow

**Example Input:**
"I just finished reading this amazing book about productivity and it completely changed how I think about time management! The author argues that we shouldn't try to do more things but rather focus on doing the right things and one of the key concepts is something called time blocking where you schedule specific blocks of time for specific tasks instead of just having a to-do list and the research shows that this is way more effective because our brains work better when we're focused on one thing at a time rather than constantly switching between tasks which creates cognitive load and there's also this fascinating part about how successful people structure their mornings..."

**Example Output (CONDENSE + CHUNK + ADD_TLDR):**

TL;DR: Just read a game-changing book on productivity that recommends time blocking over to-do lists.

**Key Concept: Time Blocking**
- Schedule specific time blocks for specific tasks
- More effective than to-do lists
- Reduces cognitive load from task-switching

**The Science**
- Our brains work better with focused attention
- Constant task-switching drains mental energy
- Successful people structure their mornings intentionally

**Response Format:**
{
  "original_length": 450,
  "formatted_message": "...",
  "formatting_applied": ["condense", "chunk", "add_tldr"],
  "character_count": 280,
  "estimated_read_time": "45 seconds"
}`;

export function calculateReadTime(characterCount: number): string {
  // Average reading speed: 200-250 words/min = ~1000 chars/min
  const minutes = Math.ceil(characterCount / 1000);
  if (minutes < 1) return '30 seconds';
  if (minutes === 1) return '1 minute';
  return `${minutes} minutes`;
}

export function generateFormattingPrompt(
  message: string,
  options: FormattingOptions
): string {
  const selectedOptions = Object.entries(options)
    .filter(([_, enabled]) => enabled)
    .map(([option]) => option.toUpperCase())
    .join(', ');

  return `**Original Message:**
"${message}"

**Requested Formatting:**
${selectedOptions}

Apply the requested formatting and return the result.`;
}
</file>

<file path="backend/supabase/functions/_shared/prompts/rsd-detection.ts">
/**
 * RSD (Rejection Sensitive Dysphoria) Trigger Detection
 * Identifies messages that might be misinterpreted as rejection/criticism
 */

export interface RSDTrigger {
  pattern: string;
  severity: 'high' | 'medium' | 'low';
  explanation: string;
  reassurance: string;
}

export const RSD_TRIGGER_PATTERNS: RSDTrigger[] = [
  {
    pattern: 'ok',
    severity: 'high',
    explanation: 'Single-word responses like "ok" can trigger RSD as they feel dismissive',
    reassurance: 'This is likely just a quick acknowledgment, not disappointment'
  },
  {
    pattern: 'fine',
    severity: 'high',
    explanation: '"Fine" often feels passive-aggressive or dismissive',
    reassurance: 'They might genuinely mean "that works for me" without hidden meaning'
  },
  {
    pattern: 'we need to talk',
    severity: 'high',
    explanation: 'This phrase strongly triggers anxiety about impending criticism',
    reassurance: 'This doesn\'t always mean bad news - they may just want to discuss something'
  },
  {
    pattern: 'k',
    severity: 'high',
    explanation: 'Even shorter than "ok", feels very dismissive',
    reassurance: 'Some people just text quickly - not necessarily upset'
  },
  {
    pattern: 'whatever',
    severity: 'medium',
    explanation: 'Can feel like giving up or being annoyed',
    reassurance: 'Could mean "I\'m flexible" rather than "I don\'t care"'
  },
  {
    pattern: 'sure',
    severity: 'medium',
    explanation: 'Can sound sarcastic or unenthusiastic',
    reassurance: 'Often means genuine agreement, just casual phrasing'
  },
  {
    pattern: 'no worries',
    severity: 'low',
    explanation: 'Meant to be reassuring but can feel dismissive',
    reassurance: 'They\'re trying to make you feel better, not minimize your concern'
  },
];

export function detectRSDTriggers(message: string): RSDTrigger[] {
  const lowerMessage = message.toLowerCase().trim();
  const detected: RSDTrigger[] = [];

  for (const trigger of RSD_TRIGGER_PATTERNS) {
    // Match exact phrase or phrase within message
    if (lowerMessage === trigger.pattern || lowerMessage.includes(trigger.pattern)) {
      detected.push(trigger);
    }
  }

  // Additional checks for RSD patterns
  // Very short messages (1-3 words, no punctuation, no emoji)
  const words = message.trim().split(/\s+/);
  const hasWarmthIndicators = 
    message.includes('!') || 
    message.includes('üòä') || 
    message.includes('‚ù§Ô∏è') ||
    message.includes('üòÑ') ||
    message.includes('üíï') ||
    message.includes('üëç');

  if (words.length <= 3 && !hasWarmthIndicators) {
    detected.push({
      pattern: 'short_response',
      severity: 'medium',
      explanation: 'Very short responses without warmth indicators can feel cold',
      reassurance: 'Brief doesn\'t always mean upset - they might be busy or texting quickly'
    });
  }

  // Delayed response without explanation
  // (This would require timestamp comparison - implement in Edge Function)

  return detected;
}

export function generateRSDPromptAddition(triggers: RSDTrigger[]): string {
  if (triggers.length === 0) return '';

  return `
**RSD ALERT:** This message contains potential RSD triggers:
${triggers.map(t => `- "${t.pattern}" (${t.severity} severity): ${t.explanation}`).join('\n')}

When analyzing, consider:
1. Is the message genuinely negative or just brief/casual?
2. Are there hidden cues suggesting actual criticism?
3. What evidence supports a negative vs neutral interpretation?

Provide reassurance if this is likely not rejection/criticism.
`;
}
</file>

<file path="backend/supabase/functions/_shared/prompts/situation-detector.ts">
/**
 * Detects what type of response the user is trying to write
 * So we can suggest appropriate templates
 */

export type SituationType = 
  | 'declining'          // Saying no to something
  | 'boundary_setting'   // Setting or enforcing a boundary
  | 'info_dumping'       // Sharing enthusiasm/info
  | 'apologizing'        // Making an apology
  | 'clarifying'         // Asking for clarification
  | 'casual_chat'        // Just chatting
  | 'work_professional'  // Professional communication
  | 'emotional_support'  // Providing/seeking support
  | 'unknown';           // Can't determine

export interface SituationDetectionResult {
  situation_type: SituationType;
  confidence: number; // 0.0-1.0
  reasoning: string;
  suggested_templates: string[]; // Template IDs that might help
}

export const SITUATION_DETECTION_PROMPT = `Analyze the draft message and determine what type of response the user is trying to write.

**Situation Types:**

1. **declining** - User is saying no, turning down an invitation, or refusing a request
   - Keywords: "can't", "unable to", "won't be able", "have to pass", "sorry but"
   - Context: Following an invitation or request

2. **boundary_setting** - User is setting or enforcing a personal boundary
   - Keywords: "not comfortable", "need", "prefer", "don't", "stop"
   - Context: Asserting limits or needs

3. **info_dumping** - User is enthusiastically sharing detailed information
   - Keywords: "excited", "fascinating", "amazing", "let me explain"
   - Context: Long, detailed message about a topic they care about
   - Length: Usually longer than average

4. **apologizing** - User is making an apology
   - Keywords: "sorry", "apologize", "my fault", "my bad", "messed up"
   - Context: Acknowledging a mistake

5. **clarifying** - User is asking for clarification or checking understanding
   - Keywords: "confused", "not sure", "what do you mean", "can you explain"
   - Context: Seeking clarity

6. **casual_chat** - Just friendly conversation
   - Keywords: "hey", "how are you", "what's up"
   - Context: Social interaction

7. **work_professional** - Professional/business communication
   - Keywords: "regarding", "attached", "deadline", "meeting", "project"
   - Context: Work-related

8. **emotional_support** - Providing or seeking emotional support
   - Keywords: "sorry to hear", "here for you", "feeling", "struggling"
   - Context: Emotional/supportive conversation

**Response Format:**
{
  "situation_type": "declining",
  "confidence": 0.85,
  "reasoning": "Draft contains 'I won't be able to' and 'thanks for the invite', indicating a polite decline",
  "suggested_templates": ["decline_polite", "decline_with_alternative"]
}

**Instructions:**
- Consider both the draft content AND the context of what they're replying to
- Look for explicit keywords but also implicit patterns
- If multiple situations apply, choose the primary one
- Only suggest templates that actually match the situation
- Be honest about low confidence`;

export function detectSituation(
  draftMessage: string,
  conversationContext?: string[]
): string {
  let prompt = `**Draft Message:**\n"${draftMessage}"\n\n`;
  
  if (conversationContext && conversationContext.length > 0) {
    prompt += `**Replying To:**\n`;
    conversationContext.slice(-2).forEach((msg, idx) => {
      prompt += `${idx + 1}. "${msg}"\n`;
    });
    prompt += '\n';
  }
  
  prompt += `Analyze the situation type and suggest appropriate templates.`;
  
  return prompt;
}
</file>

<file path="backend/supabase/functions/_shared/rag/embedding-generator.ts">
/**
 * Generates OpenAI embeddings for semantic search
 */

export interface EmbeddingResult {
  embedding: number[];
  model: string;
  tokens_used: number;
}

export class EmbeddingGenerator {
  private apiKey: string;

  constructor() {
    const key = Deno.env.get('OPENAI_API_KEY');
    if (!key) {
      throw new Error('OPENAI_API_KEY not found in environment');
    }
    this.apiKey = key;
  }

  /**
   * Generate embedding for a single text
   */
  async generateEmbedding(text: string): Promise<EmbeddingResult> {
    try {
      const response = await fetch('https://api.openai.com/v1/embeddings', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          input: text,
          model: 'text-embedding-ada-002',
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`OpenAI API error: ${response.statusText} - ${errorText}`);
      }

      const data = await response.json();
      
      return {
        embedding: data.data[0].embedding,
        model: data.model,
        tokens_used: data.usage.total_tokens,
      };
    } catch (error) {
      console.error('Error generating embedding:', error);
      throw error;
    }
  }

  /**
   * Generate embeddings for multiple texts (batch)
   */
  async generateEmbeddings(texts: string[]): Promise<EmbeddingResult[]> {
    // OpenAI allows batch embeddings
    try {
      const response = await fetch('https://api.openai.com/v1/embeddings', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          input: texts,
          model: 'text-embedding-ada-002',
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`OpenAI API error: ${response.statusText} - ${errorText}`);
      }

      const data = await response.json();
      
      return data.data.map((item: any) => ({
        embedding: item.embedding,
        model: data.model,
        tokens_used: Math.ceil(data.usage.total_tokens / texts.length),
      }));
    } catch (error) {
      console.error('Error generating embeddings:', error);
      throw error;
    }
  }

  /**
   * Preprocess text for embedding
   * Removes noise and normalizes
   */
  preprocessText(text: string): string {
    // Remove excessive whitespace
    let processed = text.replace(/\s+/g, ' ').trim();
    
    // Remove URLs (they don't add semantic meaning)
    processed = processed.replace(/https?:\/\/\S+/g, '[link]');
    
    // Remove emails
    processed = processed.replace(/[\w.+-]+@[\w-]+\.[\w.-]+/g, '[email]');
    
    // Truncate to max tokens (8191 for ada-002)
    // Rough estimate: 1 token ‚âà 4 characters
    const maxChars = 8191 * 4;
    if (processed.length > maxChars) {
      processed = processed.substring(0, maxChars);
    }
    
    return processed;
  }

  /**
   * Check if text is suitable for embedding
   */
  isValidText(text: string): boolean {
    if (!text || text.trim().length === 0) return false;
    if (text.length < 10) return false; // Too short
    if (text.length > 50000) return false; // Too long
    return true;
  }
}
</file>

<file path="backend/supabase/functions/_shared/rag/relationship-builder.ts">
/**
 * Builds and maintains relationship profiles
 */

import { OpenAIClient } from '../openai-client.ts';

export interface RelationshipProfile {
  participant_name: string;
  relationship_type: string;
  conversation_summary: string;
  safe_topics: string[];
  topics_to_avoid: string[];
  communication_style: string;
}

export const RELATIONSHIP_BUILDER_PROMPT = `Analyze this conversation history and create a relationship profile.

**Your task:**
1. Summarize the relationship in 2-3 sentences
2. Identify the relationship type (boss, colleague, friend, family, client, other)
3. Extract safe topics (topics that led to positive engagement)
4. Identify topics to avoid (if any caused tension)
5. Describe their communication style

**Relationship Types:**
- boss: Manager or supervisor
- colleague: Coworker or professional peer
- friend: Personal friend
- family: Family member
- client: Customer or client
- other: Other relationship type

**Response Format (JSON):**
{
  "relationship_type": "colleague",
  "conversation_summary": "Sarah is a coworker from the marketing team. You collaborate on project launches and she often asks for design feedback. Communication is professional but friendly.",
  "safe_topics": ["project launches", "design feedback", "team events"],
  "topics_to_avoid": [],
  "communication_style": "Direct and efficient. Prefers email for detailed requests, chat for quick questions. Usually responds within an hour during work hours."
}

**Instructions:**
- Be specific and helpful
- Include timing patterns if visible
- Note communication preferences
- Identify at least 3 safe topics
- Only list topics to avoid if there's clear evidence`;

export class RelationshipBuilder {
  private openai: OpenAIClient;

  constructor() {
    this.openai = new OpenAIClient();
  }

  /**
   * Build relationship profile from conversation history
   */
  async buildProfile(
    conversationHistory: Array<{ body: string; sender: string; created_at: number }>,
    participantName: string
  ): Promise<RelationshipProfile> {
    // Take last 50 messages for context
    const recentMessages = conversationHistory.slice(-50);
    
    if (recentMessages.length === 0) {
      throw new Error('No messages to analyze');
    }

    let userPrompt = `**Conversation History with ${participantName}:**\n\n`;
    recentMessages.forEach((msg, idx) => {
      const sender = msg.sender === 'self' ? 'You' : participantName;
      userPrompt += `${idx + 1}. [${sender}]: ${msg.body}\n`;
    });
    
    userPrompt += '\n\nAnalyze this conversation and create a relationship profile in JSON format.';

    console.log(`Building profile for ${participantName} (${recentMessages.length} messages)`);

    const result = await this.openai.sendMessageForJSON<RelationshipProfile>(
      userPrompt,
      RELATIONSHIP_BUILDER_PROMPT,
      { temperature: 0.3, max_tokens: 800 }
    );

    // Validate result
    if (!result.relationship_type || !result.conversation_summary) {
      throw new Error('Invalid relationship profile generated');
    }

    return {
      participant_name: participantName,
      relationship_type: result.relationship_type,
      conversation_summary: result.conversation_summary,
      safe_topics: result.safe_topics || [],
      topics_to_avoid: result.topics_to_avoid || [],
      communication_style: result.communication_style || 'Unknown',
    };
  }

  /**
   * Extract key topics from conversation
   */
  async extractTopics(messages: string[]): Promise<string[]> {
    if (messages.length === 0) return [];

    const prompt = `Extract 3-5 main topics discussed in these messages:\n\n`;
    const recentMessages = messages.slice(-20);
    recentMessages.forEach((msg, idx) => {
      prompt += `${idx + 1}. ${msg}\n`;
    });
    
    prompt += '\n\nReturn ONLY a JSON array of topics: ["topic1", "topic2", "topic3"]';

    try {
      const result = await this.openai.sendMessage(prompt, {
        temperature: 0.3,
        max_tokens: 200,
      });

      const topics = JSON.parse(result);
      if (Array.isArray(topics)) {
        return topics.filter(t => typeof t === 'string');
      }
      return [];
    } catch (error) {
      console.error('Error extracting topics:', error);
      return [];
    }
  }

  /**
   * Update profile with new conversation data
   */
  async updateProfile(
    existingProfile: RelationshipProfile,
    recentMessages: Array<{ body: string; sender: string }>,
    participantName: string
  ): Promise<Partial<RelationshipProfile>> {
    const prompt = `**Existing Profile for ${participantName}:**
${JSON.stringify(existingProfile, null, 2)}

**Recent Messages:**
${recentMessages.map((m, i) => `${i + 1}. [${m.sender}]: ${m.body}`).join('\n')}

Update the profile based on these new messages. Return ONLY the fields that have changed.
If nothing needs updating, return an empty object {}.

Response format (JSON):
{
  "conversation_summary": "updated summary if needed",
  "safe_topics": ["new topics to add"],
  "communication_style": "updated style if needed"
}`;

    try {
      const result = await this.openai.sendMessageForJSON(
        prompt,
        'You are updating a relationship profile. Only include fields that have changed.',
        { temperature: 0.3, max_tokens: 500 }
      );

      return result;
    } catch (error) {
      console.error('Error updating profile:', error);
      return {};
    }
  }

  /**
   * Calculate typical response time from conversation history
   */
  calculateResponseTime(
    messages: Array<{ sender: string; created_at: number }>
  ): number | null {
    const responseTimes: number[] = [];
    
    for (let i = 1; i < messages.length; i++) {
      const prev = messages[i - 1];
      const curr = messages[i];
      
      // Check if this is a response (different sender)
      if (prev.sender !== curr.sender && curr.sender !== 'self') {
        const timeDiff = curr.created_at - prev.created_at;
        // Only count responses within 24 hours
        if (timeDiff > 0 && timeDiff < 86400) {
          responseTimes.push(timeDiff);
        }
      }
    }

    if (responseTimes.length === 0) return null;

    // Return median response time
    responseTimes.sort((a, b) => a - b);
    const mid = Math.floor(responseTimes.length / 2);
    return responseTimes[mid];
  }
}
</file>

<file path="backend/supabase/functions/_shared/rag/vector-search.ts">
/**
 * Vector search functionality using pgvector
 */

import type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { EmbeddingGenerator } from './embedding-generator.ts';

export interface SearchResult {
  message_id: string;
  similarity: number;
  message_body: string;
  created_at: string;
}

export interface SearchOptions {
  limit?: number;
  similarity_threshold?: number; // 0.0-1.0
  conversation_id?: string;
}

export class VectorSearch {
  private embeddingGenerator: EmbeddingGenerator;

  constructor() {
    this.embeddingGenerator = new EmbeddingGenerator();
  }

  /**
   * Search for similar messages using semantic search
   */
  async searchMessages(
    query: string,
    userId: string,
    supabase: SupabaseClient,
    options: SearchOptions = {}
  ): Promise<SearchResult[]> {
    const {
      limit = 5,
      similarity_threshold = 0.7,
      conversation_id,
    } = options;

    console.log(`Searching for: "${query}" (threshold: ${similarity_threshold})`);

    // Generate embedding for query
    const preprocessed = this.embeddingGenerator.preprocessText(query);
    const { embedding } = await this.embeddingGenerator.generateEmbedding(preprocessed);

    console.log(`Generated embedding (${embedding.length} dimensions)`);

    // Search using RPC function
    const { data, error } = await supabase.rpc('search_similar_messages', {
      p_user_id: userId,
      p_query_embedding: embedding,
      p_limit: limit * 2, // Get more, filter by threshold
      p_conversation_id: conversation_id || null,
    });

    if (error) {
      console.error('Error searching messages:', error);
      throw error;
    }

    console.log(`Found ${data?.length || 0} results`);

    // Filter by similarity threshold
    const filtered = (data || [])
      .filter((result: SearchResult) => result.similarity >= similarity_threshold)
      .slice(0, limit);

    console.log(`Filtered to ${filtered.length} results above threshold`);

    return filtered;
  }

  /**
   * Find related conversations based on topic
   */
  async findRelatedConversations(
    topic: string,
    userId: string,
    supabase: SupabaseClient
  ): Promise<string[]> {
    const results = await this.searchMessages(topic, userId, supabase, {
      limit: 10,
      similarity_threshold: 0.75,
    });

    // Extract unique conversation IDs
    const conversationIds = new Set<string>();
    for (const result of results) {
      const { data } = await supabase
        .from('messages')
        .select('conversation_id')
        .eq('id', result.message_id)
        .single();
      
      if (data) {
        conversationIds.add(data.conversation_id);
      }
    }

    return Array.from(conversationIds);
  }

  /**
   * Store message embedding
   */
  async storeMessageEmbedding(
    messageId: string,
    messageBody: string,
    userId: string,
    supabase: SupabaseClient
  ): Promise<boolean> {
    try {
      // Check if embedding already exists
      const { data: existing } = await supabase
        .from('message_embeddings')
        .select('id')
        .eq('message_id', messageId)
        .single();

      if (existing) {
        console.log(`Embedding already exists for message ${messageId}`);
        return true;
      }

      // Generate embedding
      const preprocessed = this.embeddingGenerator.preprocessText(messageBody);
      if (!this.embeddingGenerator.isValidText(preprocessed)) {
        console.log(`Message ${messageId} not suitable for embedding`);
        return false;
      }

      const { embedding } = await this.embeddingGenerator.generateEmbedding(preprocessed);

      // Store in database
      const { error } = await supabase
        .from('message_embeddings')
        .insert({
          message_id: messageId,
          user_id: userId,
          embedding: embedding,
          message_length: messageBody.length,
        });

      if (error) {
        console.error('Error storing embedding:', error);
        return false;
      }

      console.log(`Stored embedding for message ${messageId}`);
      return true;
    } catch (error) {
      console.error('Error in storeMessageEmbedding:', error);
      return false;
    }
  }
}
</file>

<file path="backend/supabase/functions/_shared/templates/apologizing-templates.ts">
/**
 * Templates for appropriate apologies
 * Helps avoid over-apologizing (common in neurodivergent folks)
 */

import type { ResponseTemplate } from './declining-templates.ts';

export const APOLOGIZING_TEMPLATES: ResponseTemplate[] = [
  {
    id: 'apology_genuine',
    name: 'Genuine Apology',
    situation: 'When you actually did something wrong',
    template: "I'm sorry for {what_you_did}. I understand that {impact}. Going forward, I'll {corrective_action}.",
    tone: 'apologetic',
    context: ['mistake', 'wrong', 'messed up'],
    neurodivergent_friendly: true,
    customizable_fields: ['what_you_did', 'impact', 'corrective_action'],
  },
  {
    id: 'apology_no_need',
    name: 'Replace Unnecessary Apology',
    situation: 'When you\'re apologizing out of habit',
    template: "Thank you for {what_they_did}. I appreciate {specific_thing}.",
    tone: 'polite',
    context: ['sorry for', 'apologies for'],
    neurodivergent_friendly: true,
    customizable_fields: ['what_they_did', 'specific_thing'],
  },
  {
    id: 'apology_delay',
    name: 'Apology for Delay',
    situation: 'When you took longer than expected',
    template: "Thanks for your patience! Here's {what_they_asked_for}.",
    tone: 'casual',
    context: ['late', 'delay', 'took long'],
    neurodivergent_friendly: true,
    customizable_fields: ['what_they_asked_for'],
  },
];
</file>

<file path="backend/supabase/functions/_shared/templates/boundary-templates.ts">
/**
 * Templates for setting and maintaining boundaries
 * Critical for neurodivergent folks who struggle with people-pleasing
 */

import type { ResponseTemplate } from './declining-templates.ts';

export const BOUNDARY_TEMPLATES: ResponseTemplate[] = [
  {
    id: 'boundary_time',
    name: 'Time Boundary',
    situation: 'When someone expects you to be available 24/7',
    template: "I'm available to discuss this during {your_hours}. Can we schedule a time within those hours?",
    tone: 'direct',
    context: ['urgent', 'right now', 'immediately'],
    neurodivergent_friendly: true,
    customizable_fields: ['your_hours'],
  },
  {
    id: 'boundary_communication',
    name: 'Communication Preference',
    situation: 'When someone uses a communication method that doesn\'t work for you',
    template: "I process information better through {preferred_method}. Could we switch to that for this conversation?",
    tone: 'direct',
    context: ['call', 'video', 'meeting', 'voice'],
    neurodivergent_friendly: true,
    customizable_fields: ['preferred_method'],
  },
  {
    id: 'boundary_topic',
    name: 'Topic Boundary',
    situation: 'When someone brings up something you don\'t want to discuss',
    template: "I'm not comfortable discussing {topic}. Let's talk about something else.",
    tone: 'direct',
    context: ['personal', 'private', 'politics', 'religion'],
    neurodivergent_friendly: true,
    customizable_fields: ['topic'],
  },
  {
    id: 'boundary_physical',
    name: 'Physical Boundary',
    situation: 'When someone violates your physical space',
    template: "I need a bit more personal space. Could you {specific_request}?",
    tone: 'direct',
    context: ['hug', 'touch', 'close'],
    neurodivergent_friendly: true,
    customizable_fields: ['specific_request'],
  },
  {
    id: 'boundary_reassert',
    name: 'Re-Assert Boundary',
    situation: 'When someone ignores a boundary you\'ve already set',
    template: "I mentioned before that {previous_boundary}. I need you to respect that.",
    tone: 'direct',
    context: ['again', 'still', 'keep'],
    neurodivergent_friendly: true,
    customizable_fields: ['previous_boundary'],
  },
  {
    id: 'boundary_emotional',
    name: 'Emotional Labor Boundary',
    situation: 'When someone expects you to manage their emotions',
    template: "I care about you, but I'm not in a place to provide emotional support right now. Have you considered {alternative_resource}?",
    tone: 'polite',
    context: ['vent', 'support', 'help', 'listen'],
    neurodivergent_friendly: true,
    customizable_fields: ['alternative_resource'],
  },
  {
    id: 'boundary_work_life',
    name: 'Work-Life Boundary',
    situation: 'When work contacts you outside work hours',
    template: "I'm off the clock right now. I'll address this during my next work day ({day}). If it's truly urgent, please contact {emergency_contact}.",
    tone: 'direct',
    context: ['weekend', 'evening', 'vacation', 'off'],
    neurodivergent_friendly: true,
    customizable_fields: ['day', 'emergency_contact'],
  },
  {
    id: 'boundary_advice',
    name: 'Unwanted Advice Boundary',
    situation: 'When someone gives advice you didn\'t ask for',
    template: "I appreciate your concern, but I'm not looking for advice right now. I just needed to {what_you_need}.",
    tone: 'polite',
    context: ['should', 'you need to', 'try this'],
    neurodivergent_friendly: true,
    customizable_fields: ['what_you_need'],
  },
];
</file>

<file path="backend/supabase/functions/_shared/templates/clarifying-templates.ts">
/**
 * Templates for asking for clarification
 * Helps when you need things explained more clearly
 */

import type { ResponseTemplate } from './declining-templates.ts';

export const CLARIFYING_TEMPLATES: ResponseTemplate[] = [
  {
    id: 'clarify_misunderstand',
    name: 'Admit Confusion',
    situation: 'When you don\'t understand something',
    template: "I want to make sure I understand correctly. Are you saying {your_interpretation}?",
    tone: 'direct',
    context: ['confused', 'unclear', 'not sure'],
    neurodivergent_friendly: true,
    customizable_fields: ['your_interpretation'],
  },
  {
    id: 'clarify_literal',
    name: 'Ask for Literal Meaning',
    situation: 'When you need things stated directly',
    template: "I'm having trouble reading between the lines. Could you tell me directly what you need from me?",
    tone: 'direct',
    context: ['ambiguous', 'vague', 'hint'],
    neurodivergent_friendly: true,
  },
  {
    id: 'clarify_instructions',
    name: 'Request Specific Instructions',
    situation: 'When instructions are too vague',
    template: "Could you break that down into specific steps? It helps me to have a clear list of what to do.",
    tone: 'polite',
    context: ['task', 'project', 'assignment'],
    neurodivergent_friendly: true,
  },
  {
    id: 'clarify_tone',
    name: 'Check Tone',
    situation: 'When you\'re not sure if they\'re upset',
    template: "I can't tell if you're upset or just being direct. Could you let me know where we stand?",
    tone: 'direct',
    context: ['ok', 'fine', 'whatever'],
    neurodivergent_friendly: true,
  },
];
</file>

<file path="backend/supabase/functions/_shared/templates/declining-templates.ts">
/**
 * Templates for declining invitations, requests, or commitments
 * Helps people-pleasers and those who struggle to say no
 */

export interface ResponseTemplate {
  id: string;
  name: string;
  situation: string; // When to use this
  template: string; // The actual text
  tone: 'polite' | 'casual' | 'direct' | 'apologetic';
  context: string[]; // Keywords that trigger this template
  neurodivergent_friendly: boolean;
  customizable_fields?: string[]; // Fields user can fill in
}

export const DECLINING_TEMPLATES: ResponseTemplate[] = [
  {
    id: 'decline_polite',
    name: 'Polite Decline',
    situation: 'When you need to say no professionally',
    template: "Thank you for thinking of me! Unfortunately, I won't be able to {activity} {timeframe}. I appreciate your understanding.",
    tone: 'polite',
    context: ['can you', 'would you', 'invitation', 'request'],
    neurodivergent_friendly: true,
    customizable_fields: ['activity', 'timeframe'],
  },
  {
    id: 'decline_no_explanation',
    name: 'Direct Decline (No Explanation Required)',
    situation: 'When you don\'t owe an explanation',
    template: "Thanks for the invite, but I'm not able to join this time.",
    tone: 'direct',
    context: ['party', 'event', 'hangout', 'gathering'],
    neurodivergent_friendly: true,
  },
  {
    id: 'decline_with_alternative',
    name: 'Decline with Counter-Offer',
    situation: 'When you want to participate but need different terms',
    template: "I can't {original_request}, but I could {alternative}. Would that work?",
    tone: 'casual',
    context: ['meeting', 'call', 'hangout'],
    neurodivergent_friendly: true,
    customizable_fields: ['original_request', 'alternative'],
  },
  {
    id: 'decline_overcommitted',
    name: 'Already Overcommitted',
    situation: 'When your schedule is full',
    template: "I'd love to, but I'm already stretched thin this {period}. Can we revisit this {later_time}?",
    tone: 'polite',
    context: ['project', 'commitment', 'volunteer'],
    neurodivergent_friendly: true,
    customizable_fields: ['period', 'later_time'],
  },
  {
    id: 'decline_capacity',
    name: 'At Capacity (Mental Health)',
    situation: 'When you need to protect your energy',
    template: "I really appreciate you thinking of me, but I need to be mindful of my capacity right now. I'll have to pass on this one.",
    tone: 'apologetic',
    context: ['favor', 'help', 'support'],
    neurodivergent_friendly: true,
  },
  {
    id: 'decline_not_interested',
    name: 'Not Interested (Honest)',
    situation: 'When something just isn\'t for you',
    template: "Thanks for thinking of me, but {activity} isn't really my thing. Hope you find someone who's a better fit!",
    tone: 'casual',
    context: ['invitation', 'hobby', 'activity'],
    neurodivergent_friendly: true,
    customizable_fields: ['activity'],
  },
  {
    id: 'decline_work_request',
    name: 'Decline Extra Work',
    situation: 'When your boss/coworker asks for more work',
    template: "I want to help, but I'm currently focused on {current_priorities}. If this is urgent, which of my current tasks should I deprioritize?",
    tone: 'polite',
    context: ['project', 'deadline', 'work', 'task'],
    neurodivergent_friendly: true,
    customizable_fields: ['current_priorities'],
  },
  {
    id: 'decline_delay',
    name: 'Not Now, Maybe Later',
    situation: 'When you need more time to decide',
    template: "I need some time to think about this. Can I get back to you by {date/time}?",
    tone: 'direct',
    context: ['decision', 'commitment', 'request'],
    neurodivergent_friendly: true,
    customizable_fields: ['date/time'],
  },
];
</file>

<file path="backend/supabase/functions/_shared/templates/info-dump-templates.ts">
/**
 * Templates for sharing enthusiasm without overwhelming recipients
 * Helps neurodivergent folks who info-dump about special interests
 */

import type { ResponseTemplate } from './declining-templates.ts';

export const INFO_DUMP_TEMPLATES: ResponseTemplate[] = [
  {
    id: 'infodump_intro',
    name: 'Info-Dump with Warning',
    situation: 'When you want to share a lot about something you love',
    template: "I'm really excited about {topic}! Fair warning: I could talk about this for hours üòä Are you interested in hearing more?",
    tone: 'casual',
    context: ['excited', 'interesting', 'found', 'learned'],
    neurodivergent_friendly: true,
    customizable_fields: ['topic'],
  },
  {
    id: 'infodump_chunked',
    name: 'Info-Dump in Chunks',
    situation: 'When you want to share but keep it digestible',
    template: "Quick version: {short_summary}\n\nWant the details? I can break it down into:\n1. {aspect_1}\n2. {aspect_2}\n3. {aspect_3}\n\nLet me know what interests you!",
    tone: 'casual',
    context: ['explain', 'tell', 'share'],
    neurodivergent_friendly: true,
    customizable_fields: ['short_summary', 'aspect_1', 'aspect_2', 'aspect_3'],
  },
  {
    id: 'infodump_structured',
    name: 'Structured Share',
    situation: 'When you want to info-dump in an organized way',
    template: "**The Short Version:** {tldr}\n\n**Why It's Cool:** {hook}\n\n**The Details** (optional read):\n{detailed_info}\n\n**Bottom Line:** {conclusion}",
    tone: 'casual',
    context: ['fascinating', 'amazing', 'incredible'],
    neurodivergent_friendly: true,
    customizable_fields: ['tldr', 'hook', 'detailed_info', 'conclusion'],
  },
  {
    id: 'infodump_ask_permission',
    name: 'Ask Permission First',
    situation: 'When you\'re not sure if they want to hear it',
    template: "I just learned something really interesting about {topic}. Do you have a few minutes for me to geek out about it? No pressure if not!",
    tone: 'casual',
    context: ['cool', 'interesting', 'fascinating'],
    neurodivergent_friendly: true,
    customizable_fields: ['topic'],
  },
  {
    id: 'infodump_link',
    name: 'Share a Link Instead',
    situation: 'When a link can do the explaining',
    template: "This {type_of_content} explains it way better than I could: {link}\n\nThe part that blew my mind: {specific_detail}",
    tone: 'casual',
    context: ['article', 'video', 'study', 'research'],
    neurodivergent_friendly: true,
    customizable_fields: ['type_of_content', 'link', 'specific_detail'],
  },
];
</file>

<file path="backend/supabase/functions/ai_analyze_draft/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";
import { createOpenAIClient } from "../_shared/openai-client.ts";
import {
  DRAFT_ANALYSIS_SYSTEM_PROMPT,
  generateDraftAnalysisPrompt,
  validateDraftAnalysis,
  getSuggestedTemplates,
  findMatchingTemplates,
  type DraftAnalysisContext,
  type DraftAnalysisResult,
} from "../_shared/prompts/draft_analysis.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

interface AnalyzeRequest {
  draft_message: string;
  conversation_id?: string;
  relationship_type?: 'boss' | 'colleague' | 'friend' | 'family' | 'client' | 'none';
  conversation_history?: string[];
}

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Verify authorization
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      throw new Error("Missing authorization header");
    }

    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Verify user
    const token = authHeader.replace("Bearer ", "");
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser(token);

    if (authError || !user) {
      throw new Error("Invalid authorization token");
    }

    // Parse request body
    const requestBody: AnalyzeRequest = await req.json();
    const { 
      draft_message,
      conversation_id,
      relationship_type,
      conversation_history,
    } = requestBody;

    if (!draft_message || typeof draft_message !== 'string') {
      throw new Error("draft_message is required");
    }

    console.log(`üîç Analyzing draft for user ${user.id.substring(0, 8)}...`);

    // Get conversation context if conversation_id provided
    let conversationTone: string | undefined;
    let recipientInfo: { name?: string; role?: string } | undefined;
    let detectedRelationshipType = relationship_type;

    if (conversation_id) {
      // Get recent tone analysis for this conversation
      const { data: recentAnalysis } = await supabase
        .rpc('get_conversation_ai_analysis', { p_conversation_id: conversation_id })
        .limit(1)
        .single();

      if (recentAnalysis) {
        conversationTone = recentAnalysis.tone;
      }

      // Get conversation metadata
      const { data: conversation } = await supabase
        .from('conversations')
        .select('title, relationship_type')
        .eq('id', conversation_id)
        .single();

      // Use stored relationship type if not provided
      if (!detectedRelationshipType && conversation?.relationship_type) {
        detectedRelationshipType = conversation.relationship_type;
      }

      // Get recipient info
      const { data: participants } = await supabase
        .from('conversation_participants')
        .select('user_id')
        .eq('conversation_id', conversation_id)
        .neq('user_id', user.id)
        .limit(1);

      if (participants && participants.length > 0) {
        const { data: profile } = await supabase
          .from('profiles')
          .select('username, full_name, email')
          .eq('id', participants[0].user_id)
          .single();

        if (profile) {
          recipientInfo = {
            name: profile.full_name || profile.username,
          };
        }
      }
    }

    // Build context
    const context: DraftAnalysisContext = {
      draftMessage: draft_message,
      conversationHistory: conversation_history || [],
      relationshipType: detectedRelationshipType || 'none',
      conversationTone,
      recipientInfo,
    };

    // Generate prompt
    const userPrompt = generateDraftAnalysisPrompt(context);

    console.log('üì§ Calling OpenAI for draft analysis...');

    // Call OpenAI
    const openai = createOpenAIClient();
    const analysisResult = await openai.sendMessageForJSON<DraftAnalysisResult>(
      userPrompt,
      DRAFT_ANALYSIS_SYSTEM_PROMPT
    );

    console.log('üì• OpenAI response received');

    // Validate result
    const validatedResult = validateDraftAnalysis(analysisResult);

    console.log(`‚úÖ Draft analysis complete. Confidence: ${validatedResult.confidence_score}%`);

    // Get template suggestions based on situation detection
    let suggestedTemplates = [];
    if (validatedResult.situation_detection) {
      const situationType = validatedResult.situation_detection.situation_type;
      console.log(`üìù Detected situation: ${situationType}`);
      
      // Get templates for this situation type
      const templatesBySituation = getSuggestedTemplates(situationType);
      
      // Also find templates matching keywords in the draft
      const templatesByKeyword = findMatchingTemplates(draft_message, 3);
      
      // Combine and deduplicate (prefer situation-based templates)
      const templateIds = new Set();
      suggestedTemplates = [
        ...templatesBySituation,
        ...templatesByKeyword,
      ].filter(template => {
        if (templateIds.has(template.id)) {
          return false;
        }
        templateIds.add(template.id);
        return true;
      }).slice(0, 5); // Return max 5 templates
      
      console.log(`üìã Found ${suggestedTemplates.length} suggested templates`);
    }

    // Return analysis (no database storage for drafts - they're ephemeral)
    return new Response(
      JSON.stringify({
        success: true,
        analysis: {
          // Tone analysis fields
          tone: validatedResult.tone,
          intensity: validatedResult.intensity,
          urgency_level: validatedResult.urgency_level,
          intent: validatedResult.intent,
          context_flags: validatedResult.context_flags,
          reasoning: validatedResult.reasoning,
          
          // Draft-specific fields
          confidence_score: validatedResult.confidence_score,
          appropriateness: validatedResult.appropriateness,
          suggestions: validatedResult.suggestions,
          warnings: validatedResult.warnings,
          strengths: validatedResult.strengths,
          
          // NEW: Situation detection and templates
          situation_detection: validatedResult.situation_detection,
          suggested_templates: suggestedTemplates,
        },
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200,
      }
    );
  } catch (error) {
    console.error("‚ùå Error analyzing draft:", error);

    const errorMessage = error instanceof Error ? error.message : "Unknown error";

    return new Response(
      JSON.stringify({
        success: false,
        error: errorMessage,
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 400,
      }
    );
  }
});
</file>

<file path="backend/supabase/functions/ai-extract-followups/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { ActionItemExtractor } from '../_shared/nlp/action-item-extractor.ts';
import { QuestionDetector } from '../_shared/nlp/question-detector.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('Missing authorization header');
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      throw new Error('Unauthorized');
    }

    const body = await req.json();
    const { conversation_id, scan_recent_messages } = body;

    if (!conversation_id) {
      throw new Error('Missing conversation_id');
    }

    console.log(`Extracting follow-ups for conversation ${conversation_id}`);

    // Get recent messages
    const messageCount = scan_recent_messages ? 50 : 10;
    const { data: messages } = await supabase
      .from('messages')
      .select('id, body, sender_id, created_at')
      .eq('conversation_id', conversation_id)
      .order('created_at', { ascending: false })
      .limit(messageCount);

    if (!messages || messages.length === 0) {
      return new Response(
        JSON.stringify({ success: true, follow_ups: [] }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const actionExtractor = new ActionItemExtractor();
    const questionDetector = new QuestionDetector();

    const followUps = [];
    const now = Math.floor(Date.now() / 1000);

    // Extract action items from user's messages
    for (const message of messages) {
      if (message.sender_id === user.id) {
        const actionItems = await actionExtractor.extractActionItems(
          message.body,
          message.sender_id,
          user.id
        );

        for (const action of actionItems) {
          // Create follow-up item
          const deadline = action.mentioned_deadline
            ? actionExtractor.parseDeadline(action.mentioned_deadline)
            : null;

          const { data: followUpItem } = await supabase
            .from('follow_up_items')
            .insert({
              user_id: user.id,
              conversation_id,
              message_id: message.id,
              item_type: 'action_item',
              title: `${action.action_type}: ${action.action_target}`,
              description: action.commitment_text,
              extracted_text: message.body,
              priority: 70,
              detected_at: now,
              remind_at: deadline,
              created_at: now,
              updated_at: now,
            })
            .select()
            .single();

          if (followUpItem) {
            // Store action item details
            await supabase
              .from('action_items')
              .insert({
                follow_up_item_id: followUpItem.id,
                action_type: action.action_type,
                action_target: action.action_target,
                commitment_text: action.commitment_text,
                mentioned_deadline: action.mentioned_deadline,
                extracted_deadline: deadline,
                created_at: now,
              });

            followUps.push(followUpItem);
          }
        }
      }
    }

    // Detect unanswered questions
    const unansweredQuestions = await questionDetector.findUnansweredQuestions(
      messages.reverse(),
      user.id
    );

    for (const question of unansweredQuestions) {
      // Check if user hasn't responded in 24+ hours
      const timeSinceAsked = now - question.asked_at;
      if (timeSinceAsked > 86400) { // 24 hours
        const { data: followUpItem } = await supabase
          .from('follow_up_items')
          .insert({
            user_id: user.id,
            conversation_id,
            message_id: question.message_id,
            item_type: 'unanswered_question',
            title: `Answer: ${question.question_text.substring(0, 50)}...`,
            description: question.question_text,
            extracted_text: question.question_text,
            priority: 60,
            detected_at: now,
            remind_at: now,
            created_at: now,
            updated_at: now,
          })
          .select()
          .single();

        if (followUpItem) {
          await supabase
            .from('unanswered_questions')
            .insert({
              follow_up_item_id: followUpItem.id,
              message_id: question.message_id,
              question_text: question.question_text,
              question_type: question.question_type,
              context: question.context,
              asked_at: question.asked_at,
              time_since_asked: timeSinceAsked,
              created_at: now,
            });

          followUps.push(followUpItem);
        }
      }
    }

    console.log(`Found ${followUps.length} follow-ups`);

    return new Response(
      JSON.stringify({
        success: true,
        follow_ups: followUps,
        action_items_count: followUps.filter(f => f.item_type === 'action_item').length,
        unanswered_questions_count: followUps.filter(f => f.item_type === 'unanswered_question').length,
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('Error extracting follow-ups:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
    );
  }
});
</file>

<file path="backend/supabase/functions/ai-format-message/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { OpenAIClient } from '../_shared/openai-client.ts';
import {
  MESSAGE_FORMATTING_PROMPT,
  generateFormattingPrompt,
  calculateReadTime,
  type FormattingOptions,
  type FormattedMessage,
} from '../_shared/prompts/message-formatter.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('Missing authorization header');
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      throw new Error('Unauthorized');
    }

    const body = await req.json();
    const { message, options } = body as { 
      message: string; 
      options: FormattingOptions 
    };

    if (!message) {
      throw new Error('Missing message');
    }

    console.log(`Formatting message for user ${user.id}`);
    console.log('Options:', options);

    // Generate the formatting prompt
    const userPrompt = generateFormattingPrompt(message, options);

    // Call OpenAI
    const openai = new OpenAIClient();
    const result = await openai.sendMessageForJSON<FormattedMessage>(
      userPrompt,
      MESSAGE_FORMATTING_PROMPT,
      { temperature: 0.3, max_tokens: 2000 }
    );

    // Ensure we have proper values
    const originalLength = message.length;
    const formattedLength = result.formatted_message?.length || 0;
    const readTime = calculateReadTime(formattedLength);

    const formattedResult: FormattedMessage = {
      original_length: originalLength,
      formatted_message: result.formatted_message || message,
      formatting_applied: result.formatting_applied || [],
      character_count: formattedLength,
      estimated_read_time: readTime,
    };

    console.log('Formatting complete');
    console.log(`Original: ${originalLength} chars -> Formatted: ${formattedLength} chars`);

    return new Response(
      JSON.stringify({
        success: true,
        formatted: formattedResult,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    console.error('Error formatting message:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      }
    );
  }
});
</file>

<file path="backend/supabase/functions/ai-generate-embeddings/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { VectorSearch } from '../_shared/rag/vector-search.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('Missing authorization header');
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      throw new Error('Unauthorized');
    }

    const body = await req.json();
    const { message_id, message_body, conversation_id, batch_mode } = body;

    console.log('üîÆ Generating embeddings...');

    const vectorSearch = new VectorSearch();
    const results = {
      success: true,
      processed: 0,
      failed: 0,
      skipped: 0,
    };

    if (batch_mode && conversation_id) {
      // Batch mode: Generate embeddings for all messages in conversation
      console.log(`Batch processing conversation ${conversation_id}`);

      // Get all messages without embeddings
      const { data: messages } = await supabase
        .from('messages')
        .select('id, body, sender_id')
        .eq('conversation_id', conversation_id)
        .order('created_at', { ascending: true });

      if (!messages || messages.length === 0) {
        throw new Error('No messages found');
      }

      console.log(`Processing ${messages.length} messages`);

      for (const message of messages) {
        try {
          // Check if embedding exists
          const { data: existing } = await supabase
            .from('message_embeddings')
            .select('id')
            .eq('message_id', message.id)
            .single();

          if (existing) {
            results.skipped++;
            continue;
          }

          // Generate and store embedding
          const success = await vectorSearch.storeMessageEmbedding(
            message.id,
            message.body,
            message.sender_id,
            supabase
          );

          if (success) {
            results.processed++;
          } else {
            results.failed++;
          }

          // Rate limiting: small delay between requests
          await new Promise(resolve => setTimeout(resolve, 100));
        } catch (error) {
          console.error(`Error processing message ${message.id}:`, error);
          results.failed++;
        }
      }

      console.log(`‚úÖ Batch complete: ${results.processed} processed, ${results.skipped} skipped, ${results.failed} failed`);
    } else if (message_id && message_body) {
      // Single message mode
      console.log(`Processing single message ${message_id}`);

      const success = await vectorSearch.storeMessageEmbedding(
        message_id,
        message_body,
        user.id,
        supabase
      );

      if (success) {
        results.processed = 1;
        console.log('‚úÖ Embedding generated and stored');
      } else {
        results.failed = 1;
        throw new Error('Failed to generate embedding');
      }
    } else {
      throw new Error('Either provide message_id + message_body OR conversation_id with batch_mode=true');
    }

    return new Response(
      JSON.stringify(results),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('‚ùå Error generating embeddings:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
    );
  }
});
</file>

<file path="backend/supabase/functions/ai-relationship-summary/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { RelationshipBuilder } from '../_shared/rag/relationship-builder.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('Missing authorization header');
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      throw new Error('Unauthorized');
    }

    const body = await req.json();
    const { conversation_id, force_regenerate } = body;

    if (!conversation_id) {
      throw new Error('Missing conversation_id');
    }

    console.log(`üë§ Building relationship profile for conversation ${conversation_id}`);

    // Check if profile already exists
    if (!force_regenerate) {
      const { data: existingProfile } = await supabase.rpc('get_relationship_profile', {
        p_user_id: user.id,
        p_conversation_id: conversation_id,
      });

      if (existingProfile && existingProfile.length > 0) {
        console.log('‚úÖ Returning existing profile');
        return new Response(
          JSON.stringify({
            success: true,
            profile: existingProfile[0],
            regenerated: false,
          }),
          { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      }
    }

    // Get conversation participants
    const { data: participants } = await supabase
      .from('conversation_participants')
      .select('user_id')
      .eq('conversation_id', conversation_id)
      .neq('user_id', user.id);

    if (!participants || participants.length === 0) {
      throw new Error('No other participants found');
    }

    const participantId = participants[0].user_id;

    // Get participant name
    const { data: profile } = await supabase
      .from('profiles')
      .select('username, full_name')
      .eq('id', participantId)
      .single();

    const participantName = profile?.full_name || profile?.username || 'Unknown';

    // Get conversation history
    const { data: messages } = await supabase
      .from('messages')
      .select('body, sender_id, created_at')
      .eq('conversation_id', conversation_id)
      .order('created_at', { ascending: true })
      .limit(100);

    if (!messages || messages.length === 0) {
      throw new Error('No messages found');
    }

    console.log(`Analyzing ${messages.length} messages`);

    // Format messages for AI
    const formattedMessages = messages.map(m => ({
      body: m.body,
      sender: m.sender_id === user.id ? 'self' : 'other',
      created_at: new Date(m.created_at).getTime() / 1000,
    }));

    // Build profile
    const builder = new RelationshipBuilder();
    const relationshipProfile = await builder.buildProfile(
      formattedMessages,
      participantName
    );

    // Calculate response time
    const typicalResponseTime = builder.calculateResponseTime(formattedMessages);

    console.log('‚úÖ Profile generated');

    // Store in database
    const now = new Date();
    const { data: storedProfile, error: insertError } = await supabase
      .from('relationship_profiles')
      .upsert({
        user_id: user.id,
        conversation_id: conversation_id,
        participant_name: participantName,
        participant_user_id: participantId,
        relationship_type: relationshipProfile.relationship_type,
        conversation_summary: relationshipProfile.conversation_summary,
        safe_topics: relationshipProfile.safe_topics,
        topics_to_avoid: relationshipProfile.topics_to_avoid,
        communication_style: relationshipProfile.communication_style,
        typical_response_time: typicalResponseTime,
        total_messages: messages.length,
        first_message_at: new Date(messages[0].created_at),
        last_message_at: new Date(messages[messages.length - 1].created_at),
        updated_at: now.toISOString(),
      }, {
        onConflict: 'user_id,conversation_id',
      })
      .select()
      .single();

    if (insertError) {
      console.error('Error storing profile:', insertError);
      throw insertError;
    }

    return new Response(
      JSON.stringify({
        success: true,
        profile: storedProfile,
        regenerated: true,
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('‚ùå Error building relationship profile:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
    );
  }
});
</file>

<file path="backend/supabase/functions/create_group/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.38.0";

interface CreateGroupPayload {
  title: string;
  description?: string;
  member_ids: string[]; // Array of user IDs to add to group
}

interface CreateGroupResponse {
  id: string;
  title: string;
  description: string | null;
  is_group: boolean;
  created_by: string;
  created_at: string;
  member_count: number;
  members: Array<{
    user_id: string;
    joined_at: string;
  }>;
}

interface ErrorResponse {
  error: string;
  status: number;
}

// CORS headers
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Content-Type": "application/json",
};

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Get authenticated user
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: "Unauthorized" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Create Supabase client
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Get user ID from JWT token
    const token = authHeader.replace("Bearer ", "");
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: "Invalid token" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Parse request body
    const payload: CreateGroupPayload = await req.json();

    // Validate required fields
    if (!payload.title || !payload.member_ids) {
      return new Response(
        JSON.stringify({
          error: "Missing required fields: title, member_ids",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Validate title
    const title = payload.title.trim();
    if (title.length === 0) {
      return new Response(
        JSON.stringify({ error: "Group title cannot be empty" }),
        { status: 400, headers: corsHeaders }
      );
    }

    if (title.length > 255) {
      return new Response(
        JSON.stringify({ error: "Group title too long (max 255 characters)" }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Validate member_ids
    if (!Array.isArray(payload.member_ids) || payload.member_ids.length === 0) {
      return new Response(
        JSON.stringify({
          error: "member_ids must be a non-empty array",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Limit group size
    if (payload.member_ids.length > 500) {
      return new Response(
        JSON.stringify({
          error: "Too many members: maximum 500 per group",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Ensure creator is included in members
    const memberSet = new Set(payload.member_ids);
    memberSet.add(user.id);
    const uniqueMemberIds = Array.from(memberSet);

    // Validate all members exist in profiles table
    const { data: existingProfiles, error: profileError } = await supabase
      .from("profiles")
      .select("user_id")
      .in("user_id", uniqueMemberIds);

    if (profileError) {
      console.error("Error checking profiles:", profileError);
      return new Response(
        JSON.stringify({ error: "Failed to validate members" }),
        { status: 500, headers: corsHeaders }
      );
    }

    const existingUserIds = new Set(
      existingProfiles?.map((p) => p.user_id) || []
    );
    const invalidMembers = uniqueMemberIds.filter(
      (id) => !existingUserIds.has(id)
    );

    if (invalidMembers.length > 0) {
      return new Response(
        JSON.stringify({
          error: `Invalid member IDs: ${invalidMembers.join(", ")}`,
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Create conversation
    const { data: conversation, error: conversationError } = await supabase
      .from("conversations")
      .insert({
        title: title,
        description: payload.description || null,
        is_group: true,
        created_by: user.id,
      })
      .select()
      .single();

    if (conversationError || !conversation) {
      console.error("Error creating conversation:", conversationError);
      return new Response(
        JSON.stringify({ error: "Failed to create group" }),
        { status: 500, headers: corsHeaders }
      );
    }

    // Add all members to conversation
    const participantRecords = uniqueMemberIds.map((userId) => ({
      conversation_id: conversation.id,
      user_id: userId,
      joined_at: new Date().toISOString(),
    }));

    const { data: participants, error: participantError } = await supabase
      .from("conversation_participants")
      .insert(participantRecords)
      .select();

    if (participantError) {
      console.error("Error adding participants:", participantError);
      // Log error but don't fail - group is created
    }

    const response: CreateGroupResponse = {
      id: conversation.id,
      title: conversation.title,
      description: conversation.description,
      is_group: conversation.is_group,
      created_by: conversation.created_by,
      created_at: conversation.created_at,
      member_count: uniqueMemberIds.length,
      members: (participants || []).map((p) => ({
        user_id: p.user_id,
        joined_at: p.joined_at,
      })),
    };

    return new Response(JSON.stringify(response), {
      status: 200,
      headers: corsHeaders,
    });
  } catch (error) {
    console.error("Error in create_group:", error);
    return new Response(
      JSON.stringify({ error: "Internal server error" }),
      { status: 500, headers: corsHeaders }
    );
  }
});
</file>

<file path="backend/supabase/functions/messages_send/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.38.0";

interface MessagePayload {
  id: string; // UUID - client-generated for idempotency
  conversation_id: string; // UUID
  body: string;
  media_url?: string | null;
}

interface MessageResponse {
  id: string;
  conversation_id: string;
  sender_id: string;
  body: string;
  media_url: string | null;
  created_at: string;
  server_time: string;
  status: "created" | "already_exists";
}

interface ErrorResponse {
  error: string;
  status: number;
}

// CORS headers
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Content-Type": "application/json",
};

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Get authenticated user
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: "Unauthorized" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Create Supabase client
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Get user ID from JWT token
    const token = authHeader.replace("Bearer ", "");
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: "Invalid token" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Parse request body
    const payload: MessagePayload = await req.json();

    // Validate required fields
    if (!payload.id || !payload.conversation_id || !payload.body) {
      return new Response(
        JSON.stringify({
          error: "Missing required fields: id, conversation_id, body",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Trim and validate body
    const body = payload.body.trim();
    if (body.length === 0) {
      return new Response(
        JSON.stringify({ error: "Message body cannot be empty" }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Verify user is participant in conversation
    const { data: participant, error: participantError } = await supabase
      .from("conversation_participants")
      .select("id")
      .eq("conversation_id", payload.conversation_id)
      .eq("user_id", user.id)
      .single();

    if (participantError || !participant) {
      return new Response(
        JSON.stringify({
          error: "Not a participant in this conversation",
        }),
        { status: 403, headers: corsHeaders }
      );
    }

    // UPSERT message (idempotent)
    // If message with this ID already exists, do nothing (returns 409 equivalent)
    const { data: message, error: messageError } = await supabase
      .from("messages")
      .upsert(
        {
          id: payload.id,
          conversation_id: payload.conversation_id,
          sender_id: user.id,
          body: body,
          media_url: payload.media_url || null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        },
        { onConflict: "id" }
      )
      .select()
      .single();

    if (messageError) {
      console.error("Error inserting message:", messageError);
      return new Response(
        JSON.stringify({ error: "Failed to send message" }),
        { status: 500, headers: corsHeaders }
      );
    }

    // Check if this was a new insert or already existed
    const { data: count, error: checkError } = await supabase
      .from("messages")
      .select("id", { count: "exact", head: true })
      .eq("id", payload.id);

    const status = count && count.length > 0 ? "created" : "already_exists";

    const response: MessageResponse = {
      id: message.id,
      conversation_id: message.conversation_id,
      sender_id: message.sender_id,
      body: message.body,
      media_url: message.media_url,
      created_at: message.created_at,
      server_time: new Date().toISOString(),
      status: status,
    };

    return new Response(JSON.stringify(response), {
      status: 200,
      headers: corsHeaders,
    });
  } catch (error) {
    console.error("Error in messages_send:", error);
    return new Response(
      JSON.stringify({ error: "Internal server error" }),
      { status: 500, headers: corsHeaders }
    );
  }
});
</file>

<file path="backend/supabase/functions/receipts_ack/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.38.0";

interface ReceiptPayload {
  message_ids: string[]; // Array of message UUIDs
  status: "delivered" | "read";
}

interface ReceiptResponse {
  success: boolean;
  count: number;
  status: string;
  server_time: string;
}

interface ErrorResponse {
  error: string;
  status: number;
}

// CORS headers
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Content-Type": "application/json",
};

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Get authenticated user
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: "Unauthorized" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Create Supabase client
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Get user ID from JWT token
    const token = authHeader.replace("Bearer ", "");
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: "Invalid token" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Parse request body
    const payload: ReceiptPayload = await req.json();

    // Validate required fields
    if (!payload.message_ids || !Array.isArray(payload.message_ids) || payload.message_ids.length === 0) {
      return new Response(
        JSON.stringify({
          error: "Invalid message_ids: must be a non-empty array of UUIDs",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    if (!payload.status || !["delivered", "read"].includes(payload.status)) {
      return new Response(
        JSON.stringify({
          error: "Invalid status: must be 'delivered' or 'read'",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Limit batch size to prevent abuse
    if (payload.message_ids.length > 1000) {
      return new Response(
        JSON.stringify({
          error: "Too many message IDs: maximum 1000 per request",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Prepare receipt records (batch insert with conflict handling)
    const now = new Date().toISOString();
    const receipts = payload.message_ids.map((messageId) => ({
      id: crypto.randomUUID(), // Generate unique receipt ID
      message_id: messageId,
      user_id: user.id,
      status: payload.status,
      at: now,
    }));

    // Insert receipts with "on conflict do nothing" to handle duplicates gracefully
    const { error: insertError, data: insertedReceipts } = await supabase
      .from("message_receipts")
      .insert(receipts, { onConflict: "message_id,user_id" })
      .select("id");

    if (insertError) {
      console.error("Error inserting receipts:", insertError);
      // Log but don't fail - some receipts may have already existed
      // This is expected for idempotent operations
    }

    // Count successful inserts
    const successCount = insertedReceipts?.length || 0;

    // Also try to update existing receipts if they have a lower status
    // (e.g., "delivered" ‚Üí "read")
    if (payload.status === "read") {
      const { error: updateError, data: updatedReceipts } = await supabase
        .from("message_receipts")
        .update({ status: "read", at: now })
        .in("message_id", payload.message_ids)
        .eq("user_id", user.id)
        .eq("status", "delivered")
        .select("id");

      if (updateError) {
        console.error("Error updating receipts:", updateError);
      } else if (updatedReceipts) {
        // Log update count for debugging
        console.log(`Updated ${updatedReceipts.length} receipts from delivered to read`);
      }
    }

    const response: ReceiptResponse = {
      success: true,
      count: successCount,
      status: payload.status,
      server_time: now,
    };

    return new Response(JSON.stringify(response), {
      status: 200,
      headers: corsHeaders,
    });
  } catch (error) {
    console.error("Error in receipts_ack:", error);
    return new Response(
      JSON.stringify({ error: "Internal server error" }),
      { status: 500, headers: corsHeaders }
    );
  }
});
</file>

<file path="backend/supabase/migrations/20251231_000001_smart_interpreter.sql">
-- ============================================================
-- SMART MESSAGE INTERPRETER - Phase 1 Enhancements
-- Adds RSD detection, alternative interpretations, and evidence
-- ============================================================

-- Add enhanced fields to message_ai_analysis table
ALTER TABLE message_ai_analysis
  ADD COLUMN IF NOT EXISTS rsd_triggers JSONB DEFAULT '[]'::jsonb,
  ADD COLUMN IF NOT EXISTS alternative_interpretations JSONB DEFAULT '[]'::jsonb,
  ADD COLUMN IF NOT EXISTS evidence JSONB DEFAULT '[]'::jsonb;

-- Add indexes for the new JSONB fields (optional, for performance)
CREATE INDEX IF NOT EXISTS idx_ai_analysis_rsd_triggers 
  ON message_ai_analysis USING GIN (rsd_triggers);
CREATE INDEX IF NOT EXISTS idx_ai_analysis_alternatives 
  ON message_ai_analysis USING GIN (alternative_interpretations);
CREATE INDEX IF NOT EXISTS idx_ai_analysis_evidence 
  ON message_ai_analysis USING GIN (evidence);

-- Add helpful comment
COMMENT ON COLUMN message_ai_analysis.rsd_triggers IS 
  'RSD (Rejection Sensitive Dysphoria) triggers detected in message';
COMMENT ON COLUMN message_ai_analysis.alternative_interpretations IS 
  'Multiple possible interpretations for ambiguous messages';
COMMENT ON COLUMN message_ai_analysis.evidence IS 
  'Specific evidence supporting the tone analysis';
</file>

<file path="backend/supabase/migrations/20260101_000001_response_assistant.sql">
-- =====================================================
-- Phase 2: Adaptive Response Assistant Migration
-- Adds support for template suggestions and message formatting
-- =====================================================

-- Note: This phase doesn't require new database tables
-- Template data is stored in code (backend/supabase/functions/_shared/templates/)
-- Situation detection happens via AI analysis (no persistence needed)
-- Formatted messages are returned to client without storage

-- However, we can add optional user preferences for templates
CREATE TABLE IF NOT EXISTS user_template_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- Favorite templates (user can star templates for quick access)
  favorite_template_ids TEXT[] DEFAULT '{}',
  
  -- Custom templates (user can create their own)
  custom_templates JSONB DEFAULT '[]'::jsonb,
  
  -- Template usage history (for smart suggestions)
  template_usage_history JSONB DEFAULT '[]'::jsonb,
  
  -- Preferences
  show_template_suggestions BOOLEAN DEFAULT true,
  auto_detect_situation BOOLEAN DEFAULT true,
  preferred_tone TEXT, -- 'polite', 'casual', 'direct', 'apologetic'
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(user_id)
);

-- Index for quick user lookups
CREATE INDEX IF NOT EXISTS idx_template_prefs_user_id 
  ON user_template_preferences(user_id);

-- RLS Policies
ALTER TABLE user_template_preferences ENABLE ROW LEVEL SECURITY;

-- Users can only access their own preferences
CREATE POLICY "Users can view their own template preferences"
  ON user_template_preferences
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own template preferences"
  ON user_template_preferences
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own template preferences"
  ON user_template_preferences
  FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own template preferences"
  ON user_template_preferences
  FOR DELETE
  USING (auth.uid() = user_id);

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_template_preferences_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for updated_at
DROP TRIGGER IF EXISTS update_template_preferences_timestamp ON user_template_preferences;
CREATE TRIGGER update_template_preferences_timestamp
  BEFORE UPDATE ON user_template_preferences
  FOR EACH ROW
  EXECUTE FUNCTION update_template_preferences_timestamp();

-- Helper function to get or create user template preferences
CREATE OR REPLACE FUNCTION get_user_template_preferences(p_user_id UUID)
RETURNS TABLE (
  id UUID,
  user_id UUID,
  favorite_template_ids TEXT[],
  custom_templates JSONB,
  template_usage_history JSONB,
  show_template_suggestions BOOLEAN,
  auto_detect_situation BOOLEAN,
  preferred_tone TEXT,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
  -- Check authorization
  IF auth.uid() != p_user_id THEN
    RAISE EXCEPTION 'Access denied';
  END IF;
  
  -- Get or create preferences
  INSERT INTO user_template_preferences (user_id)
  VALUES (p_user_id)
  ON CONFLICT (user_id) DO NOTHING;
  
  RETURN QUERY
  SELECT 
    prefs.id,
    prefs.user_id,
    prefs.favorite_template_ids,
    prefs.custom_templates,
    prefs.template_usage_history,
    prefs.show_template_suggestions,
    prefs.auto_detect_situation,
    prefs.preferred_tone,
    prefs.created_at,
    prefs.updated_at
  FROM user_template_preferences prefs
  WHERE prefs.user_id = p_user_id;
END;
$$;

-- Function to record template usage (for smart suggestions)
CREATE OR REPLACE FUNCTION record_template_usage(
  p_user_id UUID,
  p_template_id TEXT,
  p_situation_type TEXT
)
RETURNS VOID
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
DECLARE
  v_usage_entry JSONB;
BEGIN
  -- Check authorization
  IF auth.uid() != p_user_id THEN
    RAISE EXCEPTION 'Access denied';
  END IF;
  
  -- Create usage entry
  v_usage_entry := jsonb_build_object(
    'template_id', p_template_id,
    'situation_type', p_situation_type,
    'used_at', EXTRACT(EPOCH FROM NOW())::INTEGER
  );
  
  -- Ensure preferences exist
  INSERT INTO user_template_preferences (user_id)
  VALUES (p_user_id)
  ON CONFLICT (user_id) DO NOTHING;
  
  -- Append to usage history (keep last 100 entries)
  UPDATE user_template_preferences
  SET 
    template_usage_history = (
      SELECT jsonb_agg(entry)
      FROM (
        SELECT entry
        FROM jsonb_array_elements(
          template_usage_history || v_usage_entry
        ) entry
        ORDER BY (entry->>'used_at')::INTEGER DESC
        LIMIT 100
      ) recent
    ),
    updated_at = NOW()
  WHERE user_id = p_user_id;
END;
$$;

-- Comments for documentation
COMMENT ON TABLE user_template_preferences IS 'User preferences for response templates and message formatting';
COMMENT ON FUNCTION get_user_template_preferences(UUID) IS 'Gets or creates user template preferences';
COMMENT ON FUNCTION record_template_usage(UUID, TEXT, TEXT) IS 'Records template usage for smart suggestions';

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT ALL ON user_template_preferences TO authenticated;
GRANT EXECUTE ON FUNCTION get_user_template_preferences(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION record_template_usage(UUID, TEXT, TEXT) TO authenticated;
</file>

<file path="backend/supabase/migrations/20260102_000001_context_system.sql">
-- ============================================================
-- SMART INBOX CONTEXT SYSTEM - Phase 3
-- Adds conversation context, relationship profiles, and semantic search
-- ============================================================

-- Enable pgvector extension for semantic search
CREATE EXTENSION IF NOT EXISTS vector;

-- Message embeddings for semantic search
CREATE TABLE IF NOT EXISTS message_embeddings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  message_id UUID NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- OpenAI embedding (1536 dimensions for text-embedding-ada-002)
  embedding vector(1536) NOT NULL,
  
  -- Metadata for search optimization
  message_length INTEGER NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(message_id)
);

-- Index for fast similarity search
CREATE INDEX IF NOT EXISTS idx_message_embeddings_vector ON message_embeddings 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

CREATE INDEX IF NOT EXISTS idx_message_embeddings_user ON message_embeddings(user_id);
CREATE INDEX IF NOT EXISTS idx_message_embeddings_message ON message_embeddings(message_id);

-- Relationship profiles
CREATE TABLE IF NOT EXISTS relationship_profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  
  -- Profile data
  participant_name TEXT NOT NULL,
  participant_user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  
  -- Relationship metadata
  relationship_type TEXT, -- boss, colleague, friend, family, client, other
  relationship_notes TEXT, -- User-added notes
  
  -- Auto-generated context
  conversation_summary TEXT, -- AI-generated summary
  safe_topics JSONB DEFAULT '[]'::jsonb, -- Topics that went well
  topics_to_avoid JSONB DEFAULT '[]'::jsonb, -- Topics that caused issues
  communication_style TEXT, -- How they prefer to communicate
  typical_response_time INTEGER, -- Average response time in seconds
  
  -- Stats
  total_messages INTEGER DEFAULT 0,
  first_message_at TIMESTAMPTZ,
  last_message_at TIMESTAMPTZ,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(user_id, conversation_id)
);

CREATE INDEX IF NOT EXISTS idx_relationship_profiles_user ON relationship_profiles(user_id);
CREATE INDEX IF NOT EXISTS idx_relationship_profiles_conversation ON relationship_profiles(conversation_id);

-- Conversation context cache
CREATE TABLE IF NOT EXISTS conversation_context_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  
  -- Cached context
  last_discussed TEXT, -- "Last talked about project deadline"
  key_points JSONB DEFAULT '[]'::jsonb, -- Important points from recent messages
  pending_questions JSONB DEFAULT '[]'::jsonb, -- Unanswered questions
  
  -- Cache metadata
  generated_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL,
  
  UNIQUE(user_id, conversation_id)
);

CREATE INDEX IF NOT EXISTS idx_context_cache_user ON conversation_context_cache(user_id);
CREATE INDEX IF NOT EXISTS idx_context_cache_expires ON conversation_context_cache(expires_at);

-- Safe topics tracking
CREATE TABLE IF NOT EXISTS safe_topics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  
  -- Topic data
  topic_name TEXT NOT NULL, -- "work projects", "weekend plans", etc.
  topic_keywords JSONB DEFAULT '[]'::jsonb, -- Related keywords
  
  -- Engagement metrics
  message_count INTEGER DEFAULT 1,
  avg_response_time INTEGER, -- How fast user responds to this topic (seconds)
  positive_tone_rate REAL, -- % of messages with positive tone
  
  -- Status
  is_safe BOOLEAN DEFAULT true, -- Safe to discuss
  last_discussed TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(user_id, conversation_id, topic_name)
);

CREATE INDEX IF NOT EXISTS idx_safe_topics_user ON safe_topics(user_id);
CREATE INDEX IF NOT EXISTS idx_safe_topics_conversation ON safe_topics(conversation_id);
CREATE INDEX IF NOT EXISTS idx_safe_topics_discussed ON safe_topics(last_discussed);

-- ============================================================
-- RLS POLICIES
-- ============================================================

ALTER TABLE message_embeddings ENABLE ROW LEVEL SECURITY;
ALTER TABLE relationship_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversation_context_cache ENABLE ROW LEVEL SECURITY;
ALTER TABLE safe_topics ENABLE ROW LEVEL SECURITY;

-- Message embeddings: users can only access their own
CREATE POLICY "Users can view their own message embeddings"
  ON message_embeddings FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own message embeddings"
  ON message_embeddings FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Relationship profiles: users can manage their own
CREATE POLICY "Users can view their own relationship profiles"
  ON relationship_profiles FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own relationship profiles"
  ON relationship_profiles FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own relationship profiles"
  ON relationship_profiles FOR UPDATE
  USING (auth.uid() = user_id);

-- Context cache: users can access their own
CREATE POLICY "Users can view their own context cache"
  ON conversation_context_cache FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their own context cache"
  ON conversation_context_cache FOR ALL
  USING (auth.uid() = user_id);

-- Safe topics: users can manage their own
CREATE POLICY "Users can manage their own safe topics"
  ON safe_topics FOR ALL
  USING (auth.uid() = user_id);

-- ============================================================
-- RPC FUNCTIONS
-- ============================================================

-- Semantic search for similar messages
CREATE OR REPLACE FUNCTION search_similar_messages(
  p_user_id UUID,
  p_query_embedding vector(1536),
  p_limit INTEGER DEFAULT 5,
  p_conversation_id UUID DEFAULT NULL
)
RETURNS TABLE (
  message_id UUID,
  similarity REAL,
  message_body TEXT,
  created_at TIMESTAMPTZ
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verify user access
  IF auth.uid() != p_user_id THEN
    RAISE EXCEPTION 'Access denied';
  END IF;

  RETURN QUERY
  SELECT 
    m.id AS message_id,
    1 - (me.embedding <=> p_query_embedding) AS similarity,
    m.body AS message_body,
    m.created_at
  FROM message_embeddings me
  JOIN messages m ON me.message_id = m.id
  WHERE me.user_id = p_user_id
    AND (p_conversation_id IS NULL OR m.conversation_id = p_conversation_id)
  ORDER BY me.embedding <=> p_query_embedding
  LIMIT p_limit;
END;
$$;

-- Get relationship profile
CREATE OR REPLACE FUNCTION get_relationship_profile(
  p_user_id UUID,
  p_conversation_id UUID
)
RETURNS TABLE (
  profile_id UUID,
  participant_name TEXT,
  relationship_type TEXT,
  conversation_summary TEXT,
  safe_topics JSONB,
  topics_to_avoid JSONB,
  communication_style TEXT,
  typical_response_time INTEGER,
  total_messages INTEGER
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verify user access
  IF auth.uid() != p_user_id THEN
    RAISE EXCEPTION 'Access denied';
  END IF;

  -- Verify user is participant
  IF NOT EXISTS (
    SELECT 1 FROM conversation_participants
    WHERE conversation_id = p_conversation_id AND user_id = p_user_id
  ) THEN
    RAISE EXCEPTION 'Access denied to conversation';
  END IF;

  RETURN QUERY
  SELECT 
    rp.id AS profile_id,
    rp.participant_name,
    rp.relationship_type,
    rp.conversation_summary,
    rp.safe_topics,
    rp.topics_to_avoid,
    rp.communication_style,
    rp.typical_response_time,
    rp.total_messages
  FROM relationship_profiles rp
  WHERE rp.user_id = p_user_id
    AND rp.conversation_id = p_conversation_id
  LIMIT 1;
END;
$$;

-- Get cached conversation context
CREATE OR REPLACE FUNCTION get_conversation_context(
  p_user_id UUID,
  p_conversation_id UUID
)
RETURNS TABLE (
  last_discussed TEXT,
  key_points JSONB,
  pending_questions JSONB,
  cache_age INTEGER
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
DECLARE
  v_now TIMESTAMPTZ;
BEGIN
  v_now := NOW();

  -- Verify access
  IF auth.uid() != p_user_id THEN
    RAISE EXCEPTION 'Access denied';
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM conversation_participants
    WHERE conversation_id = p_conversation_id AND user_id = p_user_id
  ) THEN
    RAISE EXCEPTION 'Access denied to conversation';
  END IF;

  RETURN QUERY
  SELECT 
    ccc.last_discussed,
    ccc.key_points,
    ccc.pending_questions,
    EXTRACT(EPOCH FROM (v_now - ccc.generated_at))::INTEGER AS cache_age
  FROM conversation_context_cache ccc
  WHERE ccc.user_id = p_user_id
    AND ccc.conversation_id = p_conversation_id
    AND ccc.expires_at > v_now
  LIMIT 1;
END;
$$;

-- Get safe topics for conversation
CREATE OR REPLACE FUNCTION get_safe_topics(
  p_user_id UUID,
  p_conversation_id UUID
)
RETURNS TABLE (
  topic_name TEXT,
  message_count INTEGER,
  positive_tone_rate REAL,
  last_discussed TIMESTAMPTZ
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verify access
  IF auth.uid() != p_user_id THEN
    RAISE EXCEPTION 'Access denied';
  END IF;

  RETURN QUERY
  SELECT 
    st.topic_name,
    st.message_count,
    st.positive_tone_rate,
    st.last_discussed
  FROM safe_topics st
  WHERE st.user_id = p_user_id
    AND st.conversation_id = p_conversation_id
    AND st.is_safe = true
  ORDER BY st.positive_tone_rate DESC, st.message_count DESC
  LIMIT 10;
END;
$$;

-- Comments
COMMENT ON TABLE message_embeddings IS 'Vector embeddings for semantic search of messages';
COMMENT ON TABLE relationship_profiles IS 'AI-generated relationship profiles for conversations';
COMMENT ON TABLE conversation_context_cache IS 'Cached conversation context for quick loading';
COMMENT ON TABLE safe_topics IS 'Topics that have led to positive engagement';

-- Grant permissions
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT ALL ON message_embeddings TO authenticated;
GRANT ALL ON relationship_profiles TO authenticated;
GRANT ALL ON conversation_context_cache TO authenticated;
GRANT ALL ON safe_topics TO authenticated;
GRANT EXECUTE ON FUNCTION search_similar_messages(UUID, vector, INTEGER, UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION get_relationship_profile(UUID, UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION get_conversation_context(UUID, UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION get_safe_topics(UUID, UUID) TO authenticated;
</file>

<file path="backend/supabase/migrations/20260103_000001_followup_system.sql">
-- ============================================================
-- SMART FOLLOW-UP SYSTEM
-- ============================================================

-- Follow-up items (things that need response)
CREATE TABLE follow_up_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  message_id UUID REFERENCES messages(id) ON DELETE CASCADE,
  
  -- Item details
  item_type TEXT NOT NULL CHECK (item_type IN (
    'action_item',      -- "I'll send you..."
    'unanswered_question', -- Question without response
    'pending_response',    -- Conversation waiting for reply
    'scheduled_followup'   -- User-scheduled reminder
  )),
  
  title TEXT NOT NULL,
  description TEXT,
  extracted_text TEXT, -- Original text that triggered this
  
  -- Status
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
    'pending',
    'completed',
    'dismissed',
    'snoozed'
  )),
  
  -- Priority
  priority INTEGER DEFAULT 50 CHECK (priority >= 0 AND priority <= 100),
  
  -- Timing
  detected_at INTEGER NOT NULL,
  due_at INTEGER, -- When action should be completed
  remind_at INTEGER, -- When to remind user
  snoozed_until INTEGER, -- If snoozed
  completed_at INTEGER,
  
  -- Context triggers
  triggers JSONB, -- { "app": "email", "calendar_event": "meeting", "location": "office" }
  
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  
  UNIQUE(user_id, message_id, item_type)
);

CREATE INDEX idx_followup_items_user ON follow_up_items(user_id);
CREATE INDEX idx_followup_items_status ON follow_up_items(status);
CREATE INDEX idx_followup_items_remind_at ON follow_up_items(remind_at);
CREATE INDEX idx_followup_items_conversation ON follow_up_items(conversation_id);

-- Action items (specific commitments)
CREATE TABLE action_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  follow_up_item_id UUID NOT NULL REFERENCES follow_up_items(id) ON DELETE CASCADE,
  
  -- Action details
  action_type TEXT NOT NULL, -- send, call, meet, review, decide, etc.
  action_target TEXT, -- What/who is the action about
  commitment_text TEXT NOT NULL, -- Original promise
  
  -- Extracted details
  mentioned_deadline TEXT, -- "this afternoon", "by Friday"
  extracted_deadline INTEGER, -- Parsed timestamp
  
  created_at INTEGER NOT NULL
);

CREATE INDEX idx_action_items_followup ON action_items(follow_up_item_id);

-- Unanswered questions
CREATE TABLE unanswered_questions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  follow_up_item_id UUID NOT NULL REFERENCES follow_up_items(id) ON DELETE CASCADE,
  message_id UUID NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
  
  -- Question details
  question_text TEXT NOT NULL,
  question_type TEXT, -- when, where, what, who, why, how, yes/no
  context TEXT, -- Surrounding context
  
  -- Timing
  asked_at INTEGER NOT NULL,
  time_since_asked INTEGER, -- In seconds
  
  created_at INTEGER NOT NULL
);

CREATE INDEX idx_unanswered_questions_followup ON unanswered_questions(follow_up_item_id);
CREATE INDEX idx_unanswered_questions_message ON unanswered_questions(message_id);

-- Context triggers (app usage, calendar, location)
CREATE TABLE context_triggers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  follow_up_item_id UUID NOT NULL REFERENCES follow_up_items(id) ON DELETE CASCADE,
  
  -- Trigger details
  trigger_type TEXT NOT NULL CHECK (trigger_type IN (
    'app_opened',       -- When user opens specific app
    'calendar_event',   -- Before/during calendar event
    'location',         -- When at specific location
    'time_of_day',      -- Specific time
    'day_of_week'       -- Specific day
  )),
  
  trigger_config JSONB NOT NULL, -- Configuration for trigger
  
  -- Status
  is_active BOOLEAN DEFAULT true,
  last_triggered INTEGER,
  trigger_count INTEGER DEFAULT 0,
  
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

CREATE INDEX idx_context_triggers_user ON context_triggers(user_id);
CREATE INDEX idx_context_triggers_active ON context_triggers(is_active);
CREATE INDEX idx_context_triggers_followup ON context_triggers(follow_up_item_id);

-- ============================================================
-- RPC FUNCTIONS
-- ============================================================

-- Get pending follow-ups for user
CREATE OR REPLACE FUNCTION get_pending_followups(
  p_user_id UUID,
  p_limit INTEGER DEFAULT 50
)
RETURNS TABLE (
  item_id UUID,
  conversation_id UUID,
  item_type TEXT,
  title TEXT,
  description TEXT,
  priority INTEGER,
  detected_at INTEGER,
  remind_at INTEGER,
  triggers JSONB
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    fi.id AS item_id,
    fi.conversation_id,
    fi.item_type,
    fi.title,
    fi.description,
    fi.priority,
    fi.detected_at,
    fi.remind_at,
    fi.triggers
  FROM follow_up_items fi
  WHERE fi.user_id = p_user_id
    AND fi.status = 'pending'
    AND (fi.snoozed_until IS NULL OR fi.snoozed_until < EXTRACT(EPOCH FROM NOW())::INTEGER)
  ORDER BY fi.priority DESC, fi.detected_at ASC
  LIMIT p_limit;
END;
$$;

-- Get follow-ups for specific conversation
CREATE OR REPLACE FUNCTION get_conversation_followups(
  p_user_id UUID,
  p_conversation_id UUID
)
RETURNS TABLE (
  item_id UUID,
  item_type TEXT,
  title TEXT,
  description TEXT,
  priority INTEGER,
  status TEXT
)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    fi.id AS item_id,
    fi.item_type,
    fi.title,
    fi.description,
    fi.priority,
    fi.status
  FROM follow_up_items fi
  WHERE fi.user_id = p_user_id
    AND fi.conversation_id = p_conversation_id
    AND fi.status IN ('pending', 'snoozed')
  ORDER BY fi.priority DESC, fi.detected_at DESC;
END;
$$;

-- Mark follow-up as completed
CREATE OR REPLACE FUNCTION complete_followup(
  p_user_id UUID,
  p_item_id UUID
)
RETURNS VOID
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
DECLARE
  v_now INTEGER;
BEGIN
  v_now := EXTRACT(EPOCH FROM NOW())::INTEGER;
  
  UPDATE follow_up_items
  SET 
    status = 'completed',
    completed_at = v_now,
    updated_at = v_now
  WHERE id = p_item_id AND user_id = p_user_id;
END;
$$;

-- Snooze follow-up
CREATE OR REPLACE FUNCTION snooze_followup(
  p_user_id UUID,
  p_item_id UUID,
  p_snooze_duration INTEGER -- In seconds
)
RETURNS VOID
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
DECLARE
  v_now INTEGER;
BEGIN
  v_now := EXTRACT(EPOCH FROM NOW())::INTEGER;
  
  UPDATE follow_up_items
  SET 
    status = 'snoozed',
    snoozed_until = v_now + p_snooze_duration,
    updated_at = v_now
  WHERE id = p_item_id AND user_id = p_user_id;
END;
$$;
</file>

<file path="backend/supabase/migrations/20260104_000001_fix_followup_fk.sql">
-- ============================================================
-- FIX FOLLOW-UP SYSTEM FOREIGN KEY CONSTRAINTS
-- Changes user_id references to point to profiles.user_id instead of profiles.id
-- ============================================================

-- Fix follow_up_items.user_id FK
ALTER TABLE follow_up_items 
DROP CONSTRAINT IF EXISTS follow_up_items_user_id_fkey;

ALTER TABLE follow_up_items 
ADD CONSTRAINT follow_up_items_user_id_fkey 
FOREIGN KEY (user_id) 
REFERENCES profiles (user_id) 
ON DELETE CASCADE;

-- Fix context_triggers.user_id FK
ALTER TABLE context_triggers 
DROP CONSTRAINT IF EXISTS context_triggers_user_id_fkey;

ALTER TABLE context_triggers 
ADD CONSTRAINT context_triggers_user_id_fkey 
FOREIGN KEY (user_id) 
REFERENCES profiles (user_id) 
ON DELETE CASCADE;

-- Add comments
COMMENT ON CONSTRAINT follow_up_items_user_id_fkey ON follow_up_items IS 
  'References profiles.user_id which maps to auth.users.id';

COMMENT ON CONSTRAINT context_triggers_user_id_fkey ON context_triggers IS 
  'References profiles.user_id which maps to auth.users.id';
</file>

<file path="backend/supabase/migrations/20260106_000001_add_profile_devices_rls.sql">
-- ============================================================
-- RLS POLICIES FOR profile_devices
-- Allows users to manage their own device registrations
-- ============================================================

-- Enable RLS
ALTER TABLE profile_devices ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can view their own devices" ON profile_devices;
DROP POLICY IF EXISTS "Users can insert their own devices" ON profile_devices;
DROP POLICY IF EXISTS "Users can update their own devices" ON profile_devices;
DROP POLICY IF EXISTS "Users can delete their own devices" ON profile_devices;

-- Policy: Users can read their own devices
CREATE POLICY "Users can view their own devices"
  ON profile_devices
  FOR SELECT
  USING (auth.uid() = user_id);

-- Policy: Users can insert their own devices
CREATE POLICY "Users can insert their own devices"
  ON profile_devices
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Policy: Users can update their own devices
CREATE POLICY "Users can update their own devices"
  ON profile_devices
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Policy: Users can delete their own devices
CREATE POLICY "Users can delete their own devices"
  ON profile_devices
  FOR DELETE
  USING (auth.uid() = user_id);
</file>

<file path="backend/supabase/migrations/20260108_000001_comprehensive_schema_fixes.sql">
-- ============================================================
-- COMPREHENSIVE SCHEMA MIGRATION - Complete Fix
-- This migration ensures message_ai_analysis has all required columns
-- with correct types matching backend code expectations
-- ============================================================

-- Add all missing columns to message_ai_analysis
-- Using ALTER TABLE so existing data is preserved
ALTER TABLE IF EXISTS message_ai_analysis
  ADD COLUMN IF NOT EXISTS intensity TEXT,
  ADD COLUMN IF NOT EXISTS secondary_tones JSONB DEFAULT '[]'::jsonb,
  ADD COLUMN IF NOT EXISTS anxiety_assessment JSONB,
  ADD COLUMN IF NOT EXISTS context_flags JSONB,
  ADD COLUMN IF NOT EXISTS rsd_triggers JSONB DEFAULT '[]'::jsonb,
  ADD COLUMN IF NOT EXISTS alternative_interpretations JSONB DEFAULT '[]'::jsonb,
  ADD COLUMN IF NOT EXISTS evidence JSONB DEFAULT '[]'::jsonb,
  ADD COLUMN IF NOT EXISTS boundary_analysis JSONB,
  ADD COLUMN IF NOT EXISTS figurative_language_detected JSONB;

-- Create GIN indexes for JSONB columns (for performance)
CREATE INDEX IF NOT EXISTS idx_message_ai_analysis_secondary_tones 
  ON message_ai_analysis USING GIN (secondary_tones);
CREATE INDEX IF NOT EXISTS idx_message_ai_analysis_anxiety_assessment 
  ON message_ai_analysis USING GIN (anxiety_assessment);
CREATE INDEX IF NOT EXISTS idx_message_ai_analysis_context_flags 
  ON message_ai_analysis USING GIN (context_flags);
CREATE INDEX IF NOT EXISTS idx_message_ai_analysis_rsd_triggers 
  ON message_ai_analysis USING GIN (rsd_triggers);
CREATE INDEX IF NOT EXISTS idx_message_ai_analysis_alternative_interpretations 
  ON message_ai_analysis USING GIN (alternative_interpretations);
CREATE INDEX IF NOT EXISTS idx_message_ai_analysis_evidence 
  ON message_ai_analysis USING GIN (evidence);
CREATE INDEX IF NOT EXISTS idx_message_ai_analysis_boundary_analysis 
  ON message_ai_analysis USING GIN (boundary_analysis);
CREATE INDEX IF NOT EXISTS idx_message_ai_analysis_figurative_language_detected 
  ON message_ai_analysis USING GIN (figurative_language_detected);

-- ============================================================
-- RECREATE RPC FUNCTIONS WITH CORRECT TYPES
-- ============================================================

-- Drop old functions first
DROP FUNCTION IF EXISTS get_message_ai_analysis(TEXT);
DROP FUNCTION IF EXISTS get_conversation_ai_analysis(TEXT);

-- Function to get AI analysis for a single message
CREATE OR REPLACE FUNCTION get_message_ai_analysis(p_message_id TEXT)
RETURNS TABLE (
  id UUID,
  message_id UUID,
  tone TEXT,
  urgency_level TEXT,
  intent TEXT,
  confidence_score DOUBLE PRECISION,
  intensity TEXT,
  secondary_tones JSONB,
  context_flags JSONB,
  anxiety_assessment JSONB,
  rsd_triggers JSONB,
  alternative_interpretations JSONB,
  evidence JSONB,
  boundary_analysis JSONB,
  figurative_language_detected JSONB,
  analysis_timestamp BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    maa.id,
    maa.message_id,
    maa.tone,
    maa.urgency_level,
    maa.intent,
    maa.confidence_score,
    maa.intensity,
    COALESCE(maa.secondary_tones, '[]'::jsonb),
    maa.context_flags,
    maa.anxiety_assessment,
    COALESCE(maa.rsd_triggers, '[]'::jsonb),
    COALESCE(maa.alternative_interpretations, '[]'::jsonb),
    COALESCE(maa.evidence, '[]'::jsonb),
    maa.boundary_analysis,
    maa.figurative_language_detected,
    maa.analysis_timestamp
  FROM message_ai_analysis maa
  WHERE maa.message_id = p_message_id::UUID;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get all AI analyses for a conversation
CREATE OR REPLACE FUNCTION get_conversation_ai_analysis(p_conversation_id TEXT)
RETURNS TABLE (
  id UUID,
  message_id UUID,
  tone TEXT,
  urgency_level TEXT,
  intent TEXT,
  confidence_score DOUBLE PRECISION,
  intensity TEXT,
  secondary_tones JSONB,
  context_flags JSONB,
  anxiety_assessment JSONB,
  rsd_triggers JSONB,
  alternative_interpretations JSONB,
  evidence JSONB,
  boundary_analysis JSONB,
  figurative_language_detected JSONB,
  analysis_timestamp BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    maa.id,
    maa.message_id,
    maa.tone,
    maa.urgency_level,
    maa.intent,
    maa.confidence_score,
    maa.intensity,
    COALESCE(maa.secondary_tones, '[]'::jsonb),
    maa.context_flags,
    maa.anxiety_assessment,
    COALESCE(maa.rsd_triggers, '[]'::jsonb),
    COALESCE(maa.alternative_interpretations, '[]'::jsonb),
    COALESCE(maa.evidence, '[]'::jsonb),
    maa.boundary_analysis,
    maa.figurative_language_detected,
    maa.analysis_timestamp
  FROM message_ai_analysis maa
  INNER JOIN messages m ON m.id = maa.message_id
  WHERE m.conversation_id = p_conversation_id::UUID
  ORDER BY m.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions
GRANT EXECUTE ON FUNCTION get_message_ai_analysis(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION get_conversation_ai_analysis(TEXT) TO authenticated;

-- Add column documentation
COMMENT ON COLUMN message_ai_analysis.intensity IS 'Intensity level: very_low, low, medium, high, very_high';
COMMENT ON COLUMN message_ai_analysis.secondary_tones IS 'JSONB array of secondary emotional tones';
COMMENT ON COLUMN message_ai_analysis.anxiety_assessment IS 'Neurodivergent anxiety assessment';
COMMENT ON COLUMN message_ai_analysis.context_flags IS 'Context flags: sarcasm, figurative_language, etc';
COMMENT ON COLUMN message_ai_analysis.rsd_triggers IS 'RSD trigger analysis results';
COMMENT ON COLUMN message_ai_analysis.alternative_interpretations IS 'Alternative message interpretations';
COMMENT ON COLUMN message_ai_analysis.evidence IS 'Supporting evidence for analysis';
COMMENT ON COLUMN message_ai_analysis.boundary_analysis IS 'Boundary violation detection';
COMMENT ON COLUMN message_ai_analysis.figurative_language_detected IS 'Figurative language detection';
</file>

<file path="backend/supabase/policies/conversations.sql">
-- RLS Policies for conversations table
-- Users can only view and interact with conversations they are members of

-- SELECT: Users can view conversations they are participants in
CREATE POLICY "Conversations are viewable by participants" 
  ON conversations FOR SELECT 
  USING (
    EXISTS (
      SELECT 1 FROM conversation_participants 
      WHERE conversation_id = conversations.id 
      AND user_id = auth.uid()
    )
  );

-- INSERT: Users can create new conversations
CREATE POLICY "Users can create conversations" 
  ON conversations FOR INSERT 
  WITH CHECK (auth.uid() = created_by);

-- UPDATE: Users can update conversations they created
CREATE POLICY "Conversation creators can update conversations" 
  ON conversations FOR UPDATE 
  USING (auth.uid() = created_by)
  WITH CHECK (auth.uid() = created_by);

-- DELETE: Conversation creators can delete conversations
CREATE POLICY "Conversation creators can delete conversations" 
  ON conversations FOR DELETE 
  USING (auth.uid() = created_by);
</file>

<file path="backend/supabase/policies/messages.sql">
-- RLS Policies for messages table
-- Users can only read messages in conversations they are participants in
-- Users can only send messages to conversations they are participants in

-- SELECT: Users can read messages in conversations they are in
CREATE POLICY "Users can read messages in their conversations" 
  ON messages FOR SELECT 
  USING (
    EXISTS (
      SELECT 1 FROM conversation_participants 
      WHERE conversation_id = messages.conversation_id 
      AND user_id = auth.uid()
    )
  );

-- INSERT: Users can send messages to conversations they are in
CREATE POLICY "Users can send messages to their conversations" 
  ON messages FOR INSERT 
  WITH CHECK (
    sender_id = auth.uid()
    AND EXISTS (
      SELECT 1 FROM conversation_participants 
      WHERE conversation_id = messages.conversation_id 
      AND user_id = auth.uid()
    )
  );

-- UPDATE: Users can only edit their own messages
CREATE POLICY "Users can edit their own messages" 
  ON messages FOR UPDATE 
  USING (sender_id = auth.uid())
  WITH CHECK (sender_id = auth.uid());

-- DELETE: Users can delete their own messages
CREATE POLICY "Users can delete their own messages" 
  ON messages FOR DELETE 
  USING (sender_id = auth.uid());
</file>

<file path="backend/supabase/policies/participants.sql">
-- RLS Policies for conversation_participants table
-- Users can manage their own participation in conversations

-- SELECT: Users can view participant lists of conversations they are in
CREATE POLICY "Participants viewable by conversation members" 
  ON conversation_participants FOR SELECT 
  USING (
    EXISTS (
      SELECT 1 FROM conversation_participants AS cp
      WHERE cp.conversation_id = conversation_participants.conversation_id 
      AND cp.user_id = auth.uid()
    )
  );

-- INSERT: Users can join conversations
CREATE POLICY "Users can join conversations" 
  ON conversation_participants FOR INSERT 
  WITH CHECK (user_id = auth.uid());

-- UPDATE: Users can update their own participation record (e.g., last_read_at)
CREATE POLICY "Users can update their own participation" 
  ON conversation_participants FOR UPDATE 
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

-- DELETE: Users can leave conversations
CREATE POLICY "Users can leave conversations" 
  ON conversation_participants FOR DELETE 
  USING (user_id = auth.uid());
</file>

<file path="backend/supabase/policies/profile_devices.sql">
-- ============================================================
-- RLS POLICIES FOR profile_devices
-- Allows users to manage their own device registrations
-- ============================================================

-- Enable RLS
ALTER TABLE profile_devices ENABLE ROW LEVEL SECURITY;

-- Policy: Users can read their own devices
CREATE POLICY "Users can view their own devices"
  ON profile_devices
  FOR SELECT
  USING (auth.uid() = user_id);

-- Policy: Users can insert their own devices
CREATE POLICY "Users can insert their own devices"
  ON profile_devices
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Policy: Users can update their own devices
CREATE POLICY "Users can update their own devices"
  ON profile_devices
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Policy: Users can delete their own devices
CREATE POLICY "Users can delete their own devices"
  ON profile_devices
  FOR DELETE
  USING (auth.uid() = user_id);
</file>

<file path="backend/supabase/policies/receipts.sql">
-- RLS Policies for message_receipts table
-- Users can only see receipts for messages in conversations they are in
-- Users can only create receipts for themselves

-- SELECT: Users can read receipts for messages in their conversations
CREATE POLICY "Users can read receipts from their conversations" 
  ON message_receipts FOR SELECT 
  USING (
    EXISTS (
      SELECT 1 FROM messages 
      WHERE messages.id = message_receipts.message_id
      AND EXISTS (
        SELECT 1 FROM conversation_participants 
        WHERE conversation_id = messages.conversation_id 
        AND user_id = auth.uid()
      )
    )
  );

-- INSERT: Users can create receipts for messages in conversations they are in
CREATE POLICY "Users can create receipts in their conversations" 
  ON message_receipts FOR INSERT 
  WITH CHECK (
    user_id = auth.uid()
    AND EXISTS (
      SELECT 1 FROM messages 
      WHERE messages.id = message_receipts.message_id
      AND EXISTS (
        SELECT 1 FROM conversation_participants 
        WHERE conversation_id = messages.conversation_id 
        AND user_id = auth.uid()
      )
    )
  );

-- UPDATE: Users can update their own receipts (e.g., marking as read)
CREATE POLICY "Users can update their own receipts" 
  ON message_receipts FOR UPDATE 
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

-- DELETE: Users can delete their own receipts
CREATE POLICY "Users can delete their own receipts" 
  ON message_receipts FOR DELETE 
  USING (user_id = auth.uid());
</file>

<file path="backend/supabase/storage/buckets.sql">
-- Supabase Storage Buckets Configuration
-- Creates and configures storage buckets for avatars and media uploads

-- ============================================================================
-- Bucket 1: avatars
-- ============================================================================
-- Create avatars bucket if it doesn't exist
INSERT INTO storage.buckets (id, name, owner, public)
VALUES ('avatars', 'avatars', auth.uid(), false)
ON CONFLICT (id) DO NOTHING;

-- Set bucket to public (files are stored with public paths, accessed via signed URLs)
UPDATE storage.buckets 
SET public = true 
WHERE id = 'avatars';

-- Avatar bucket policy: Users can upload avatars
CREATE POLICY "Users can upload avatars"
ON storage.objects
FOR INSERT
TO public
WITH CHECK (
  bucket_id = 'avatars'
  AND (storage.foldername(name))[1] = auth.uid()::text
  AND auth.role() = 'authenticated'
);

-- Avatar bucket policy: Users can read avatars
CREATE POLICY "Users can read avatars"
ON storage.objects
FOR SELECT
TO public
USING (
  bucket_id = 'avatars'
  AND auth.role() = 'authenticated'
);

-- Avatar bucket policy: Users can update their own avatars
CREATE POLICY "Users can update their own avatars"
ON storage.objects
FOR UPDATE
TO public
USING (
  bucket_id = 'avatars'
  AND (storage.foldername(name))[1] = auth.uid()::text
  AND auth.role() = 'authenticated'
)
WITH CHECK (
  bucket_id = 'avatars'
  AND (storage.foldername(name))[1] = auth.uid()::text
  AND auth.role() = 'authenticated'
);

-- Avatar bucket policy: Users can delete their own avatars
CREATE POLICY "Users can delete their own avatars"
ON storage.objects
FOR DELETE
TO public
USING (
  bucket_id = 'avatars'
  AND (storage.foldername(name))[1] = auth.uid()::text
  AND auth.role() = 'authenticated'
);

-- ============================================================================
-- Bucket 2: media
-- ============================================================================
-- Create media bucket if it doesn't exist
INSERT INTO storage.buckets (id, name, owner, public)
VALUES ('media', 'media', auth.uid(), false)
ON CONFLICT (id) DO NOTHING;

-- Set bucket to public (files accessed via signed URLs)
UPDATE storage.buckets 
SET public = true 
WHERE id = 'media';

-- Media bucket policy: Users can upload media
CREATE POLICY "Users can upload media"
ON storage.objects
FOR INSERT
TO public
WITH CHECK (
  bucket_id = 'media'
  AND (storage.foldername(name))[1] = auth.uid()::text
  AND auth.role() = 'authenticated'
);

-- Media bucket policy: Users can read media
CREATE POLICY "Users can read media"
ON storage.objects
FOR SELECT
TO public
USING (
  bucket_id = 'media'
  AND auth.role() = 'authenticated'
);

-- Media bucket policy: Users can delete their own media
CREATE POLICY "Users can delete their own media"
ON storage.objects
FOR DELETE
TO public
USING (
  bucket_id = 'media'
  AND (storage.foldername(name))[1] = auth.uid()::text
  AND auth.role() = 'authenticated'
);
</file>

<file path="backend/test_message_insert.js">
/**
 * Message Insert Diagnostic Test
 * 
 * Tests specifically why messages aren't inserting into Supabase
 */

const { createClient } = require('@supabase/supabase-js');
const { v4: uuidv4 } = require('uuid');
require('dotenv').config();

const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY;

if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
  console.error('‚ùå Missing SUPABASE_URL or SUPABASE_ANON_KEY in .env file');
  process.exit(1);
}

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

async function testMessageInsert() {
  console.log('üîç Testing Message Insert to Supabase\n');
  console.log('‚ïê'.repeat(60));
  
  try {
    // Step 1: Sign in (use an existing user email)
    console.log('\nüìù Step 1: Enter your test user credentials');
    console.log('Use the email you logged in with on the emulator');
    
    // You'll need to replace these with actual credentials
    const testEmail = 'tannereischen@gmail.com';
    const testPassword = 'password';
    
    console.log(`\nüîê Signing in as: ${testEmail}`);
    const { data: authData, error: authError } = await supabase.auth.signInWithPassword({
      email: testEmail,
      password: testPassword
    });
    
    if (authError) {
      console.log('‚ùå Authentication failed:', authError.message);
      console.log('\nüí° TIP: Update testEmail and testPassword in test_message_insert.js');
      return;
    }
    
    console.log('‚úÖ Authenticated as:', authData.user.email);
    console.log('   User ID:', authData.user.id);
    
    // Step 2: Check if user has any conversations
    console.log('\nüìã Step 2: Checking conversations...');
    const { data: conversations, error: convError } = await supabase
      .from('conversation_participants')
      .select('conversation_id, conversations(*)')
      .eq('user_id', authData.user.id);
    
    if (convError) {
      console.log('‚ùå Error fetching conversations:', convError.message);
      return;
    }
    
    console.log(`‚úÖ Found ${conversations.length} conversation(s)`);
    
    if (conversations.length === 0) {
      console.log('\n‚ö†Ô∏è  No conversations found!');
      console.log('   You need to create a conversation first in the app.');
      return;
    }
    
    const conversationId = conversations[0].conversation_id;
    console.log('   Using conversation:', conversationId);
    
    // Step 3: Check RLS policies
    console.log('\nüîí Step 3: Checking RLS policies...');
    
    // Try to read messages (should work if user is participant)
    const { data: readTest, error: readError } = await supabase
      .from('messages')
      .select('*')
      .eq('conversation_id', conversationId)
      .limit(1);
    
    if (readError) {
      console.log('‚ùå Cannot read messages:', readError.message);
      console.log('   This means RLS is blocking SELECT');
    } else {
      console.log('‚úÖ Can read messages - RLS SELECT policy OK');
    }
    
    // Step 4: Try to insert a test message
    console.log('\nüì§ Step 4: Attempting to insert test message...');
    
    const testMessage = {
      id: uuidv4(), // Proper UUID format
      conversation_id: conversationId,
      sender_id: authData.user.id,
      body: 'Test message from diagnostic script',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
    
    console.log('   Message payload:');
    console.log('   ', JSON.stringify(testMessage, null, 2));
    
    const { data: insertData, error: insertError } = await supabase
      .from('messages')
      .insert(testMessage)
      .select();
    
    if (insertError) {
      console.log('\n‚ùå MESSAGE INSERT FAILED!');
      console.log('   Error:', insertError.message);
      console.log('   Code:', insertError.code);
      console.log('   Details:', insertError.details);
      console.log('   Hint:', insertError.hint);
      
      // Common issues and solutions
      console.log('\nüîç Common Issues:');
      
      if (insertError.message.includes('row-level security')) {
        console.log('\n   üî¥ RLS Policy Issue');
        console.log('   The user is blocked from inserting messages.');
        console.log('\n   Possible causes:');
        console.log('   1. User is not a participant in the conversation');
        console.log('   2. RLS policy is too restrictive');
        console.log('   3. Policy check is failing');
        
        // Check if user is actually a participant
        const { data: partCheck } = await supabase
          .from('conversation_participants')
          .select('*')
          .eq('conversation_id', conversationId)
          .eq('user_id', authData.user.id);
        
        if (partCheck && partCheck.length > 0) {
          console.log('\n   ‚úÖ User IS a participant');
          console.log('   üî¥ But RLS policy is still blocking!');
          console.log('\n   FIX: Check the messages RLS policy in Supabase Dashboard');
          console.log('   Go to: Database > Tables > messages > RLS Policies');
        } else {
          console.log('\n   ‚ùå User is NOT a participant!');
          console.log('   FIX: Add user as participant to the conversation');
        }
      }
      
      if (insertError.message.includes('duplicate key')) {
        console.log('\n   ‚ö†Ô∏è  Duplicate ID');
        console.log('   The message ID already exists');
      }
      
      if (insertError.message.includes('foreign key')) {
        console.log('\n   ‚ö†Ô∏è  Foreign Key Violation');
        console.log('   The conversation or user does not exist');
      }
    } else {
      console.log('\n‚úÖ MESSAGE INSERTED SUCCESSFULLY!');
      console.log('   Message ID:', insertData[0].id);
      console.log('   Body:', insertData[0].body);
      
      // Clean up - delete test message
      await supabase.from('messages').delete().eq('id', testMessage.id);
      console.log('   (Test message deleted)');
    }
    
    // Step 5: Summary
    console.log('\n' + '‚ïê'.repeat(60));
    console.log('üìä SUMMARY');
    console.log('‚ïê'.repeat(60));
    
    if (insertError) {
      console.log('‚ùå Messages are NOT inserting into Supabase');
      console.log('üî¥ Issue:', insertError.message);
      console.log('\nüí° NEXT STEPS:');
      console.log('   1. Check RLS policies for messages table');
      console.log('   2. Verify user is a participant in conversations');
      console.log('   3. Check Flutter app logs for similar errors');
    } else {
      console.log('‚úÖ Messages CAN insert into Supabase');
      console.log('üéØ The database configuration is correct!');
      console.log('\nüí° If messages still don\'t sync from Flutter:');
      console.log('   1. Check Flutter app logs for errors');
      console.log('   2. Verify network connectivity');
      console.log('   3. Check if auth token is valid');
    }
    
  } catch (error) {
    console.error('\nüí• Unexpected error:', error);
  }
}

// Run the test
testMessageInsert();
</file>

<file path="contracts/openapitools.json">
{
  "$schema": "./node_modules/@openapitools/openapi-generator-cli/config.schema.json",
  "spaces": 2,
  "generator-cli": {
    "version": "7.16.0"
  }
}
</file>

<file path="contracts/package.json">
{
  "name": "messageai-contracts",
  "version": "0.1.0",
  "scripts": {
    "validate": "openapi-generator-cli validate -i openapi.yaml && ajv -s events/*.json",
    "gen:dart": "openapi-generator-cli generate -g dart-dio -i openapi.yaml -o ../frontend/lib/gen/api --additional-properties=pubName=message_ai_client"
  },
  "devDependencies": {
    "@openapitools/openapi-generator-cli": "^2.9.0",
    "ajv-cli": "^5.0.0"
  }
}
</file>

<file path="docs/Architecture.puml">
@startuml Architecture
title MessageAI Simplified Layered Architecture
actor User as U
rectangle "Flutter Frontend\n(/frontend)" as FE {
  component "UI Layer\n(Riverpod + Widgets)" as UI
  component "Data Layer\n(Drift + Supabase Client)" as DL
}
rectangle "Contracts\n(/contracts)" as CT {
  artifact "OpenAPI Spec\n(openapi.yaml)"
  artifact "Event Schemas\n(events/*.json)"
  artifact "Dart Client\n(/frontend/lib/gen/api)"
}
rectangle "Supabase Backend\n(/backend)" as BE {
  component "Edge Functions\n(messages_send, receipts_ack)" as EF
  component "Realtime Channels\n(messages, receipts)" as RT
  component "Storage Buckets\n(avatars, media)" as ST
}
database "Postgres DB\n(migrations + RLS)" as DB
U --> UI : Interacts via App
UI --> DL : Local Reads/Writes\nOffline Cache
DL --> CT : Uses Generated Client (OpenAPI)
CT --> EF : API Requests (Validated)
EF --> DB : SQL + Policies
DB --> RT : Broadcast Changes (Realtime)
RT --> DL : Push Updates\nPresence/Receipts
BE --> ST : Signed URL Access
@enduml
</file>

<file path="docs/ERD.puml">
@startuml ERD
title MessageAI Simplified ERD
entity "profiles" {
  *id : uuid [PK]
  --
  display_name : text
  avatar_url : text
  last_seen : timestamptz
}
entity "conversations" {
  *id : uuid [PK]
  --
  title : text
  is_group : boolean
  created_at : timestamptz
}
entity "conversation_participants" {
  *conversation_id : uuid [PK, FK -> conversations.id]
  *user_id : uuid [PK, FK -> profiles.id]
  role : text
  joined_at : timestamptz
}
entity "messages" {
  *id : uuid [PK]
  conversation_id : uuid [FK -> conversations.id]
  sender_id : uuid [FK -> profiles.id]
  body : text
  media_url : text
  created_at : timestamptz
}
entity "message_receipts" {
  *message_id : uuid [PK, FK -> messages.id]
  *user_id : uuid [PK, FK -> profiles.id]
  status : text
  at : timestamptz
}
profiles ||--o{ conversation_participants
conversations ||--o{ conversation_participants
conversations ||--o{ messages
messages ||--o{ message_receipts
profiles ||--o{ messages : "sender"
profiles ||--o{ message_receipts
@enduml
</file>

<file path="frontend/.gitignore">
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.packages
.pub-cache/
.pub/
/build/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release

# iOS/macOS
**/ios/**/*.mode1v3
**/ios/**/*.mode2v3
**/ios/**/*.moved-aside
**/ios/**/*.pbxuser
**/ios/**/*.perspectivev3
**/ios/**/*sync/
**/ios/**/.sconsign.dblite
**/ios/**/.tags*
**/ios/**/.vscode/*
!**/ios/**/.vscode/extensions.json
**/ios/**/DerivedData/
**/ios/**/Flutter/Flutter.framework/*
**/ios/**/Flutter/Flutter.podspec
**/ios/**/Flutter/Generated.xcconfig
**/ios/**/Flutter/ephemeral/
**/ios/**/Flutter/app.flx
**/ios/**/Flutter/app.zip
**/ios/**/Flutter/flutter_assets/
**/ios/**/Flutter/flutter_export_environment.sh
**/ios/**/GoogleService-Info.plist
**/ios/**/ServiceAccount.json
**/ios/**/.symlinks/
**/ios/**/.vagrant
**/ios/**/Flutter/Flutter.framework
**/ios/**/Flutter/Flutter.podspec
**/ios/Podfile
**/ios/Podfile.lock

# Web
lib/generated_plugin_registrant.dart

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
**/android/app/debug
**/android/app/profile
**/android/app/release
**/android/app/outputs
**/android/.gradle
**/android/captures/
**/android/gradlew
**/android/gradlew.bat
**/android/gradle/wrapper/gradle-wrapper.jar
**/android/gradle/wrapper/gradle-wrapper.properties

# Firebase
google-services.json
GoogleService-Info.plist
**/android/app/google-services.json
**/ios/GoogleService-Info.plist

# Exceptions to above rules.
!/packages/flutter_tools/test/data/dart_dependencies_test/**/.packages

# Environment files
.env
.env.local
.env.*.local
.env.dev.json
.env.prod.json

# Generated code
*.g.dart
*.config.dart
*.freezed.dart
*.chopper.dart

# Drift related
.dart_tool/build
lib/data/drift/**/*.g.dart

# Coverage
coverage/
.coverage

# Exceptions to above rules.
!/packages/flutter_tools/test/data/dart_dependencies_test/**/.packages

# Xcode related
*.xcarchive
*.xcworkspace
xcuser.xcuserdatad

# Compiled output
*.app/
*.framework/
*.so
.symbols/

# Obfuscation
app.*.map.json

# macOS
.DS_Store
.AppleDouble
.LSOverride
*.mode1v3
*.mode2v3
*.moved-aside
*.pbxuser
*.perspectivev3
**/*.sconsign.dblite
.sconsign.dblite
dsa_cert.certSigningRequest
profile
DerivedData/
build/
Generated.xcconfig
GeneratedPluginRegistrant.swift

# iOS
**/ios/.symlinks/
**/ios/.vagrant
**/ios/**/Flutter/Flutter.framework
**/ios/**/Flutter/Flutter.podspec
**/ios/**/Flutter/Generated.xcconfig
**/ios/**/Flutter/generated_plugin_registrant.m
**/ios/**/Flutter/ephemeral/
**/ios/**/GoogleService-Info.plist
**/ios/**/ServiceAccount.json
**/ios/**/.sconsign.dblite
**/ios/**/.tags
**/ios/**/.vscode/*
!**/ios/**/.vscode/extensions.json
**/ios/**/Flutter/.last_build_id
**/ios/**/Flutter/app.flx
**/ios/**/Flutter/app.zip
**/ios/**/Flutter/flutter_assets/
**/ios/**/Flutter/flutter_export_environment.sh

# Android
**/android/app/debug
**/android/app/profile
**/android/app/release
**/android/app/outputs/
**/android/.gradle
**/android/captures/
**/android/gradle-app.setting
**/android/gradlew
**/android/gradlew.bat
**/android/gradle/wrapper/gradle-wrapper.jar
**/android/gradle/wrapper/gradle-wrapper.properties
**/android/local.properties

# Web
lib/generated_plugin_registrant.dart

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
**/android/**/gradle-wrapper.jar
**/android/gradle
**/android/gradlew
**/android/gradlew.bat
**/android/local.properties
**/android/**/GeneratedPluginRegistrant.java

# iOS/macOS
**/ios/**/*.mode1v3
**/ios/**/*.mode2v3
**/ios/**/.vscode/*
!**/ios/**/.vscode/extensions.json
**/ios/**/DerivedData/
**/ios/**/Flutter/Flutter.framework
**/ios/**/Flutter/Flutter.podspec
**/ios/**/Flutter/Generated.xcconfig
**/ios/**/Flutter/ephemeral/
**/ios/**/Flutter/app.flx
**/ios/**/Flutter/app.zip
**/ios/**/Flutter/flutter_assets/
**/ios/**/Flutter/flutter_export_environment.sh
**/ios/**/GoogleService-Info.plist
**/ios/**/ServiceAccount.json
**/ios/**/.symlinks/
**/ios/**/.vagrant
**/macos/Flutter/Flutter-Debug.xcconfig
**/macos/Flutter/Flutter-Release.xcconfig
**/macos/Flutter/GeneratedPluginRegistrant.swift

# Windows
windows/flutter/generated_plugin_registrant.cc
windows/flutter/generated_plugin_registrant.h
windows/flutter/generated_plugins.cmake

# Linux
linux/flutter/generated_plugin_registrant.cc
linux/flutter/generated_plugin_registrant.h
linux/flutter/generated_plugins.cmake

# Coverage
coverage/

# Symbols
app.*.symbols

# Local env files
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# VS Code settings
.vscode/*
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json

# misc
*.deb
*.dsc
*.buildinfo
*.changes
*.orig.*
/.dart_tool
/.flutter-plugins
/.flutter-plugins-dependencies
/.packages
/.pub-cache
/pubspec.lock
/build
/linux/flutter/generated_plugin_registrant.cc
/linux/flutter/generated_plugin_registrant.h
/linux/flutter/generated_plugins.cmake
/macos/Flutter/GeneratedPluginRegistrant.swift
/web/plugins.json
/windows/flutter/generated_plugin_registrant.cc
/windows/flutter/generated_plugin_registrant.h
/windows/flutter/generated_plugins.cmake

# Firebase & Google Services
**/GoogleService-Info.plist
**/google-services.json
**/ServiceAccount.json

# Temporary files
*.tmp
*.swp
*.swo
*~
.~*

# System
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
</file>

<file path="frontend/.metadata">
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "9f455d2486bcb28cad87b062475f42edc959f636"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: 9f455d2486bcb28cad87b062475f42edc959f636
      base_revision: 9f455d2486bcb28cad87b062475f42edc959f636
    - platform: windows
      create_revision: 9f455d2486bcb28cad87b062475f42edc959f636
      base_revision: 9f455d2486bcb28cad87b062475f42edc959f636

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'
</file>

<file path="frontend/analysis_options.yaml">
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options
</file>

<file path="frontend/android/.gitignore">
gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java
.cxx/

# Remember to never publicly share your keystore.
# See https://flutter.dev/to/reference-keystore
key.properties
**/*.keystore
**/*.jks
</file>

<file path="frontend/android/app/src/debug/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
</file>

<file path="frontend/android/app/src/main/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="messageai"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>
</file>

<file path="frontend/android/app/src/main/kotlin/com/example/messageai/MainActivity.kt">
package com.example.messageai

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()
</file>

<file path="frontend/android/app/src/main/res/drawable-v21/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
</file>

<file path="frontend/android/app/src/main/res/drawable/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
</file>

<file path="frontend/android/app/src/main/res/values-night/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="frontend/android/app/src/main/res/values/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="frontend/android/build.gradle.kts">
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}
</file>

<file path="frontend/android/gradle.properties">
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
android.enableJetifier=true
</file>

<file path="frontend/devtools_options.yaml">
description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:
</file>

<file path="frontend/firebase.json">
{"flutter":{"platforms":{"android":{"default":{"projectId":"messageai-e2e9e","appId":"1:397483513751:android:bb838799a2cd3f7f1c56d2","fileOutput":"android/app/google-services.json"}},"dart":{"lib/firebase_options.dart":{"projectId":"messageai-e2e9e","configurations":{"android":"1:397483513751:android:bb838799a2cd3f7f1c56d2","web":"1:397483513751:web:3121cbb846ddd8381c56d2","windows":"1:397483513751:web:ba73c764d577f4f51c56d2"}}}}}}
</file>

<file path="frontend/integration_test/ai_flow_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/app.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('AI Analysis Integration Flow', () {
    testWidgets('app structure loads correctly', (tester) async {
      // Verify the app widget exists
      const app = MessageAIApp();
      
      // Basic structure test
      expect(app, isA<MessageAIApp>());
    });
    
    testWidgets('complete AI analysis flow - TODO', (tester) async {
      // This is a placeholder for a full integration test
      // To implement when backend is fully configured:
      // 
      // 1. Initialize Supabase with test credentials
      // 2. Login with test user
      // 3. Navigate to a test conversation
      // 4. Send a message: "Hello, how are you doing today?"
      // 5. Wait for AI analysis to complete (may take 3-5 seconds)
      // 6. Verify ToneBadge appears on the message bubble
      // 7. Tap the badge to open ToneDetailSheet
      // 8. Verify sheet shows: tone, urgency level, intent, confidence
      // 9. Close sheet and pull down the message panel
      // 10. Verify AIInsightsPanel shows conversation-level insights
      // 
      // Requirements:
      // - Supabase running with test database
      // - OpenAI API key configured in ai_analyze_tone Edge Function
      // - Test user account in auth.users table
      // - Test conversation and participants in database
      
      // TODO: Implement full flow when authentication is configured
      expect(true, isTrue); // Placeholder assertion
    });
  });
}
</file>

<file path="frontend/integration_test/all_phases_comprehensive_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';

import 'phase1_smart_interpreter_test.dart' as phase1;
import 'phase2_response_assistant_test.dart' as phase2;
import 'phase3_context_system_test.dart' as phase3;
import 'phase4_followup_system_test.dart' as phase4;

/// Comprehensive Integration Tests for All 4 Phases
/// Runs all phase tests in sequence
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('MessageAI - All Phases Comprehensive Tests', () {
    print('üöÄ Starting Comprehensive Test Suite for All 4 Phases');
    print('================================================\n');

    group('Phase 1: Smart Message Interpreter', () {
      print('\nüìù Testing Phase 1: Smart Message Interpreter');
      print('  - Enhanced Tone Analysis (23 tones)');
      print('  - RSD Detection');
      print('  - Alternative Interpretations\n');
      
      phase1.main();
    });

    group('Phase 2: Adaptive Response Assistant', () {
      print('\n‚úçÔ∏è  Testing Phase 2: Adaptive Response Assistant');
      print('  - Draft Confidence Checker');
      print('  - Social Scripts & Templates');
      print('  - Boundary Support\n');
      
      phase2.main();
    });

    group('Phase 3: Smart Inbox with Context', () {
      print('\nüìö Testing Phase 3: Smart Inbox with Context');
      print('  - Context Preloading');
      print('  - Relationship Memory');
      print('  - RAG System (Vector Search)\n');
      
      phase3.main();
    });

    group('Phase 4: Smart Follow-up System', () {
      print('\n‚úÖ Testing Phase 4: Smart Follow-up System');
      print('  - Action Item Extraction');
      print('  - Question Detection');
      print('  - Follow-up Dashboard\n');
      
      phase4.main();
    });

    print('\n================================================');
    print('‚úÖ All Phase Tests Complete!');
  });
}
</file>

<file path="frontend/integration_test/context_system_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/main.dart' as app;

/// Integration tests for Phase 3: Context System
///
/// These tests verify the complete flow of:
/// 1. Loading conversation context
/// 2. Displaying context preview card
/// 3. Opening relationship profiles
/// 4. Viewing safe topics and communication patterns
///
/// Prerequisites:
/// - Test Supabase instance with sample data
/// - Authenticated user session
/// - At least one conversation with messages
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Context System Integration Tests', () {
    testWidgets('Full context preview flow', (tester) async {
      // Start the app
      app.main();
      await tester.pumpAndSettle();

      // Wait for authentication/home screen
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to a conversation (adjust selector based on your UI)
      // This is a template - adjust based on your actual navigation
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Verify context preview card appears
        expect(find.text('Last Conversation'), findsOneWidget,
            reason: 'Context preview card should appear at top of messages');

        // Verify key points are displayed if available
        final recentTopicsFinder = find.text('Recent topics:');
        if (recentTopicsFinder.evaluate().isNotEmpty) {
          expect(recentTopicsFinder, findsOneWidget,
              reason: 'Recent topics section should be visible');
        }
      }
    });

    testWidgets('Relationship profile flow', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to a conversation
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Find and tap "Who is this?" button
        final whoIsThisButton = find.byTooltip('Who is this?');
        if (whoIsThisButton.evaluate().isNotEmpty) {
          await tester.tap(whoIsThisButton);
          await tester.pumpAndSettle();

          // Verify relationship sheet opens
          // Look for common elements that should be in the sheet
          await tester.pumpAndSettle(const Duration(seconds: 2));

          // Close the sheet
          final closeButton = find.byIcon(Icons.close);
          if (closeButton.evaluate().isNotEmpty) {
            await tester.tap(closeButton);
            await tester.pumpAndSettle();
          }
        }
      }
    });

    testWidgets('Context caching behavior', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Open a conversation
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Wait for context to load
        await tester.pumpAndSettle(const Duration(seconds: 2));

        // Go back
        final backButton = find.byTooltip('Back');
        if (backButton.evaluate().isNotEmpty) {
          await tester.tap(backButton);
          await tester.pumpAndSettle();

          // Open same conversation again
          await tester.tap(conversationFinder);
          await tester.pumpAndSettle();

          // Second load should be faster (cached)
          // Look for 'cached' indicator
          final cachedIndicator = find.text('cached');
          // Note: This may not always appear depending on timing
          await tester.pumpAndSettle();
        }
      }
    });

    testWidgets('Pending questions display', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to conversation with pending questions
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Look for pending questions badge
        final pendingQuestionsFinder = find.byIcon(Icons.help_outline);
        if (pendingQuestionsFinder.evaluate().isNotEmpty) {
          expect(pendingQuestionsFinder, findsOneWidget,
              reason: 'Pending questions indicator should be visible');

          // Verify text format
          final questionTextFinder = find.textContaining('unanswered question');
          expect(questionTextFinder, findsOneWidget,
              reason: 'Pending questions count should be displayed');
        }
      }
    });

    testWidgets('Safe topics display in relationship profile', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to conversation
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Open relationship profile
        final whoIsThisButton = find.byTooltip('Who is this?');
        if (whoIsThisButton.evaluate().isNotEmpty) {
          await tester.tap(whoIsThisButton);
          await tester.pumpAndSettle(const Duration(seconds: 2));

          // Look for safe topics section
          final safeTopicsFinder = find.text('Safe Topics');
          if (safeTopicsFinder.evaluate().isNotEmpty) {
            expect(safeTopicsFinder, findsOneWidget,
                reason: 'Safe topics section should be visible');
          }

          // Look for topics to avoid section
          final avoidTopicsFinder = find.text('Topics to Avoid');
          if (avoidTopicsFinder.evaluate().isNotEmpty) {
            expect(avoidTopicsFinder, findsOneWidget,
                reason: 'Topics to avoid section should be visible');
          }

          // Close the sheet
          final closeButton = find.byIcon(Icons.close);
          if (closeButton.evaluate().isNotEmpty) {
            await tester.tap(closeButton);
            await tester.pumpAndSettle();
          }
        }
      }
    });

    testWidgets('Context updates after sending message', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to conversation
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Note initial context
        await tester.pumpAndSettle(const Duration(seconds: 2));

        // Send a message
        final messageField = find.byType(TextField);
        if (messageField.evaluate().isNotEmpty) {
          await tester.enterText(messageField.first, 'Test message for context');
          await tester.testTextInput.receiveAction(TextInputAction.send);
          await tester.pumpAndSettle();

          // Context should eventually update
          // Note: In real scenario, this depends on backend processing
          await tester.pumpAndSettle(const Duration(seconds: 3));
        }
      }
    });
  });

  group('Error Handling Tests', () {
    testWidgets('Handles missing context gracefully', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to a new conversation with no context
      // Should not crash or show errors
      final conversationFinder = find.text('New Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Should show messages without context card
        expect(tester.takeException(), isNull,
            reason: 'Should handle missing context without crashing');
      }
    });

    testWidgets('Handles missing relationship profile', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      final conversationFinder = find.text('New Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Try to open relationship profile
        final whoIsThisButton = find.byTooltip('Who is this?');
        if (whoIsThisButton.evaluate().isNotEmpty) {
          await tester.tap(whoIsThisButton);
          await tester.pumpAndSettle(const Duration(seconds: 2));

          // Should show "No profile available" message
          final noProfileFinder = find.text('No profile available');
          if (noProfileFinder.evaluate().isNotEmpty) {
            expect(noProfileFinder, findsOneWidget);
          }

          // Close if needed
          final closeButton = find.byIcon(Icons.close);
          if (closeButton.evaluate().isNotEmpty) {
            await tester.tap(closeButton);
            await tester.pumpAndSettle();
          }
        }
      }
    });
  });
}
</file>

<file path="frontend/integration_test/enhanced_tone_analysis_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/features/messages/widgets/tone_detail_sheet.dart';
import 'package:flutter/material.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Enhanced Tone Analysis Integration Tests', () {
    testWidgets('Full flow: Parse analysis -> Display badge -> Show detail sheet',
        (tester) async {
      // Simulate API response with enhanced fields
      final apiResponse = {
        'id': 'analysis-123',
        'message_id': 'msg-456',
        'tone': 'Overwhelmed',
        'urgency_level': 'High',
        'intent': 'expressing severe stress about deadline',
        'confidence_score': 0.95,
        'analysis_timestamp': DateTime.now().millisecondsSinceEpoch ~/ 1000,
        'intensity': 'very_high',
        'secondary_tones': ['Frustrated', 'Concerned'],
        'context_flags': {
          'tone_indicator_present': true,
          'sarcasm_detected': false,
          'ambiguous': false,
        },
        'anxiety_assessment': {
          'risk_level': 'high',
          'mitigation_suggestions': [
            'Urgent tone detected. Consider asking for a specific timeline.',
            'Take a moment before responding to reduce pressure.',
          ],
        },
      };

      // 1. Parse the analysis
      final analysis = AIAnalysis.fromJson(apiResponse);
      expect(analysis.tone, 'Overwhelmed');
      expect(analysis.intensity, 'very_high');
      expect(analysis.contextFlags?['tone_indicator_present'], true);
      expect(analysis.anxietyAssessment?['risk_level'], 'high');

      // 2. Display in ToneBadge
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(
              analysis: analysis,
              onTap: () {},
            ),
          ),
        ),
      );

      expect(find.text('üòµ'), findsOneWidget, reason: 'Overwhelmed emoji');
      expect(find.text('Overwhelmed'), findsOneWidget);
      
      // Should have intensity and urgency dots
      final containers = tester.widgetList<Container>(find.byType(Container)).toList();
      final circleDots = containers.where((c) {
        final d = c.decoration;
        return d is BoxDecoration && d.shape == BoxShape.circle;
      }).length;
      expect(circleDots, greaterThanOrEqualTo(2));

      // 3. Show detail sheet
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: Builder(
              builder: (context) => ElevatedButton(
                onPressed: () {
                  ToneDetailSheet.show(
                    context,
                    analysis,
                    "I'm SO stressed about this deadline /srs",
                  );
                },
                child: const Text('Show Details'),
              ),
            ),
          ),
        ),
      );

      await tester.tap(find.text('Show Details'));
      await tester.pumpAndSettle();

      // Verify detail sheet content
      expect(find.text('AI Analysis'), findsOneWidget);
      expect(find.text('Overwhelmed'), findsOneWidget);
      expect(find.text('High'), findsOneWidget, reason: 'Urgency level');
      expect(find.text('Very High'), findsOneWidget, reason: 'Intensity formatted');
      
      // Check for anxiety assessment
      expect(find.textContaining('Response Anxiety'), findsOneWidget);
      expect(find.textContaining('HIGH'), findsOneWidget);
    });

    testWidgets('Playful tone with tone indicator /j', (tester) async {
      final apiResponse = {
        'id': 'analysis-789',
        'message_id': 'msg-012',
        'tone': 'Playful',
        'urgency_level': 'Low',
        'intent': 'joking about suggestion',
        'confidence_score': 0.92,
        'analysis_timestamp': DateTime.now().millisecondsSinceEpoch ~/ 1000,
        'intensity': 'medium',
        'context_flags': {
          'tone_indicator_present': true,
          'sarcasm_detected': false,
        },
        'anxiety_assessment': {
          'risk_level': 'low',
          'mitigation_suggestions': [],
        },
      };

      final analysis = AIAnalysis.fromJson(apiResponse);

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      expect(find.text('üòú'), findsOneWidget, reason: 'Playful emoji');
      expect(find.text('Playful'), findsOneWidget);
    });

    testWidgets('Sarcastic tone detection', (tester) async {
      final apiResponse = {
        'id': 'analysis-sarcasm',
        'message_id': 'msg-sarcasm',
        'tone': 'Sarcastic',
        'urgency_level': 'Low',
        'intent': 'expressing frustration sarcastically',
        'confidence_score': 0.88,
        'analysis_timestamp': DateTime.now().millisecondsSinceEpoch ~/ 1000,
        'intensity': 'high',
        'context_flags': {
          'sarcasm_detected': true,
          'tone_indicator_present': true,
        },
        'anxiety_assessment': {
          'risk_level': 'medium',
          'mitigation_suggestions': [
            'Sarcasm detected. Literal meaning may differ.',
          ],
        },
      };

      final analysis = AIAnalysis.fromJson(apiResponse);

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      expect(find.text('üôÑ'), findsOneWidget, reason: 'Sarcastic emoji');
      expect(analysis.contextFlags?['sarcasm_detected'], true);
      expect(analysis.anxietyAssessment?['risk_level'], 'medium');
    });

    testWidgets('All 5 intensity levels display correctly', (tester) async {
      final intensities = ['very_low', 'low', 'medium', 'high', 'very_high'];

      for (final intensity in intensities) {
        final analysis = AIAnalysis(
          id: 'test-$intensity',
          messageId: 'msg-$intensity',
          tone: 'Friendly',
          intensity: intensity,
          analysisTimestamp: DateTime.now().millisecondsSinceEpoch ~/ 1000,
        );

        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: ToneBadge(analysis: analysis),
            ),
          ),
        );

        // Should display intensity dot
        final containers = tester.widgetList<Container>(find.byType(Container));
        final hasIntensityDot = containers.any((c) {
          final d = c.decoration;
          return d is BoxDecoration && d.shape == BoxShape.circle;
        });
        
        expect(hasIntensityDot, true, reason: 'Intensity dot for $intensity');
      }
    });

    testWidgets('Backward compatibility: Analysis without enhanced fields', (tester) async {
      // Old API response without enhanced fields
      final oldApiResponse = {
        'id': 'old-analysis',
        'message_id': 'old-msg',
        'tone': 'Friendly',
        'urgency_level': 'Low',
        'intent': 'greeting',
        'confidence_score': 0.85,
        'analysis_timestamp': DateTime.now().millisecondsSinceEpoch ~/ 1000,
      };

      final analysis = AIAnalysis.fromJson(oldApiResponse);
      expect(analysis.intensity, null);
      expect(analysis.contextFlags, null);

      // Should still display correctly
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      expect(find.text('üòä'), findsOneWidget);
      expect(find.text('Friendly'), findsOneWidget);
    });
  });
}
</file>

<file path="frontend/integration_test/phase1_smart_interpreter_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/services/tone_analysis_service.dart';
import 'package:messageai/services/message_interpreter_service.dart';

/// Phase 1: Smart Message Interpreter Integration Tests
/// Tests: Enhanced Tone Analysis, RSD Detection, Alternative Interpretations
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Phase 1: Smart Message Interpreter', () {
    late ToneAnalysisService toneService;
    late MessageInterpreterService interpreterService;

    setUp(() {
      toneService = ToneAnalysisService();
      interpreterService = MessageInterpreterService();
    });

    group('Enhanced Tone Analysis (23 tones)', () {
      test('analyzes supportive message correctly', () async {
        final result = await toneService.analyzeTone(
          "You're doing great! I'm here to help if you need anything.",
        );

        expect(result, isNotNull);
        expect(result!.primaryTone, isIn(['supportive', 'encouraging', 'warm']));
        expect(result.intensity, greaterThan(0.5));
        expect(result.neurodivergentContext, isNotNull);
      });

      test('analyzes sarcastic message correctly', () async {
        final result = await toneService.analyzeTone(
          "Oh great, another meeting. Just what I needed today.",
        );

        expect(result, isNotNull);
        expect(result!.primaryTone, contains('sarcastic'));
        expect(result.confidence, greaterThan(0.6));
      });

      test('detects mixed tones', () async {
        final result = await toneService.analyzeTone(
          "I appreciate your help, but I'm a bit frustrated with the delay.",
        );

        expect(result, isNotNull);
        expect(result!.tones.length, greaterThanOrEqualTo(2));
        expect(result.tones, anyElement(contains('appreciative')));
        expect(result.tones, anyElement(contains('frustrated')));
      });

      test('provides neurodivergent-friendly context', () async {
        final result = await toneService.analyzeTone(
          "Can you send me that thing we talked about?",
        );

        expect(result, isNotNull);
        expect(result!.neurodivergentContext, isNotNull);
        expect(result.neurodivergentContext!.needsClarification, isTrue);
      });
    });

    group('RSD Detection', () {
      test('detects potential RSD trigger - criticism', () async {
        final result = await interpreterService.interpretMessage(
          "You didn't do this correctly.",
          senderName: 'Boss',
        );

        expect(result.rsdAlert, isNotNull);
        expect(result.rsdAlert!.triggerType, contains('criticism'));
        expect(result.rsdAlert!.severity, greaterThan(0.5));
      });

      test('detects potential RSD trigger - rejection', () async {
        final result = await interpreterService.interpretMessage(
          "I don't think this is a good fit for us right now.",
          senderName: 'Client',
        );

        expect(result.rsdAlert, isNotNull);
        expect(result.rsdAlert!.triggerType, contains('rejection'));
      });

      test('does not flag neutral messages', () async {
        final result = await interpreterService.interpretMessage(
          "The meeting is scheduled for 3pm tomorrow.",
          senderName: 'Colleague',
        );

        expect(result.rsdAlert, isNull);
      });

      test('provides coping strategies for RSD triggers', () async {
        final result = await interpreterService.interpretMessage(
          "Your work is consistently below expectations.",
          senderName: 'Manager',
        );

        expect(result.rsdAlert, isNotNull);
        expect(result.rsdAlert!.copingStrategies, isNotEmpty);
      });
    });

    group('Alternative Interpretations', () {
      test('provides multiple interpretations for ambiguous messages', () async {
        final result = await interpreterService.interpretMessage(
          "We need to talk.",
          senderName: 'Friend',
        );

        expect(result.alternativeInterpretations, isNotEmpty);
        expect(result.alternativeInterpretations.length, greaterThanOrEqualTo(2));
      });

      test('extracts evidence for each interpretation', () async {
        final result = await interpreterService.interpretMessage(
          "Thanks for your input. I'll consider it.",
          senderName: 'Boss',
        );

        for (final interpretation in result.alternativeInterpretations) {
          expect(interpretation.evidence, isNotEmpty);
          expect(interpretation.likelihood, greaterThan(0));
          expect(interpretation.likelihood, lessThanOrEqualTo(1));
        }
      });

      test('handles literal interpretation for neurodivergent users', () async {
        final result = await interpreterService.interpretMessage(
          "That's interesting.",
          senderName: 'Coworker',
        );

        expect(
          result.alternativeInterpretations,
          anyElement((interp) => interp.interpretation.contains('literal')),
        );
      });
    });

    group('Comprehensive Message Analysis', () {
      test('analyzes complex professional email', () async {
        final message = """
Hi there,

I wanted to follow up on our conversation from last week. 
While I appreciate your efforts, I think we need to reconsider 
our approach. Can we schedule a call to discuss?

Best regards
        """;

        final result = await interpreterService.interpretMessage(
          message,
          senderName: 'Project Lead',
        );

        expect(result.toneAnalysis, isNotNull);
        expect(result.alternativeInterpretations, isNotEmpty);
        // Should detect "reconsider" as potential concern
        expect(result.rsdAlert != null || result.toneAnalysis!.primaryTone.contains('concern'), isTrue);
      });

      test('analyzes casual message with emojis', () async {
        final result = await interpreterService.interpretMessage(
          "Hey! üòä Just checking in. How's it going?",
          senderName: 'Friend',
        );

        expect(result.toneAnalysis, isNotNull);
        expect(result.toneAnalysis!.primaryTone, contains(['friendly', 'casual', 'warm']));
        expect(result.rsdAlert, isNull);
      });
    });
  });
}
</file>

<file path="frontend/integration_test/phase2_response_assistant_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/services/draft_confidence_service.dart';
import 'package:messageai/services/message_formatter_service.dart';

/// Phase 2: Adaptive Response Assistant Integration Tests
/// Tests: Draft Confidence Checker, Social Scripts, Boundary Support
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Phase 2: Adaptive Response Assistant', () {
    late DraftConfidenceService confidenceService;
    late MessageFormatterService formatterService;

    setUp(() {
      confidenceService = DraftConfidenceService();
      formatterService = MessageFormatterService();
    });

    group('Draft Confidence Checker', () {
      test('analyzes confident professional message', () async {
        final result = await confidenceService.analyzeDraft(
          "Thank you for your email. I'll review the proposal and send my feedback by Friday.",
        );

        expect(result, isNotNull);
        expect(result!.overallConfidence, greaterThan(0.7));
        expect(result.flags, isEmpty);
      });

      test('detects excessive apologizing', () async {
        final result = await confidenceService.analyzeDraft(
          "Sorry to bother you, I'm really sorry but I just wanted to ask if maybe you could possibly help me? Sorry!",
        );

        expect(result, isNotNull);
        expect(result!.flags, isNotEmpty);
        expect(
          result.flags,
          anyElement((flag) => flag.type.contains('excessive_apologizing')),
        );
        expect(result.overallConfidence, lessThan(0.5));
      });

      test('detects hedging language', () async {
        final result = await confidenceService.analyzeDraft(
          "I kind of think that maybe we should perhaps consider possibly doing this differently.",
        );

        expect(result, isNotNull);
        expect(
          result!.flags,
          anyElement((flag) => flag.type.contains('hedging')),
        );
        expect(result.suggestions, isNotEmpty);
      });

      test('detects self-deprecation', () async {
        final result = await confidenceService.analyzeDraft(
          "I'm not great at this, but here's my terrible attempt at solving the problem.",
        );

        expect(result, isNotNull);
        expect(
          result!.flags,
          anyElement((flag) => flag.type.contains('self_deprecating')),
        );
      });

      test('provides specific suggestions for improvement', () async {
        final result = await confidenceService.analyzeDraft(
          "Sorry, but I think maybe we could possibly try this?",
        );

        expect(result, isNotNull);
        expect(result!.suggestions, isNotEmpty);
        expect(result.improvedVersion, isNotNull);
        expect(result.improvedVersion, isNot(equals(result.suggestions.first)));
      });
    });

    group('Message Formatter with Templates', () {
      test('formats declining invitation message', () async {
        final result = await formatterService.formatMessage(
          situation: 'declining_invitation',
          context: 'dinner party',
          userInput: "I can't make it",
        );

        expect(result, isNotNull);
        expect(result.formattedMessage, isNotEmpty);
        expect(result.formattedMessage, contains(['thank', 'appreciate', 'unfortunately']));
        expect(result.tone, equals('polite'));
      });

      test('formats boundary setting message', () async {
        final result = await formatterService.formatMessage(
          situation: 'setting_boundary',
          context: 'work hours',
          userInput: "I don't work on weekends",
        );

        expect(result, isNotNull);
        expect(result.formattedMessage, isNotEmpty);
        expect(result.formattedMessage.toLowerCase(), contains(['weekend', 'time', 'balance']));
        expect(result.tone, equals('assertive'));
      });

      test('formats apologizing message', () async {
        final result = await formatterService.formatMessage(
          situation: 'apologizing',
          context: 'missed deadline',
          userInput: "I'm sorry for missing the deadline",
        );

        expect(result, isNotNull);
        expect(result.formattedMessage, contains(['apologize', 'sorry']));
        expect(result.actionItems, isNotEmpty);
      });

      test('formats info dump with structure', () async {
        final result = await formatterService.formatMessage(
          situation: 'info_dump',
          context: 'project explanation',
          userInput: "So there's this thing and it does stuff and also this other thing connects to it...",
        );

        expect(result, isNotNull);
        expect(result.formattedMessage, isNotEmpty);
        // Should have better structure
        expect(result.formattedMessage, contains(['\n', 'first', 'second', '1', '2']));
      });

      test('formats clarifying question', () async {
        final result = await formatterService.formatMessage(
          situation: 'asking_clarification',
          context: 'meeting details',
          userInput: "When is the meeting?",
        );

        expect(result, isNotNull);
        expect(result.formattedMessage, contains(['could', 'please', 'clarify', 'confirm']));
      });
    });

    group('Situation Detection', () {
      test('detects when user is declining', () async {
        final situation = await formatterService.detectSituation(
          "I don't think I can make it to the event",
        );

        expect(situation, isNotNull);
        expect(situation, equals('declining_invitation'));
      });

      test('detects when user is setting boundary', () async {
        final situation = await formatterService.detectSituation(
          "I need you to stop calling me after 9pm",
        );

        expect(situation, isNotNull);
        expect(situation, contains('boundary'));
      });

      test('detects when user is apologizing', () async {
        final situation = await formatterService.detectSituation(
          "I'm really sorry about the mistake I made",
        );

        expect(situation, isNotNull);
        expect(situation, contains('apolog'));
      });
    });

    group('Comprehensive Draft Analysis', () {
      test('analyzes and improves weak professional email', () async {
        final draft = """
Sorry to bother you! I was just wondering if maybe you might possibly 
have a moment to look at my work? I know you're super busy and I'm 
probably not doing this right, but I'd really appreciate it if you could 
possibly give me some feedback? Sorry again for bothering you!
        """;

        final result = await confidenceService.analyzeDraft(draft);

        expect(result, isNotNull);
        expect(result!.flags.length, greaterThanOrEqualTo(3));
        expect(result.overallConfidence, lessThan(0.4));
        expect(result.improvedVersion, isNotNull);
        expect(result.improvedVersion!.length, lessThan(draft.length));
      });

      test('validates strong professional message', () async {
        final draft = """
Hi Sarah,

I wanted to follow up on the project proposal we discussed. I've reviewed 
the requirements and have some suggestions that could improve efficiency.

Could we schedule a 30-minute call this week to discuss?

Best regards,
Alex
        """;

        final result = await confidenceService.analyzeDraft(draft);

        expect(result, isNotNull);
        expect(result!.overallConfidence, greaterThan(0.7));
        expect(result.flags, isEmpty);
      });
    });
  });
}
</file>

<file path="frontend/integration_test/phase3_context_system_test.dart">
import 'dart:math' show sqrt;
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/services/context_preloader_service.dart';
import 'package:messageai/services/relationship_summary_service.dart';

/// Phase 3: Smart Inbox with Context Integration Tests
/// Tests: Context Preloading, Relationship Memory, RAG System
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Phase 3: Smart Inbox with Context', () {
    late ContextPreloaderService contextService;
    late RelationshipSummaryService relationshipService;

    setUp(() {
      contextService = ContextPreloaderService();
      relationshipService = RelationshipSummaryService();
    });

    group('Context Preloader', () {
      test('preloads context for conversation', () async {
        final context = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        expect(context, isNotNull);
        expect(context.conversationId, equals('test-conv-123'));
        expect(context.summary, isNotNull);
      });

      test('identifies key topics from conversation history', () async {
        final context = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        expect(context.keyTopics, isNotEmpty);
        expect(context.keyTopics.length, lessThanOrEqualTo(5));
      });

      test('detects recent action items from history', () async {
        final context = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        expect(context.recentActionItems, isNotNull);
      });

      test('identifies unanswered questions', () async {
        final context = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        expect(context.unansweredQuestions, isNotNull);
      });

      test('provides relationship context', () async {
        final context = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        expect(context.relationshipSummary, isNotNull);
        expect(context.relationshipSummary!.communicationStyle, isNotEmpty);
      });

      test('caches context for performance', () async {
        // First call
        final start1 = DateTime.now();
        await contextService.preloadContext(conversationId: 'test-conv-123');
        final duration1 = DateTime.now().difference(start1);

        // Second call (should be cached)
        final start2 = DateTime.now();
        await contextService.preloadContext(conversationId: 'test-conv-123');
        final duration2 = DateTime.now().difference(start2);

        expect(duration2.inMilliseconds, lessThan(duration1.inMilliseconds));
      });
    });

    group('Relationship Summary', () {
      test('generates relationship profile', () async {
        final summary = await relationshipService.generateSummary(
          conversationId: 'test-conv-123',
        );

        expect(summary, isNotNull);
        expect(summary.communicationStyle, isNotEmpty);
        expect(summary.relationshipType, isNotEmpty);
      });

      test('detects professional relationship', () async {
        final summary = await relationshipService.generateSummary(
          conversationId: 'work-conv-456',
        );

        expect(summary, isNotNull);
        expect(summary.relationshipType.toLowerCase(), contains(['professional', 'work', 'colleague']));
      });

      test('detects casual/friend relationship', () async {
        final summary = await relationshipService.generateSummary(
          conversationId: 'friend-conv-789',
        );

        expect(summary, isNotNull);
        expect(summary.relationshipType.toLowerCase(), contains(['friend', 'casual', 'personal']));
      });

      test('identifies communication preferences', () async {
        final summary = await relationshipService.generateSummary(
          conversationId: 'test-conv-123',
        );

        expect(summary.communicationStyle, isNotEmpty);
        expect(summary.communicationStyle, contains(['formal', 'casual', 'direct', 'detailed']));
      });

      test('tracks shared topics and interests', () async {
        final summary = await relationshipService.generateSummary(
          conversationId: 'test-conv-123',
        );

        expect(summary.sharedTopics, isNotEmpty);
      });

      test('provides conversation history stats', () async {
        final summary = await relationshipService.generateSummary(
          conversationId: 'test-conv-123',
        );

        expect(summary.messageCount, greaterThan(0));
        expect(summary.lastInteractionAt, isNotNull);
      });
    });

    group('RAG (Vector Search)', () {
      test('finds relevant past messages by semantic similarity', () async {
        final results = await contextService.searchSimilarMessages(
          query: 'project deadline',
          conversationId: 'test-conv-123',
        );

        expect(results, isNotEmpty);
        expect(results.length, lessThanOrEqualTo(5));
      });

      test('ranks results by relevance', () async {
        final results = await contextService.searchSimilarMessages(
          query: 'meeting schedule',
          conversationId: 'test-conv-123',
        );

        expect(results, isNotEmpty);
        // Should be sorted by relevance score
        for (int i = 0; i < results.length - 1; i++) {
          expect(
            results[i].relevanceScore,
            greaterThanOrEqualTo(results[i + 1].relevanceScore),
          );
        }
      });

      test('searches across all conversations when not limited', () async {
        final results = await contextService.searchSimilarMessages(
          query: 'vacation plans',
          // No conversationId specified = search all
        );

        expect(results, isNotEmpty);
        // Should include results from multiple conversations
        final conversationIds = results.map((r) => r.conversationId).toSet();
        expect(conversationIds.length, greaterThanOrEqualTo(1));
      });
    });

    group('Embeddings Generation', () {
      test('generates embeddings for new message', () async {
        final embedding = await contextService.generateEmbedding(
          'This is a test message about project planning',
        );

        expect(embedding, isNotNull);
        expect(embedding.vector, isNotEmpty);
        expect(embedding.vector.length, equals(1536)); // OpenAI embedding size
      });

      test('similar messages have similar embeddings', () async {
        final embedding1 = await contextService.generateEmbedding(
          'Let\'s schedule a meeting for next week',
        );
        final embedding2 = await contextService.generateEmbedding(
          'Can we set up a meeting next week?',
        );
        final embedding3 = await contextService.generateEmbedding(
          'I love pizza and ice cream',
        );

        final similarity12 = _cosineSimilarity(embedding1.vector, embedding2.vector);
        final similarity13 = _cosineSimilarity(embedding1.vector, embedding3.vector);

        expect(similarity12, greaterThan(similarity13));
      });
    });

    group('Comprehensive Context System', () {
      test('provides full context for conversation', () async {
        final context = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        // Should have all components
        expect(context.summary, isNotEmpty);
        expect(context.keyTopics, isNotEmpty);
        expect(context.relationshipSummary, isNotNull);
        expect(context.recentActionItems, isNotNull);
        expect(context.unansweredQuestions, isNotNull);
      });

      test('handles conversations with no history gracefully', () async {
        final context = await contextService.preloadContext(
          conversationId: 'new-conv-999',
        );

        expect(context, isNotNull);
        expect(context.summary, isNotEmpty); // Should have default message
        expect(context.keyTopics, isEmpty);
      });

      test('updates context when new messages arrive', () async {
        // Get initial context
        final context1 = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        // Simulate new message
        await contextService.invalidateCache('test-conv-123');

        // Get updated context
        final context2 = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        expect(context2, isNotNull);
        // Cache should be refreshed
      });
    });
  });
}

/// Helper function to calculate cosine similarity
double _cosineSimilarity(List<double> a, List<double> b) {
  if (a.length != b.length) return 0.0;

  double dotProduct = 0.0;
  double normA = 0.0;
  double normB = 0.0;

  for (int i = 0; i < a.length; i++) {
    dotProduct += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }

  if (normA == 0.0 || normB == 0.0) return 0.0;

  return dotProduct / (sqrt(normA) * sqrt(normB));
}
</file>

<file path="frontend/integration_test/phase4_followup_system_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/services/follow_up_service.dart';
import 'package:messageai/models/follow_up_item.dart';

/// Phase 4: Smart Follow-up System Integration Tests
/// Tests: Action Item Extraction, Question Detection, Follow-up Dashboard
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Phase 4: Smart Follow-up System', () {
    late FollowUpService followUpService;

    setUp(() {
      followUpService = FollowUpService();
    });

    group('Action Item Extraction', () {
      test('extracts "I\'ll" commitment', () async {
        await followUpService.extractFollowUps('test-conv-123');
        
        // After extraction, check if items were created
        final items = await followUpService.getConversationFollowUps('test-conv-123');
        
        final actionItems = items.where(
          (item) => item.itemType == FollowUpItemType.actionItem,
        ).toList();

        expect(actionItems, isNotEmpty);
      });

      test('extracts "I can" commitment', () async {
        await followUpService.extractFollowUps('test-conv-456');
        
        final items = await followUpService.getConversationFollowUps('test-conv-456');
        expect(items, isNotEmpty);
      });

      test('extracts action with target', () async {
        await followUpService.extractFollowUps('test-conv-789');
        
        final items = await followUpService.getConversationFollowUps('test-conv-789');
        final actionItems = items.where(
          (item) => item.itemType == FollowUpItemType.actionItem,
        ).toList();

        if (actionItems.isNotEmpty) {
          expect(actionItems.first.title, isNotEmpty);
        }
      });

      test('extracts deadline when mentioned', () async {
        // Message: "I'll send the report by Friday"
        await followUpService.extractFollowUps('test-conv-deadline');
        
        final items = await followUpService.getConversationFollowUps('test-conv-deadline');
        final actionItems = items.where(
          (item) => item.itemType == FollowUpItemType.actionItem && item.dueAt != null,
        ).toList();

        if (actionItems.isNotEmpty) {
          expect(actionItems.first.dueAt, isNotNull);
        }
      });

      test('does not extract non-commitments', () async {
        // Message: "You should send the report"
        await followUpService.extractFollowUps('test-conv-no-commit');
        
        final items = await followUpService.getConversationFollowUps('test-conv-no-commit');
        final myCommitments = items.where(
          (item) => item.itemType == FollowUpItemType.actionItem,
        ).toList();

        // Should not extract third-person suggestions
        expect(myCommitments.length, lessThanOrEqualTo(0));
      });
    });

    group('Unanswered Question Detection', () {
      test('detects question without response', () async {
        await followUpService.extractFollowUps('test-conv-question');
        
        final items = await followUpService.getConversationFollowUps('test-conv-question');
        final questions = items.where(
          (item) => item.itemType == FollowUpItemType.unansweredQuestion,
        ).toList();

        expect(questions, isNotEmpty);
      });

      test('identifies "when" questions', () async {
        await followUpService.extractFollowUps('test-conv-when');
        
        final items = await followUpService.getConversationFollowUps('test-conv-when');
        final questions = items.where(
          (item) => item.itemType == FollowUpItemType.unansweredQuestion,
        ).toList();

        if (questions.isNotEmpty) {
          expect(questions.first.description, contains('when'));
        }
      });

      test('identifies "what" questions', () async {
        await followUpService.extractFollowUps('test-conv-what');
        
        final items = await followUpService.getConversationFollowUps('test-conv-what');
        expect(items, isNotEmpty);
      });

      test('does not flag answered questions', () async {
        // Conversation with question and answer
        await followUpService.extractFollowUps('test-conv-answered');
        
        final items = await followUpService.getConversationFollowUps('test-conv-answered');
        final unansweredQuestions = items.where(
          (item) => item.itemType == FollowUpItemType.unansweredQuestion,
        ).toList();

        // Should be empty if question was answered
        expect(unansweredQuestions.length, lessThanOrEqualTo(0));
      });
    });

    group('Follow-up Management', () {
      test('retrieves pending follow-ups', () async {
        final items = await followUpService.getPendingFollowUps();
        
        expect(items, isList);
        // All should be pending status
        for (final item in items) {
          expect(item.status, equals(FollowUpStatus.pending));
        }
      });

      test('retrieves follow-ups for specific conversation', () async {
        final items = await followUpService.getConversationFollowUps('test-conv-123');
        
        expect(items, isList);
        for (final item in items) {
          expect(item.conversationId, equals('test-conv-123'));
        }
      });

      test('completes follow-up item', () async {
        final items = await followUpService.getPendingFollowUps();
        if (items.isNotEmpty) {
          final item = items.first;
          
          await followUpService.completeFollowUp(item.id);
          
          // Verify it's no longer in pending list
          final updatedItems = await followUpService.getPendingFollowUps();
          expect(
            updatedItems.any((i) => i.id == item.id),
            isFalse,
          );
        }
      });

      test('snoozes follow-up item', () async {
        final items = await followUpService.getPendingFollowUps();
        if (items.isNotEmpty) {
          final item = items.first;
          
          await followUpService.snoozeFollowUp(
            item.id,
            const Duration(hours: 1),
          );
          
          // Verify it's snoozed
          final updatedItems = await followUpService.getPendingFollowUps();
          expect(
            updatedItems.any((i) => i.id == item.id),
            isFalse,
          );
        }
      });

      test('dismisses follow-up item', () async {
        final items = await followUpService.getPendingFollowUps();
        if (items.isNotEmpty) {
          final item = items.first;
          
          await followUpService.dismissFollowUp(item.id);
          
          // Verify it's dismissed
          final updatedItems = await followUpService.getPendingFollowUps();
          expect(
            updatedItems.any((i) => i.id == item.id),
            isFalse,
          );
        }
      });
    });

    group('Follow-up Item Properties', () {
      test('identifies overdue items', () async {
        final items = await followUpService.getPendingFollowUps();
        
        // Check if any items have proper overdue detection
        for (final item in items) {
          if (item.dueAt != null) {
            final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
            final isOverdue = now > item.dueAt!;
            expect(item.isOverdue, equals(isOverdue));
          }
        }
      });

      test('identifies due soon items', () async {
        final items = await followUpService.getPendingFollowUps();
        
        for (final item in items) {
          if (item.dueAt != null) {
            final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
            final hoursUntilDue = (item.dueAt! - now) / 3600;
            final isDueSoon = hoursUntilDue > 0 && hoursUntilDue <= 24;
            expect(item.isDueSoon, equals(isDueSoon));
          }
        }
      });

      test('calculates time until due correctly', () async {
        final items = await followUpService.getPendingFollowUps();
        
        for (final item in items) {
          if (item.dueAt != null) {
            final timeStr = item.getTimeUntilDue();
            expect(timeStr, isNotEmpty);
            
            if (item.isOverdue) {
              expect(timeStr, equals('Overdue'));
            } else {
              expect(timeStr, matches(RegExp(r'\d+[mhd]')));
            }
          }
        }
      });

      test('calculates time since detected correctly', () async {
        final items = await followUpService.getPendingFollowUps();
        
        for (final item in items) {
          final timeStr = item.getTimeSinceDetected();
          expect(timeStr, isNotEmpty);
          expect(timeStr, contains('ago'));
        }
      });
    });

    group('Priority and Sorting', () {
      test('assigns priority to follow-ups', () async {
        final items = await followUpService.getPendingFollowUps();
        
        for (final item in items) {
          expect(item.priority, greaterThanOrEqualTo(0));
          expect(item.priority, lessThanOrEqualTo(100));
        }
      });

      test('overdue items have high priority', () async {
        final items = await followUpService.getPendingFollowUps();
        final overdueItems = items.where((item) => item.isOverdue).toList();
        
        for (final item in overdueItems) {
          expect(item.priority, greaterThan(60));
        }
      });
    });

    group('Comprehensive Follow-up System', () {
      test('handles conversation with multiple follow-up types', () async {
        // Conversation with: action item, question, and pending response
        await followUpService.extractFollowUps('test-conv-mixed');
        
        final items = await followUpService.getConversationFollowUps('test-conv-mixed');
        
        expect(items, isNotEmpty);
        
        // Should have different types
        final types = items.map((item) => item.itemType).toSet();
        expect(types.length, greaterThanOrEqualTo(1));
      });

      test('prevents duplicate extraction', () async {
        // Extract twice
        await followUpService.extractFollowUps('test-conv-duplicate');
        await followUpService.extractFollowUps('test-conv-duplicate');
        
        final items = await followUpService.getConversationFollowUps('test-conv-duplicate');
        
        // Should not have duplicates (check by unique IDs)
        final ids = items.map((item) => item.id).toList();
        expect(ids.length, equals(ids.toSet().length));
      });

      test('handles empty conversation', () async {
        await followUpService.extractFollowUps('empty-conv');
        
        final items = await followUpService.getConversationFollowUps('empty-conv');
        
        expect(items, isEmpty);
      });

      test('handles conversation with no follow-ups', () async {
        // Conversation with only statements, no questions or commitments
        await followUpService.extractFollowUps('test-conv-no-followups');
        
        final items = await followUpService.getConversationFollowUps('test-conv-no-followups');
        
        expect(items.length, lessThanOrEqualTo(0));
      });
    });
  });
}
</file>

<file path="frontend/lib/core/env.dart">
/// Environment configuration for Supabase connection.
/// 
/// Reads SUPABASE_URL and SUPABASE_ANON_KEY from:
/// 1. Dart defines (via --dart-define-from-file=.env.dev.json)
/// 2. Environment variables as fallback

class Env {
  static const String supabaseUrl = String.fromEnvironment(
    'SUPABASE_URL',
    defaultValue: 'https://your-project.supabase.co',
  );

  static const String supabaseAnonKey = String.fromEnvironment(
    'SUPABASE_ANON_KEY',
    defaultValue: 'your-anon-key',
  );

  // Validate that required config is present
  static void validate() {
    assert(
      supabaseUrl != 'https://your-project.supabase.co',
      'SUPABASE_URL not configured',
    );
    assert(
      supabaseAnonKey != 'your-anon-key',
      'SUPABASE_ANON_KEY not configured',
    );
  }
}
</file>

<file path="frontend/lib/core/errors/app_error.dart">
/// Application error types and models
/// Provides structured error handling across the app

/// Error categories for classification
enum ErrorCategory {
  auth,
  network,
  database,
  messaging,
  storage,
  permission,
  validation,
  unknown,
}

/// Error severity levels
enum ErrorSeverity {
  info,     // Informational, no action required
  warning,  // Warning, user should be aware
  error,    // Error, user action may help
  critical, // Critical, likely requires app restart or support
}

/// Structured application error
class AppError implements Exception {
  final ErrorCategory category;
  final ErrorSeverity severity;
  final String code;
  final String message;
  final String? userMessage;
  final dynamic originalError;
  final StackTrace? stackTrace;
  final Map<String, dynamic>? context;
  final bool isRetryable;

  const AppError({
    required this.category,
    required this.severity,
    required this.code,
    required this.message,
    this.userMessage,
    this.originalError,
    this.stackTrace,
    this.context,
    this.isRetryable = false,
  });

  /// Get user-friendly error message
  String get displayMessage => userMessage ?? message;

  /// Check if error requires user action
  bool get requiresUserAction => 
      severity == ErrorSeverity.error || 
      severity == ErrorSeverity.critical;

  @override
  String toString() {
    return 'AppError($category.$code): $message';
  }

  /// Copy with modifications
  AppError copyWith({
    ErrorCategory? category,
    ErrorSeverity? severity,
    String? code,
    String? message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    Map<String, dynamic>? context,
    bool? isRetryable,
  }) {
    return AppError(
      category: category ?? this.category,
      severity: severity ?? this.severity,
      code: code ?? this.code,
      message: message ?? this.message,
      userMessage: userMessage ?? this.userMessage,
      originalError: originalError ?? this.originalError,
      stackTrace: stackTrace ?? this.stackTrace,
      context: context ?? this.context,
      isRetryable: isRetryable ?? this.isRetryable,
    );
  }
}

/// Authentication errors
class AuthError extends AppError {
  AuthError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = false,
  }) : super(
          category: ErrorCategory.auth,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory AuthError.invalidCredentials() => AuthError(
        code: 'AUTH001',
        message: 'Invalid email or password',
        userMessage: 'The email or password you entered is incorrect. Please try again.',
      );

  factory AuthError.emailAlreadyExists() => AuthError(
        code: 'AUTH002',
        message: 'Email already registered',
        userMessage: 'An account with this email already exists. Try signing in instead.',
      );

  factory AuthError.weakPassword() => AuthError(
        code: 'AUTH003',
        message: 'Password too weak',
        userMessage: 'Please choose a stronger password (at least 6 characters).',
      );

  factory AuthError.invalidEmail() => AuthError(
        code: 'AUTH004',
        message: 'Invalid email format',
        userMessage: 'Please enter a valid email address.',
      );

  factory AuthError.sessionExpired() => AuthError(
        code: 'AUTH005',
        message: 'Session expired',
        userMessage: 'Your session has expired. Please sign in again.',
      );

  factory AuthError.networkError() => AuthError(
        code: 'AUTH006',
        message: 'Network error during authentication',
        userMessage: 'Unable to connect. Please check your internet connection and try again.',
        isRetryable: true,
      );

  factory AuthError.unknown(dynamic error) => AuthError(
        code: 'AUTH999',
        message: 'Unknown authentication error',
        userMessage: 'Something went wrong during authentication. Please try again.',
        originalError: error,
        isRetryable: true,
      );
}

/// Network errors
class NetworkError extends AppError {
  NetworkError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
  }) : super(
          category: ErrorCategory.network,
          severity: ErrorSeverity.warning,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: true,
        );

  factory NetworkError.noConnection() => NetworkError(
        code: 'NET001',
        message: 'No internet connection',
        userMessage: 'No internet connection. Please check your network settings.',
      );

  factory NetworkError.timeout() => NetworkError(
        code: 'NET002',
        message: 'Request timeout',
        userMessage: 'The request took too long. Please try again.',
      );

  factory NetworkError.serverError() => NetworkError(
        code: 'NET003',
        message: 'Server error',
        userMessage: 'Server is temporarily unavailable. Please try again later.',
      );
}

/// Message sending errors
class MessageError extends AppError {
  MessageError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = true,
  }) : super(
          category: ErrorCategory.messaging,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory MessageError.sendFailed() => MessageError(
        code: 'MSG001',
        message: 'Failed to send message',
        userMessage: 'Unable to send message. Please try again.',
      );

  factory MessageError.networkError() => MessageError(
        code: 'MSG002',
        message: 'Network error while sending message',
        userMessage: 'Message saved offline. It will send when you\'re back online.',
      );

  factory MessageError.unauthorized() => MessageError(
        code: 'MSG003',
        message: 'Not authorized to send message',
        userMessage: 'You don\'t have permission to send messages to this conversation.',
        isRetryable: false,
      );

  factory MessageError.conversationNotFound() => MessageError(
        code: 'MSG004',
        message: 'Conversation not found',
        userMessage: 'This conversation no longer exists.',
        isRetryable: false,
      );

  factory MessageError.mediaTooLarge() => MessageError(
        code: 'MSG005',
        message: 'Media file too large',
        userMessage: 'The image is too large. Please choose a smaller file.',
        isRetryable: false,
      );

  factory MessageError.mediaUploadFailed() => MessageError(
        code: 'MSG006',
        message: 'Failed to upload media',
        userMessage: 'Unable to upload image. Please try again.',
      );
}

/// Storage errors
class StorageError extends AppError {
  StorageError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = true,
  }) : super(
          category: ErrorCategory.storage,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory StorageError.uploadFailed() => StorageError(
        code: 'STR001',
        message: 'Upload failed',
        userMessage: 'Unable to upload file. Please try again.',
      );

  factory StorageError.fileTooLarge() => StorageError(
        code: 'STR002',
        message: 'File too large',
        userMessage: 'The file is too large. Maximum size is 10MB.',
        isRetryable: false,
      );

  factory StorageError.unsupportedFormat() => StorageError(
        code: 'STR003',
        message: 'Unsupported file format',
        userMessage: 'This file type is not supported. Please use JPG, PNG, or GIF.',
        isRetryable: false,
      );
}

/// Database errors
class DatabaseError extends AppError {
  DatabaseError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = true,
  }) : super(
          category: ErrorCategory.database,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory DatabaseError.queryFailed() => DatabaseError(
        code: 'DB001',
        message: 'Database query failed',
        userMessage: 'Unable to fetch data. Please try again.',
      );

  factory DatabaseError.syncFailed() => DatabaseError(
        code: 'DB002',
        message: 'Sync failed',
        userMessage: 'Unable to sync data. Your changes are saved locally.',
      );
}

/// Permission errors
class PermissionError extends AppError {
  PermissionError({
    required String code,
    required String message,
    String? userMessage,
    bool isRetryable = false,
  }) : super(
          category: ErrorCategory.permission,
          severity: ErrorSeverity.warning,
          code: code,
          message: message,
          userMessage: userMessage,
          isRetryable: isRetryable,
        );

  factory PermissionError.cameraNotGranted() => PermissionError(
        code: 'PERM001',
        message: 'Camera permission not granted',
        userMessage: 'Camera access is required. Please enable it in Settings.',
      );

  factory PermissionError.storageNotGranted() => PermissionError(
        code: 'PERM002',
        message: 'Storage permission not granted',
        userMessage: 'Storage access is required. Please enable it in Settings.',
      );

  factory PermissionError.notificationsNotGranted() => PermissionError(
        code: 'PERM003',
        message: 'Notification permission not granted',
        userMessage: 'Enable notifications to receive message alerts.',
      );
}
</file>

<file path="frontend/lib/core/errors/error_handler.dart">
import 'package:messageai/core/errors/app_error.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

/// Global error handler service
class ErrorHandler {
  static final ErrorHandler _instance = ErrorHandler._internal();

  factory ErrorHandler() {
    return _instance;
  }

  ErrorHandler._internal();

  /// Convert any error to AppError
  AppError handleError(dynamic error, {StackTrace? stackTrace, String? context}) {
    AppError appError;

    if (error is AppError) {
      appError = error;
    } else if (error is AuthException) {
      appError = _handleAuthException(error);
    } else if (error is PostgrestException) {
      appError = _handlePostgrestException(error);
    } else if (error is StorageException) {
      appError = _handleStorageException(error);
    } else if (error is String) {
      appError = _handleStringError(error);
    } else {
      appError = _handleUnknownError(error);
    }

    // Log error
    _logError(appError, stackTrace, context);

    return appError;
  }

  /// Handle Supabase Auth exceptions
  AppError _handleAuthException(AuthException error) {
    final message = error.message.toLowerCase();

    if (message.contains('invalid login credentials') ||
        message.contains('invalid email or password')) {
      return AuthError.invalidCredentials();
    } else if (message.contains('already registered') ||
               message.contains('already been registered')) {
      return AuthError.emailAlreadyExists();
    } else if (message.contains('password') && message.contains('weak')) {
      return AuthError.weakPassword();
    } else if (message.contains('invalid email')) {
      return AuthError.invalidEmail();
    } else if (message.contains('session') && 
               (message.contains('expired') || message.contains('invalid'))) {
      return AuthError.sessionExpired();
    } else if (message.contains('network') || 
               message.contains('connection') ||
               message.contains('timeout')) {
      return AuthError.networkError();
    } else {
      return AuthError.unknown(error);
    }
  }

  /// Handle Supabase Postgrest (database) exceptions
  AppError _handlePostgrestException(PostgrestException error) {
    final message = error.message.toLowerCase();
    final code = error.code ?? '';

    // RLS policy violations
    if (code.contains('42501') || message.contains('permission denied')) {
      return MessageError.unauthorized();
    }

    // Foreign key violations
    if (code.contains('23503') || message.contains('foreign key')) {
      return MessageError.conversationNotFound();
    }

    // Network errors
    if (message.contains('network') || 
        message.contains('timeout') ||
        message.contains('connection')) {
      return NetworkError.noConnection();
    }

    // Server errors
    if (code.startsWith('5')) {
      return NetworkError.serverError();
    }

    // Generic database error
    return DatabaseError.queryFailed();
  }

  /// Handle Supabase Storage exceptions
  AppError _handleStorageException(StorageException error) {
    final message = error.message.toLowerCase();

    if (message.contains('size') || message.contains('too large')) {
      return StorageError.fileTooLarge();
    } else if (message.contains('format') || 
               message.contains('type') ||
               message.contains('invalid file')) {
      return StorageError.unsupportedFormat();
    } else {
      return StorageError.uploadFailed();
    }
  }

  /// Handle string errors (thrown as strings)
  AppError _handleStringError(String error) {
    final message = error.toLowerCase();

    // Auth errors
    if (message.contains('sign in') || message.contains('sign up')) {
      if (message.contains('failed')) {
        return AuthError.unknown(error);
      }
    }

    // Message errors
    if (message.contains('message')) {
      if (message.contains('failed') || message.contains('error')) {
        return MessageError.sendFailed();
      }
    }

    // Network errors
    if (message.contains('network') || 
        message.contains('connection') ||
        message.contains('offline') ||
        message.contains('internet')) {
      return NetworkError.noConnection();
    }

    // Generic error
    return AppError(
      category: ErrorCategory.unknown,
      severity: ErrorSeverity.error,
      code: 'UNK001',
      message: error,
      userMessage: 'Something went wrong. Please try again.',
      isRetryable: true,
    );
  }

  /// Handle unknown errors
  AppError _handleUnknownError(dynamic error) {
    return AppError(
      category: ErrorCategory.unknown,
      severity: ErrorSeverity.error,
      code: 'UNK999',
      message: error.toString(),
      userMessage: 'An unexpected error occurred. Please try again.',
      originalError: error,
      isRetryable: true,
    );
  }

  /// Log error for debugging
  void _logError(AppError error, StackTrace? stackTrace, String? context) {
    // Only log critical errors and non-retryable errors
    if (error.severity == ErrorSeverity.critical || !error.isRetryable) {
      final emoji = _getEmojiForSeverity(error.severity);
      print('$emoji ${error.code}: ${error.userMessage ?? error.message}');
    }
  }

  /// Get emoji for severity level
  String _getEmojiForSeverity(ErrorSeverity severity) {
    switch (severity) {
      case ErrorSeverity.info:
        return '‚ÑπÔ∏è';
      case ErrorSeverity.warning:
        return '‚ö†Ô∏è';
      case ErrorSeverity.error:
        return '‚ùå';
      case ErrorSeverity.critical:
        return 'üö®';
    }
  }

  /// Check if error is network-related
  bool isNetworkError(AppError error) {
    return error.category == ErrorCategory.network ||
           (error.category == ErrorCategory.auth && error.code == 'AUTH006') ||
           (error.category == ErrorCategory.messaging && error.code == 'MSG002');
  }

  /// Check if error should trigger offline mode
  bool shouldGoOffline(AppError error) {
    return error.category == ErrorCategory.network &&
           error.code == 'NET001';
  }

  /// Get retry delay based on attempt number (exponential backoff)
  Duration getRetryDelay(int attemptNumber) {
    // Exponential backoff: 1s, 2s, 4s, 8s, 16s
    final delaySeconds = (1 << (attemptNumber - 1)).clamp(1, 16);
    return Duration(seconds: delaySeconds);
  }

  /// Check if should retry based on attempt count
  bool shouldRetry(AppError error, int attemptNumber, {int maxAttempts = 3}) {
    return error.isRetryable && attemptNumber < maxAttempts;
  }
}

/// Extension to add error handling to Future
extension FutureErrorHandler<T> on Future<T> {
  /// Handle errors and convert to AppError
  Future<T> handleAppError({String? context}) async {
    try {
      return await this;
    } catch (error, stackTrace) {
      throw ErrorHandler().handleError(error, stackTrace: stackTrace, context: context);
    }
  }
}
</file>

<file path="frontend/lib/core/errors/error_ui.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/errors/app_error.dart';

/// UI utilities for displaying errors to users
class ErrorUI {
  /// Show error as snackbar (for non-critical errors)
  static void showErrorSnackbar(
    BuildContext context,
    AppError error, {
    VoidCallback? onRetry,
  }) {
    final snackBar = SnackBar(
      content: Row(
        children: [
          Icon(
            _getIconForError(error),
            color: Colors.white,
            size: 20,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              error.displayMessage,
              style: const TextStyle(fontSize: 14),
            ),
          ),
        ],
      ),
      backgroundColor: _getColorForSeverity(error.severity),
      behavior: SnackBarBehavior.floating,
      action: error.isRetryable && onRetry != null
          ? SnackBarAction(
              label: 'Retry',
              textColor: Colors.white,
              onPressed: onRetry,
            )
          : null,
      duration: Duration(
        seconds: error.severity == ErrorSeverity.critical ? 6 : 4,
      ),
    );

    ScaffoldMessenger.of(context)
      ..hideCurrentSnackBar()
      ..showSnackBar(snackBar);
  }

  /// Show error as dialog (for critical errors or when user action required)
  static Future<bool?> showErrorDialog(
    BuildContext context,
    AppError error, {
    VoidCallback? onRetry,
    String? actionLabel,
  }) {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        icon: Icon(
          _getIconForError(error),
          color: _getColorForSeverity(error.severity),
          size: 48,
        ),
        title: Text(_getTitleForError(error)),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(error.displayMessage),
            if (error.code.isNotEmpty) ...[
              const SizedBox(height: 16),
              Text(
                'Error Code: ${error.code}',
                style: TextStyle(
                  fontSize: 12,
                  color: Colors.grey[600],
                ),
              ),
            ],
          ],
        ),
        actions: [
          if (!error.requiresUserAction)
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Dismiss'),
            ),
          if (error.isRetryable && onRetry != null)
            FilledButton(
              onPressed: () {
                Navigator.of(context).pop(true);
                onRetry();
              },
              child: Text(actionLabel ?? 'Retry'),
            ),
          if (!error.isRetryable || onRetry == null)
            FilledButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('OK'),
            ),
        ],
      ),
    );
  }

  /// Show permission error with option to open settings
  static Future<void> showPermissionError(
    BuildContext context,
    PermissionError error,
  ) {
    return showDialog(
      context: context,
      builder: (context) => AlertDialog(
        icon: const Icon(
          Icons.security,
          color: Colors.orange,
          size: 48,
        ),
        title: const Text('Permission Required'),
        content: Text(error.displayMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              Navigator.of(context).pop();
              // TODO: Open app settings
              // OpenSettings.openAppSettings();
            },
            child: const Text('Open Settings'),
          ),
        ],
      ),
    );
  }

  /// Show loading indicator with cancellation
  static Future<T?> showLoadingDialog<T>(
    BuildContext context, {
    required Future<T> Function() action,
    String message = 'Loading...',
  }) async {
    // Show loading dialog
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        content: Row(
          children: [
            const CircularProgressIndicator(),
            const SizedBox(width: 24),
            Text(message),
          ],
        ),
      ),
    );

    try {
      final result = await action();
      if (context.mounted) {
        Navigator.of(context).pop();
      }
      return result;
    } catch (error) {
      if (context.mounted) {
        Navigator.of(context).pop();
        if (error is AppError) {
          showErrorDialog(context, error);
        }
      }
      return null;
    }
  }

  /// Get icon for error
  static IconData _getIconForError(AppError error) {
    switch (error.category) {
      case ErrorCategory.auth:
        return Icons.lock_outline;
      case ErrorCategory.network:
        return Icons.wifi_off;
      case ErrorCategory.database:
        return Icons.storage_outlined;
      case ErrorCategory.messaging:
        return Icons.message_outlined;
      case ErrorCategory.storage:
        return Icons.cloud_upload_outlined;
      case ErrorCategory.permission:
        return Icons.security;
      case ErrorCategory.validation:
        return Icons.error_outline;
      case ErrorCategory.unknown:
        return Icons.warning_amber;
    }
  }

  /// Get color for severity
  static Color _getColorForSeverity(ErrorSeverity severity) {
    switch (severity) {
      case ErrorSeverity.info:
        return Colors.blue;
      case ErrorSeverity.warning:
        return Colors.orange;
      case ErrorSeverity.error:
        return Colors.red;
      case ErrorSeverity.critical:
        return Colors.red.shade900;
    }
  }

  /// Get title for error dialog
  static String _getTitleForError(AppError error) {
    switch (error.category) {
      case ErrorCategory.auth:
        return 'Authentication Error';
      case ErrorCategory.network:
        return 'Connection Problem';
      case ErrorCategory.database:
        return 'Data Error';
      case ErrorCategory.messaging:
        return 'Message Error';
      case ErrorCategory.storage:
        return 'Upload Error';
      case ErrorCategory.permission:
        return 'Permission Required';
      case ErrorCategory.validation:
        return 'Invalid Input';
      case ErrorCategory.unknown:
        return 'Error';
    }
  }
}

/// Mixin for widgets that need error handling
mixin ErrorHandlerMixin<T extends StatefulWidget> on State<T> {
  /// Show error to user
  void showError(AppError error, {VoidCallback? onRetry}) {
    if (!mounted) return;

    if (error.severity == ErrorSeverity.critical || error.requiresUserAction) {
      ErrorUI.showErrorDialog(context, error, onRetry: onRetry);
    } else {
      ErrorUI.showErrorSnackbar(context, error, onRetry: onRetry);
    }
  }

  /// Handle error from async operation
  Future<T?> handleAsyncError<T>(
    Future<T> Function() operation, {
    String? context,
    VoidCallback? onRetry,
  }) async {
    try {
      return await operation();
    } on AppError catch (error) {
      showError(error, onRetry: onRetry);
      return null;
    } catch (error) {
      final appError = AppError(
        category: ErrorCategory.unknown,
        severity: ErrorSeverity.error,
        code: 'UNK001',
        message: error.toString(),
        userMessage: 'An unexpected error occurred.',
      );
      showError(appError, onRetry: onRetry);
      return null;
    }
  }
}
</file>

<file path="frontend/lib/core/theme/app_theme.dart">
import 'package:flutter/material.dart';

/// MessageAI Theme System
/// Monochrome black/white/gray palette for clean, accessible design
class AppTheme {
  // Prevent instantiation
  AppTheme._();

  // ============================================================================
  // COLORS - Grayscale System
  // ============================================================================
  
  /// Pure colors
  static const Color white = Color(0xFFFFFFFF);
  static const Color black = Color(0xFF000000);
  
  /// Gray scale (Light Mode)
  static const Color gray50 = Color(0xFFFAFAFA);   // Almost white
  static const Color gray100 = Color(0xFFF5F5F5);  // Off white
  static const Color gray200 = Color(0xFFEEEEEE);  // Very light gray
  static const Color gray300 = Color(0xFFE0E0E0);  // Light gray
  static const Color gray400 = Color(0xFFBDBDBD);  // Light-medium gray
  static const Color gray500 = Color(0xFF9E9E9E);  // Medium gray
  static const Color gray600 = Color(0xFF757575);  // Medium-dark gray
  static const Color gray700 = Color(0xFF616161);  // Dark gray
  static const Color gray800 = Color(0xFF424242);  // Very dark gray
  static const Color gray900 = Color(0xFF212121);  // Almost black
  
  /// Dark mode grays
  static const Color darkGray100 = Color(0xFF1A1A1A);  // Near black surface
  static const Color darkGray200 = Color(0xFF242424);  // Dark surface
  static const Color darkGray300 = Color(0xFF2E2E2E);  // Medium dark
  static const Color darkGray400 = Color(0xFF3A3A3A);  // Lighter dark
  
  /// Accent colors (minimal use only)
  static const Color accentBlue = Color(0xFF000000);     // Actions, links
  static const Color accentGreen = Color(0xFF4CAF50);    // Online, success
  static const Color accentRed = Color(0xFFF44336);      // Error, urgent
  static const Color accentOrange = Color(0xFFFF9800);   // Warning
  
  // ============================================================================
  // TYPOGRAPHY
  // ============================================================================
  
  /// Font sizes
  static const double fontSizeXXL = 32.0;  // Page titles
  static const double fontSizeXL = 24.0;   // Section headers
  static const double fontSizeL = 20.0;    // Card titles
  static const double fontSizeM = 16.0;    // Body text (BASE)
  static const double fontSizeS = 14.0;    // Captions
  static const double fontSizeXS = 12.0;   // Timestamps
  static const double fontSizeXXS = 10.0;  // Micro-copy
  
  /// Font weights
  static const FontWeight fontWeightLight = FontWeight.w300;
  static const FontWeight fontWeightRegular = FontWeight.w400;
  static const FontWeight fontWeightMedium = FontWeight.w500;
  static const FontWeight fontWeightSemibold = FontWeight.w600;
  static const FontWeight fontWeightBold = FontWeight.w700;
  
  /// Line heights
  static const double lineHeightTight = 1.2;
  static const double lineHeightNormal = 1.5;
  static const double lineHeightRelaxed = 1.75;
  
  // ============================================================================
  // SPACING
  // ============================================================================
  
  /// Base unit: 4px - all spacing uses multiples of this
  static const double spacingXXS = 4.0;
  static const double spacingXS = 8.0;
  static const double spacingS = 12.0;
  static const double spacingM = 16.0;   // Standard spacing (BASE)
  static const double spacingL = 24.0;
  static const double spacingXL = 32.0;
  static const double spacingXXL = 48.0;
  static const double spacingXXXL = 64.0;
  
  // ============================================================================
  // BORDER RADIUS
  // ============================================================================
  
  static const double radiusNone = 0.0;
  static const double radiusXS = 2.0;
  static const double radiusS = 4.0;
  static const double radiusM = 8.0;    // Standard radius (BASE)
  static const double radiusL = 12.0;
  static const double radiusXL = 16.0;
  static const double radiusXXL = 24.0;
  static const double radiusPill = 9999.0;
  
  // ============================================================================
  // SHADOWS
  // ============================================================================
  
  /// Light mode shadows
  static List<BoxShadow> get shadow1Light => [
    BoxShadow(
      color: black.withOpacity(0.12),
      blurRadius: 3,
      offset: const Offset(0, 1),
    ),
    BoxShadow(
      color: black.withOpacity(0.08),
      blurRadius: 2,
      offset: const Offset(0, 1),
    ),
  ];
  
  static List<BoxShadow> get shadow2Light => [
    BoxShadow(
      color: black.withOpacity(0.12),
      blurRadius: 6,
      offset: const Offset(0, 2),
    ),
    BoxShadow(
      color: black.withOpacity(0.08),
      blurRadius: 4,
      offset: const Offset(0, 2),
    ),
  ];
  
  static List<BoxShadow> get shadow3Light => [
    BoxShadow(
      color: black.withOpacity(0.15),
      blurRadius: 12,
      offset: const Offset(0, 4),
    ),
    BoxShadow(
      color: black.withOpacity(0.10),
      blurRadius: 6,
      offset: const Offset(0, 2),
    ),
  ];
  
  /// Dark mode shadows (more subtle)
  static List<BoxShadow> get shadow1Dark => [
    BoxShadow(
      color: black.withOpacity(0.30),
      blurRadius: 3,
      offset: const Offset(0, 1),
    ),
    BoxShadow(
      color: black.withOpacity(0.20),
      blurRadius: 2,
      offset: const Offset(0, 1),
    ),
  ];
  
  static List<BoxShadow> get shadow2Dark => [
    BoxShadow(
      color: black.withOpacity(0.35),
      blurRadius: 6,
      offset: const Offset(0, 2),
    ),
    BoxShadow(
      color: black.withOpacity(0.25),
      blurRadius: 4,
      offset: const Offset(0, 2),
    ),
  ];
  
  // ============================================================================
  // THEME DATA
  // ============================================================================
  
  /// Light theme configuration
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      
      // Color scheme
      colorScheme: const ColorScheme.light(
        primary: accentBlue,
        onPrimary: white,
        secondary: gray900,
        onSecondary: white,
        surface: white,
        onSurface: black,
        surfaceContainerHighest: gray100,
        error: accentRed,
        onError: white,
      ),
      
      // Scaffold
      scaffoldBackgroundColor: white,
      
      // App bar
      appBarTheme: const AppBarTheme(
        backgroundColor: white,
        foregroundColor: black,
        elevation: 0,
        centerTitle: false,
        titleTextStyle: TextStyle(
          color: black,
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
        ),
        iconTheme: IconThemeData(
          color: black,
          size: 24,
        ),
      ),
      
      // Cards
      cardTheme: CardThemeData(
        color: white,
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radiusM),
          side: const BorderSide(color: gray300, width: 1),
        ),
        margin: const EdgeInsets.all(spacingS),
      ),
      
      // Text theme
      textTheme: const TextTheme(
        displayLarge: TextStyle(
          fontSize: fontSizeXXL,
          fontWeight: fontWeightBold,
          color: black,
          height: lineHeightTight,
        ),
        displayMedium: TextStyle(
          fontSize: fontSizeXL,
          fontWeight: fontWeightBold,
          color: black,
          height: lineHeightTight,
        ),
        displaySmall: TextStyle(
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
          color: black,
          height: lineHeightTight,
        ),
        bodyLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightRegular,
          color: black,
          height: lineHeightNormal,
        ),
        bodyMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightRegular,
          color: gray800,
          height: lineHeightNormal,
        ),
        bodySmall: TextStyle(
          fontSize: fontSizeXS,
          fontWeight: fontWeightRegular,
          color: gray600,
          height: lineHeightNormal,
        ),
        labelLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightSemibold,
          color: black,
        ),
        labelMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightMedium,
          color: black,
        ),
      ),
      
      // Buttons
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: accentBlue,
          foregroundColor: white,
          elevation: 0,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingL,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: accentBlue,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingM,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      // FAB
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: black,
        foregroundColor: white,
        elevation: 4,
        shape: CircleBorder(),
      ),
      
      // Input decoration
      inputDecorationTheme: InputDecorationTheme(
        filled: false,
        fillColor: white,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: gray300, width: 1),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: gray300, width: 1),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentBlue, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentRed, width: 1),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: spacingM,
          vertical: spacingS,
        ),
        hintStyle: const TextStyle(color: gray500),
      ),
      
      // Divider
      dividerTheme: const DividerThemeData(
        color: gray300,
        thickness: 1,
        space: 1,
      ),
      
      // Icon theme
      iconTheme: const IconThemeData(
        color: black,
        size: 24,
      ),
    );
  }
  
  /// Dark theme configuration
  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      
      // Color scheme
      colorScheme: const ColorScheme.dark(
        primary: accentBlue,
        onPrimary: black,
        secondary: white,
        onSecondary: black,
        surface: black,
        onSurface: white,
        surfaceContainerHighest: darkGray100,
        error: accentRed,
        onError: black,
      ),
      
      // Scaffold
      scaffoldBackgroundColor: black,
      
      // App bar
      appBarTheme: const AppBarTheme(
        backgroundColor: black,
        foregroundColor: white,
        elevation: 0,
        centerTitle: false,
        titleTextStyle: TextStyle(
          color: white,
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
        ),
        iconTheme: IconThemeData(
          color: white,
          size: 24,
        ),
      ),
      
      // Cards
      cardTheme: CardThemeData(
        color: darkGray100,
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radiusM),
          side: const BorderSide(color: darkGray300, width: 1),
        ),
        margin: const EdgeInsets.all(spacingS),
      ),
      
      // Text theme
      textTheme: const TextTheme(
        displayLarge: TextStyle(
          fontSize: fontSizeXXL,
          fontWeight: fontWeightBold,
          color: white,
          height: lineHeightTight,
        ),
        displayMedium: TextStyle(
          fontSize: fontSizeXL,
          fontWeight: fontWeightBold,
          color: white,
          height: lineHeightTight,
        ),
        displaySmall: TextStyle(
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
          color: white,
          height: lineHeightTight,
        ),
        bodyLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightRegular,
          color: white,
          height: lineHeightNormal,
        ),
        bodyMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightRegular,
          color: gray400,
          height: lineHeightNormal,
        ),
        bodySmall: TextStyle(
          fontSize: fontSizeXS,
          fontWeight: fontWeightRegular,
          color: gray500,
          height: lineHeightNormal,
        ),
        labelLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightSemibold,
          color: white,
        ),
        labelMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightMedium,
          color: white,
        ),
      ),
      
      // Buttons
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: white,
          foregroundColor: black,
          elevation: 0,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingL,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: accentBlue,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingM,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      // FAB
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: white,
        foregroundColor: black,
        elevation: 4,
        shape: CircleBorder(),
      ),
      
      // Input decoration
      inputDecorationTheme: InputDecorationTheme(
        filled: false,
        fillColor: darkGray100,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: darkGray300, width: 1),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: darkGray300, width: 1),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentBlue, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentRed, width: 1),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: spacingM,
          vertical: spacingS,
        ),
        hintStyle: const TextStyle(color: gray600),
      ),
      
      // Divider
      dividerTheme: const DividerThemeData(
        color: darkGray300,
        thickness: 1,
        space: 1,
      ),
      
      // Icon theme
      iconTheme: const IconThemeData(
        color: white,
        size: 24,
      ),
    );
  }
}
</file>

<file path="frontend/lib/data/repositories/group_repository.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/conversation_dao.dart';
import 'package:messageai/data/drift/daos/participant_dao.dart';
import 'package:uuid/uuid.dart';

/// Repository for group operations
class GroupRepository {
  final ConversationDao _conversationDao;
  final ParticipantDao _participantDao;

  GroupRepository({
    required ConversationDao conversationDao,
    required ParticipantDao participantDao,
  })  : _conversationDao = conversationDao,
        _participantDao = participantDao;

  /// Create a new group conversation
  Future<Conversation> createGroup({
    required String title,
    required String description,
    required String creatorId,
    required List<String> memberIds,
  }) async {
    const uuid = Uuid();
    final conversationId = uuid.v4();
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Create conversation
    final conversation = Conversation(
      id: conversationId,
      title: title,
      description: description,
      createdAt: now,
      updatedAt: now,
      isGroup: true,
      isSynced: false,
    );
    
    await _conversationDao.upsertConversation(conversation);
    
    // Add creator as admin
    final creatorParticipant = Participant(
      id: uuid.v4(),
      conversationId: conversationId,
      userId: creatorId,
      joinedAt: now,
      isAdmin: true,
      isSynced: false,
    );
    
    await _participantDao.addParticipant(creatorParticipant);
    
    // Add other members
    final participants = memberIds.map((userId) {
      return Participant(
        id: uuid.v4(),
        conversationId: conversationId,
        userId: userId,
        joinedAt: now,
        isAdmin: false,
        isSynced: false,
      );
    }).toList();
    
    await _participantDao.addParticipants(participants);
    
    return conversation;
  }

  /// Get group details with members
  Future<(Conversation, List<Participant>)> getGroupWithMembers(String groupId) async {
    final conversation = await _conversationDao.getConversationById(groupId);
    if (conversation == null) {
      throw Exception('Group not found: $groupId');
    }
    
    final participants = await _participantDao.getParticipantsByConversation(groupId);
    
    return (conversation, participants);
  }

  /// Update group info
  Future<void> updateGroupInfo({
    required String groupId,
    String? title,
    String? description,
  }) async {
    // This would require a Conversation update method in ConversationDao
    // For now, creating a placeholder
    // TODO: Implement in ConversationDao
  }

  /// Add member to group
  Future<void> addGroupMember({
    required String groupId,
    required String userId,
  }) async {
    const uuid = Uuid();
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Check if already a member
    final existing = await _participantDao.getParticipant(groupId, userId);
    if (existing != null) {
      throw Exception('User is already a member of this group');
    }
    
    final participant = Participant(
      id: uuid.v4(),
      conversationId: groupId,
      userId: userId,
      joinedAt: now,
      isAdmin: false,
      isSynced: false,
    );
    
    await _participantDao.addParticipant(participant);
  }

  /// Remove member from group
  Future<void> removeGroupMember({
    required String groupId,
    required String userId,
  }) async {
    await _participantDao.removeParticipant(groupId, userId);
  }

  /// Promote member to admin
  Future<void> promoteToAdmin({
    required String groupId,
    required String userId,
  }) async {
    final participant = await _participantDao.getParticipant(groupId, userId);
    if (participant == null) {
      throw Exception('Member not found in group');
    }
    
    await _participantDao.promoteToAdmin(participant.id);
  }

  /// Demote admin to member
  Future<void> demoteFromAdmin({
    required String groupId,
    required String userId,
  }) async {
    final participant = await _participantDao.getParticipant(groupId, userId);
    if (participant == null) {
      throw Exception('Member not found in group');
    }
    
    await _participantDao.demoteFromAdmin(participant.id);
  }

  /// Get user's groups
  Future<List<Conversation>> getUserGroups(String userId) async {
    final allConversations = await _conversationDao.getAllConversations();
    
    // Filter to only groups where user is a participant
    final userGroups = <Conversation>[];
    
    for (final conversation in allConversations) {
      if (conversation.isGroup) {
        final isParticipant = await _participantDao.isParticipant(
          conversation.id,
          userId,
        );
        if (isParticipant) {
          userGroups.add(conversation);
        }
      }
    }
    
    return userGroups;
  }

  /// Leave group
  Future<void> leaveGroup({
    required String groupId,
    required String userId,
  }) async {
    await _participantDao.removeParticipant(groupId, userId);
  }

  /// Delete group (admin only)
  Future<void> deleteGroup(String groupId) async {
    // Remove all participants
    await _participantDao.removeConversationParticipants(groupId);
    
    // Delete conversation
    await _conversationDao.deleteConversation(groupId);
  }

  /// Get group members count
  Future<int> getGroupMemberCount(String groupId) async {
    return _participantDao.getParticipantCount(groupId);
  }

  /// Check if user is group admin
  Future<bool> isUserGroupAdmin(String groupId, String userId) async {
    return _participantDao.isAdmin(groupId, userId);
  }
}
</file>

<file path="frontend/lib/data/repositories/message_repository.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/message_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';
import 'package:messageai/gen/api/clients/messages_api.dart';
import 'package:messageai/gen/api/models/message_payload.dart';

/// Repository for message operations combining API and local database
class MessageRepository {
  final MessagesApi _messagesApi;
  final MessageDao _messageDao;
  final PendingOutboxDao _outboxDao;

  MessageRepository({
    required MessagesApi messagesApi,
    required MessageDao messageDao,
    required PendingOutboxDao outboxDao,
  })  : _messagesApi = messagesApi,
        _messageDao = messageDao,
        _outboxDao = outboxDao;

  /// Send a message (optimistic - save locally first, sync later)
  Future<Message> sendMessage({
    required String id,
    required String conversationId,
    required String senderId,
    required String body,
    String? mediaUrl,
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Create message locally first (optimistic)
    final message = Message(
      id: id,
      conversationId: conversationId,
      senderId: senderId,
      body: body,
      mediaUrl: mediaUrl,
      createdAt: now,
      updatedAt: now,
      isSynced: false,
    );
    
    // Save to local DB
    await _messageDao.insertMessage(message);
    
    // Queue for sync
    await _outboxDao.addPendingOperation(
      id: '${id}_send',
      operation: 'send_message',
      payload: message.toJson().toString(),
      conversationId: conversationId,
    );
    
    return message;
  }

  /// Get messages for a conversation from local DB
  Future<List<Message>> getConversationMessages(String conversationId) async {
    return _messageDao.getMessagesByConversation(conversationId);
  }

  /// Get recent messages for a conversation (paginated)
  Future<List<Message>> getRecentMessages(String conversationId, {int limit = 50}) async {
    return _messageDao.getRecentMessages(conversationId, limit: limit);
  }

  /// Sync unsynced messages to server
  Future<void> syncUnsyncedMessages() async {
    final unsyncedMessages = await _messageDao.getUnsyncedMessages();
    
    for (final message in unsyncedMessages) {
      try {
        final payload = MessagePayload(
          id: message.id,
          conversationId: message.conversationId,
          body: message.body,
        );
        
        // Send to server
        await _messagesApi.send(payload);
        
        // Mark as synced locally
        await _messageDao.markMessageAsSynced(message.id);
        
        // Remove from outbox
        await _outboxDao.removePendingOperation('${message.id}_send');
      } catch (e) {
        // Log error and continue
        print('Error syncing message ${message.id}: $e');
      }
    }
  }

  /// Search messages in a conversation
  Future<List<Message>> searchMessages(String conversationId, String query) async {
    return _messageDao.searchMessages(conversationId, query);
  }

  /// Insert messages from server
  Future<void> insertServerMessages(List<Message> messages) async {
    await _messageDao.insertMessages(messages);
  }

  /// Update message from server
  Future<void> updateMessageFromServer(Message message) async {
    await _messageDao.upsertMessage(message);
  }

  /// Upsert message (helper)
  Future<void> upsertMessage(Message message) async {
    // This would be added to MessageDao
    await _messageDao.insertMessage(message);
  }

  /// Get pending message count (for UI)
  Future<int> getPendingMessageCount() async {
    return _messageDao.getUnsyncedMessageCount();
  }
}

extension on Message {
  Map<String, dynamic> toJson() => {
    'id': id,
    'conversation_id': conversationId,
    'sender_id': senderId,
    'body': body,
    'media_url': mediaUrl,
    'created_at': createdAt,
    'updated_at': updatedAt,
    'is_synced': isSynced,
  };
}
</file>

<file path="frontend/lib/data/repositories/receipt_repository.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';
import 'package:messageai/gen/api/clients/receipts_api.dart';
import 'package:messageai/gen/api/models/receipt_payload.dart';

/// Repository for receipt operations combining API and local database
class ReceiptRepository {
  final ReceiptsApi _receiptsApi;
  final ReceiptDao _receiptDao;
  final PendingOutboxDao _outboxDao;

  ReceiptRepository({
    required ReceiptsApi receiptsApi,
    required ReceiptDao receiptDao,
    required PendingOutboxDao outboxDao,
  })  : _receiptsApi = receiptsApi,
        _receiptDao = receiptDao,
        _outboxDao = outboxDao;

  /// Acknowledge message receipts (optimistic)
  Future<void> acknowledgeReceipts({
    required List<String> messageIds,
    required String status, // 'delivered' or 'read'
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Save receipts locally first
    final receipts = messageIds.map((msgId) {
      return Receipt(
        id: '${msgId}_${status}_$now',
        messageId: msgId,
        userId: '', // Would be current user ID
        status: status,
        createdAt: now,
        updatedAt: now,
        isSynced: false,
      );
    }).toList();
    
    await _receiptDao.addReceipts(receipts);
    
    // Queue for sync
    await _outboxDao.addPendingOperation(
      id: 'ack_${status}_$now',
      operation: 'ack_receipt',
      payload: ReceiptPayload(
        messageIds: messageIds,
        status: status == 'delivered' ? ReceiptStatus.delivered : ReceiptStatus.read,
      ).toJson().toString(),
      conversationId: null,
    );
  }

  /// Get receipts for a message
  Future<List<Receipt>> getMessageReceipts(String messageId) async {
    return _receiptDao.getReceiptsByMessage(messageId);
  }

  /// Get read count for a message
  Future<int> getReadCount(String messageId) async {
    return _receiptDao.getReadCount(messageId);
  }

  /// Get delivered count for a message
  Future<int> getDeliveredCount(String messageId) async {
    return _receiptDao.getDeliveredCount(messageId);
  }

  /// Check if message is read by all participants
  Future<bool> isReadByAll(String messageId, int participantCount) async {
    return _receiptDao.isReadByAll(messageId, participantCount);
  }

  /// Sync unsynced receipts to server
  Future<void> syncUnsyncedReceipts() async {
    final unsyncedReceipts = await _receiptDao.getUnsyncedReceipts();
    
    if (unsyncedReceipts.isEmpty) return;
    
    try {
      // Group by status
      final deliveredIds = unsyncedReceipts
          .where((r) => r.status == 'delivered')
          .map((r) => r.messageId)
          .toList();
      
      final readIds = unsyncedReceipts
          .where((r) => r.status == 'read')
          .map((r) => r.messageId)
          .toList();
      
      // Send to server
      if (deliveredIds.isNotEmpty) {
        final payload = ReceiptPayload(
          messageIds: deliveredIds,
          status: ReceiptStatus.delivered,
        );
        await _receiptsApi.ack(payload);
      }
      
      if (readIds.isNotEmpty) {
        final payload = ReceiptPayload(
          messageIds: readIds,
          status: ReceiptStatus.read,
        );
        await _receiptsApi.ack(payload);
      }
      
      // Mark as synced
      final allIds = unsyncedReceipts.map((r) => r.id).toList();
      await _receiptDao.markReceiptsAsSynced(allIds);
    } catch (e) {
      print('Error syncing receipts: $e');
    }
  }

  /// Insert receipts from server
  Future<void> insertServerReceipts(List<Receipt> receipts) async {
    await _receiptDao.addReceipts(receipts);
  }

  /// Get unsynced receipt count (for UI)
  Future<int> getUnsyncedReceiptCount() async {
    return _receiptDao.getUnsyncedReceiptCount();
  }
}

extension on ReceiptPayload {
  Map<String, dynamic> toJson() => {
    'message_ids': messageIds,
    'status': status.toValue(),
  };
}
</file>

<file path="frontend/lib/features/conversations/widgets/conversation_filter_chips.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/conversation_filter.dart';
import 'package:messageai/core/theme/app_theme.dart';

/// Collapsible filter button and expandable filter chips
class ConversationFilterChips extends StatefulWidget {
  final Set<ConversationFilter> activeFilters;
  final Function(ConversationFilter) onFilterToggled;
  final Map<ConversationFilter, int>? badgeCounts;
  
  const ConversationFilterChips({
    Key? key,
    required this.activeFilters,
    required this.onFilterToggled,
    this.badgeCounts,
  }) : super(key: key);

  @override
  State<ConversationFilterChips> createState() => _ConversationFilterChipsState();
}

class _ConversationFilterChipsState extends State<ConversationFilterChips> {
  bool _isExpanded = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    // Count active filters
    final activeCount = widget.activeFilters.isEmpty 
        ? 0 
        : widget.activeFilters.length;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        children: [
          // Filter button (always visible)
          InkWell(
            onTap: () => setState(() => _isExpanded = !_isExpanded),
            borderRadius: BorderRadius.circular(8),
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              decoration: BoxDecoration(
                color: isDark ? AppTheme.darkGray200 : AppTheme.gray100,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(
                  color: activeCount > 0 
                      ? const Color(0xFF6366F1)
                      : (isDark ? AppTheme.darkGray300 : AppTheme.gray300),
                  width: activeCount > 0 ? 2 : 1,
                ),
              ),
              child: Row(
                children: [
                  // üîµ INDIGO: Sparkle for Smart Inbox Filters
                  Icon(
                    Icons.auto_awesome,
                    size: 20,
                    color: const Color(0xFF6366F1),
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      activeCount == 0
                          ? 'Filters'
                          : '$activeCount filter${activeCount > 1 ? 's' : ''} active',
                      style: TextStyle(
                        fontSize: 14,
                        fontWeight: activeCount > 0 
                            ? FontWeight.w600 
                            : FontWeight.normal,
                        color: activeCount > 0
                            ? const Color(0xFF6366F1)
                            : (isDark ? AppTheme.gray500 : AppTheme.gray600),
                      ),
                    ),
                  ),
                  Icon(
                    _isExpanded ? Icons.expand_less : Icons.expand_more,
                    size: 20,
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                  ),
                ],
              ),
            ),
          ),
          
          // Expandable filter chips
          if (_isExpanded) ...[
            const SizedBox(height: 12),
            Container(
              decoration: BoxDecoration(
                color: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(
                  color: isDark ? AppTheme.darkGray300 : AppTheme.gray200,
                  width: 1,
                ),
              ),
              padding: const EdgeInsets.all(12),
              child: Wrap(
                spacing: 8,
                runSpacing: 8,
                children: [
                  // "All" filter chip
                  _buildFilterChip(
                    context,
                    ConversationFilterConfig.configs[ConversationFilter.all]!,
                    widget.activeFilters.isEmpty,
                    null,
                    isDark,
                  ),
                  
                  // Other filter chips
                  ...ConversationFilter.values
                      .where((f) => f != ConversationFilter.all)
                      .map((filter) {
                    final config = ConversationFilterConfig.configs[filter]!;
                    final isSelected = widget.activeFilters.contains(filter);
                    final count = widget.badgeCounts?[filter];
                    
                    return _buildFilterChip(
                      context,
                      config,
                      isSelected,
                      count,
                      isDark,
                    );
                  }).toList(),
                ],
              ),
            ),
          ],
        ],
      ),
    );
  }
  
  Widget _buildFilterChip(
    BuildContext context,
    ConversationFilterConfig config,
    bool isSelected,
    int? count,
    bool isDark,
  ) {
    return FilterChip(
      selected: isSelected,
      label: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            config.icon,
            size: 16,
            color: isSelected ? config.color : (isDark ? AppTheme.gray500 : AppTheme.gray600),
          ),
          const SizedBox(width: 6),
          Text(config.label),
          if (count != null && count > 0) ...[
            const SizedBox(width: 4),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
              decoration: BoxDecoration(
                color: config.color,
                borderRadius: BorderRadius.circular(10),
              ),
              child: Text(
                count.toString(),
                style: const TextStyle(
                  fontSize: 10,
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ],
        ],
      ),
      onSelected: (selected) {
        widget.onFilterToggled(config.filter);
      },
      backgroundColor: isDark ? AppTheme.darkGray200 : AppTheme.gray100,
      selectedColor: config.color.withOpacity(0.15),
      checkmarkColor: config.color,
      labelStyle: TextStyle(
        color: isSelected ? config.color : (isDark ? AppTheme.gray500 : AppTheme.gray700),
        fontSize: 13,
        fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
      ),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
        side: BorderSide(
          color: isSelected ? config.color : (isDark ? AppTheme.darkGray300 : AppTheme.gray300),
          width: isSelected ? 1.5 : 1,
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/follow_ups/widgets/follow_up_badge.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/ai_providers.dart';

/// Badge showing number of pending follow-ups for a conversation
class FollowUpBadge extends ConsumerWidget {
  final String conversationId;
  final bool compact;

  const FollowUpBadge({
    Key? key,
    required this.conversationId,
    this.compact = true,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final followUpsAsync = ref.watch(conversationFollowUpsProvider(conversationId));

    return followUpsAsync.when(
      data: (followUps) {
        if (followUps.isEmpty) {
          return const SizedBox.shrink();
        }

        final overdue = followUps.where((f) => f.isOverdue).length;
        final dueSoon = followUps.where((f) => f.isDueSoon).length;

        if (compact) {
          return _buildCompactBadge(followUps.length, overdue, dueSoon);
        } else {
          return _buildExpandedBadge(followUps.length, overdue, dueSoon);
        }
      },
      loading: () => const SizedBox.shrink(),
      error: (_, __) => const SizedBox.shrink(),
    );
  }

  Widget _buildCompactBadge(int total, int overdue, int dueSoon) {
    Color color;
    if (overdue > 0) {
      color = Colors.red;
    } else if (dueSoon > 0) {
      color = Colors.orange;
    } else {
      color = Colors.blue;
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: color,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            Icons.notification_important,
            size: 12,
            color: Colors.white,
          ),
          const SizedBox(width: 4),
          Text(
            total.toString(),
            style: const TextStyle(
              color: Colors.white,
              fontSize: 11,
              fontWeight: FontWeight.bold,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildExpandedBadge(int total, int overdue, int dueSoon) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: Colors.purple.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: Colors.purple.withOpacity(0.3),
          width: 1,
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            Icons.task_alt,
            size: 16,
            color: Colors.purple,
          ),
          const SizedBox(width: 6),
          Text(
            '$total follow-up${total != 1 ? 's' : ''}',
            style: TextStyle(
              color: Colors.purple[800],
              fontSize: 12,
              fontWeight: FontWeight.w600,
            ),
          ),
          if (overdue > 0) ...[
            const SizedBox(width: 6),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
              decoration: BoxDecoration(
                color: Colors.red,
                borderRadius: BorderRadius.circular(4),
              ),
              child: Text(
                '$overdue overdue',
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 10,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/ai_insights_background.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';

/// Background panel for AI insights that appears behind the sliding message panel
/// Users can swipe down the message panel to reveal this content
class AIInsightsBackground extends StatelessWidget {
  final String conversationId;
  final double panelPosition;

  const AIInsightsBackground({
    Key? key,
    required this.conversationId,
    this.panelPosition = 0.0,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    // Calculate opacity based on panel position
    // When panel is fully up (position = 1.0), fade out insights
    // When panel is down (position = 0.0), show insights fully
    final opacity = 1.0 - panelPosition;
    
    return Container(
      color: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
      padding: const EdgeInsets.all(AppTheme.spacingL),
      child: SafeArea(
        child: Opacity(
          opacity: opacity.clamp(0.3, 1.0), // Keep minimum visibility
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  Icon(
                    Icons.auto_awesome,
                    size: 28,
                    color: isDark ? AppTheme.white : AppTheme.black,
                  ),
                  const SizedBox(width: AppTheme.spacingS),
                  Text(
                    'AI Insights',
                    style: theme.textTheme.displaySmall?.copyWith(
                      fontWeight: AppTheme.fontWeightBold,
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: AppTheme.spacingXL),
              
              // Placeholder content
              _buildPlaceholderCard(
                context,
                icon: Icons.insights,
                title: 'Tone Analysis',
                description: 'Pull down to see how messages are being interpreted',
                isDark: isDark,
              ),
              
              const SizedBox(height: AppTheme.spacingM),
              
              _buildPlaceholderCard(
                context,
                icon: Icons.lightbulb_outline,
                title: 'Smart Suggestions',
                description: 'AI-powered response recommendations coming soon',
                isDark: isDark,
              ),
              
              const SizedBox(height: AppTheme.spacingM),
              
              _buildPlaceholderCard(
                context,
                icon: Icons.analytics_outlined,
                title: 'Conversation Health',
                description: 'Monitor communication patterns and insights',
                isDark: isDark,
              ),
              
              const Spacer(),
              
              // Hint text
              Center(
                child: Column(
                  children: [
                    Icon(
                      Icons.keyboard_arrow_down,
                      size: 32,
                      color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                    ),
                    const SizedBox(height: AppTheme.spacingXS),
                    Text(
                      'Pull down messages to view insights',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: isDark ? AppTheme.gray600 : AppTheme.gray500,
                      ),
                    ),
                  ],
                ),
              ),
              
              const SizedBox(height: AppTheme.spacingXXL),
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildPlaceholderCard(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String description,
    required bool isDark,
  }) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingS),
            decoration: BoxDecoration(
              color: isDark 
                ? AppTheme.darkGray300 
                : AppTheme.gray100,
              borderRadius: BorderRadius.circular(AppTheme.radiusS),
            ),
            child: Icon(
              icon,
              size: 24,
              color: isDark ? AppTheme.white : AppTheme.black,
            ),
          ),
          const SizedBox(width: AppTheme.spacingM),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: theme.textTheme.labelLarge?.copyWith(
                    fontWeight: AppTheme.fontWeightSemibold,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  description,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/context_panel.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/conversation_context.dart';

/// Displays relationship context and conversation history
/// Uses RAG search results to show relevant information
class ContextPanel extends StatefulWidget {
  final String conversationId;
  final ConversationContext? context;
  
  const ContextPanel({
    Key? key,
    required this.conversationId,
    this.context,
  }) : super(key: key);
  
  @override
  State<ContextPanel> createState() => _ContextPanelState();
}

class _ContextPanelState extends State<ContextPanel> {
  bool _isExpanded = true;
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    if (widget.context == null) {
      return _buildLoadingState(isDark);
    }
    
    return Container(
      margin: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: Colors.green.withOpacity(0.2),
          width: 2,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildHeader(isDark),
          
          if (_isExpanded) ...[
            const Divider(height: 1),
            _buildContextContent(isDark),
          ],
        ],
      ),
    );
  }
  
  Widget _buildHeader(bool isDark) {
    final theme = Theme.of(context);
    
    
    return InkWell(
      onTap: () => setState(() => _isExpanded = !_isExpanded),
      borderRadius: BorderRadius.circular(16),
      child: Padding(
        padding: const EdgeInsets.all(AppTheme.spacingM),
        child: Row(
          children: [
            // üü¢ GREEN: Sparkle for RAG Context Panel
            Icon(
              Icons.auto_awesome,
              size: 20,
              color: Colors.green,
            ),
            
            const SizedBox(width: AppTheme.spacingM),
            
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Conversation Context',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: isDark ? AppTheme.white : AppTheme.darkGray100,
                    ),
                  ),
                  const SizedBox(height: 2),
                  Text(
                    _getContextSummary(),
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: isDark ? AppTheme.gray400 : AppTheme.gray600,
                    ),
                  ),
                ],
              ),
            ),
            Icon(
              _isExpanded ? Icons.expand_less : Icons.expand_more,
              color: isDark ? AppTheme.gray400 : AppTheme.gray600,
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildContextContent(bool isDark) {
    return Padding(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Last discussed
          _buildSection(
            icon: Icons.chat_bubble_outline,
            title: 'Last Discussed',
            content: widget.context!.lastDiscussed,
            isDark: isDark,
          ),
          
          const SizedBox(height: AppTheme.spacingM),
          
          // Key points
          if (widget.context!.keyPoints.isNotEmpty)
            _buildKeyPointsSection(isDark),
          
          if (widget.context!.keyPoints.isNotEmpty)
            const SizedBox(height: AppTheme.spacingM),
          
          // Pending questions
          if (widget.context!.pendingQuestions.isNotEmpty)
            _buildPendingQuestionsSection(isDark),
          
          if (widget.context!.pendingQuestions.isNotEmpty)
            const SizedBox(height: AppTheme.spacingM),
          
          // Safe topics
          if (widget.context!.safeTopics != null &&
              widget.context!.safeTopics!.isNotEmpty)
            _buildSafeTopicsSection(isDark),
          
          if (widget.context!.safeTopics != null &&
              widget.context!.safeTopics!.isNotEmpty)
            const SizedBox(height: AppTheme.spacingM),
          
          // Relationship type
          if (widget.context!.relationshipType != null)
            _buildRelationshipSection(isDark),
        ],
      ),
    );
  }
  
  Widget _buildSection({
    required IconData icon,
    required String title,
    required String content,
    required bool isDark,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(
              icon,
              size: 16,
              color: isDark ? AppTheme.gray400 : AppTheme.gray600,
            ),
            const SizedBox(width: 6),
            Text(
              title,
              style: TextStyle(
                fontSize: 12,
                fontWeight: FontWeight.w600,
                color: isDark ? AppTheme.gray400 : AppTheme.gray600,
                letterSpacing: 0.5,
              ),
            ),
          ],
        ),
        const SizedBox(height: 6),
        Text(
          content,
          style: TextStyle(
            fontSize: 14,
            color: isDark ? AppTheme.white : AppTheme.darkGray100,
            height: 1.4,
          ),
        ),
      ],
    );
  }
  
  Widget _buildKeyPointsSection(bool isDark) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(
              Icons.lightbulb_outline,
              size: 16,
              color: isDark ? AppTheme.gray400 : AppTheme.gray600,
            ),
            const SizedBox(width: 6),
            Text(
              'Recent Topics',
              style: TextStyle(
                fontSize: 12,
                fontWeight: FontWeight.w600,
                color: isDark ? AppTheme.gray400 : AppTheme.gray600,
                letterSpacing: 0.5,
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        ...widget.context!.keyPoints.take(5).map((point) {
          return Padding(
            padding: const EdgeInsets.only(bottom: 6),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Container(
                  margin: const EdgeInsets.only(top: 6),
                  width: 4,
                  height: 4,
                  decoration: const BoxDecoration(
                    color: Color(0xFF6366F1),
                    shape: BoxShape.circle,
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    point.text,
                    style: TextStyle(
                      fontSize: 13,
                      color: isDark ? AppTheme.gray300 : AppTheme.gray700,
                      height: 1.4,
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                Text(
                  point.getTimeAgo(),
                  style: TextStyle(
                    fontSize: 11,
                    color: isDark ? AppTheme.gray500 : AppTheme.gray500,
                  ),
                ),
              ],
            ),
          );
        }).toList(),
      ],
    );
  }
  
  Widget _buildPendingQuestionsSection(bool isDark) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.orange.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: Colors.orange.withOpacity(0.3),
          width: 1,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const Icon(
                Icons.help_outline,
                size: 16,
                color: Colors.orange,
              ),
              const SizedBox(width: 6),
              Text(
                'Unanswered Questions',
                style: TextStyle(
                  fontSize: 12,
                  fontWeight: FontWeight.w600,
                  color: Colors.orange[800],
                  letterSpacing: 0.5,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          ...widget.context!.pendingQuestions.map((question) {
            return Padding(
              padding: const EdgeInsets.only(bottom: 4),
              child: Text(
                '‚Ä¢ $question',
                style: TextStyle(
                  fontSize: 13,
                  color: Colors.orange[900],
                  height: 1.4,
                ),
              ),
            );
          }).toList(),
        ],
      ),
    );
  }
  
  Widget _buildSafeTopicsSection(bool isDark) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(
              Icons.topic_outlined,
              size: 16,
              color: isDark ? AppTheme.gray400 : AppTheme.gray600,
            ),
            const SizedBox(width: 6),
            Text(
              'Safe Topics',
              style: TextStyle(
                fontSize: 12,
                fontWeight: FontWeight.w600,
                color: isDark ? AppTheme.gray400 : AppTheme.gray600,
                letterSpacing: 0.5,
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: widget.context!.safeTopics!.map((topic) {
            return Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
              decoration: BoxDecoration(
                color: const Color(0xFF10B981).withOpacity(0.1),
                borderRadius: BorderRadius.circular(16),
                border: Border.all(
                  color: const Color(0xFF10B981).withOpacity(0.3),
                  width: 1,
                ),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    topic.emoji,
                    style: const TextStyle(fontSize: 14),
                  ),
                  const SizedBox(width: 4),
                  Text(
                    topic.name,
                    style: const TextStyle(
                      fontSize: 12,
                      color: Color(0xFF10B981),
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            );
          }).toList(),
        ),
      ],
    );
  }
  
  Widget _buildRelationshipSection(bool isDark) {
    final relationship = widget.context!.relationshipType!;
    
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: const Color(0xFF6366F1).withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: const Color(0xFF6366F1).withOpacity(0.3),
          width: 1,
        ),
      ),
      child: Row(
        children: [
          const Icon(
            Icons.people_outline,
            size: 18,
            color: Color(0xFF6366F1),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Relationship',
                  style: TextStyle(
                    fontSize: 11,
                    color: const Color(0xFF6366F1).withOpacity(0.7),
                    fontWeight: FontWeight.w600,
                    letterSpacing: 0.5,
                  ),
                ),
                const SizedBox(height: 2),
                Text(
                  relationship,
                  style: const TextStyle(
                    fontSize: 14,
                    color: Color(0xFF6366F1),
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildLoadingState(bool isDark) {
    return Container(
      margin: const EdgeInsets.all(AppTheme.spacingM),
      padding: const EdgeInsets.all(AppTheme.spacingL),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: const Color(0xFF6366F1).withOpacity(0.2),
          width: 2,
        ),
      ),
      child: Row(
        children: [
          const SizedBox(
            width: 20,
            height: 20,
            child: CircularProgressIndicator(
              strokeWidth: 2,
              valueColor: AlwaysStoppedAnimation<Color>(
                Color(0xFF6366F1),
              ),
            ),
          ),
          const SizedBox(width: 12),
          Text(
            'Loading conversation context...',
            style: TextStyle(
              fontSize: 14,
              color: isDark ? AppTheme.gray400 : AppTheme.gray600,
            ),
          ),
        ],
      ),
    );
  }
  
  String _getContextSummary() {
    if (widget.context == null) {
      return 'Loading...';
    }
    
    final parts = <String>[];
    
    if (widget.context!.pendingQuestions.isNotEmpty) {
      parts.add('${widget.context!.pendingQuestions.length} unanswered');
    }
    
    if (widget.context!.keyPoints.isNotEmpty) {
      parts.add('${widget.context!.keyPoints.length} recent topics');
    }
    
    if (parts.isEmpty) {
      return 'View conversation history';
    }
    
    return parts.join(' ‚Ä¢ ');
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/evidence_viewer.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Widget showing evidence that supports the tone analysis
class EvidenceViewer extends StatefulWidget {
  final List<Evidence> evidence;

  const EvidenceViewer({super.key, required this.evidence});

  @override
  State<EvidenceViewer> createState() => _EvidenceViewerState();
}

class _EvidenceViewerState extends State<EvidenceViewer> {
  bool _expanded = false;

  @override
  Widget build(BuildContext context) {
    if (widget.evidence.isEmpty) {
      return Container(
        padding: const EdgeInsets.all(10),
        decoration: BoxDecoration(
          color: Colors.grey.withOpacity(0.1),
          borderRadius: BorderRadius.circular(6),
        ),
        child: const Row(
          children: [
            Icon(Icons.info_outline, size: 16, color: Colors.grey),
            SizedBox(width: 8),
            Expanded(
              child: Text(
                'No specific evidence found in message',
                style: TextStyle(fontSize: 12, color: Colors.grey),
              ),
            ),
          ],
        ),
      );
    }

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.teal.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.teal.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          InkWell(
            onTap: () => setState(() => _expanded = !_expanded),
            child: Row(
              children: [
                const Icon(Icons.search, color: Colors.teal, size: 20),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    'Evidence (${widget.evidence.length})',
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      color: Colors.teal,
                    ),
                  ),
                ),
                Icon(
                  _expanded ? Icons.expand_less : Icons.expand_more,
                  color: Colors.teal,
                ),
              ],
            ),
          ),
          if (_expanded) ...[
            const SizedBox(height: 12),
            const Text(
              'Specific evidence supporting this analysis:',
              style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic),
            ),
            const SizedBox(height: 8),
            
            // Evidence items
            ...widget.evidence.map((evidence) => Padding(
              padding: const EdgeInsets.only(bottom: 8),
              child: _EvidenceItem(evidence: evidence),
            )),
          ],
        ],
      ),
    );
  }
}

class _EvidenceItem extends StatelessWidget {
  final Evidence evidence;

  const _EvidenceItem({required this.evidence});

  @override
  Widget build(BuildContext context) {
    final typeColor = _getTypeColor(evidence.type);
    final typeIcon = _getTypeIcon(evidence.type);

    return Container(
      padding: const EdgeInsets.all(10),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(6),
        border: Border.all(color: typeColor.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Type and quote
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Icon(typeIcon, size: 16, color: typeColor),
              const SizedBox(width: 8),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                      decoration: BoxDecoration(
                        color: typeColor.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(3),
                      ),
                      child: Text(
                        evidence.type.toUpperCase(),
                        style: TextStyle(
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                          color: typeColor,
                        ),
                      ),
                    ),
                    const SizedBox(height: 6),
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      decoration: BoxDecoration(
                        color: Colors.grey.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(4),
                      ),
                      child: Text(
                        '"${evidence.quote}"',
                        style: const TextStyle(
                          fontSize: 13,
                          fontWeight: FontWeight.w600,
                          fontFamily: 'monospace',
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          
          // What it supports
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Icon(Icons.arrow_forward, size: 14, color: Colors.grey),
              const SizedBox(width: 6),
              Expanded(
                child: Text(
                  'Supports: ${evidence.supports}',
                  style: const TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                    color: Colors.black87,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 4),
          
          // Reasoning
          Padding(
            padding: const EdgeInsets.only(left: 20),
            child: Text(
              evidence.reasoning,
              style: const TextStyle(
                fontSize: 11,
                color: Colors.black54,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Color _getTypeColor(String type) {
    switch (type) {
      case 'keyword':
        return Colors.blue;
      case 'punctuation':
        return Colors.orange;
      case 'emoji':
        return Colors.pink;
      case 'length':
        return Colors.purple;
      case 'pattern':
        return Colors.teal;
      case 'timing':
        return Colors.amber;
      default:
        return Colors.grey;
    }
  }

  IconData _getTypeIcon(String type) {
    switch (type) {
      case 'keyword':
        return Icons.text_fields;
      case 'punctuation':
        return Icons.format_quote;
      case 'emoji':
        return Icons.emoji_emotions;
      case 'length':
        return Icons.straighten;
      case 'pattern':
        return Icons.pattern;
      case 'timing':
        return Icons.access_time;
      default:
        return Icons.info;
    }
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/interpretation_options.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Widget showing alternative interpretations for ambiguous messages
class InterpretationOptions extends StatefulWidget {
  final List<MessageInterpretation> interpretations;

  const InterpretationOptions({super.key, required this.interpretations});

  @override
  State<InterpretationOptions> createState() => _InterpretationOptionsState();
}

class _InterpretationOptionsState extends State<InterpretationOptions> {
  bool _expanded = false;

  @override
  Widget build(BuildContext context) {
    if (widget.interpretations.isEmpty) return const SizedBox.shrink();

    // Sort by likelihood (highest first)
    final sorted = List<MessageInterpretation>.from(widget.interpretations)
      ..sort((a, b) => b.likelihood.compareTo(a.likelihood));

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.purple.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.purple.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          InkWell(
            onTap: () => setState(() => _expanded = !_expanded),
            child: Row(
              children: [
                const Icon(Icons.lightbulb_outline, color: Colors.purple, size: 20),
                const SizedBox(width: 8),
                const Expanded(
                  child: Text(
                    'Alternative Interpretations',
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                      color: Colors.purple,
                    ),
                  ),
                ),
                Icon(
                  _expanded ? Icons.expand_less : Icons.expand_more,
                  color: Colors.purple,
                ),
              ],
            ),
          ),
          if (_expanded) ...[
            const SizedBox(height: 12),
            const Text(
              'This message could be interpreted in multiple ways:',
              style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic),
            ),
            const SizedBox(height: 8),
            
            // Interpretations
            ...sorted.asMap().entries.map((entry) {
              final index = entry.key;
              final interp = entry.value;
              return Padding(
                padding: const EdgeInsets.only(bottom: 12),
                child: _InterpretationCard(
                  interpretation: interp,
                  rank: index + 1,
                ),
              );
            }),
          ],
        ],
      ),
    );
  }
}

class _InterpretationCard extends StatelessWidget {
  final MessageInterpretation interpretation;
  final int rank;

  const _InterpretationCard({
    required this.interpretation,
    required this.rank,
  });

  @override
  Widget build(BuildContext context) {
    Color likelihoodColor;
    if (interpretation.isLikely) {
      likelihoodColor = Colors.green;
    } else if (interpretation.isPossible) {
      likelihoodColor = Colors.orange;
    } else {
      likelihoodColor = Colors.grey;
    }

    return Container(
      padding: const EdgeInsets.all(10),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(6),
        border: Border.all(color: likelihoodColor.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Rank and likelihood
          Row(
            children: [
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: likelihoodColor.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Text(
                  '#$rank',
                  style: TextStyle(
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                    color: likelihoodColor,
                  ),
                ),
              ),
              const SizedBox(width: 8),
              Text(
                '${interpretation.likelihood}% likely',
                style: TextStyle(
                  fontSize: 12,
                  fontWeight: FontWeight.w600,
                  color: likelihoodColor,
                ),
              ),
              const Spacer(),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                decoration: BoxDecoration(
                  color: Colors.grey.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Text(
                  interpretation.tone,
                  style: const TextStyle(
                    fontSize: 11,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          
          // Interpretation text
          Text(
            interpretation.interpretation,
            style: const TextStyle(
              fontSize: 13,
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 6),
          
          // Reasoning
          Text(
            interpretation.reasoning,
            style: const TextStyle(
              fontSize: 12,
              color: Colors.black87,
            ),
          ),
          
          // Context clues
          if (interpretation.contextClues.isNotEmpty) ...[
            const SizedBox(height: 6),
            Wrap(
              spacing: 4,
              runSpacing: 4,
              children: interpretation.contextClues.map((clue) {
                return Container(
                  padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                  decoration: BoxDecoration(
                    color: Colors.blue.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(3),
                  ),
                  child: Text(
                    clue,
                    style: const TextStyle(
                      fontSize: 10,
                      color: Colors.blue,
                    ),
                  ),
                );
              }).toList(),
            ),
          ],
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/message_bubble.dart">
import 'package:flutter/material.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/services/ai_analysis_service.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/features/messages/widgets/tone_detail_sheet.dart';
import 'dart:async'; // Added for Timer

/// Message bubble with long-press for manual AI analysis
class MessageBubble extends StatefulWidget {
  final Message message;
  final bool isFromCurrentUser;
  final AIAnalysis? analysis;
  final bool isMostRecentReceived; // NEW: Track if this is the newest received message
  
  const MessageBubble({
    Key? key,
    required this.message,
    required this.isFromCurrentUser,
    this.analysis,
    this.isMostRecentReceived = false,
  }) : super(key: key);

  @override
  State<MessageBubble> createState() => _MessageBubbleState();
}

class _MessageBubbleState extends State<MessageBubble> {
  final _aiService = AIAnalysisService();
  bool _isAnalyzing = false;
  AIAnalysis? _analysisResult;
  
  // üîß FIXED: Increased timeout from 10s to 20s (backend takes 12+ seconds)
  late final Duration _analysisTimeout = const Duration(seconds: 20);
  
  // üîî NEW: StreamSubscription for auto-analysis completion
  late StreamSubscription<AnalysisEvent> _analysisCompletionSubscription;

  @override
  void initState() {
    super.initState();
    _analysisResult = widget.analysis;
    
    // üîß NEW: Check if analysis is already cached from a previous request
    _aiService.getAnalysis(widget.message.id).then((cachedAnalysis) {
      if (cachedAnalysis != null && mounted && _analysisResult == null) {
        print('‚úÖ [BUBBLE] Found cached analysis on init: ${cachedAnalysis.tone}');
        setState(() {
          _analysisResult = cachedAnalysis;
        });
      }
    }).catchError((e) {
      print('‚ö†Ô∏è [BUBBLE] Error checking cache on init: $e');
    });
    
    // üîî NEW: Listen for auto-analysis completion events
    _analysisCompletionSubscription = _aiService.analysisEventStream.listen((event) {
      // Only update if this message's analysis event occurred
      if (event.messageId == widget.message.id && mounted) {
        if (event.isStarting) {
          // Show loading spinner when auto-analysis starts
          print('‚ñ∂Ô∏è [BUBBLE] Auto-analysis starting for ${widget.message.id.substring(0, 8)}');
          setState(() {
            _isAnalyzing = true;
          });
        } else {
          // Update UI when auto-analysis completes
          print('‚úÖ [BUBBLE] Auto-analysis completed for ${widget.message.id.substring(0, 8)}');
          
          // üîß FIX: Get analysis from cache directly (already stored by service)
          // This avoids recursion and works for both new analyses and cached ones
          _aiService.getAnalysis(widget.message.id).then((analysis) {
            if (analysis != null && mounted) {
              setState(() {
                _analysisResult = analysis;
                _isAnalyzing = false;
              });
            } else if (mounted) {
              // Fallback: try requestAnalysis if getAnalysis fails
              _aiService.requestAnalysis(
                widget.message.id,
                widget.message.body,
                isFromCurrentUser: widget.isFromCurrentUser,
                messageTimestamp: widget.message.createdAt,
              ).then((analysis) {
                if (analysis != null && mounted) {
                  setState(() {
                    _analysisResult = analysis;
                    _isAnalyzing = false;
                  });
                }
              });
            }
          }).catchError((e) {
            print('‚ùå [BUBBLE] Error getting analysis: $e');
            if (mounted) {
              setState(() => _isAnalyzing = false);
            }
          });
        }
      }
    });
  }
  
  @override
  void dispose() {
    // üîî NEW: Cancel subscription when widget is disposed
    _analysisCompletionSubscription.cancel();
    super.dispose();
  }

  /// Manually request AI analysis when user long-presses
  Future<void> _requestManualAnalysis() async {
    setState(() => _isAnalyzing = true);
    
    // üîß Safety net: Force close spinner after 25 seconds (20s API + 5s buffer)
    final safetyTimer = Timer(const Duration(seconds: 25), () {
      if (mounted && _isAnalyzing) {
        print('‚ö†Ô∏è Force-closing analysis spinner (safety timeout)');
        setState(() => _isAnalyzing = false);
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('‚è±Ô∏è Analysis took too long, cancelled automatically'),
            backgroundColor: Colors.orange,
            duration: Duration(seconds: 3),
          ),
        );
      }
    });
    
    try {
      // üîß Add timeout to prevent infinite loading (20 seconds for backend processing)
      final analysis = await _aiService.requestAnalysis(
        widget.message.id,
        widget.message.body,
        isFromCurrentUser: widget.isFromCurrentUser,
        messageTimestamp: widget.message.createdAt,
      ).timeout(
        _analysisTimeout,
        onTimeout: () {
          print('‚è±Ô∏è Analysis request timed out after ${_analysisTimeout.inSeconds}s');
          return null;
        },
      );
      
      if (mounted) {
        safetyTimer.cancel(); // Cancel safety timer if request completed
        setState(() {
          _analysisResult = analysis;
          _isAnalyzing = false;
        });
        
        // Show detail sheet with analysis
        if (_analysisResult != null) {
          _showAnalysisSheet();
        } else {
          // Timeout or failed
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('‚è±Ô∏è Analysis timed out. Please try again.'),
              backgroundColor: Colors.orange,
              duration: Duration(seconds: 3),
            ),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        safetyTimer.cancel();
        setState(() => _isAnalyzing = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Analysis failed: $e'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    }
  }

  /// Show the tone detail sheet
  void _showAnalysisSheet() {
    if (_analysisResult == null) return;
    
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => ToneDetailSheet(
        analysis: _analysisResult!,
        messageBody: widget.message.body,
        messageId: widget.message.id,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    return GestureDetector(
      onLongPress: !widget.isFromCurrentUser ? _requestManualAnalysis : null,
      child: Container(
        margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        alignment: widget.isFromCurrentUser ? Alignment.centerRight : Alignment.centerLeft,
        child: Stack(
          clipBehavior: Clip.none,
          children: [
            Column(
              crossAxisAlignment: widget.isFromCurrentUser 
                  ? CrossAxisAlignment.end 
                  : CrossAxisAlignment.start,
              children: [
                // Main bubble
                Container(
                  constraints: BoxConstraints(
                    maxWidth: MediaQuery.of(context).size.width * 0.75,
                  ),
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  decoration: BoxDecoration(
                    color: widget.isFromCurrentUser
                        ? theme.colorScheme.primary
                        : (isDark ? AppTheme.darkGray200 : AppTheme.gray100),
                    borderRadius: BorderRadius.circular(16),
                    border: Border.all(
                      color: _isAnalyzing
                          ? theme.colorScheme.primary.withOpacity(0.3)
                          : Colors.transparent,
                      width: 2,
                    ),
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        widget.message.body,
                        style: TextStyle(
                          fontSize: 15,
                          color: widget.isFromCurrentUser ? Colors.white : null,
                          height: 1.4,
                        ),
                      ),
                      
                      // Show tone badge for analyzed incoming messages
                      if (!widget.isFromCurrentUser && _analysisResult != null) ...[
                        const SizedBox(height: 8),
                        ToneBadge(
                          analysis: _analysisResult!,
                          onTap: _showAnalysisSheet,
                        ),
                      ],
                      
                      // üü£ Sparkle indicator at bottom-right (only for most recent received message)
                      if (widget.isMostRecentReceived && !widget.isFromCurrentUser) ...[
                        const SizedBox(height: 8),
                        Align(
                          alignment: Alignment.bottomRight,
                          child: _buildSparkleButton(context),
                        ),
                      ],
                    ],
                  ),
                ),
                
                // Long-press hint for incoming messages without analysis
                if (!widget.isFromCurrentUser && _analysisResult == null && !_isAnalyzing)
                  Padding(
                    padding: const EdgeInsets.only(top: 4),
                    child: Text(
                      'üí° Long-press for analysis',
                      style: TextStyle(
                        fontSize: 11,
                        color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                        fontStyle: FontStyle.italic,
                      ),
                    ),
                  ),
                
                // Timestamp
                Padding(
                  padding: const EdgeInsets.only(top: 4),
                  child: Text(
                    _formatTime(widget.message.createdAt),
                    style: TextStyle(
                      fontSize: 11,
                      color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                    ),
                  ),
                ),
              ],
            ),
            
            // üü£ Sparkle indicator at bottom-right (only for most recent received message)
            // This line is removed as the sparkle indicator is now a child of the Column
            // if (widget.isMostRecentReceived && !widget.isFromCurrentUser)
            //   Positioned(
            //     bottom: 8,
            //     right: 12,
            //     child: _buildSparkleButton(context),
            //   ),
          ],
        ),
      ),
    );
  }

  String _formatTime(int timestamp) {
    final dateTime = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inMinutes < 1) {
      return 'now';
    } else if (difference.inHours < 1) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inDays < 1) {
      return '${difference.inHours}h ago';
    } else {
      return '${dateTime.month}/${dateTime.day}';
    }
  }

  /// Build the sparkle button for the most recent received message
  Widget _buildSparkleButton(BuildContext context) {
    return StreamBuilder<AnalysisEvent>(
      stream: _aiService.analysisEventStream,
      builder: (context, snapshot) {
        // Only show spinner if this specific message is being analyzed
        final isAnalyzing = snapshot.hasData && 
            snapshot.data!.messageId == widget.message.id && 
            snapshot.data!.isStarting;
        
        return GestureDetector(
          onTap: !isAnalyzing ? () {
            // Trigger analysis on click
            _aiService.requestAnalysis(
              widget.message.id,
              widget.message.body,
              conversationContext: [],
            );
          } : null,
          child: isAnalyzing
              ? const SizedBox(
                  width: 18,
                  height: 18,
                  child: CircularProgressIndicator(
                    valueColor: AlwaysStoppedAnimation<Color>(Colors.purple),
                    strokeWidth: 2.5,
                  ),
                )
              : Icon(
                  Icons.auto_awesome,
                  size: 20,
                  color: Colors.purple,
                ),
        );
      },
    );
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/message_formatter_panel.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/services/message_formatter_service.dart';
import 'package:messageai/models/formatted_message.dart';

/// Panel for formatting long messages
class MessageFormatterPanel extends ConsumerStatefulWidget {
  final String originalMessage;
  final Function(String) onFormatted;

  const MessageFormatterPanel({
    super.key,
    required this.originalMessage,
    required this.onFormatted,
  });

  @override
  ConsumerState<MessageFormatterPanel> createState() => 
      _MessageFormatterPanelState();
}

class _MessageFormatterPanelState extends ConsumerState<MessageFormatterPanel> {
  late final MessageFormatterService formatterService;
  
  bool condense = false;
  bool chunk = false;
  bool addTldr = false;
  bool addStructure = false;
  
  FormattedMessage? formattedResult;
  bool isFormatting = false;

  @override
  void initState() {
    super.initState();
    formatterService = MessageFormatterService(Supabase.instance.client);
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      constraints: const BoxConstraints(maxHeight: 600),
      child: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header
            Row(
              children: [
                const Icon(Icons.auto_fix_high, color: Colors.purple, size: 20),
                const SizedBox(width: 8),
                const Text(
                  'Message Formatter',
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 16,
                  ),
                ),
                const Spacer(),
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () => Navigator.pop(context),
                ),
              ],
            ),
            Text(
              'Original: ${widget.originalMessage.length} characters',
              style: const TextStyle(
                fontSize: 12,
                color: Colors.grey,
              ),
            ),
            const SizedBox(height: 4),
            const Text(
              'Make your message more digestible',
              style: TextStyle(
                fontSize: 13,
                color: Colors.grey,
              ),
            ),
            const SizedBox(height: 16),

            // Formatting options
            CheckboxListTile(
              title: const Text('Condense', style: TextStyle(fontSize: 14)),
              subtitle: const Text(
                'Reduce length while keeping key points (50-70% shorter)',
                style: TextStyle(fontSize: 11),
              ),
              value: condense,
              dense: true,
              onChanged: (value) => setState(() => condense = value!),
            ),
            CheckboxListTile(
              title: const Text('Break into Chunks', style: TextStyle(fontSize: 14)),
              subtitle: const Text(
                'Add sections with headers for easier reading',
                style: TextStyle(fontSize: 11),
              ),
              value: chunk,
              dense: true,
              onChanged: (value) => setState(() => chunk = value!),
            ),
            CheckboxListTile(
              title: const Text('Add TL;DR', style: TextStyle(fontSize: 14)),
              subtitle: const Text(
                'Brief 1-2 sentence summary at the top',
                style: TextStyle(fontSize: 11),
              ),
              value: addTldr,
              dense: true,
              onChanged: (value) => setState(() => addTldr = value!),
            ),
            CheckboxListTile(
              title: const Text('Add Structure', style: TextStyle(fontSize: 14)),
              subtitle: const Text(
                'Headings, bullets, and emphasis for clarity',
                style: TextStyle(fontSize: 11),
              ),
              value: addStructure,
              dense: true,
              onChanged: (value) => setState(() => addStructure = value!),
            ),

            const SizedBox(height: 16),

            // Format button
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: isFormatting ? null : _formatMessage,
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.purple,
                ),
                child: isFormatting
                    ? const SizedBox(
                        width: 16,
                        height: 16,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          color: Colors.white,
                        ),
                      )
                    : const Text('Format Message'),
              ),
            ),

            // Result preview
            if (formattedResult != null) ...[
              const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.green.shade50,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.green.shade300),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        const Text(
                          'Formatted Result',
                          style: TextStyle(
                            fontSize: 13,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const Spacer(),
                        Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 8,
                            vertical: 4,
                          ),
                          decoration: BoxDecoration(
                            color: Colors.green,
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Text(
                            '-${formattedResult!.getSavingsPercentage().toStringAsFixed(0)}% shorter',
                            style: const TextStyle(
                              fontSize: 10,
                              fontWeight: FontWeight.bold,
                              color: Colors.white,
                            ),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Text(
                      '${formattedResult!.characterCount} chars ‚Ä¢ ${formattedResult!.estimatedReadTime}',
                      style: const TextStyle(
                        fontSize: 11,
                        color: Colors.grey,
                      ),
                    ),
                    const SizedBox(height: 8),
                    ConstrainedBox(
                      constraints: const BoxConstraints(maxHeight: 150),
                      child: SingleChildScrollView(
                        child: Text(
                          formattedResult!.formattedMessage,
                          style: const TextStyle(fontSize: 12),
                        ),
                      ),
                    ),
                    const SizedBox(height: 12),
                    Row(
                      children: [
                        Expanded(
                          child: OutlinedButton(
                            onPressed: () {
                              // Show full preview
                              showDialog(
                                context: context,
                                builder: (context) => AlertDialog(
                                  title: const Text('Formatted Message'),
                                  content: SingleChildScrollView(
                                    child: Text(formattedResult!.formattedMessage),
                                  ),
                                  actions: [
                                    TextButton(
                                      onPressed: () => Navigator.pop(context),
                                      child: const Text('Close'),
                                    ),
                                  ],
                                ),
                              );
                            },
                            child: const Text('Preview Full', style: TextStyle(fontSize: 12)),
                          ),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: ElevatedButton(
                            onPressed: () {
                              widget.onFormatted(formattedResult!.formattedMessage);
                              Navigator.pop(context);
                            },
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.purple,
                            ),
                            child: const Text('Use This', style: TextStyle(fontSize: 12)),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Future<void> _formatMessage() async {
    if (!condense && !chunk && !addTldr && !addStructure) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Select at least one formatting option')),
      );
      return;
    }

    setState(() => isFormatting = true);

    try {
      final result = await formatterService.formatMessage(
        message: widget.originalMessage,
        condense: condense,
        chunk: chunk,
        addTldr: addTldr,
        addStructure: addStructure,
      );

      if (mounted) {
        setState(() {
          formattedResult = result;
          isFormatting = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() => isFormatting = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error formatting message: $e')),
        );
      }
    }
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/relationship_type_selector.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/draft_analysis.dart';

/// Simple dialog for selecting relationship type
class RelationshipTypeSelector extends StatelessWidget {
  final RelationshipType currentType;
  final Function(RelationshipType) onSelected;

  const RelationshipTypeSelector({
    Key? key,
    required this.currentType,
    required this.onSelected,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AlertDialog(
      title: const Text('Set Relationship Type'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: RelationshipType.values.map((type) {
          final isSelected = type == currentType;
          return ListTile(
            leading: Icon(
              type.icon,
              color: isSelected ? AppTheme.accentBlue : null,
            ),
            title: Text(
              type.displayName,
              style: isSelected
                  ? TextStyle(
                      color: AppTheme.accentBlue,
                      fontWeight: AppTheme.fontWeightBold,
                    )
                  : null,
            ),
            trailing: isSelected
                ? const Icon(Icons.check, color: AppTheme.accentBlue)
                : null,
            onTap: () {
              onSelected(type);
              Navigator.pop(context);
            },
          );
        }).toList(),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Cancel'),
        ),
      ],
    );
  }

  static Future<void> show(
    BuildContext context,
    RelationshipType currentType,
    Function(RelationshipType) onSelected,
  ) {
    return showDialog(
      context: context,
      builder: (context) => RelationshipTypeSelector(
        currentType: currentType,
        onSelected: onSelected,
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/rsd_alert_card.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Alert card for RSD triggers
class RSDAlertCard extends StatelessWidget {
  final List<RSDTrigger> triggers;

  const RSDAlertCard({super.key, required this.triggers});

  @override
  Widget build(BuildContext context) {
    if (triggers.isEmpty) return const SizedBox.shrink();

    final highSeverity = triggers.any((t) => t.isHighSeverity);

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: highSeverity 
            ? Colors.orange.withOpacity(0.1)
            : Colors.blue.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: highSeverity 
              ? Colors.orange.withOpacity(0.5)
              : Colors.blue.withOpacity(0.5),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Row(
            children: [
              Icon(
                highSeverity ? Icons.warning_amber : Icons.info_outline,
                color: highSeverity ? Colors.orange : Colors.blue,
                size: 20,
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  'RSD Alert: This might not be what it seems',
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                    color: highSeverity ? Colors.orange : Colors.blue,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          
          // Triggers
          ...triggers.map((trigger) => Padding(
            padding: const EdgeInsets.only(bottom: 8),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'üìå "${trigger.pattern}"',
                  style: const TextStyle(
                    fontWeight: FontWeight.w600,
                    fontSize: 13,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  '‚ö†Ô∏è ${trigger.explanation}',
                  style: const TextStyle(fontSize: 12),
                ),
                const SizedBox(height: 4),
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.green.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Row(
                    children: [
                      const Icon(Icons.check_circle, size: 16, color: Colors.green),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          trigger.reassurance,
                          style: const TextStyle(
                            fontSize: 12,
                            color: Colors.green,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          )),
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/template_picker.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/models/response_template.dart';
import 'package:messageai/models/situation_type.dart';
import 'package:messageai/services/response_template_service.dart';

/// Widget for picking and using response templates
class TemplatePicker extends ConsumerStatefulWidget {
  final SituationType? detectedSituation;
  final Function(String) onTemplateSelected;

  const TemplatePicker({
    super.key,
    this.detectedSituation,
    required this.onTemplateSelected,
  });

  @override
  ConsumerState<TemplatePicker> createState() => _TemplatePickerState();
}

class _TemplatePickerState extends ConsumerState<TemplatePicker> {
  final templateService = ResponseTemplateService();
  ResponseTemplate? selectedTemplate;
  final Map<String, TextEditingController> _fieldControllers = {};

  @override
  void initState() {
    super.initState();
    templateService.loadTemplates();
  }

  @override
  void dispose() {
    // Dispose all controllers
    for (final controller in _fieldControllers.values) {
      controller.dispose();
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final templates = widget.detectedSituation != null
        ? templateService.getTemplatesForSituation(widget.detectedSituation!)
        : templateService.getAllTemplates();

    if (templates.isEmpty) {
      return const SizedBox.shrink();
    }

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).scaffoldBackgroundColor,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 10,
            offset: const Offset(0, -2),
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Row(
            children: [
              Icon(
                widget.detectedSituation?.icon ?? Icons.lightbulb,
                color: widget.detectedSituation?.getColor() ?? Colors.blue,
              ),
              const SizedBox(width: 8),
              const Expanded(
                child: Text(
                  'Response Templates',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              IconButton(
                icon: const Icon(Icons.close),
                onPressed: () => Navigator.pop(context),
              ),
            ],
          ),
          
          if (widget.detectedSituation != null) ...[
            const SizedBox(height: 8),
            Text(
              'Detected: ${widget.detectedSituation!.displayName}',
              style: const TextStyle(
                fontSize: 13,
                color: Colors.grey,
              ),
            ),
          ],
          
          const SizedBox(height: 16),

          // Template list
          Expanded(
            child: ListView.builder(
              itemCount: templates.length,
              itemBuilder: (context, index) {
                final template = templates[index];
                final isSelected = selectedTemplate?.id == template.id;

                return Card(
                  margin: const EdgeInsets.only(bottom: 8),
                  elevation: isSelected ? 4 : 1,
                  color: isSelected ? Colors.blue.shade50 : null,
                  child: ListTile(
                    title: Text(
                      template.name,
                      style: TextStyle(
                        fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                      ),
                    ),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const SizedBox(height: 4),
                        Text(
                          template.situation,
                          style: const TextStyle(fontSize: 12),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          template.template,
                          style: const TextStyle(
                            fontSize: 11,
                            fontStyle: FontStyle.italic,
                            color: Colors.grey,
                          ),
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ],
                    ),
                    trailing: Icon(
                      isSelected ? Icons.check_circle : Icons.chevron_right,
                      color: isSelected ? Colors.blue : null,
                    ),
                    onTap: () {
                      setState(() {
                        selectedTemplate = template;
                        // Initialize controllers for this template's fields
                        _fieldControllers.clear();
                        if (template.customizableFields != null) {
                          for (final field in template.customizableFields!) {
                            _fieldControllers[field] = TextEditingController();
                          }
                        }
                      });
                    },
                  ),
                );
              },
            ),
          ),

          // Customization section (if template selected with fields)
          if (selectedTemplate != null &&
              selectedTemplate!.customizableFields != null &&
              selectedTemplate!.customizableFields!.isNotEmpty) ...[
            const SizedBox(height: 16),
            const Text(
              'Fill in the blanks:',
              style: TextStyle(
                fontSize: 14,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            ...selectedTemplate!.customizableFields!.map((field) {
              return Padding(
                padding: const EdgeInsets.only(bottom: 8),
                child: TextField(
                  controller: _fieldControllers[field],
                  decoration: InputDecoration(
                    labelText: field.replaceAll('_', ' ').toUpperCase(),
                    border: const OutlineInputBorder(),
                    isDense: true,
                  ),
                  onChanged: (_) => setState(() {}),
                ),
              );
            }),
          ],

          // Preview and use button
          if (selectedTemplate != null) ...[
            const SizedBox(height: 16),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.grey.shade200,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Preview:',
                    style: TextStyle(
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    _getPreviewText(),
                    style: const TextStyle(fontSize: 13),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () {
                  final filledTemplate = _getPreviewText();
                  widget.onTemplateSelected(filledTemplate);
                  Navigator.pop(context);
                },
                child: const Text('Use This Template'),
              ),
            ),
          ],
        ],
      ),
    );
  }

  String _getPreviewText() {
    if (selectedTemplate == null) return '';
    
    final values = <String, String>{};
    for (final entry in _fieldControllers.entries) {
      values[entry.key] = entry.value.text;
    }
    
    return selectedTemplate!.fillTemplate(values);
  }
}

/// Show template picker as bottom sheet
void showTemplatePicker(
  BuildContext context,
  SituationType? detectedSituation,
  Function(String) onTemplateSelected,
) {
  showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    builder: (context) => SizedBox(
      height: MediaQuery.of(context).size.height * 0.7,
      child: TemplatePicker(
        detectedSituation: detectedSituation,
        onTemplateSelected: onTemplateSelected,
      ),
    ),
  );
}
</file>

<file path="frontend/lib/features/messages/widgets/tone_detail_sheet_simplified.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/state/ai_providers.dart';

/// Simplified tone detail sheet with progressive disclosure
/// Designed for neurodivergent users - calm, clear, less overwhelming
class ToneDetailSheetSimplified extends ConsumerStatefulWidget {
  final AIAnalysis analysis;
  final String messageBody;
  final String messageId;

  const ToneDetailSheetSimplified({
    Key? key,
    required this.analysis,
    required this.messageBody,
    required this.messageId,
  }) : super(key: key);

  @override
  ConsumerState<ToneDetailSheetSimplified> createState() => _ToneDetailSheetSimplifiedState();

  static void show(
    BuildContext context,
    AIAnalysis analysis,
    String messageBody,
    String messageId,
  ) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => DraggableScrollableSheet(
        initialChildSize: 0.7,
        minChildSize: 0.4,
        maxChildSize: 0.9,
        builder: (context, scrollController) => ToneDetailSheetSimplified(
          analysis: analysis,
          messageBody: messageBody,
          messageId: messageId,
        ),
      ),
    );
  }
}

class _ToneDetailSheetSimplifiedState extends ConsumerState<ToneDetailSheetSimplified> {
  String? _expandedSection;
  bool _isLoadingInterpretation = false;
  AIAnalysis? _enhancedAnalysis;

  @override
  void initState() {
    super.initState();
    _enhancedAnalysis = widget.analysis;
  }

  /// Trigger deeper interpretation
  Future<void> _interpretMessage() async {
    if (_isLoadingInterpretation) return;

    setState(() => _isLoadingInterpretation = true);

    try {
      final service = ref.read(messageInterpreterServiceProvider);
      final analysis = await service.interpretMessage(
        widget.messageId,
        widget.messageBody,
      );

      if (mounted) {
        setState(() {
          _enhancedAnalysis = analysis;
          _isLoadingInterpretation = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isLoadingInterpretation = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final analysis = _enhancedAnalysis ?? widget.analysis;
    
    return Container(
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          // Handle bar
          Container(
            margin: const EdgeInsets.only(top: 12),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: isDark ? AppTheme.gray600 : AppTheme.gray300,
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          // Content
          Expanded(
            child: ListView(
              padding: const EdgeInsets.all(AppTheme.spacingL),
              children: [
                // Quick summary (always visible)
                _buildQuickSummary(analysis, isDark),
                
                const SizedBox(height: AppTheme.spacingL),
                
                // RSD Alert (if present - always visible, high priority)
                if (analysis.rsdTriggers != null && analysis.rsdTriggers!.isNotEmpty)
                  _buildRSDAlert(analysis.rsdTriggers!, isDark),
                
                // Deeper interpretation button
                if (analysis.alternativeInterpretations == null ||
                    analysis.alternativeInterpretations!.isEmpty)
                  _buildInterpretButton(isDark),
                
                const SizedBox(height: AppTheme.spacingM),
                
                // Expandable sections (progressive disclosure)
                _buildExpandableSection(
                  'details',
                  'More Details',
                  Icons.info_outline_rounded,
                  isDark,
                  () => _buildDetailsSection(analysis, isDark),
                ),
                
                if (analysis.alternativeInterpretations != null &&
                    analysis.alternativeInterpretations!.isNotEmpty) ...[
                  const SizedBox(height: AppTheme.spacingS),
                  _buildExpandableSection(
                    'interpretations',
                    'Other Meanings',
                    Icons.lightbulb_outline_rounded,
                    isDark,
                    () => _buildInterpretationsSection(analysis.alternativeInterpretations!, isDark),
                  ),
                ],
                
                if (analysis.evidence != null && analysis.evidence!.isNotEmpty) ...[
                  const SizedBox(height: AppTheme.spacingS),
                  _buildExpandableSection(
                    'evidence',
                    'Why AI Thinks This',
                    Icons.checklist_rounded,
                    isDark,
                    () => _buildEvidenceSection(analysis.evidence!, isDark),
                  ),
                ],
              ],
            ),
          ),
          
          // Close button
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingL),
            decoration: BoxDecoration(
              border: Border(
                top: BorderSide(
                  color: isDark ? AppTheme.darkGray300 : AppTheme.gray200,
                ),
              ),
            ),
            child: SafeArea(
              top: false,
              child: SizedBox(
                width: double.infinity,
                child: FilledButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text('Done'),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  /// Quick summary - always visible, easy to scan
  Widget _buildQuickSummary(AIAnalysis analysis, bool isDark) {
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: _getToneColor(analysis.tone).withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: _getToneColor(analysis.tone).withOpacity(0.3),
          width: 2,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Tone (primary info)
          Row(
            children: [
              Icon(
                _getToneIcon(analysis.tone),
                color: _getToneColor(analysis.tone),
                size: 24,
              ),
              const SizedBox(width: AppTheme.spacingS),
              Expanded(
                child: Text(
                  analysis.tone,
                  style: TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.w600,
                    color: isDark ? AppTheme.white : AppTheme.darkGray100,
                  ),
                ),
              ),
            ],
          ),
          
          const SizedBox(height: AppTheme.spacingS),
          
          // Key stats (urgency, intensity)
          Wrap(
            spacing: AppTheme.spacingS,
            runSpacing: AppTheme.spacingXS,
            children: [
              if (analysis.urgencyLevel != null)
                _buildChip(
                  analysis.urgencyLevel!,
                  _getUrgencyColor(analysis.urgencyLevel),
                  isDark,
                ),
              if (analysis.intensity != null)
                _buildChip(
                  'Intensity: ${analysis.intensity}/10',
                  Colors.blue,
                  isDark,
                ),
              if (analysis.intent != null)
                _buildChip(
                  analysis.intent!,
                  Colors.purple,
                  isDark,
                ),
            ],
          ),
        ],
      ),
    );
  }

  /// RSD alert - high priority, always visible
  Widget _buildRSDAlert(List<RSDTrigger> triggers, bool isDark) {
    final highSeverity = triggers.where((t) => t.severity == 'high').toList();
    
    return Container(
      margin: const EdgeInsets.only(bottom: AppTheme.spacingM),
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: const Color(0xFFEC4899).withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: const Color(0xFFEC4899).withOpacity(0.3),
          width: 2,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.warning_amber_rounded,
                color: const Color(0xFFEC4899),
                size: 20,
              ),
              const SizedBox(width: AppTheme.spacingS),
              Text(
                'RSD Alert',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                  color: isDark ? AppTheme.white : AppTheme.darkGray100,
                ),
              ),
            ],
          ),
          const SizedBox(height: AppTheme.spacingS),
          Text(
            highSeverity.isNotEmpty
                ? highSeverity.first.explanation
                : triggers.first.explanation,
            style: TextStyle(
              fontSize: 14,
              color: isDark ? AppTheme.gray400 : AppTheme.gray700,
            ),
          ),
        ],
      ),
    );
  }

  /// Interpret button
  Widget _buildInterpretButton(bool isDark) {
    return FilledButton.icon(
      onPressed: _isLoadingInterpretation ? null : _interpretMessage,
      icon: _isLoadingInterpretation
          ? const SizedBox(
              width: 16,
              height: 16,
              child: CircularProgressIndicator(strokeWidth: 2),
            )
          : const Icon(Icons.psychology_outlined, size: 20),
      label: Text(
        _isLoadingInterpretation
            ? 'Analyzing...'
            : 'Get Deeper Interpretation',
      ),
      style: FilledButton.styleFrom(
        backgroundColor: const Color(0xFF7C3AED),
        padding: const EdgeInsets.symmetric(
          horizontal: AppTheme.spacingM,
          vertical: 12,
        ),
      ),
    );
  }

  /// Expandable section with progressive disclosure
  Widget _buildExpandableSection(
    String id,
    String title,
    IconData icon,
    bool isDark,
    Widget Function() contentBuilder,
  ) {
    final isExpanded = _expandedSection == id;
    
    return Container(
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        children: [
          InkWell(
            onTap: () {
              setState(() {
                _expandedSection = isExpanded ? null : id;
              });
            },
            borderRadius: BorderRadius.circular(12),
            child: Padding(
              padding: const EdgeInsets.all(AppTheme.spacingM),
              child: Row(
                children: [
                  Icon(
                    icon,
                    size: 20,
                    color: isDark ? AppTheme.gray400 : AppTheme.gray600,
                  ),
                  const SizedBox(width: AppTheme.spacingS),
                  Expanded(
                    child: Text(
                      title,
                      style: TextStyle(
                        fontSize: 15,
                        fontWeight: FontWeight.w600,
                        color: isDark ? AppTheme.white : AppTheme.darkGray100,
                      ),
                    ),
                  ),
                  Icon(
                    isExpanded ? Icons.expand_less_rounded : Icons.expand_more_rounded,
                    color: isDark ? AppTheme.gray400 : AppTheme.gray600,
                  ),
                ],
              ),
            ),
          ),
          if (isExpanded)
            Padding(
              padding: const EdgeInsets.fromLTRB(
                AppTheme.spacingM,
                0,
                AppTheme.spacingM,
                AppTheme.spacingM,
              ),
              child: contentBuilder(),
            ),
        ],
      ),
    );
  }

  /// Details section content
  Widget _buildDetailsSection(AIAnalysis analysis, bool isDark) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (analysis.confidenceScore != null) ...[
          _buildDetailItem(
            'Confidence',
            '${(analysis.confidenceScore! * 100).toStringAsFixed(0)}%',
            isDark,
          ),
          const SizedBox(height: AppTheme.spacingS),
        ],
        if (analysis.contextFlags != null && analysis.contextFlags!.isNotEmpty)
          ...analysis.contextFlags!.entries
              .where((e) => e.value == true)
              .map((e) => Padding(
                    padding: const EdgeInsets.only(bottom: AppTheme.spacingXS),
                    child: _buildDetailItem(
                      _formatFlag(e.key),
                      '‚úì',
                      isDark,
                    ),
                  )),
      ],
    );
  }

  /// Interpretations section content
  Widget _buildInterpretationsSection(List<MessageInterpretation> interps, bool isDark) {
    return Column(
      children: interps.map((interp) {
        return Container(
          margin: const EdgeInsets.only(bottom: AppTheme.spacingS),
          padding: const EdgeInsets.all(AppTheme.spacingS),
          decoration: BoxDecoration(
            color: isDark ? AppTheme.darkGray100 : AppTheme.white,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                    decoration: BoxDecoration(
                      color: _getLikelihoodColor(interp.likelihood).withOpacity(0.2),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      '${interp.likelihood}%',
                      style: TextStyle(
                        fontSize: 11,
                        fontWeight: FontWeight.w600,
                        color: _getLikelihoodColor(interp.likelihood),
                      ),
                    ),
                  ),
                  const SizedBox(width: AppTheme.spacingXS),
                  Expanded(
                    child: Text(
                      interp.interpretation,
                      style: TextStyle(
                        fontSize: 14,
                        fontWeight: FontWeight.w500,
                        color: isDark ? AppTheme.white : AppTheme.darkGray100,
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        );
      }).toList(),
    );
  }

  /// Evidence section content
  Widget _buildEvidenceSection(List<Evidence> evidence, bool isDark) {
    return Column(
      children: evidence.map((e) {
        return Container(
          margin: const EdgeInsets.only(bottom: AppTheme.spacingXS),
          padding: const EdgeInsets.all(AppTheme.spacingS),
          decoration: BoxDecoration(
            color: isDark ? AppTheme.darkGray100 : AppTheme.white,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Row(
            children: [
              Icon(
                Icons.format_quote,
                size: 16,
                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
              ),
              const SizedBox(width: AppTheme.spacingXS),
              Expanded(
                child: Text(
                  e.quote,
                  style: TextStyle(
                    fontSize: 13,
                    fontStyle: FontStyle.italic,
                    color: isDark ? AppTheme.gray400 : AppTheme.gray700,
                  ),
                ),
              ),
            ],
          ),
        );
      }).toList(),
    );
  }

  Widget _buildChip(String label, Color color, bool isDark) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
      decoration: BoxDecoration(
        color: color.withOpacity(0.15),
        borderRadius: BorderRadius.circular(6),
      ),
      child: Text(
        label,
        style: TextStyle(
          fontSize: 12,
          fontWeight: FontWeight.w600,
          color: color,
        ),
      ),
    );
  }

  Widget _buildDetailItem(String label, String value, bool isDark) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          label,
          style: TextStyle(
            fontSize: 14,
            color: isDark ? AppTheme.gray500 : AppTheme.gray600,
          ),
        ),
        Text(
          value,
          style: TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            color: isDark ? AppTheme.white : AppTheme.darkGray100,
          ),
        ),
      ],
    );
  }

  // Helper methods
  Color _getToneColor(String tone) {
    final lower = tone.toLowerCase();
    if (lower.contains('urgent') || lower.contains('critical')) return Colors.red;
    if (lower.contains('sad') || lower.contains('disappointed')) return Colors.blue;
    if (lower.contains('angry') || lower.contains('frustrated')) return Colors.orange;
    if (lower.contains('happy') || lower.contains('excited')) return Colors.green;
    return const Color(0xFF7C3AED);
  }

  IconData _getToneIcon(String tone) {
    final lower = tone.toLowerCase();
    if (lower.contains('urgent') || lower.contains('critical')) return Icons.error_rounded;
    if (lower.contains('sad')) return Icons.sentiment_dissatisfied_rounded;
    if (lower.contains('angry')) return Icons.sentiment_very_dissatisfied_rounded;
    if (lower.contains('happy')) return Icons.sentiment_satisfied_rounded;
    return Icons.sentiment_neutral_rounded;
  }

  Color _getUrgencyColor(String? urgency) {
    switch (urgency?.toLowerCase()) {
      case 'critical':
        return const Color(0xFFEF4444);
      case 'high':
        return const Color(0xFFF59E0B);
      case 'medium':
        return const Color(0xFF06B6D4);
      default:
        return const Color(0xFF10B981);
    }
  }

  Color _getLikelihoodColor(int likelihood) {
    if (likelihood >= 70) return Colors.green;
    if (likelihood >= 40) return Colors.orange;
    return Colors.red;
  }

  String _formatFlag(String flag) {
    return flag.replaceAll('_', ' ').split(' ').map((w) => 
      w[0].toUpperCase() + w.substring(1)
    ).join(' ');
  }
}
</file>

<file path="frontend/lib/features/settings/widgets/ai_feature_tile.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/ai_feature.dart';
import 'package:messageai/core/theme/app_theme.dart';

/// Expandable tile showing AI feature information and toggle
class AIFeatureTile extends StatefulWidget {
  final AIFeature feature;
  final Function(bool) onToggle;
  final VoidCallback? onMoreInfo;

  const AIFeatureTile({
    Key? key,
    required this.feature,
    required this.onToggle,
    this.onMoreInfo,
  }) : super(key: key);

  @override
  State<AIFeatureTile> createState() => _AIFeatureTileState();
}

class _AIFeatureTileState extends State<AIFeatureTile> {
  bool _isExpanded = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final config = widget.feature.config;

    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray200 : AppTheme.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: config.color.withOpacity(0.2),
          width: 1,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        children: [
          // Header (always visible)
          InkWell(
            onTap: () => setState(() => _isExpanded = !_isExpanded),
            borderRadius: const BorderRadius.vertical(top: Radius.circular(12)),
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Row(
                children: [
                  // Icon
                  Container(
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                      color: config.color.withOpacity(0.15),
                      borderRadius: BorderRadius.circular(10),
                    ),
                    child: Icon(
                      config.icon,
                      color: config.color,
                      size: 24,
                    ),
                  ),
                  
                  const SizedBox(width: 16),
                  
                  // Title and status
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          config.title,
                          style: theme.textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                        const SizedBox(height: 4),
                        // üÜï Color-coded checkmark instead of badge
                        Row(
                          children: [
                            Icon(
                              widget.feature.isEnabled 
                                  ? Icons.check_circle
                                  : Icons.circle_outlined,
                              size: 18,
                              color: widget.feature.isEnabled 
                                  ? config.color
                                  : (isDark ? AppTheme.gray500 : AppTheme.gray400),
                            ),
                            const SizedBox(width: 6),
                            Text(
                              widget.feature.isEnabled ? 'Enabled' : 'Disabled',
                              style: TextStyle(
                                fontSize: 12,
                                fontWeight: FontWeight.w500,
                                color: widget.feature.isEnabled
                                    ? config.color
                                    : (isDark ? AppTheme.gray500 : AppTheme.gray600),
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                  
                  // Toggle + Expand
                  Switch(
                    value: widget.feature.isEnabled,
                    onChanged: widget.onToggle,
                    activeColor: config.color,
                  ),
                  
                  IconButton(
                    icon: Icon(
                      _isExpanded ? Icons.expand_less : Icons.expand_more,
                      color: isDark ? AppTheme.gray400 : AppTheme.gray600,
                    ),
                    onPressed: () => setState(() => _isExpanded = !_isExpanded),
                  ),
                ],
              ),
            ),
          ),
          
          // Expandable details
          if (_isExpanded) ...[
            Divider(
              height: 1,
              color: config.color.withOpacity(0.1),
            ),
            Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Description
                  Text(
                    config.description,
                    style: TextStyle(
                      fontSize: 14,
                      color: isDark ? AppTheme.gray300 : AppTheme.gray700,
                      height: 1.5,
                    ),
                  ),
                  
                  const SizedBox(height: 16),
                  
                  // What the AI does
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: config.color.withOpacity(0.05),
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(
                        color: config.color.withOpacity(0.2),
                      ),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            Icon(
                              Icons.auto_awesome,
                              size: 16,
                              color: config.color,
                            ),
                            const SizedBox(width: 6),
                            Text(
                              'What the AI does:',
                              style: TextStyle(
                                fontSize: 13,
                                fontWeight: FontWeight.w600,
                                color: config.color,
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 8),
                        ...config.whatItDoes.map((action) {
                          return Padding(
                            padding: const EdgeInsets.only(bottom: 4),
                            child: Row(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  '‚Ä¢ ',
                                  style: TextStyle(
                                    color: config.color,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                                Expanded(
                                  child: Text(
                                    action,
                                    style: TextStyle(
                                      fontSize: 13,
                                      color: isDark
                                          ? AppTheme.gray300
                                          : AppTheme.gray700,
                                      height: 1.4,
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          );
                        }).toList(),
                      ],
                    ),
                  ),
                  
                  const SizedBox(height: 12),
                  
                  // Where it appears
                  Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Icon(
                        Icons.location_on_outlined,
                        size: 14,
                        color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                      ),
                      const SizedBox(width: 6),
                      Expanded(
                        child: Text(
                          config.location,
                          style: TextStyle(
                            fontSize: 12,
                            color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                            fontStyle: FontStyle.italic,
                          ),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/gen/api/api.dart">
// Generated API models and clients
export 'models/message_payload.dart';
export 'models/receipt_payload.dart';
export 'clients/messages_api.dart';
export 'clients/receipts_api.dart';
</file>

<file path="frontend/lib/gen/api/clients/messages_api.dart">
import 'package:dio/dio.dart';
import '../models/message_payload.dart';

/// API client for message operations
class MessagesApi {
  final Dio dio;
  final String baseUrl;

  MessagesApi({
    required this.dio,
    required this.baseUrl,
  });

  /// Send a message to the backend
  /// 
  /// [message] - The message payload to send
  /// 
  /// Returns the response from the server
  Future<Response> send(MessagePayload message) async {
    try {
      final response = await dio.post(
        '$baseUrl/v1/messages.send',
        data: message.toJson(),
      );
      return response;
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Exception _handleDioError(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.receiveTimeout:
      case DioExceptionType.sendTimeout:
        return Exception('Connection timeout: ${e.message}');
      case DioExceptionType.badResponse:
        return Exception(
          'Server error: ${e.response?.statusCode} - ${e.response?.data}',
        );
      case DioExceptionType.cancel:
        return Exception('Request cancelled');
      default:
        return Exception('Network error: ${e.message}');
    }
  }
}
</file>

<file path="frontend/lib/gen/api/clients/receipts_api.dart">
import 'package:dio/dio.dart';
import '../models/receipt_payload.dart';

/// API client for receipt operations
class ReceiptsApi {
  final Dio dio;
  final String baseUrl;

  ReceiptsApi({
    required this.dio,
    required this.baseUrl,
  });

  /// Acknowledge message receipts to the backend
  /// 
  /// [receipt] - The receipt payload to send
  /// 
  /// Returns the response from the server
  Future<Response> ack(ReceiptPayload receipt) async {
    try {
      final response = await dio.post(
        '$baseUrl/v1/receipts.ack',
        data: receipt.toJson(),
      );
      return response;
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Exception _handleDioError(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.receiveTimeout:
      case DioExceptionType.sendTimeout:
        return Exception('Connection timeout: ${e.message}');
      case DioExceptionType.badResponse:
        return Exception(
          'Server error: ${e.response?.statusCode} - ${e.response?.data}',
        );
      case DioExceptionType.cancel:
        return Exception('Request cancelled');
      default:
        return Exception('Network error: ${e.message}');
    }
  }
}
</file>

<file path="frontend/lib/gen/api/models/message_payload.dart">
class MessagePayload {
  final String id;
  final String conversationId;
  final String? body;

  MessagePayload({
    required this.id,
    required this.conversationId,
    this.body,
  });

  factory MessagePayload.fromJson(Map<String, dynamic> json) {
    return MessagePayload(
      id: json['id'] as String,
      conversationId: json['conversation_id'] as String,
      body: json['body'] as String?,
    );
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'conversation_id': conversationId,
        if (body != null) 'body': body,
      };

  @override
  String toString() =>
      'MessagePayload(id: $id, conversationId: $conversationId, body: $body)';
}
</file>

<file path="frontend/lib/gen/api/models/receipt_payload.dart">
enum ReceiptStatus {
  delivered,
  read;

  static ReceiptStatus fromString(String value) {
    return ReceiptStatus.values.firstWhere(
      (e) => e.name == value,
      orElse: () => throw ArgumentError('Unknown status: $value'),
    );
  }

  String toValue() => name;
}

class ReceiptPayload {
  final List<String> messageIds;
  final ReceiptStatus status;

  ReceiptPayload({
    required this.messageIds,
    required this.status,
  });

  factory ReceiptPayload.fromJson(Map<String, dynamic> json) {
    return ReceiptPayload(
      messageIds: List<String>.from(json['message_ids'] as List),
      status: ReceiptStatus.fromString(json['status'] as String),
    );
  }

  Map<String, dynamic> toJson() => {
        'message_ids': messageIds,
        'status': status.toValue(),
      };

  @override
  String toString() =>
      'ReceiptPayload(messageIds: $messageIds, status: ${status.name})';
}
</file>

<file path="frontend/lib/models/action_item.dart">
/// Model for action item details
class ActionItem {
  final String id;
  final String followUpItemId;
  final String actionType;
  final String? actionTarget;
  final String commitmentText;
  final String? mentionedDeadline;
  final int? extractedDeadline;

  ActionItem({
    required this.id,
    required this.followUpItemId,
    required this.actionType,
    this.actionTarget,
    required this.commitmentText,
    this.mentionedDeadline,
    this.extractedDeadline,
  });

  factory ActionItem.fromJson(Map<String, dynamic> json) {
    return ActionItem(
      id: json['id'] as String,
      followUpItemId: json['follow_up_item_id'] as String,
      actionType: json['action_type'] as String,
      actionTarget: json['action_target'] as String?,
      commitmentText: json['commitment_text'] as String,
      mentionedDeadline: json['mentioned_deadline'] as String?,
      extractedDeadline: json['extracted_deadline'] as int?,
    );
  }

  String getActionEmoji() {
    switch (actionType.toLowerCase()) {
      case 'send':
        return 'üì§';
      case 'call':
        return 'üìû';
      case 'meet':
        return 'ü§ù';
      case 'review':
        return 'üìã';
      case 'decide':
        return 'ü§î';
      case 'follow_up':
        return 'üîÑ';
      case 'check':
        return '‚úÖ';
      case 'schedule':
        return 'üìÖ';
      default:
        return 'üìå';
    }
  }
}
</file>

<file path="frontend/lib/models/ai_feature.dart">
import 'package:flutter/material.dart';

/// AI feature types
enum AIFeatureType {
  smartMessageInterpreter,
  adaptiveResponseAssistant,
  smartInboxFilters,
  ragContextPanel,
}

/// Configuration for each AI feature
class AIFeatureConfig {
  final AIFeatureType type;
  final String title;
  final IconData icon;
  final Color color;
  final String description;
  final List<String> whatItDoes;
  final String location;

  const AIFeatureConfig({
    required this.type,
    required this.title,
    required this.icon,
    required this.color,
    required this.description,
    required this.whatItDoes,
    required this.location,
  });

  static const Map<AIFeatureType, AIFeatureConfig> configs = {
    AIFeatureType.smartMessageInterpreter: AIFeatureConfig(
      type: AIFeatureType.smartMessageInterpreter,
      title: 'Smart Message Interpreter',
      icon: Icons.psychology_outlined,
      color: Colors.purple,
      description:
          'Analyzes incoming messages to help you understand tone, detect RSD triggers, explain literal vs figurative language, and identify boundary violations.',
      whatItDoes: [
        'Analyzes emotional tone and sentiment',
        'Detects RSD (Rejection Sensitive Dysphoria) triggers',
        'Explains idioms and figurative language',
        'Identifies boundary violations (after-hours, pressure language, etc.)',
        'Provides evidence for its analysis',
        'Suggests boundary-respecting responses',
      ],
      location: 'Tone badges on each incoming message, expandable detail sheet',
    ),
    AIFeatureType.adaptiveResponseAssistant: AIFeatureConfig(
      type: AIFeatureType.adaptiveResponseAssistant,
      title: 'Adaptive Response Assistant',
      icon: Icons.edit_note_outlined,
      color: Colors.blue,
      description:
          'Provides feedback on your drafted replies when you manually request it, analyzing the situation and suggesting appropriate templates and formatting options.',
      whatItDoes: [
        'Analyzes your draft message when you request it',
        'Detects the situation (declining, setting boundaries, info-dumping, etc.)',
        'Checks tone, clarity, and appropriateness',
        'Suggests social scripts and templates',
        'Offers formatting options (condense, break into chunks)',
        'Warns about potential issues before you send',
      ],
      location: 'Draft feedback panel when composing messages',
    ),
    AIFeatureType.smartInboxFilters: AIFeatureConfig(
      type: AIFeatureType.smartInboxFilters,
      title: 'Smart Inbox Filters',
      icon: Icons.filter_list_outlined,
      color: Colors.indigo,
      description:
          'Automatically categorizes and prioritizes your inbox based on message content, sender, and context to help you focus on the most important communications.',
      whatItDoes: [
        'Categorizes messages by type (email, chat, etc.)',
        'Prioritizes based on urgency and importance',
        'Filters out spam and low-priority messages',
        'Sorts conversations by relevance',
        'Helps identify important follow-ups',
        'Reduces manual sorting time',
      ],
      location: 'Inbox view, filter chips on conversation list',
    ),
    AIFeatureType.ragContextPanel: AIFeatureConfig(
      type: AIFeatureType.ragContextPanel,
      title: 'RAG Context Panel',
      icon: Icons.memory_outlined,
      color: Colors.green,
      description:
          'Provides a rich, context-aware interface for accessing and managing your long-term memory and knowledge base, enabling the AI to draw on past interactions and experiences.',
      whatItDoes: [
        'Accesses and manages your long-term memory',
        'Draws on past interactions and experiences',
        'Provides context for current conversation',
        'Helps the AI understand your preferences and patterns',
        'Enables the AI to learn from past conversations',
        'Improves its ability to provide relevant responses',
      ],
      location: 'Context panel at top of conversation (expandable header)',
    ),
  };
}

/// AI Feature state model
class AIFeature {
  final AIFeatureType type;
  bool isEnabled;

  AIFeature({
    required this.type,
    this.isEnabled = true,
  });

  AIFeatureConfig get config => AIFeatureConfig.configs[type]!;
}
</file>

<file path="frontend/lib/models/context_trigger.dart">
/// Model for context triggers
class ContextTrigger {
  final String id;
  final String userId;
  final String followUpItemId;
  final String triggerType;
  final Map<String, dynamic> triggerConfig;
  final bool isActive;
  final int? lastTriggered;
  final int triggerCount;
  final int createdAt;
  final int updatedAt;

  ContextTrigger({
    required this.id,
    required this.userId,
    required this.followUpItemId,
    required this.triggerType,
    required this.triggerConfig,
    required this.isActive,
    this.lastTriggered,
    required this.triggerCount,
    required this.createdAt,
    required this.updatedAt,
  });

  factory ContextTrigger.fromJson(Map<String, dynamic> json) {
    return ContextTrigger(
      id: json['id'] as String,
      userId: json['user_id'] as String,
      followUpItemId: json['follow_up_item_id'] as String,
      triggerType: json['trigger_type'] as String,
      triggerConfig: json['trigger_config'] as Map<String, dynamic>,
      isActive: json['is_active'] as bool? ?? true,
      lastTriggered: json['last_triggered'] as int?,
      triggerCount: json['trigger_count'] as int? ?? 0,
      createdAt: json['created_at'] as int,
      updatedAt: json['updated_at'] as int,
    );
  }

  String getTriggerLabel() {
    switch (triggerType) {
      case 'app_opened':
        final app = triggerConfig['app'] as String?;
        return 'When you open ${app ?? "the app"}';
      case 'calendar_event':
        final event = triggerConfig['event'] as String?;
        return 'Before ${event ?? "calendar event"}';
      case 'location':
        final location = triggerConfig['location'] as String?;
        return 'At ${location ?? "this location"}';
      case 'time_of_day':
        final time = triggerConfig['time'] as String?;
        return 'At $time';
      case 'day_of_week':
        final day = triggerConfig['day'] as String?;
        return 'Every $day';
      default:
        return 'Context trigger';
    }
  }

  String getTriggerEmoji() {
    switch (triggerType) {
      case 'app_opened':
        return 'üì±';
      case 'calendar_event':
        return 'üìÖ';
      case 'location':
        return 'üìç';
      case 'time_of_day':
        return '‚è∞';
      case 'day_of_week':
        return 'üìÜ';
      default:
        return 'üîî';
    }
  }
}
</file>

<file path="frontend/lib/models/conversation_filter.dart">
import 'package:flutter/material.dart';

/// Available conversation filters
enum ConversationFilter {
  all,
  urgent,          // Smart Inbox: AI detected high priority
  rsd,             // Smart Inbox: Contains RSD triggers
  boundary,        // Smart Inbox: Boundary violations detected
  unanswered,      // Follow-up: They asked you questions
  tasks,           // Follow-up: You made promises
  overdue,         // Follow-up: Deadline passed
}

/// Configuration for each filter
class ConversationFilterConfig {
  final ConversationFilter filter;
  final String label;
  final IconData icon;
  final Color color;
  
  const ConversationFilterConfig({
    required this.filter,
    required this.label,
    required this.icon,
    required this.color,
  });
  
  static const Map<ConversationFilter, ConversationFilterConfig> configs = {
    ConversationFilter.all: ConversationFilterConfig(
      filter: ConversationFilter.all,
      label: 'All',
      icon: Icons.inbox_rounded,
      color: Colors.grey,
    ),
    ConversationFilter.urgent: ConversationFilterConfig(
      filter: ConversationFilter.urgent,
      label: 'Urgent',
      icon: Icons.priority_high_rounded,
      color: Colors.red,
    ),
    ConversationFilter.rsd: ConversationFilterConfig(
      filter: ConversationFilter.rsd,
      label: 'RSD',
      icon: Icons.warning_amber_rounded,
      color: Colors.orange,
    ),
    ConversationFilter.boundary: ConversationFilterConfig(
      filter: ConversationFilter.boundary,
      label: 'Boundary',
      icon: Icons.shield_outlined,
      color: Colors.purple,
    ),
    ConversationFilter.unanswered: ConversationFilterConfig(
      filter: ConversationFilter.unanswered,
      label: 'Unanswered',
      icon: Icons.help_outline_rounded,
      color: Colors.blue,
    ),
    ConversationFilter.tasks: ConversationFilterConfig(
      filter: ConversationFilter.tasks,
      label: 'Tasks',
      icon: Icons.task_alt_rounded,
      color: Colors.green,
    ),
    ConversationFilter.overdue: ConversationFilterConfig(
      filter: ConversationFilter.overdue,
      label: 'Overdue',
      icon: Icons.schedule_rounded,
      color: Colors.deepOrange,
    ),
  };
}
</file>

<file path="frontend/lib/models/conversation_with_metadata.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/models/conversation_filter.dart';

/// Conversation with metadata for filtering
class ConversationWithMetadata {
  final Conversation conversation;
  final bool hasUrgentMessages;
  final bool hasRSDTriggers;
  final bool hasBoundaryViolations;
  final int unansweredCount;
  final int taskCount;
  final int overdueCount;
  
  ConversationWithMetadata({
    required this.conversation,
    this.hasUrgentMessages = false,
    this.hasRSDTriggers = false,
    this.hasBoundaryViolations = false,
    this.unansweredCount = 0,
    this.taskCount = 0,
    this.overdueCount = 0,
  });
  
  /// Check if conversation matches a filter
  bool matchesFilter(ConversationFilter filter) {
    switch (filter) {
      case ConversationFilter.all:
        return true;
      case ConversationFilter.urgent:
        return hasUrgentMessages;
      case ConversationFilter.rsd:
        return hasRSDTriggers;
      case ConversationFilter.boundary:
        return hasBoundaryViolations;
      case ConversationFilter.unanswered:
        return unansweredCount > 0;
      case ConversationFilter.tasks:
        return taskCount > 0;
      case ConversationFilter.overdue:
        return overdueCount > 0;
    }
  }
  
  /// Check if conversation matches any of the given filters
  bool matchesAnyFilter(Set<ConversationFilter> filters) {
    if (filters.isEmpty || filters.contains(ConversationFilter.all)) {
      return true;
    }
    return filters.any((filter) => matchesFilter(filter));
  }
  
  /// Get all active flags for this conversation
  Set<ConversationFilter> getActiveFilters() {
    final active = <ConversationFilter>{};
    if (hasUrgentMessages) active.add(ConversationFilter.urgent);
    if (hasRSDTriggers) active.add(ConversationFilter.rsd);
    if (hasBoundaryViolations) active.add(ConversationFilter.boundary);
    if (unansweredCount > 0) active.add(ConversationFilter.unanswered);
    if (taskCount > 0) active.add(ConversationFilter.tasks);
    if (overdueCount > 0) active.add(ConversationFilter.overdue);
    return active;
  }
}
</file>

<file path="frontend/lib/models/draft_analysis.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/situation_type.dart';
import 'package:messageai/models/response_template.dart';

/// Model for draft message analysis results
/// Extends tone analysis with confidence scoring and suggestions
class DraftAnalysis {
  // Tone analysis fields
  final String tone;
  final String? intensity;
  final String? urgencyLevel;
  final String? intent;
  final Map<String, dynamic>? contextFlags;
  final String? reasoning;
  
  // Draft-specific fields
  final int confidenceScore; // 0-100
  final AppropriatenessLevel appropriateness;
  final List<String> suggestions;
  final List<String> warnings;
  final List<String> strengths;
  
  // ‚úÖ NEW: Phase 2 fields
  final SituationDetection? situationDetection;
  final List<ResponseTemplate>? suggestedTemplates;

  const DraftAnalysis({
    required this.tone,
    this.intensity,
    this.urgencyLevel,
    this.intent,
    this.contextFlags,
    this.reasoning,
    required this.confidenceScore,
    required this.appropriateness,
    required this.suggestions,
    required this.warnings,
    required this.strengths,
    // NEW
    this.situationDetection,
    this.suggestedTemplates,
  });

  factory DraftAnalysis.fromJson(Map<String, dynamic> json) {
    return DraftAnalysis(
      // Tone fields
      tone: json['tone'] as String,
      intensity: json['intensity'] as String?,
      urgencyLevel: json['urgency_level'] as String?,
      intent: json['intent'] as String?,
      contextFlags: json['context_flags'] as Map<String, dynamic>?,
      reasoning: json['reasoning'] as String?,
      
      // Draft fields
      confidenceScore: json['confidence_score'] as int,
      appropriateness: AppropriatenessLevel.fromString(
        json['appropriateness'] as String,
      ),
      suggestions: (json['suggestions'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ?? [],
      warnings: (json['warnings'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ?? [],
      strengths: (json['strengths'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ?? [],
      
      // NEW: Phase 2 fields
      situationDetection: json['situation_detection'] != null
          ? SituationDetection.fromJson(json['situation_detection'] as Map<String, dynamic>)
          : null,
      suggestedTemplates: (json['suggested_templates'] as List<dynamic>?)
          ?.map((e) => ResponseTemplate.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  /// Get color based on confidence score
  Color getConfidenceColor() {
    if (confidenceScore >= 90) return Colors.green;
    if (confidenceScore >= 75) return Colors.lightGreen;
    if (confidenceScore >= 60) return Colors.orange;
    return Colors.red;
  }

  /// Get icon based on appropriateness
  IconData getAppropriatenessIcon() {
    switch (appropriateness) {
      case AppropriatenessLevel.excellent:
        return Icons.check_circle;
      case AppropriatenessLevel.good:
        return Icons.thumb_up;
      case AppropriatenessLevel.okay:
        return Icons.info;
      case AppropriatenessLevel.needsWork:
        return Icons.warning;
    }
  }

  /// Get brief status message
  String getStatusMessage() {
    if (confidenceScore >= 90) return 'Ready to send!';
    if (confidenceScore >= 75) return 'Looking good';
    if (confidenceScore >= 60) return 'Could be improved';
    return 'Needs revision';
  }
}

enum AppropriatenessLevel {
  excellent('excellent'),
  good('good'),
  okay('okay'),
  needsWork('needs_work');

  final String value;
  const AppropriatenessLevel(this.value);

  static AppropriatenessLevel fromString(String value) {
    return AppropriatenessLevel.values.firstWhere(
      (e) => e.value == value,
      orElse: () => AppropriatenessLevel.okay,
    );
  }

  String get displayName {
    switch (this) {
      case AppropriatenessLevel.excellent:
        return 'Excellent';
      case AppropriatenessLevel.good:
        return 'Good';
      case AppropriatenessLevel.okay:
        return 'Okay';
      case AppropriatenessLevel.needsWork:
        return 'Needs Work';
    }
  }
}

enum RelationshipType {
  boss('boss', 'Boss/Manager'),
  colleague('colleague', 'Colleague'),
  friend('friend', 'Friend'),
  family('family', 'Family'),
  client('client', 'Client'),
  none('none', 'Not specified');

  final String value;
  final String displayName;
  const RelationshipType(this.value, this.displayName);

  static RelationshipType fromString(String? value) {
    if (value == null) return RelationshipType.none;
    return RelationshipType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => RelationshipType.none,
    );
  }

  IconData get icon {
    switch (this) {
      case RelationshipType.boss:
        return Icons.business;
      case RelationshipType.colleague:
        return Icons.people;
      case RelationshipType.friend:
        return Icons.emoji_people;
      case RelationshipType.family:
        return Icons.family_restroom;
      case RelationshipType.client:
        return Icons.handshake;
      case RelationshipType.none:
        return Icons.help_outline;
    }
  }
}
</file>

<file path="frontend/lib/models/draft_confidence.dart">
/// Result of draft confidence analysis (Phase 2: Response Assistant)
class DraftConfidence {
  final String draft;
  final int overallScore;
  final Map<String, int> scores;
  final List<String> strengths;
  final List<String> weaknesses;
  final List<String> suggestions;
  final bool readyToSend;

  DraftConfidence({
    required this.draft,
    required this.overallScore,
    required this.scores,
    required this.strengths,
    required this.weaknesses,
    required this.suggestions,
    required this.readyToSend,
  });

  factory DraftConfidence.fromJson(Map<String, dynamic> json) {
    return DraftConfidence(
      draft: json['draft'] as String? ?? '',
      overallScore: json['overall_score'] as int? ?? 0,
      scores: (json['scores'] as Map<String, dynamic>?)?.map(
            (key, value) => MapEntry(key, value as int),
          ) ??
          {},
      strengths: (json['strengths'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          [],
      weaknesses: (json['weaknesses'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          [],
      suggestions: (json['suggestions'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          [],
      readyToSend: json['ready_to_send'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'draft': draft,
      'overall_score': overallScore,
      'scores': scores,
      'strengths': strengths,
      'weaknesses': weaknesses,
      'suggestions': suggestions,
      'ready_to_send': readyToSend,
    };
  }

  /// Get confidence level as a string
  String get confidenceLevel {
    if (overallScore >= 80) return 'High';
    if (overallScore >= 60) return 'Medium';
    return 'Low';
  }

  /// Get color for confidence level
  String get confidenceColor {
    if (overallScore >= 80) return 'green';
    if (overallScore >= 60) return 'orange';
    return 'red';
  }

  bool get hasStrengths => strengths.isNotEmpty;
  bool get hasWeaknesses => weaknesses.isNotEmpty;
  bool get hasSuggestions => suggestions.isNotEmpty;

  @override
  String toString() {
    return 'DraftConfidence(score: $overallScore%, level: $confidenceLevel, ready: $readyToSend)';
  }
}
</file>

<file path="frontend/lib/models/follow_up_item.dart">
import 'package:flutter/material.dart';

/// Follow-up item types
enum FollowUpItemType {
  actionItem('action_item', 'Action Item', Icons.task_alt),
  unansweredQuestion('unanswered_question', 'Unanswered Question', Icons.help_outline),
  pendingResponse('pending_response', 'Pending Response', Icons.pending),
  scheduledFollowup('scheduled_followup', 'Scheduled', Icons.schedule);

  final String value;
  final String displayName;
  final IconData icon;

  const FollowUpItemType(this.value, this.displayName, this.icon);

  static FollowUpItemType fromString(String value) {
    return FollowUpItemType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => FollowUpItemType.pendingResponse,
    );
  }

  Color getColor() {
    switch (this) {
      case FollowUpItemType.actionItem:
        return Colors.orange;
      case FollowUpItemType.unansweredQuestion:
        return Colors.blue;
      case FollowUpItemType.pendingResponse:
        return Colors.purple;
      case FollowUpItemType.scheduledFollowup:
        return Colors.green;
    }
  }
}

/// Follow-up item status
enum FollowUpStatus {
  pending('pending'),
  completed('completed'),
  dismissed('dismissed'),
  snoozed('snoozed');

  final String value;
  const FollowUpStatus(this.value);

  static FollowUpStatus fromString(String value) {
    return FollowUpStatus.values.firstWhere(
      (e) => e.value == value,
      orElse: () => FollowUpStatus.pending,
    );
  }
}

/// Model for follow-up item
class FollowUpItem {
  final String id;
  final String userId;
  final String conversationId;
  final String? messageId;
  final FollowUpItemType itemType;
  final String title;
  final String? description;
  final String? extractedText;
  final FollowUpStatus status;
  final int priority;
  final int detectedAt;
  final int? dueAt;
  final int? remindAt;
  final int? snoozedUntil;
  final int? completedAt;
  final Map<String, dynamic>? triggers;

  FollowUpItem({
    required this.id,
    required this.userId,
    required this.conversationId,
    this.messageId,
    required this.itemType,
    required this.title,
    this.description,
    this.extractedText,
    required this.status,
    required this.priority,
    required this.detectedAt,
    this.dueAt,
    this.remindAt,
    this.snoozedUntil,
    this.completedAt,
    this.triggers,
  });

  factory FollowUpItem.fromJson(Map<String, dynamic> json) {
    return FollowUpItem(
      id: json['item_id'] as String? ?? json['id'] as String,
      userId: json['user_id'] as String,
      conversationId: json['conversation_id'] as String,
      messageId: json['message_id'] as String?,
      itemType: FollowUpItemType.fromString(json['item_type'] as String),
      title: json['title'] as String,
      description: json['description'] as String?,
      extractedText: json['extracted_text'] as String?,
      status: FollowUpStatus.fromString(json['status'] as String? ?? 'pending'),
      priority: json['priority'] as int,
      detectedAt: json['detected_at'] as int,
      dueAt: json['due_at'] as int?,
      remindAt: json['remind_at'] as int?,
      snoozedUntil: json['snoozed_until'] as int?,
      completedAt: json['completed_at'] as int?,
      triggers: json['triggers'] as Map<String, dynamic>?,
    );
  }

  bool get isOverdue {
    if (dueAt == null) return false;
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    return now > dueAt!;
  }

  bool get isDueSoon {
    if (dueAt == null) return false;
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final hoursUntilDue = (dueAt! - now) / 3600;
    return hoursUntilDue > 0 && hoursUntilDue <= 24;
  }

  String getTimeUntilDue() {
    if (dueAt == null) return '';
    
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final diff = dueAt! - now;
    
    if (diff < 0) return 'Overdue';
    if (diff < 3600) return '${diff ~/ 60}m';
    if (diff < 86400) return '${diff ~/ 3600}h';
    return '${diff ~/ 86400}d';
  }

  String getTimeSinceDetected() {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final diff = now - detectedAt;
    
    if (diff < 3600) return '${diff ~/ 60}m ago';
    if (diff < 86400) return '${diff ~/ 3600}h ago';
    return '${diff ~/ 86400}d ago';
  }
}
</file>

<file path="frontend/lib/models/formatted_message.dart">
/// Result of message formatting
class FormattedMessage {
  final int originalLength;
  final String formattedMessage;
  final List<String> formattingApplied;
  final int characterCount;
  final String estimatedReadTime;
  final String? tone;
  final List<String>? actionItems;

  FormattedMessage({
    required this.originalLength,
    required this.formattedMessage,
    required this.formattingApplied,
    required this.characterCount,
    required this.estimatedReadTime,
    this.tone,
    this.actionItems,
  });

  factory FormattedMessage.fromJson(Map<String, dynamic> json) {
    return FormattedMessage(
      originalLength: json['original_length'] as int,
      formattedMessage: json['formatted_message'] as String,
      formattingApplied: (json['formatting_applied'] as List<dynamic>)
          .map((e) => e as String)
          .toList(),
      characterCount: json['character_count'] as int,
      estimatedReadTime: json['estimated_read_time'] as String,
      tone: json['tone'] as String?,
      actionItems: json['action_items'] != null
          ? (json['action_items'] as List<dynamic>)
              .map((e) => e as String)
              .toList()
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'original_length': originalLength,
      'formatted_message': formattedMessage,
      'formatting_applied': formattingApplied,
      'character_count': characterCount,
      'estimated_read_time': estimatedReadTime,
      if (tone != null) 'tone': tone,
      if (actionItems != null) 'action_items': actionItems,
    };
  }

  double getSavingsPercentage() {
    if (originalLength == 0) return 0;
    return ((originalLength - characterCount) / originalLength) * 100;
  }

  @override
  String toString() {
    return 'FormattedMessage(original: $originalLength chars, formatted: $characterCount chars, saved: ${getSavingsPercentage().toStringAsFixed(0)}%)';
  }
}
</file>

<file path="frontend/lib/models/relationship_profile.dart">
/// Model for relationship profile
class RelationshipProfile {
  final String id;
  final String userId;
  final String conversationId;
  final String participantName;
  final String? participantUserId;
  final String? relationshipType;
  final String? relationshipNotes;
  final String? conversationSummary;
  final List<String> safeTopics;
  final List<String> topicsToAvoid;
  final String? communicationStyle;
  final int? typicalResponseTime;
  final int totalMessages;
  final int? firstMessageAt;
  final int? lastMessageAt;

  RelationshipProfile({
    required this.id,
    required this.userId,
    required this.conversationId,
    required this.participantName,
    this.participantUserId,
    this.relationshipType,
    this.relationshipNotes,
    this.conversationSummary,
    this.safeTopics = const [],
    this.topicsToAvoid = const [],
    this.communicationStyle,
    this.typicalResponseTime,
    this.totalMessages = 0,
    this.firstMessageAt,
    this.lastMessageAt,
  });

  factory RelationshipProfile.fromJson(Map<String, dynamic> json) {
    return RelationshipProfile(
      id: json['profile_id'] as String? ?? json['id'] as String,
      userId: json['user_id'] as String,
      conversationId: json['conversation_id'] as String,
      participantName: json['participant_name'] as String,
      participantUserId: json['participant_user_id'] as String?,
      relationshipType: json['relationship_type'] as String?,
      relationshipNotes: json['relationship_notes'] as String?,
      conversationSummary: json['conversation_summary'] as String?,
      safeTopics: (json['safe_topics'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ??
          [],
      topicsToAvoid: (json['topics_to_avoid'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ??
          [],
      communicationStyle: json['communication_style'] as String?,
      typicalResponseTime: json['typical_response_time'] as int?,
      totalMessages: json['total_messages'] as int? ?? 0,
      firstMessageAt: json['first_message_at'] as int?,
      lastMessageAt: json['last_message_at'] as int?,
    );
  }

  String getRelationshipEmoji() {
    switch (relationshipType?.toLowerCase()) {
      case 'boss':
        return 'üëî';
      case 'colleague':
        return 'ü§ù';
      case 'friend':
        return 'üòä';
      case 'family':
        return 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶';
      case 'client':
        return 'üíº';
      default:
        return 'üë§';
    }
  }

  String formatResponseTime() {
    if (typicalResponseTime == null) return 'Unknown';

    final minutes = typicalResponseTime! ~/ 60;
    if (minutes < 60) return '$minutes min';

    final hours = minutes ~/ 60;
    if (hours < 24) return '$hours hr';

    final days = hours ~/ 24;
    return '$days days';
  }
}
</file>

<file path="frontend/lib/models/response_template.dart">
/// Model for response templates
class ResponseTemplate {
  final String id;
  final String name;
  final String situation;
  final String template;
  final String tone; // polite, casual, direct, apologetic
  final List<String> context;
  final bool neurodivergentFriendly;
  final List<String>? customizableFields;

  ResponseTemplate({
    required this.id,
    required this.name,
    required this.situation,
    required this.template,
    required this.tone,
    required this.context,
    required this.neurodivergentFriendly,
    this.customizableFields,
  });

  factory ResponseTemplate.fromJson(Map<String, dynamic> json) {
    return ResponseTemplate(
      id: json['id'] as String,
      name: json['name'] as String,
      situation: json['situation'] as String,
      template: json['template'] as String,
      tone: json['tone'] as String,
      context: (json['context'] as List<dynamic>).map((e) => e as String).toList(),
      neurodivergentFriendly: json['neurodivergent_friendly'] as bool,
      customizableFields: (json['customizable_fields'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'situation': situation,
      'template': template,
      'tone': tone,
      'context': context,
      'neurodivergent_friendly': neurodivergentFriendly,
      if (customizableFields != null) 'customizable_fields': customizableFields,
    };
  }

  /// Fill in customizable fields in the template
  String fillTemplate(Map<String, String> values) {
    String result = template;
    if (customizableFields != null) {
      for (final field in customizableFields!) {
        final value = values[field] ?? '{$field}';
        result = result.replaceAll('{$field}', value);
      }
    }
    return result;
  }

  /// Check if template has unfilled fields
  bool hasUnfilledFields(String text) {
    return text.contains(RegExp(r'\{[^}]+\}'));
  }

  @override
  String toString() {
    return 'ResponseTemplate(id: $id, name: $name, tone: $tone)';
  }
}
</file>

<file path="frontend/lib/models/safe_topic.dart">
import 'package:flutter/material.dart';

/// Model for safe topics
class SafeTopic {
  final String id;
  final String topicName;
  final List<String> keywords;
  final int messageCount;
  final int? avgResponseTime;
  final double? positiveToneRate;
  final bool isSafe;
  final int? lastDiscussed;

  SafeTopic({
    required this.id,
    required this.topicName,
    required this.keywords,
    required this.messageCount,
    this.avgResponseTime,
    this.positiveToneRate,
    this.isSafe = true,
    this.lastDiscussed,
  });

  factory SafeTopic.fromJson(Map<String, dynamic> json) {
    return SafeTopic(
      id: json['id'] as String,
      topicName: json['topic_name'] as String,
      keywords: (json['topic_keywords'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ??
          [],
      messageCount: json['message_count'] as int,
      avgResponseTime: json['avg_response_time'] as int?,
      positiveToneRate: (json['positive_tone_rate'] as num?)?.toDouble(),
      isSafe: json['is_safe'] as bool? ?? true,
      lastDiscussed: json['last_discussed'] as int?,
    );
  }

  Color getTopicColor() {
    if (positiveToneRate == null) return Colors.grey;
    if (positiveToneRate! >= 0.8) return Colors.green;
    if (positiveToneRate! >= 0.6) return Colors.blue;
    return Colors.orange;
  }

  String getEngagementLabel() {
    if (positiveToneRate == null) return 'Unknown';
    if (positiveToneRate! >= 0.8) return 'Great topic!';
    if (positiveToneRate! >= 0.6) return 'Good topic';
    return 'Neutral';
  }
}
</file>

<file path="frontend/lib/models/situation_type.dart">
import 'package:flutter/material.dart';

/// Types of situations for response templates
enum SituationType {
  declining('declining', 'Saying No', Icons.cancel),
  boundarySetting('boundary_setting', 'Setting Boundary', Icons.shield),
  infoDumping('info_dumping', 'Sharing Info', Icons.lightbulb),
  apologizing('apologizing', 'Apologizing', Icons.handshake),
  clarifying('clarifying', 'Clarifying', Icons.help_outline),
  casualChat('casual_chat', 'Casual Chat', Icons.chat),
  workProfessional('work_professional', 'Professional', Icons.work),
  emotionalSupport('emotional_support', 'Support', Icons.favorite),
  unknown('unknown', 'Unknown', Icons.question_mark);

  final String value;
  final String displayName;
  final IconData icon;

  const SituationType(this.value, this.displayName, this.icon);

  static SituationType fromString(String value) {
    return SituationType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => SituationType.unknown,
    );
  }

  Color getColor() {
    switch (this) {
      case SituationType.declining:
        return Colors.red;
      case SituationType.boundarySetting:
        return Colors.orange;
      case SituationType.infoDumping:
        return Colors.purple;
      case SituationType.apologizing:
        return Colors.blue;
      case SituationType.clarifying:
        return Colors.teal;
      case SituationType.casualChat:
        return Colors.green;
      case SituationType.workProfessional:
        return Colors.indigo;
      case SituationType.emotionalSupport:
        return Colors.pink;
      case SituationType.unknown:
        return Colors.grey;
    }
  }
}

/// Situation detection result
class SituationDetection {
  final SituationType situationType;
  final double confidence;
  final String reasoning;
  final List<String> suggestedTemplateIds;

  SituationDetection({
    required this.situationType,
    required this.confidence,
    required this.reasoning,
    required this.suggestedTemplateIds,
  });

  factory SituationDetection.fromJson(Map<String, dynamic> json) {
    return SituationDetection(
      situationType: SituationType.fromString(json['situation_type'] as String),
      confidence: (json['confidence'] as num).toDouble(),
      reasoning: json['reasoning'] as String,
      suggestedTemplateIds: (json['suggested_templates'] as List<dynamic>)
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'situation_type': situationType.value,
      'confidence': confidence,
      'reasoning': reasoning,
      'suggested_templates': suggestedTemplateIds,
    };
  }

  @override
  String toString() {
    return 'SituationDetection(type: ${situationType.displayName}, confidence: ${(confidence * 100).toInt()}%)';
  }
}
</file>

<file path="frontend/lib/services/avatar_service.dart">
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:image_picker/image_picker.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_handler.dart';

/// Service for handling avatar uploads and management
class AvatarService {
  static final AvatarService _instance = AvatarService._internal();

  factory AvatarService() {
    return _instance;
  }

  AvatarService._internal();

  final _supabase = SupabaseClientProvider.client;
  final _errorHandler = ErrorHandler();
  final _imagePicker = ImagePicker();

  /// Pick an image from gallery
  Future<XFile?> pickImage() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 512,
        maxHeight: 512,
        imageQuality: 85,
      );
      return image;
    } catch (error, stackTrace) {
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Pick Image',
      );
    }
  }

  /// Pick an image from camera
  Future<XFile?> pickImageFromCamera() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.camera,
        maxWidth: 512,
        maxHeight: 512,
        imageQuality: 85,
      );
      return image;
    } catch (error, stackTrace) {
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Take Photo',
      );
    }
  }

  /// Upload avatar to Supabase Storage and update profile
  Future<String> uploadAvatar(XFile imageFile) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      print('üì§ Uploading avatar for user: ${currentUser.id}');

      // Generate unique filename
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final extension = imageFile.path.split('.').last;
      final fileName = '${currentUser.id}/avatar_$timestamp.$extension';

      // Read file bytes
      final Uint8List fileBytes;
      if (kIsWeb) {
        fileBytes = await imageFile.readAsBytes();
      } else {
        fileBytes = await File(imageFile.path).readAsBytes();
      }

      print('üìÅ File size: ${fileBytes.length} bytes');
      print('üìÅ File name: $fileName');

      // Delete old avatar if exists
      await _deleteOldAvatar(currentUser.id);

      // Upload to Supabase Storage
      final uploadPath = await _supabase.storage
          .from('avatars')
          .uploadBinary(fileName, fileBytes);

      print('‚úÖ Avatar uploaded: $uploadPath');

      // Get public URL
      final publicUrl = _supabase.storage
          .from('avatars')
          .getPublicUrl(fileName);

      print('üîó Public URL: $publicUrl');

      // Update profile with new avatar URL
      await _updateProfileAvatar(currentUser.id, publicUrl);

      return publicUrl;
    } catch (error, stackTrace) {
      print('‚ùå Error uploading avatar: $error');
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Upload Avatar',
      );
    }
  }

  /// Delete old avatar files for a user
  Future<void> _deleteOldAvatar(String userId) async {
    try {
      // List all files in user's folder
      final files = await _supabase.storage
          .from('avatars')
          .list(path: userId);

      // Delete each file
      for (final file in files) {
        final filePath = '$userId/${file.name}';
        await _supabase.storage
            .from('avatars')
            .remove([filePath]);
        print('üóëÔ∏è  Deleted old avatar: $filePath');
      }
    } catch (e) {
      print('‚ö†Ô∏è  Error deleting old avatar (non-critical): $e');
      // Don't throw - old avatar deletion is non-critical
    }
  }

  /// Update profile table with new avatar URL
  Future<void> _updateProfileAvatar(String userId, String avatarUrl) async {
    try {
      await _supabase
          .from('profiles')
          .update({'avatar_url': avatarUrl, 'updated_at': DateTime.now().toIso8601String()})
          .eq('user_id', userId);

      print('‚úÖ Profile updated with new avatar URL');
    } catch (error, stackTrace) {
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Update Profile Avatar',
      );
    }
  }

  /// Get avatar URL for a user
  Future<String?> getAvatarUrl(String userId) async {
    try {
      final response = await _supabase
          .from('profiles')
          .select('avatar_url')
          .eq('user_id', userId)
          .maybeSingle();

      if (response != null && response['avatar_url'] != null) {
        return response['avatar_url'] as String;
      }
      return null;
    } catch (error, stackTrace) {
      print('‚ö†Ô∏è  Error fetching avatar URL: $error');
      // Return null instead of throwing - missing avatar is not critical
      return null;
    }
  }

  /// Delete avatar for current user
  Future<void> deleteAvatar() async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      print('üóëÔ∏è  Deleting avatar for user: ${currentUser.id}');

      // Delete from storage
      await _deleteOldAvatar(currentUser.id);

      // Update profile to remove avatar URL
      await _supabase
          .from('profiles')
          .update({'avatar_url': null, 'updated_at': DateTime.now().toIso8601String()})
          .eq('user_id', currentUser.id);

      print('‚úÖ Avatar deleted successfully');
    } catch (error, stackTrace) {
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Delete Avatar',
      );
    }
  }

  /// Get current user's avatar URL
  Future<String?> getCurrentUserAvatar() async {
    final currentUser = _supabase.auth.currentUser;
    if (currentUser == null) {
      return null;
    }
    return getAvatarUrl(currentUser.id);
  }
}
</file>

<file path="frontend/lib/services/conversation_filter_service.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/models/conversation_filter.dart';
import 'package:messageai/models/conversation_with_metadata.dart';
import 'package:messageai/services/ai_analysis_service.dart';
import 'package:messageai/services/message_service.dart';

/// Service for filtering conversations based on AI analysis and follow-ups
class ConversationFilterService {
  final _aiService = AIAnalysisService();
  final _messageService = MessageService();
  
  /// Get metadata for a single conversation
  Future<ConversationWithMetadata> getConversationMetadata(
    Conversation conversation,
  ) async {
    try {
      // Get recent messages for this conversation (check last 20 messages)
      final messages = await _messageService.getRecentMessages(
        conversation.id,
        limit: 20,
      );
      
      // Get current user ID
      final currentUserId = _messageService.getCurrentUserId();
      
      // Check for AI flags in recent messages
      bool hasUrgent = false;
      bool hasRSD = false;
      bool hasBoundary = false;
      
      for (final message in messages) {
        // Skip messages from current user
        if (message.senderId == currentUserId) {
          continue;
        }
        
        // Try to get cached AI analysis
        try {
          final analysis = await _aiService.getAnalysis(message.id);
          if (analysis != null) {
            // Check for urgency (High or Critical)
            if (analysis.urgencyLevel == 'High' || 
                analysis.urgencyLevel == 'Critical') {
              hasUrgent = true;
            }
            
            // Check for RSD triggers
            if (analysis.rsdTriggers != null && 
                analysis.rsdTriggers!.isNotEmpty) {
              hasRSD = true;
            }
            
            // Check for boundary violations
            if (analysis.boundaryAnalysis?.hasViolation == true) {
              hasBoundary = true;
            }
          }
        } catch (e) {
          // Skip if analysis doesn't exist or failed
          continue;
        }
      }
      
      // TODO: Get follow-up counts from follow-up service
      // For now, hardcoded to 0
      int unansweredCount = 0;
      int taskCount = 0;
      int overdueCount = 0;
      
      return ConversationWithMetadata(
        conversation: conversation,
        hasUrgentMessages: hasUrgent,
        hasRSDTriggers: hasRSD,
        hasBoundaryViolations: hasBoundary,
        unansweredCount: unansweredCount,
        taskCount: taskCount,
        overdueCount: overdueCount,
      );
    } catch (e) {
      print('‚ùå Error getting conversation metadata: $e');
      // Return conversation with no metadata on error
      return ConversationWithMetadata(conversation: conversation);
    }
  }
  
  /// Filter conversations based on selected filters
  Future<List<ConversationWithMetadata>> filterConversations(
    List<Conversation> conversations,
    Set<ConversationFilter> activeFilters,
  ) async {
    // Get metadata for all conversations
    final withMetadata = await Future.wait(
      conversations.map((conv) => getConversationMetadata(conv)),
    );
    
    // Filter based on active filters
    return withMetadata
        .where((conv) => conv.matchesAnyFilter(activeFilters))
        .toList();
  }
  
  /// Calculate badge counts for all filters
  Future<Map<ConversationFilter, int>> getFilterCounts(
    List<ConversationWithMetadata> conversationsWithMeta,
  ) async {
    return {
      ConversationFilter.urgent: conversationsWithMeta
          .where((m) => m.hasUrgentMessages)
          .length,
      ConversationFilter.rsd: conversationsWithMeta
          .where((m) => m.hasRSDTriggers)
          .length,
      ConversationFilter.boundary: conversationsWithMeta
          .where((m) => m.hasBoundaryViolations)
          .length,
      ConversationFilter.unanswered: conversationsWithMeta
          .where((m) => m.unansweredCount > 0)
          .length,
      ConversationFilter.tasks: conversationsWithMeta
          .where((m) => m.taskCount > 0)
          .length,
      ConversationFilter.overdue: conversationsWithMeta
          .where((m) => m.overdueCount > 0)
          .length,
    };
  }
}
</file>

<file path="frontend/lib/services/deep_link_handler.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Handles deep linking and navigation from notifications
class DeepLinkHandler {
  final WidgetRef ref;
  final NavigatorState? navigatorState;

  DeepLinkHandler({
    required this.ref,
    this.navigatorState,
  });

  /// Handle notification tap - navigate to conversation
  Future<void> handleNotificationTap(String conversationId) async {
    try {
      // Navigate to conversation detail screen
      navigatorState?.pushNamed(
        '/conversation/$conversationId',
      );
      print('Navigated to conversation: $conversationId');
    } catch (e) {
      print('Error handling notification tap: $e');
    }
  }

  /// Handle initial message (app terminated)
  Future<void> handleInitialMessage(String conversationId) async {
    try {
      // Wait for app to fully initialize
      await Future.delayed(const Duration(milliseconds: 500));
      
      // Navigate to conversation
      navigatorState?.pushNamedAndRemoveUntil(
        '/conversation/$conversationId',
        ModalRoute.withName('/conversations'),
      );
      print('Navigated from initial message to: $conversationId');
    } catch (e) {
      print('Error handling initial message: $e');
    }
  }

  /// Handle background message (app in background)
  Future<void> handleBackgroundMessage(String conversationId) async {
    try {
      // Just navigate normally
      navigatorState?.pushNamed('/conversation/$conversationId');
      print('Navigated from background message to: $conversationId');
    } catch (e) {
      print('Error handling background message: $e');
    }
  }

  /// Parse notification payload to extract conversation ID
  String? extractConversationId(Map<String, dynamic> data) {
    return data['conversation_id'] as String?;
  }

  /// Parse notification payload to extract message metadata
  Map<String, dynamic> extractMessageMetadata(Map<String, dynamic> data) {
    return {
      'conversation_id': data['conversation_id'],
      'sender_id': data['sender_id'],
      'message_id': data['message_id'],
      'sender_name': data['sender_name'],
    };
  }
}

/// Notification route arguments
class NotificationRouteArgs {
  final String conversationId;
  final String? senderId;
  final String? messageId;
  final String? senderName;

  NotificationRouteArgs({
    required this.conversationId,
    this.senderId,
    this.messageId,
    this.senderName,
  });

  factory NotificationRouteArgs.fromPayload(Map<String, dynamic> payload) {
    return NotificationRouteArgs(
      conversationId: payload['conversation_id'] as String,
      senderId: payload['sender_id'] as String?,
      messageId: payload['message_id'] as String?,
      senderName: payload['sender_name'] as String?,
    );
  }
}

/// Generate named route for conversation
String conversationRoute(String conversationId) => '/conversation/$conversationId';

/// Parse conversation ID from route
String? parseConversationIdFromRoute(String route) {
  if (route.startsWith('/conversation/')) {
    return route.replaceFirst('/conversation/', '');
  }
  return null;
}
</file>

<file path="frontend/lib/services/draft_analysis_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/models/draft_analysis.dart';

/// Service for analyzing draft messages on-demand
/// User manually requests analysis via button press
class DraftAnalysisService {
  final SupabaseClient _supabase;

  DraftAnalysisService(this._supabase);

  /// Analyze a draft message (called when user clicks "Check" button)
  Future<DraftAnalysis> analyzeDraft({
    required String draftMessage,
    String? conversationId,
    RelationshipType? relationshipType,
    List<String>? conversationHistory,
  }) async {
    try {
      print('üîç Analyzing draft message...');
      
      final response = await _supabase.functions.invoke(
        'ai_analyze_draft',
        body: {
          'draft_message': draftMessage,
          if (conversationId != null) 'conversation_id': conversationId,
          if (relationshipType != null && relationshipType != RelationshipType.none)
            'relationship_type': relationshipType.value,
          if (conversationHistory != null && conversationHistory.isNotEmpty)
            'conversation_history': conversationHistory,
        },
      );

      if (response.data == null) {
        throw Exception('No response from draft analysis service');
      }

      final data = response.data as Map<String, dynamic>;
      
      if (data['success'] != true) {
        throw Exception(data['error'] ?? 'Analysis failed');
      }

      final analysis = DraftAnalysis.fromJson(data['analysis'] as Map<String, dynamic>);
      
      print('‚úÖ Draft analysis complete: ${analysis.confidenceScore}% confidence');
      
      return analysis;
    } catch (e) {
      print('‚ùå Error analyzing draft: $e');
      rethrow;
    }
  }

  /// Get recent messages from conversation for context
  Future<List<String>> getConversationContext(String conversationId, {int limit = 3}) async {
    try {
      final response = await _supabase
          .from('messages')
          .select('body')
          .eq('conversation_id', conversationId)
          .order('created_at', ascending: false)
          .limit(limit);

      return (response as List).map((m) => m['body'] as String).toList();
    } catch (e) {
      print('Warning: Could not fetch conversation context: $e');
      return [];
    }
  }

  /// Get or detect relationship type for conversation
  Future<RelationshipType> getRelationshipType(String conversationId) async {
    try {
      final response = await _supabase
          .from('conversations')
          .select('relationship_type')
          .eq('id', conversationId)
          .single();

      return RelationshipType.fromString(response['relationship_type'] as String?);
    } catch (e) {
      print('Warning: Could not fetch relationship type: $e');
      return RelationshipType.none;
    }
  }

  /// Update relationship type for conversation
  Future<void> setRelationshipType(String conversationId, RelationshipType type) async {
    try {
      await _supabase
          .from('conversations')
          .update({'relationship_type': type.value})
          .eq('id', conversationId);
      
      print('‚úÖ Relationship type updated to: ${type.displayName}');
    } catch (e) {
      print('‚ùå Error updating relationship type: $e');
      rethrow;
    }
  }
}
</file>

<file path="frontend/lib/services/draft_confidence_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/models/draft_confidence.dart';

/// Service for analyzing draft confidence (Phase 2: Response Assistant)
class DraftConfidenceService {
  final SupabaseClient _supabase;

  DraftConfidenceService(this._supabase);

  /// Analyze the confidence/quality of a draft response
  Future<DraftConfidence> analyzeDraft(String draft) async {
    try {
      print('‚úçÔ∏è Analyzing draft...');
      
      final response = await _supabase.functions.invoke(
        'ai_analyze_draft',
        body: {
          'draft': draft,
        },
      );

      if (response.data == null) {
        throw Exception('No response from draft confidence service');
      }

      final data = response.data as Map<String, dynamic>;
      
      if (data['success'] != true) {
        throw Exception(data['error'] ?? 'Draft analysis failed');
      }

      final confidence = DraftConfidence.fromJson(
        data['analysis'] as Map<String, dynamic>,
      );
      
      print('‚úÖ Draft analyzed: ${confidence.overallScore}% confidence');
      
      return confidence;
    } catch (e) {
      print('‚ùå Error analyzing draft: $e');
      rethrow;
    }
  }

  /// Quick check: is draft good enough to send?
  Future<bool> isReadyToSend(String draft) async {
    final confidence = await analyzeDraft(draft);
    return confidence.overallScore >= 70; // 70% threshold
  }

  /// Get suggestions for improving draft
  Future<List<String>> getSuggestions(String draft) async {
    final confidence = await analyzeDraft(draft);
    return confidence.suggestions;
  }
}
</file>

<file path="frontend/lib/services/follow_up_service.dart">
// ignore_for_file: avoid_print

import 'package:http/http.dart' as http;
import 'dart:convert';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/models/follow_up_item.dart';

/// Service for managing follow-up items
class FollowUpService {
  static final FollowUpService _instance = FollowUpService._internal();
  factory FollowUpService() => _instance;
  FollowUpService._internal();

  final _supabase = SupabaseClientProvider.client;

  String get _baseUrl {
    final supabaseUrl = _supabase.supabaseUrl;
    return '$supabaseUrl/functions/v1';
  }

  /// Extract follow-ups from conversation
  Future<void> extractFollowUps(String conversationId, {bool scanAll = false}) async {
    try {
      final token = _supabase.auth.currentSession?.accessToken;
      if (token == null) throw Exception('Not authenticated');

      await http.post(
        Uri.parse('$_baseUrl/ai-extract-followups'),
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
        body: jsonEncode({
          'conversation_id': conversationId,
          'scan_recent_messages': scanAll,
        }),
      );
    } catch (e) {
      print('Error extracting follow-ups: $e');
      rethrow;
    }
  }

  /// Get all pending follow-ups for user
  Future<List<FollowUpItem>> getPendingFollowUps() async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return [];

      final response = await _supabase.rpc('get_pending_followups', params: {
        'p_user_id': userId,
        'p_limit': 50,
      });

      if (response == null) return [];

      return (response as List)
          .map((data) => FollowUpItem.fromJson({
                'user_id': userId,
                ...data as Map<String, dynamic>,
              }))
          .toList();
    } catch (e) {
      print('Error getting pending follow-ups: $e');
      return [];
    }
  }

  /// Get follow-ups for specific conversation
  Future<List<FollowUpItem>> getConversationFollowUps(String conversationId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return [];

      final response = await _supabase.rpc('get_conversation_followups', params: {
        'p_user_id': userId,
        'p_conversation_id': conversationId,
      });

      if (response == null) return [];

      return (response as List)
          .map((data) => FollowUpItem.fromJson({
                'user_id': userId,
                'conversation_id': conversationId,
                ...data as Map<String, dynamic>,
              }))
          .toList();
    } catch (e) {
      print('Error getting conversation follow-ups: $e');
      return [];
    }
  }

  /// Mark follow-up as completed
  Future<void> completeFollowUp(String itemId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      await _supabase.rpc('complete_followup', params: {
        'p_user_id': userId,
        'p_item_id': itemId,
      });
    } catch (e) {
      print('Error completing follow-up: $e');
      rethrow;
    }
  }

  /// Snooze follow-up
  Future<void> snoozeFollowUp(String itemId, Duration duration) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      await _supabase.rpc('snooze_followup', params: {
        'p_user_id': userId,
        'p_item_id': itemId,
        'p_snooze_duration': duration.inSeconds,
      });
    } catch (e) {
      print('Error snoozing follow-up: $e');
      rethrow;
    }
  }

  /// Dismiss follow-up
  Future<void> dismissFollowUp(String itemId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;

      await _supabase.from('follow_up_items').update({
        'status': 'dismissed',
        'updated_at': now,
      }).eq('id', itemId).eq('user_id', userId);
    } catch (e) {
      print('Error dismissing follow-up: $e');
      rethrow;
    }
  }
}
</file>

<file path="frontend/lib/services/message_formatter_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/models/formatted_message.dart';

/// Service for formatting messages
class MessageFormatterService {
  final SupabaseClient _supabase;

  MessageFormatterService(this._supabase);

  /// Format a message with specified options
  Future<FormattedMessage> formatMessage({
    required String message,
    bool condense = false,
    bool chunk = false,
    bool addTldr = false,
    bool addStructure = false,
  }) async {
    try {
      print('üé® Formatting message...');
      
      final response = await _supabase.functions.invoke(
        'ai-format-message',
        body: {
          'message': message,
          'options': {
            'condense': condense,
            'chunk': chunk,
            'add_tldr': addTldr,
            'add_structure': addStructure,
          },
        },
      );

      if (response.data == null) {
        throw Exception('No response from message formatting service');
      }

      final data = response.data as Map<String, dynamic>;
      
      if (data['success'] != true) {
        throw Exception(data['error'] ?? 'Formatting failed');
      }

      final formatted = FormattedMessage.fromJson(
        data['formatted'] as Map<String, dynamic>,
      );
      
      print('‚úÖ Message formatted: ${formatted.originalLength} ‚Üí ${formatted.characterCount} chars');
      
      return formatted;
    } catch (e) {
      print('‚ùå Error formatting message: $e');
      rethrow;
    }
  }

  /// Quick format: condense only
  Future<FormattedMessage> condenseMessage(String message) {
    return formatMessage(message: message, condense: true);
  }

  /// Quick format: add structure
  Future<FormattedMessage> structureMessage(String message) {
    return formatMessage(message: message, addStructure: true, chunk: true);
  }

  /// Quick format: full formatting (all options)
  Future<FormattedMessage> fullFormat(String message) {
    return formatMessage(
      message: message,
      condense: true,
      chunk: true,
      addTldr: true,
      addStructure: true,
    );
  }

  /// Detect the situation/context of a message
  Future<String> detectSituation(String message) async {
    try {
      print('üîç Detecting situation for message...');
      
      final response = await _supabase.functions.invoke(
        'ai-format-message',
        body: {
          'message': message,
          'detect_situation': true,
        },
      );

      if (response.data == null) {
        throw Exception('No response from situation detection service');
      }

      final data = response.data as Map<String, dynamic>;
      
      if (data['success'] != true) {
        throw Exception(data['error'] ?? 'Situation detection failed');
      }

      final situation = data['situation'] as String? ?? 'unknown';
      
      print('‚úÖ Situation detected: $situation');
      
      return situation;
    } catch (e) {
      print('‚ùå Error detecting situation: $e');
      return 'unknown';
    }
  }
}
</file>

<file path="frontend/lib/services/network_connectivity_service.dart">
import 'dart:async';
import 'package:flutter/foundation.dart';

/// Network connectivity states
enum ConnectivityStatus {
  online,
  offline,
  unknown,
}

/// Service for monitoring network connectivity
/// Note: For production, consider using connectivity_plus package
class NetworkConnectivityService {
  static final NetworkConnectivityService _instance =
      NetworkConnectivityService._internal();

  factory NetworkConnectivityService() {
    return _instance;
  }

  NetworkConnectivityService._internal();

  final _statusController = StreamController<ConnectivityStatus>.broadcast();
  ConnectivityStatus _currentStatus = ConnectivityStatus.unknown;
  Timer? _pingTimer;
  bool _isMonitoring = false;

  /// Get current connectivity status
  ConnectivityStatus get currentStatus => _currentStatus;

  /// Stream of connectivity status changes
  Stream<ConnectivityStatus> get onStatusChange => _statusController.stream;

  /// Check if currently online
  bool get isOnline => _currentStatus == ConnectivityStatus.online;

  /// Check if currently offline
  bool get isOffline => _currentStatus == ConnectivityStatus.offline;

  /// Start monitoring connectivity
  void startMonitoring({Duration checkInterval = const Duration(seconds: 10)}) {
    if (_isMonitoring) {
      print('‚ö†Ô∏è  Connectivity monitoring already started');
      return;
    }

    _isMonitoring = true;
    print('üåê Starting connectivity monitoring (every ${checkInterval.inSeconds}s)');

    // Check immediately
    _checkConnectivity();

    // Then check periodically
    _pingTimer = Timer.periodic(checkInterval, (_) {
      _checkConnectivity();
    });
  }

  /// Stop monitoring connectivity
  void stopMonitoring() {
    _pingTimer?.cancel();
    _pingTimer = null;
    _isMonitoring = false;
    print('üåê Stopped connectivity monitoring');
  }

  /// Check connectivity status
  Future<void> _checkConnectivity() async {
    try {
      // Simple connectivity check
      // In production, use connectivity_plus package for better detection
      final previousStatus = _currentStatus;
      final newStatus = await _performConnectivityCheck();

      if (newStatus != previousStatus) {
        _currentStatus = newStatus;
        _statusController.add(_currentStatus);
        _logStatusChange(previousStatus, newStatus);
      }
    } catch (e) {
      print('‚ùå Error checking connectivity: $e');
    }
  }

  /// Perform actual connectivity check
  /// Override this method to use connectivity_plus or other packages
  Future<ConnectivityStatus> _performConnectivityCheck() async {
    try {
      // For now, we assume online unless explicitly set offline
      // In production, use connectivity_plus to check actual network state
      
      // You can enhance this by:
      // 1. Using connectivity_plus package
      // 2. Pinging a known endpoint
      // 3. Checking platform-specific APIs
      
      return ConnectivityStatus.online;
    } catch (e) {
      return ConnectivityStatus.offline;
    }
  }

  /// Manually set connectivity status (useful for testing)
  void setStatus(ConnectivityStatus status) {
    if (_currentStatus != status) {
      final previousStatus = _currentStatus;
      _currentStatus = status;
      _statusController.add(_currentStatus);
      _logStatusChange(previousStatus, status);
    }
  }

  /// Force a connectivity check now
  Future<ConnectivityStatus> checkNow() async {
    final status = await _performConnectivityCheck();
    if (status != _currentStatus) {
      final previousStatus = _currentStatus;
      _currentStatus = status;
      _statusController.add(_currentStatus);
      _logStatusChange(previousStatus, status);
    }
    return _currentStatus;
  }

  /// Log status changes
  void _logStatusChange(
    ConnectivityStatus previous,
    ConnectivityStatus current,
  ) {
    final emoji = current == ConnectivityStatus.online ? '‚úÖ' : 'üì¥';
    print('$emoji Connectivity: ${previous.name} ‚Üí ${current.name}');
  }

  /// Dispose resources
  void dispose() {
    stopMonitoring();
    _statusController.close();
  }
}

/// Extension for convenience methods
extension ConnectivityStatusExtension on ConnectivityStatus {
  bool get isOnline => this == ConnectivityStatus.online;
  bool get isOffline => this == ConnectivityStatus.offline;
  bool get isUnknown => this == ConnectivityStatus.unknown;
}
</file>

<file path="frontend/lib/services/offline_queue_service.dart">
import 'dart:async';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/services/network_connectivity_service.dart';
import 'package:messageai/services/retry_service.dart';
import 'package:messageai/core/errors/app_error.dart';

/// Service for managing offline message queue and auto-sync
class OfflineQueueService {
  static final OfflineQueueService _instance =
      OfflineQueueService._internal();

  factory OfflineQueueService() {
    return _instance;
  }

  OfflineQueueService._internal();

  final _db = AppDb.instance;
  final _supabase = SupabaseClientProvider.client;
  final _connectivityService = NetworkConnectivityService();
  final _retryService = RetryService();

  StreamSubscription<ConnectivityStatus>? _connectivitySubscription;
  Timer? _syncTimer;
  bool _isSyncing = false;
  bool _isMonitoring = false;

  /// Start monitoring and auto-syncing
  void startMonitoring() {
    if (_isMonitoring) {
      return;
    }

    _isMonitoring = true;

    // Listen for connectivity changes - only sync when coming back online
    _connectivitySubscription = _connectivityService.onStatusChange.listen((status) {
      if (status == ConnectivityStatus.online) {
        syncPendingMessages();
      }
    });

    // No periodic polling - sync only happens:
    // 1. When connectivity is restored
    // 2. When explicitly requested (e.g., after sending a message)
  }

  /// Stop monitoring
  void stopMonitoring() {
    _connectivitySubscription?.cancel();
    _connectivitySubscription = null;
    _syncTimer?.cancel();
    _syncTimer = null;
    _isMonitoring = false;
    print('üì¶ Stopped offline queue monitoring');
  }

  /// Get count of pending messages
  Future<int> getPendingMessageCount() async {
    try {
      final messages = await _db.messageDao.getUnsyncedMessages();
      return messages.length;
    } catch (e) {
      print('‚ùå Error getting pending message count: $e');
      return 0;
    }
  }

  /// Sync all pending messages
  Future<SyncResult> syncPendingMessages() async {
    if (_isSyncing) {
      return SyncResult.alreadyRunning();
    }

    if (_connectivityService.isOffline) {
      return SyncResult.offline();
    }

    _isSyncing = true;
    int successCount = 0;
    int failureCount = 0;
    final List<String> failedMessageIds = [];

    try {
      final pendingMessages = await _db.messageDao.getUnsyncedMessages();

      if (pendingMessages.isEmpty) {
        return SyncResult.noMessages();
      }

      for (final message in pendingMessages) {
        final result = await _syncSingleMessage(message);
        if (result) {
          successCount++;
        } else {
          failureCount++;
          failedMessageIds.add(message.id);
        }
      }

      if (failureCount > 0) {
        print('‚ö†Ô∏è Sync: $successCount succeeded, $failureCount failed');
      }

      return SyncResult(
        totalMessages: pendingMessages.length,
        successCount: successCount,
        failureCount: failureCount,
        failedMessageIds: failedMessageIds,
      );
    } catch (e) {
      print('‚ùå Error syncing: $e');
      return SyncResult.error(e.toString());
    } finally {
      _isSyncing = false;
    }
  }

  /// Sync a single message with retry
  Future<bool> _syncSingleMessage(Message message) async {
    try {
      final result = await _retryService.execute(
        operation: () => _sendMessageToBackend(message),
        operationName: 'Sync Message ${message.id.substring(0, 8)}',
        config: RetryConfig.defaultConfig,
      );

      if (result.succeeded) {
        await _db.messageDao.markMessageAsSynced(message.id);
        return true;
      } else {
        final error = result.error;
        
        // If error is non-retryable, delete the message from queue
        if (error != null && !error.isRetryable) {
          print('üóëÔ∏è Removed invalid message: ${error.code}');
          await _db.messageDao.deleteMessage(message.id);
          return true;
        }
        
        return false;
      }
    } catch (e) {
      return false;
    }
  }

  /// Send message to backend
  Future<void> _sendMessageToBackend(Message message) async {
    final payload = {
      'id': message.id,
      'conversation_id': message.conversationId,
      'sender_id': message.senderId,
      'body': message.body,
      'media_url': message.mediaUrl,
      'created_at': DateTime.fromMillisecondsSinceEpoch(message.createdAt * 1000)
          .toIso8601String(),
      'updated_at': DateTime.fromMillisecondsSinceEpoch(message.updatedAt * 1000)
          .toIso8601String(),
    };

    await _supabase.from('messages').insert(payload);
    
    // Send push notification (don't wait for it)
    _sendPushNotification(message).catchError((e) {
      // Silently fail - push notifications are not critical
    });
  }

  /// Send push notification for message
  Future<void> _sendPushNotification(Message message) async {
    try {
      // Get sender profile (use maybeSingle to handle missing profile)
      final profile = await _supabase
          .from('profiles')
          .select('username, email')
          .eq('user_id', message.senderId)
          .maybeSingle();

      final senderName = profile?['username'] as String? ?? 
                         profile?['email'] as String? ?? 
                         'Someone';

      // Call push notification edge function with auth header
      final accessToken = _supabase.auth.currentSession?.accessToken;
      if (accessToken == null) return;
      
      await _supabase.functions.invoke(
        'push_notify',
        body: {
          'message_id': message.id,
          'conversation_id': message.conversationId,
          'sender_id': message.senderId,
          'sender_name': senderName,
          'title': senderName,
          'body': message.body,
        },
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      );
    } catch (e) {
      // Ignore errors
    }
  }

  /// Force sync now (called by user action)
  Future<SyncResult> forceSyncNow() async {
    print('üîÑ Force sync requested');
    return await syncPendingMessages();
  }

  /// Check if any messages are pending
  Future<bool> hasPendingMessages() async {
    final count = await getPendingMessageCount();
    return count > 0;
  }

  /// Dispose resources
  void dispose() {
    stopMonitoring();
  }
}

/// Result of sync operation
class SyncResult {
  final int totalMessages;
  final int successCount;
  final int failureCount;
  final List<String> failedMessageIds;
  final String? errorMessage;
  final SyncStatus status;

  SyncResult({
    required this.totalMessages,
    required this.successCount,
    required this.failureCount,
    this.failedMessageIds = const [],
    this.errorMessage,
    this.status = SyncStatus.completed,
  });

  SyncResult.noMessages()
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          status: SyncStatus.noMessages,
        );

  SyncResult.offline()
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          status: SyncStatus.offline,
        );

  SyncResult.alreadyRunning()
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          status: SyncStatus.alreadyRunning,
        );

  SyncResult.error(String message)
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          errorMessage: message,
          status: SyncStatus.error,
        );

  bool get hasErrors => failureCount > 0 || errorMessage != null;
  bool get isSuccess => failureCount == 0 && errorMessage == null;
  bool get isPartialSuccess => successCount > 0 && failureCount > 0;
}

/// Status of sync operation
enum SyncStatus {
  completed,
  noMessages,
  offline,
  alreadyRunning,
  error,
}
</file>

<file path="frontend/lib/services/realtime_diagnostic_service.dart">
import 'dart:async';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Diagnostic information about a Realtime channel
class RealtimeChannelDiagnostics {
  final String channelName;
  final String status;
  final DateTime subscribedAt;
  final DateTime? lastMessageAt;
  final int messagesReceived;
  final List<String> errors;
  final Duration? latency;

  RealtimeChannelDiagnostics({
    required this.channelName,
    required this.status,
    required this.subscribedAt,
    this.lastMessageAt,
    this.messagesReceived = 0,
    this.errors = const [],
    this.latency,
  });

  bool get isHealthy => status == 'SUBSCRIBED' && errors.isEmpty;
  
  Duration get timeSinceLastMessage => 
      lastMessageAt != null 
          ? DateTime.now().difference(lastMessageAt!)
          : Duration.zero;
}

/// Service for diagnosing and monitoring Realtime connections
class RealtimeDiagnosticService {
  static final RealtimeDiagnosticService _instance =
      RealtimeDiagnosticService._internal();

  factory RealtimeDiagnosticService() {
    return _instance;
  }

  RealtimeDiagnosticService._internal();

  final _supabase = SupabaseClientProvider.client;
  final Map<String, RealtimeChannelDiagnostics> _channelDiagnostics = {};
  final Map<String, DateTime> _messageTimestamps = {};
  Timer? _healthCheckTimer;
  bool _isMonitoring = false;

  /// Start monitoring Realtime health
  void startMonitoring({Duration checkInterval = const Duration(seconds: 5)}) {
    if (_isMonitoring) {
      return;
    }

    _isMonitoring = true;
    _healthCheckTimer = Timer.periodic(checkInterval, (_) {
      _performHealthCheck();
    });
  }

  /// Stop monitoring
  void stopMonitoring() {
    _healthCheckTimer?.cancel();
    _healthCheckTimer = null;
    _isMonitoring = false;
  }

  /// Register a channel for monitoring
  void registerChannel(String channelName, RealtimeChannel channel) {
    _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
      channelName: channelName,
      status: 'SUBSCRIBING',
      subscribedAt: DateTime.now(),
    );
  }

  /// Update channel status
  void updateChannelStatus(String channelName, String status) {
    final current = _channelDiagnostics[channelName];
    if (current != null) {
      _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
        channelName: channelName,
        status: status,
        subscribedAt: current.subscribedAt,
        lastMessageAt: current.lastMessageAt,
        messagesReceived: current.messagesReceived,
        errors: current.errors,
        latency: current.latency,
      );
    }
  }

  /// Record message received
  void recordMessageReceived(String channelName) {
    final current = _channelDiagnostics[channelName];
    if (current != null) {
      final now = DateTime.now();
      
      // Calculate latency if we have a timestamp
      Duration? latency;
      if (_messageTimestamps.containsKey(channelName)) {
        latency = now.difference(_messageTimestamps[channelName]!);
      }

      _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
        channelName: channelName,
        status: current.status,
        subscribedAt: current.subscribedAt,
        lastMessageAt: now,
        messagesReceived: current.messagesReceived + 1,
        errors: current.errors,
        latency: latency,
      );
    }
  }

  /// Record error
  void recordError(String channelName, String error) {
    final current = _channelDiagnostics[channelName];
    if (current != null) {
      final newErrors = List<String>.from(current.errors)..add(error);
      
      _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
        channelName: channelName,
        status: current.status,
        subscribedAt: current.subscribedAt,
        lastMessageAt: current.lastMessageAt,
        messagesReceived: current.messagesReceived,
        errors: newErrors,
        latency: current.latency,
      );

      print('‚ùå Error on $channelName: $error');
    }
  }

  /// Mark message send timestamp (for latency calculation)
  void markMessageSent(String channelName) {
    _messageTimestamps[channelName] = DateTime.now();
  }

  /// Perform health check on all channels
  void _performHealthCheck() {
    print('üè• Realtime Health Check');
    print('‚îÅ' * 60);

    if (_channelDiagnostics.isEmpty) {
      print('   No active channels');
      return;
    }

    for (final entry in _channelDiagnostics.entries) {
      final channel = entry.key;
      final diag = entry.value;

      final healthEmoji = diag.isHealthy ? '‚úÖ' : '‚ö†Ô∏è';
      final statusEmoji = _getStatusEmoji(diag.status);

      print('$healthEmoji $channel');
      print('   $statusEmoji Status: ${diag.status}');
      print('   üìä Messages: ${diag.messagesReceived}');
      
      if (diag.lastMessageAt != null) {
        final timeSince = DateTime.now().difference(diag.lastMessageAt!);
        print('   ‚è±Ô∏è  Last message: ${timeSince.inSeconds}s ago');
      }

      if (diag.latency != null) {
        print('   üöÄ Latency: ${diag.latency!.inMilliseconds}ms');
      }

      if (diag.errors.isNotEmpty) {
        print('   ‚ùå Errors: ${diag.errors.length}');
        for (final error in diag.errors.take(3)) {
          print('      - $error');
        }
      }

      final uptime = DateTime.now().difference(diag.subscribedAt);
      print('   ‚è∞ Uptime: ${_formatDuration(uptime)}');
      print('');
    }

    print('‚îÅ' * 60);
  }

  /// Get emoji for status
  String _getStatusEmoji(String status) {
    switch (status) {
      case 'SUBSCRIBED':
        return '‚úÖ';
      case 'SUBSCRIBING':
        return 'üîÑ';
      case 'CLOSED':
        return '‚è∏Ô∏è';
      case 'CHANNEL_ERROR':
        return '‚ùå';
      case 'TIMED_OUT':
        return '‚è∞';
      default:
        return '‚ùì';
    }
  }

  /// Format duration nicely
  String _formatDuration(Duration duration) {
    if (duration.inSeconds < 60) {
      return '${duration.inSeconds}s';
    } else if (duration.inMinutes < 60) {
      return '${duration.inMinutes}m ${duration.inSeconds % 60}s';
    } else {
      return '${duration.inHours}h ${duration.inMinutes % 60}m';
    }
  }

  /// Get diagnostics for a channel
  RealtimeChannelDiagnostics? getDiagnostics(String channelName) {
    return _channelDiagnostics[channelName];
  }

  /// Get all diagnostics
  Map<String, RealtimeChannelDiagnostics> getAllDiagnostics() {
    return Map.from(_channelDiagnostics);
  }

  /// Test Realtime connection
  Future<RealtimeTestResult> testConnection() async {
    print('üß™ Testing Realtime connection...');
    
    final startTime = DateTime.now();
    final testChannel = _supabase.realtime.channel('test_${startTime.millisecondsSinceEpoch}');
    
    try {
      final completer = Completer<RealtimeTestResult>();
      var subscribeStatus = 'UNKNOWN';

      testChannel.subscribe(
        (status, [error]) {
          subscribeStatus = status;
          
          if (status == 'SUBSCRIBED') {
            final latency = DateTime.now().difference(startTime);
            completer.complete(RealtimeTestResult(
              success: true,
              latency: latency,
              status: status,
            ));
          } else if (status == 'CHANNEL_ERROR' || status == 'TIMED_OUT') {
            completer.complete(RealtimeTestResult(
            success: false,
            status: status,
            error: error?.toString(),
          ));
        }
      },
      const Duration(seconds: 30), // Test with 30s timeout
      );

      // Timeout after 10 seconds
      final result = await completer.future.timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          return RealtimeTestResult(
            success: false,
            status: 'TIMEOUT',
            error: 'Connection test timed out after 10 seconds',
          );
        },
      );

      // Clean up
      await testChannel.unsubscribe();

      return result;
    } catch (e) {
      return RealtimeTestResult(
        success: false,
        status: 'ERROR',
        error: e.toString(),
      );
    }
  }

  /// Generate diagnostic report
  String generateReport() {
    final buffer = StringBuffer();
    
    buffer.writeln('‚ïê' * 60);
    buffer.writeln('REALTIME DIAGNOSTICS REPORT');
    buffer.writeln('Generated: ${DateTime.now()}');
    buffer.writeln('‚ïê' * 60);
    buffer.writeln();

    if (_channelDiagnostics.isEmpty) {
      buffer.writeln('No active channels');
      return buffer.toString();
    }

    for (final entry in _channelDiagnostics.entries) {
      final diag = entry.value;
      
      buffer.writeln('Channel: ${diag.channelName}');
      buffer.writeln('  Status: ${diag.status} ${diag.isHealthy ? '‚úì' : '‚úó'}');
      buffer.writeln('  Messages Received: ${diag.messagesReceived}');
      buffer.writeln('  Subscribed At: ${diag.subscribedAt}');
      
      if (diag.lastMessageAt != null) {
        buffer.writeln('  Last Message: ${diag.lastMessageAt}');
        buffer.writeln('  Time Since Last: ${diag.timeSinceLastMessage.inSeconds}s');
      }
      
      if (diag.latency != null) {
        buffer.writeln('  Latency: ${diag.latency!.inMilliseconds}ms');
      }
      
      if (diag.errors.isNotEmpty) {
        buffer.writeln('  Errors: ${diag.errors.length}');
        for (final error in diag.errors) {
          buffer.writeln('    - $error');
        }
      }
      
      buffer.writeln();
    }

    buffer.writeln('‚ïê' * 60);
    return buffer.toString();
  }

  /// Dispose resources
  void dispose() {
    stopMonitoring();
    _channelDiagnostics.clear();
    _messageTimestamps.clear();
  }
}

/// Result of Realtime connection test
class RealtimeTestResult {
  final bool success;
  final Duration? latency;
  final String status;
  final String? error;

  RealtimeTestResult({
    required this.success,
    this.latency,
    required this.status,
    this.error,
  });

  @override
  String toString() {
    if (success) {
      return 'SUCCESS: Connected in ${latency?.inMilliseconds}ms (Status: $status)';
    } else {
      return 'FAILED: $status${error != null ? ' - $error' : ''}';
    }
  }
}
</file>

<file path="frontend/lib/services/relationship_service.dart">
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/models/relationship_profile.dart';
import 'package:messageai/models/safe_topic.dart';

/// Service for managing relationship profiles
class RelationshipService {
  static final RelationshipService _instance = RelationshipService._internal();
  factory RelationshipService() => _instance;
  RelationshipService._internal();

  final _supabase = SupabaseClientProvider.client;

  /// Get relationship profile for a conversation
  Future<RelationshipProfile?> getProfile(String conversationId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return null;

      final response = await _supabase.rpc('get_relationship_profile', params: {
        'p_user_id': userId,
        'p_conversation_id': conversationId,
      });

      if (response == null || response.isEmpty) return null;

      return RelationshipProfile.fromJson({
        'user_id': userId,
        'conversation_id': conversationId,
        ...response as Map<String, dynamic>,
      });
    } catch (e) {
      print('Error getting relationship profile: $e');
      return null;
    }
  }

  /// Get safe topics for a conversation
  Future<List<SafeTopic>> getSafeTopics(String conversationId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return [];

      final response = await _supabase.rpc('get_safe_topics', params: {
        'p_user_id': userId,
        'p_conversation_id': conversationId,
      });

      if (response == null) return [];

      return (response as List)
          .map((data) => SafeTopic.fromJson(data as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('Error getting safe topics: $e');
      return [];
    }
  }

  /// Update relationship notes
  Future<void> updateNotes(String conversationId, String notes) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      await _supabase
          .from('relationship_profiles')
          .update({'relationship_notes': notes})
          .eq('user_id', userId)
          .eq('conversation_id', conversationId);
    } catch (e) {
      print('Error updating notes: $e');
      rethrow;
    }
  }

  /// Update relationship type
  Future<void> updateRelationshipType(
    String conversationId,
    String relationshipType,
  ) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      await _supabase
          .from('relationship_profiles')
          .update({'relationship_type': relationshipType})
          .eq('user_id', userId)
          .eq('conversation_id', conversationId);
    } catch (e) {
      print('Error updating relationship type: $e');
      rethrow;
    }
  }
}
</file>

<file path="frontend/lib/services/response_template_service.dart">
import 'package:messageai/models/response_template.dart';
import 'package:messageai/models/situation_type.dart';

/// Service for managing response templates
class ResponseTemplateService {
  static final ResponseTemplateService _instance = 
      ResponseTemplateService._internal();
  factory ResponseTemplateService() => _instance;
  ResponseTemplateService._internal();

  // In-memory template storage (loaded from backend)
  final Map<String, ResponseTemplate> _templates = {};
  final Map<SituationType, List<String>> _templatesBySituation = {};
  bool _initialized = false;

  /// Initialize templates (call on app start)
  Future<void> loadTemplates() async {
    if (_initialized) return;
    
    // TODO: Load from backend or local storage
    // For now, using hardcoded templates
    _initializeHardcodedTemplates();
    _initialized = true;
  }

  /// Get template by ID
  ResponseTemplate? getTemplate(String id) {
    return _templates[id];
  }

  /// Get templates for a situation type
  List<ResponseTemplate> getTemplatesForSituation(SituationType situation) {
    final templateIds = _templatesBySituation[situation] ?? [];
    return templateIds
        .map((id) => _templates[id])
        .whereType<ResponseTemplate>()
        .toList();
  }

  /// Get all templates
  List<ResponseTemplate> getAllTemplates() {
    return _templates.values.toList();
  }

  /// Search templates by keywords
  List<ResponseTemplate> searchTemplates(String query) {
    final lowerQuery = query.toLowerCase();
    return _templates.values.where((template) {
      return template.name.toLowerCase().contains(lowerQuery) ||
             template.situation.toLowerCase().contains(lowerQuery) ||
             template.context.any((c) => c.toLowerCase().contains(lowerQuery));
    }).toList();
  }

  void _initializeHardcodedTemplates() {
    // Declining templates
    final decliningTemplates = [
      ResponseTemplate(
        id: 'decline_polite',
        name: 'Polite Decline',
        situation: 'When you need to say no professionally',
        template: "Thank you for thinking of me! Unfortunately, I won't be able to {activity} {timeframe}. I appreciate your understanding.",
        tone: 'polite',
        context: ['can you', 'would you', 'invitation'],
        neurodivergentFriendly: true,
        customizableFields: ['activity', 'timeframe'],
      ),
      ResponseTemplate(
        id: 'decline_no_explanation',
        name: 'Direct Decline',
        situation: "When you don't owe an explanation",
        template: "Thanks for the invite, but I'm not able to join this time.",
        tone: 'direct',
        context: ['party', 'event', 'hangout'],
        neurodivergentFriendly: true,
      ),
      ResponseTemplate(
        id: 'decline_with_alternative',
        name: 'Decline with Counter-Offer',
        situation: 'When you want to participate but need different terms',
        template: "I can't {original_request}, but I could {alternative}. Would that work?",
        tone: 'casual',
        context: ['meeting', 'call', 'hangout'],
        neurodivergentFriendly: true,
        customizableFields: ['original_request', 'alternative'],
      ),
      ResponseTemplate(
        id: 'decline_capacity',
        name: 'At Capacity (Mental Health)',
        situation: 'When you need to protect your energy',
        template: "I really appreciate you thinking of me, but I need to be mindful of my capacity right now. I'll have to pass on this one.",
        tone: 'apologetic',
        context: ['favor', 'help', 'support'],
        neurodivergentFriendly: true,
      ),
    ];

    // Boundary templates
    final boundaryTemplates = [
      ResponseTemplate(
        id: 'boundary_time',
        name: 'Time Boundary',
        situation: 'When someone expects 24/7 availability',
        template: "I'm available to discuss this during {your_hours}. Can we schedule a time within those hours?",
        tone: 'direct',
        context: ['urgent', 'right now', 'immediately'],
        neurodivergentFriendly: true,
        customizableFields: ['your_hours'],
      ),
      ResponseTemplate(
        id: 'boundary_communication',
        name: 'Communication Preference',
        situation: "When someone uses a communication method that doesn't work for you",
        template: "I process information better through {preferred_method}. Could we switch to that for this conversation?",
        tone: 'direct',
        context: ['call', 'video', 'meeting'],
        neurodivergentFriendly: true,
        customizableFields: ['preferred_method'],
      ),
      ResponseTemplate(
        id: 'boundary_topic',
        name: 'Topic Boundary',
        situation: "When someone brings up something you don't want to discuss",
        template: "I'm not comfortable discussing {topic}. Let's talk about something else.",
        tone: 'direct',
        context: ['personal', 'private', 'politics'],
        neurodivergentFriendly: true,
        customizableFields: ['topic'],
      ),
    ];

    // Info-dump templates
    final infoDumpTemplates = [
      ResponseTemplate(
        id: 'infodump_intro',
        name: 'Info-Dump with Warning',
        situation: 'When you want to share a lot about something you love',
        template: "I'm really excited about {topic}! Fair warning: I could talk about this for hours üòä Are you interested in hearing more?",
        tone: 'casual',
        context: ['excited', 'interesting', 'found'],
        neurodivergentFriendly: true,
        customizableFields: ['topic'],
      ),
      ResponseTemplate(
        id: 'infodump_chunked',
        name: 'Info-Dump in Chunks',
        situation: 'When you want to share but keep it digestible',
        template: "Quick version: {short_summary}\n\nWant the details? I can break it down into:\n1. {aspect_1}\n2. {aspect_2}\n3. {aspect_3}\n\nLet me know what interests you!",
        tone: 'casual',
        context: ['explain', 'tell', 'share'],
        neurodivergentFriendly: true,
        customizableFields: ['short_summary', 'aspect_1', 'aspect_2', 'aspect_3'],
      ),
    ];

    // Apologizing templates
    final apologizingTemplates = [
      ResponseTemplate(
        id: 'apology_genuine',
        name: 'Genuine Apology',
        situation: 'When you actually did something wrong',
        template: "I'm sorry for {what_you_did}. I understand that {impact}. Going forward, I'll {corrective_action}.",
        tone: 'apologetic',
        context: ['mistake', 'wrong', 'messed up'],
        neurodivergentFriendly: true,
        customizableFields: ['what_you_did', 'impact', 'corrective_action'],
      ),
      ResponseTemplate(
        id: 'apology_no_need',
        name: 'Replace Unnecessary Apology',
        situation: "When you're apologizing out of habit",
        template: "Thank you for {what_they_did}. I appreciate {specific_thing}.",
        tone: 'polite',
        context: ['sorry for', 'apologies for'],
        neurodivergentFriendly: true,
        customizableFields: ['what_they_did', 'specific_thing'],
      ),
    ];

    // Clarifying templates
    final clarifyingTemplates = [
      ResponseTemplate(
        id: 'clarify_misunderstand',
        name: 'Admit Confusion',
        situation: "When you don't understand something",
        template: "I want to make sure I understand correctly. Are you saying {your_interpretation}?",
        tone: 'direct',
        context: ['confused', 'unclear', 'not sure'],
        neurodivergentFriendly: true,
        customizableFields: ['your_interpretation'],
      ),
      ResponseTemplate(
        id: 'clarify_literal',
        name: 'Ask for Literal Meaning',
        situation: 'When you need things stated directly',
        template: "I'm having trouble reading between the lines. Could you tell me directly what you need from me?",
        tone: 'direct',
        context: ['ambiguous', 'vague', 'hint'],
        neurodivergentFriendly: true,
      ),
    ];

    // Store templates
    final allTemplates = [
      ...decliningTemplates,
      ...boundaryTemplates,
      ...infoDumpTemplates,
      ...apologizingTemplates,
      ...clarifyingTemplates,
    ];
    
    for (final template in allTemplates) {
      _templates[template.id] = template;
    }

    // Index by situation
    _templatesBySituation[SituationType.declining] = 
        decliningTemplates.map((t) => t.id).toList();
    _templatesBySituation[SituationType.boundarySetting] = 
        boundaryTemplates.map((t) => t.id).toList();
    _templatesBySituation[SituationType.infoDumping] = 
        infoDumpTemplates.map((t) => t.id).toList();
    _templatesBySituation[SituationType.apologizing] = 
        apologizingTemplates.map((t) => t.id).toList();
    _templatesBySituation[SituationType.clarifying] = 
        clarifyingTemplates.map((t) => t.id).toList();
  }
}
</file>

<file path="frontend/lib/services/retry_service.dart">
import 'dart:async';
import 'dart:math';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_handler.dart';

/// Configuration for retry behavior
class RetryConfig {
  final int maxAttempts;
  final Duration initialDelay;
  final Duration maxDelay;
  final double backoffMultiplier;
  final bool useJitter;

  const RetryConfig({
    this.maxAttempts = 3,
    this.initialDelay = const Duration(seconds: 1),
    this.maxDelay = const Duration(seconds: 30),
    this.backoffMultiplier = 2.0,
    this.useJitter = true,
  });

  /// Aggressive retry (more attempts, faster)
  static const aggressive = RetryConfig(
    maxAttempts: 5,
    initialDelay: Duration(milliseconds: 500),
    maxDelay: Duration(seconds: 15),
  );

  /// Conservative retry (fewer attempts, slower)
  static const conservative = RetryConfig(
    maxAttempts: 2,
    initialDelay: Duration(seconds: 2),
    maxDelay: Duration(seconds: 60),
  );

  /// Default retry configuration
  static const defaultConfig = RetryConfig();
}

/// Result of a retry operation
class RetryResult<T> {
  final T? data;
  final AppError? error;
  final int attempts;
  final bool succeeded;

  RetryResult({
    this.data,
    this.error,
    required this.attempts,
    required this.succeeded,
  });

  RetryResult.success(T data, int attempts)
      : this(
          data: data,
          succeeded: true,
          attempts: attempts,
        );

  RetryResult.failure(AppError error, int attempts)
      : this(
          error: error,
          succeeded: false,
          attempts: attempts,
        );
}

/// Service for handling retries with exponential backoff
class RetryService {
  static final RetryService _instance = RetryService._internal();

  factory RetryService() {
    return _instance;
  }

  RetryService._internal();

  final _errorHandler = ErrorHandler();
  final _random = Random();

  /// Execute operation with retry logic
  Future<RetryResult<T>> execute<T>({
    required Future<T> Function() operation,
    required String operationName,
    RetryConfig config = RetryConfig.defaultConfig,
    bool Function(AppError)? shouldRetry,
  }) async {
    int attemptNumber = 0;
    AppError? lastError;

    while (attemptNumber < config.maxAttempts) {
      attemptNumber++;

      try {
        final result = await operation();
        return RetryResult.success(result, attemptNumber);
      } catch (error, stackTrace) {
        // Convert to AppError
        final appError = error is AppError
            ? error
            : _errorHandler.handleError(
                error,
                stackTrace: stackTrace,
                context: operationName,
              );

        lastError = appError;

        // Check if we should retry
        final shouldRetryThis = shouldRetry?.call(appError) ??
            _errorHandler.shouldRetry(appError, attemptNumber, maxAttempts: config.maxAttempts);

        if (!shouldRetryThis) {
          return RetryResult.failure(appError, attemptNumber);
        }

        // Calculate delay before next attempt
        if (attemptNumber < config.maxAttempts) {
          final delay = _calculateDelay(
            attemptNumber,
            config: config,
          );
          await Future.delayed(delay);
        }
      }
    }

    return RetryResult.failure(
      lastError ?? AppError(
        category: ErrorCategory.unknown,
        severity: ErrorSeverity.error,
        code: 'RETRY001',
        message: 'Max retry attempts exceeded',
        userMessage: 'Operation failed after multiple attempts',
      ),
      attemptNumber,
    );
  }

  /// Calculate delay for next retry attempt (exponential backoff with jitter)
  Duration _calculateDelay(int attemptNumber, {required RetryConfig config}) {
    // Calculate base delay: initialDelay * (backoffMultiplier ^ attemptNumber)
    final exponentialDelay = config.initialDelay.inMilliseconds *
        pow(config.backoffMultiplier, attemptNumber - 1);

    // Cap at max delay
    final cappedDelay = min(exponentialDelay, config.maxDelay.inMilliseconds.toDouble());

    // Add jitter to avoid thundering herd
    final delayWithJitter = config.useJitter
        ? _addJitter(cappedDelay.toDouble())
        : cappedDelay.toDouble();

    return Duration(milliseconds: delayWithJitter.round());
  }

  /// Add random jitter to delay (¬±25%)
  double _addJitter(double delay) {
    final jitterRange = delay * 0.25; // ¬±25%
    final jitter = (_random.nextDouble() * 2 - 1) * jitterRange;
    return delay + jitter;
  }

  /// Execute with simple retry (no configuration)
  Future<T> executeSimple<T>({
    required Future<T> Function() operation,
    int maxAttempts = 3,
  }) async {
    final result = await execute(
      operation: operation,
      operationName: 'Operation',
      config: RetryConfig(maxAttempts: maxAttempts),
    );

    if (result.succeeded) {
      return result.data as T;
    } else {
      throw result.error!;
    }
  }

  /// Execute with timeout and retry
  Future<RetryResult<T>> executeWithTimeout<T>({
    required Future<T> Function() operation,
    required String operationName,
    Duration timeout = const Duration(seconds: 30),
    RetryConfig config = RetryConfig.defaultConfig,
  }) async {
    return execute<T>(
      operation: () async {
        return await operation().timeout(
          timeout,
          onTimeout: () {
            throw AppError(
              category: ErrorCategory.network,
              severity: ErrorSeverity.warning,
              code: 'NET002',
              message: 'Operation timeout',
              userMessage: 'The operation took too long. Please try again.',
              isRetryable: true,
            );
          },
        );
      },
      operationName: operationName,
      config: config,
    );
  }
}

/// Extension to add retry capability to Future
extension RetryExtension<T> on Future<T> {
  /// Retry this future with exponential backoff
  Future<T> withRetry({
    String operationName = 'Operation',
    int maxAttempts = 3,
  }) async {
    final retryService = RetryService();
    return retryService.executeSimple(
      operation: () => this,
      maxAttempts: maxAttempts,
    );
  }

  /// Retry with full configuration
  Future<RetryResult<T>> withRetryConfig({
    required String operationName,
    RetryConfig config = RetryConfig.defaultConfig,
  }) async {
    final retryService = RetryService();
    return retryService.execute(
      operation: () => this,
      operationName: operationName,
      config: config,
    );
  }
}
</file>

<file path="frontend/lib/state/repository_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/repositories/message_repository.dart';
import 'package:messageai/data/repositories/receipt_repository.dart';
import 'package:messageai/data/repositories/group_repository.dart';
import 'package:messageai/state/database_provider.dart';
import 'package:messageai/state/providers.dart';

/// Provides the MessageRepository
final messageRepositoryProvider = Provider<MessageRepository>((ref) {
  final messagesApi = ref.watch(messagesApiProvider);
  final messageDao = ref.watch(messageDaoProvider);
  final outboxDao = ref.watch(pendingOutboxDaoProvider);
  
  return MessageRepository(
    messagesApi: messagesApi,
    messageDao: messageDao,
    outboxDao: outboxDao,
  );
});

/// Provides the ReceiptRepository
final receiptRepositoryProvider = Provider<ReceiptRepository>((ref) {
  final receiptsApi = ref.watch(receiptsApiProvider);
  final receiptDao = ref.watch(receiptDaoProvider);
  final outboxDao = ref.watch(pendingOutboxDaoProvider);
  
  return ReceiptRepository(
    receiptsApi: receiptsApi,
    receiptDao: receiptDao,
    outboxDao: outboxDao,
  );
});

/// Provides the GroupRepository
final groupRepositoryProvider = Provider<GroupRepository>((ref) {
  final conversationDao = ref.watch(conversationDaoProvider);
  final participantDao = ref.watch(participantDaoProvider);
  
  return GroupRepository(
    conversationDao: conversationDao,
    participantDao: participantDao,
  );
});

// Add receiptDaoProvider to database_provider.dart if not already there
// final receiptDaoProvider = Provider<ReceiptDao>((ref) {
//   final db = ref.watch(appDbProvider);
//   return ReceiptDao(db);
// });
</file>

<file path="frontend/lib/state/send_queue.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/state/repository_providers.dart';

/// Message to send
class SendableMessage {
  final String id;
  final String conversationId;
  final String senderId;
  final String body;
  final String? mediaUrl;

  SendableMessage({
    required this.id,
    required this.conversationId,
    required this.senderId,
    required this.body,
    this.mediaUrl,
  });
}

/// Manages sending messages with optimistic updates
class SendQueue {
  final Ref ref;
  
  SendQueue({required this.ref});

  /// Send a message
  Future<Message> sendMessage({
    required String conversationId,
    required String senderId,
    required String body,
    String? mediaUrl,
  }) async {
    // Generate unique ID
    const uuid = Uuid();
    final messageId = uuid.v4();
    
    // Get repository
    final messageRepo = ref.watch(messageRepositoryProvider);
    
    // Send optimistically (local first)
    final message = await messageRepo.sendMessage(
      id: messageId,
      conversationId: conversationId,
      senderId: senderId,
      body: body,
      mediaUrl: mediaUrl,
    );
    
    // Queue background sync
    _scheduleSyncIfNeeded();
    
    return message;
  }

  /// Drain the send queue (sync pending messages)
  Future<void> drainQueue() async {
    final messageRepo = ref.watch(messageRepositoryProvider);
    final receiptRepo = ref.watch(receiptRepositoryProvider);
    
    try {
      // Sync messages
      await messageRepo.syncUnsyncedMessages();
      
      // Sync receipts
      await receiptRepo.syncUnsyncedReceipts();
    } catch (e) {
      print('Error draining send queue: $e');
      rethrow;
    }
  }

  /// Schedule sync if there are pending operations
  void _scheduleSyncIfNeeded() {
    // In a real app, this would use a periodic timer or background service
    // For now, we'll just sync immediately for demo purposes
    _syncInBackground();
  }

  /// Sync in background
  void _syncInBackground() {
    // Run sync without awaiting (fire and forget)
    drainQueue().catchError((e) {
      print('Background sync error: $e');
    });
  }

  /// Get pending message count
  Future<int> getPendingCount() async {
    final messageRepo = ref.watch(messageRepositoryProvider);
    return messageRepo.getPendingMessageCount();
  }
}

/// Provider for send queue
final sendQueueProvider = Provider<SendQueue>((ref) {
  return SendQueue(ref: ref);
});

/// State notifier for managing message sends
class SendMessageNotifier extends StateNotifier<AsyncValue<void>> {
  final Ref ref;

  SendMessageNotifier({required this.ref}) : super(const AsyncValue.data(null));

  /// Send a message
  Future<Message> sendMessage({
    required String conversationId,
    required String senderId,
    required String body,
    String? mediaUrl,
  }) async {
    state = const AsyncValue.loading();
    
    try {
      final sendQueue = ref.watch(sendQueueProvider);
      final message = await sendQueue.sendMessage(
        conversationId: conversationId,
        senderId: senderId,
        body: body,
        mediaUrl: mediaUrl,
      );
      
      state = const AsyncValue.data(null);
      return message;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }

  /// Retry pending messages
  Future<void> retryPending() async {
    state = const AsyncValue.loading();
    
    try {
      final sendQueue = ref.watch(sendQueueProvider);
      await sendQueue.drainQueue();
      state = const AsyncValue.data(null);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }
}

/// State notifier provider for sending messages
final sendMessageNotifierProvider = 
    StateNotifierProvider<SendMessageNotifier, AsyncValue<void>>((ref) {
  return SendMessageNotifier(ref: ref);
});

/// Get pending message count
final pendingMessageCountProvider = FutureProvider<int>((ref) async {
  final sendQueue = ref.watch(sendQueueProvider);
  return sendQueue.getPendingCount();
});
</file>

<file path="frontend/lib/widgets/network_status_banner.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/network_connectivity_service.dart';
import 'package:messageai/services/offline_queue_service.dart';

/// Banner that shows network status and pending message count
class NetworkStatusBanner extends StatefulWidget {
  const NetworkStatusBanner({Key? key}) : super(key: key);

  @override
  State<NetworkStatusBanner> createState() => _NetworkStatusBannerState();
}

class _NetworkStatusBannerState extends State<NetworkStatusBanner> {
  final _connectivityService = NetworkConnectivityService();
  final _offlineQueueService = OfflineQueueService();
  
  ConnectivityStatus _status = ConnectivityStatus.unknown;
  int _pendingMessages = 0;

  @override
  void initState() {
    super.initState();
    _status = _connectivityService.currentStatus;
    _loadPendingCount();
    
    // Listen to connectivity changes
    _connectivityService.onStatusChange.listen((status) {
      if (mounted) {
        setState(() => _status = status);
        _loadPendingCount();
      }
    });
  }

  Future<void> _loadPendingCount() async {
    final count = await _offlineQueueService.getPendingMessageCount();
    if (mounted) {
      setState(() => _pendingMessages = count);
    }
  }

  Future<void> _handleSyncTap() async {
    // Show loading
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Row(
          children: [
            SizedBox(
              width: 16,
              height: 16,
              child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),
            ),
            SizedBox(width: 12),
            Text('Syncing pending messages...'),
          ],
        ),
        duration: Duration(seconds: 2),
      ),
    );

    final result = await _offlineQueueService.forceSyncNow();
    
    if (!mounted) return;

    ScaffoldMessenger.of(context).hideCurrentSnackBar();
    
    if (result.isSuccess) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.check_circle, color: Colors.white),
              const SizedBox(width: 12),
              Text('${result.successCount} messages synced'),
            ],
          ),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 2),
        ),
      );
      _loadPendingCount();
    } else if (result.status == SyncStatus.noMessages) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Row(
            children: [
              Icon(Icons.check_circle, color: Colors.white),
              SizedBox(width: 12),
              Text('All messages are synced'),
            ],
          ),
          backgroundColor: Colors.blue,
          duration: Duration(seconds: 2),
        ),
      );
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.error, color: Colors.white),
              const SizedBox(width: 12),
              Text('Failed to sync: ${result.errorMessage ?? "Unknown error"}'),
            ],
          ),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    // Only show banner when offline or has pending messages
    if (_status == ConnectivityStatus.online && _pendingMessages == 0) {
      return const SizedBox.shrink();
    }

    return Material(
      color: _getBannerColor(),
      child: InkWell(
        onTap: _status == ConnectivityStatus.online && _pendingMessages > 0
            ? _handleSyncTap
            : null,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: Row(
            children: [
              Icon(
                _getBannerIcon(),
                size: 20,
                color: Colors.white,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  _getBannerText(),
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 14,
                  ),
                ),
              ),
              if (_status == ConnectivityStatus.online && _pendingMessages > 0)
                const Icon(
                  Icons.sync,
                  size: 20,
                  color: Colors.white,
                ),
            ],
          ),
        ),
      ),
    );
  }

  Color _getBannerColor() {
    if (_status == ConnectivityStatus.offline) {
      return Colors.red.shade700;
    } else if (_pendingMessages > 0) {
      return Colors.orange.shade700;
    }
    return Colors.blue;
  }

  IconData _getBannerIcon() {
    if (_status == ConnectivityStatus.offline) {
      return Icons.cloud_off;
    } else if (_pendingMessages > 0) {
      return Icons.cloud_sync;
    }
    return Icons.cloud_done;
  }

  String _getBannerText() {
    if (_status == ConnectivityStatus.offline) {
      if (_pendingMessages > 0) {
        return 'Offline ‚Ä¢ $_pendingMessages message${_pendingMessages == 1 ? '' : 's'} pending';
      }
      return 'You are offline';
    } else if (_pendingMessages > 0) {
      return 'Syncing $_pendingMessages message${_pendingMessages == 1 ? '' : 's'} ‚Ä¢ Tap to sync now';
    }
    return 'All messages synced';
  }
}

/// Small inline network indicator
class NetworkStatusIndicator extends StatefulWidget {
  final bool showLabel;

  const NetworkStatusIndicator({
    Key? key,
    this.showLabel = true,
  }) : super(key: key);

  @override
  State<NetworkStatusIndicator> createState() => _NetworkStatusIndicatorState();
}

class _NetworkStatusIndicatorState extends State<NetworkStatusIndicator> {
  final _connectivityService = NetworkConnectivityService();
  ConnectivityStatus _status = ConnectivityStatus.unknown;

  @override
  void initState() {
    super.initState();
    _status = _connectivityService.currentStatus;
    
    _connectivityService.onStatusChange.listen((status) {
      if (mounted) {
        setState(() => _status = status);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          width: 8,
          height: 8,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: _getStatusColor(),
          ),
        ),
        if (widget.showLabel) ...[
          const SizedBox(width: 6),
          Text(
            _getStatusLabel(),
            style: TextStyle(
              fontSize: 12,
              color: Colors.grey[600],
            ),
          ),
        ],
      ],
    );
  }

  Color _getStatusColor() {
    switch (_status) {
      case ConnectivityStatus.online:
        return Colors.green;
      case ConnectivityStatus.offline:
        return Colors.red;
      case ConnectivityStatus.unknown:
        return Colors.grey;
    }
  }

  String _getStatusLabel() {
    switch (_status) {
      case ConnectivityStatus.online:
        return 'Online';
      case ConnectivityStatus.offline:
        return 'Offline';
      case ConnectivityStatus.unknown:
        return 'Unknown';
    }
  }
}
</file>

<file path="frontend/lib/widgets/user_avatar.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/avatar_service.dart';

/// Reusable widget for displaying user avatars
/// Fetches avatar from backend or shows fallback initial
class UserAvatar extends StatefulWidget {
  final String? userId;
  final String? avatarUrl;
  final String fallbackText;
  final double radius;
  final bool isGroup;

  const UserAvatar({
    Key? key,
    this.userId,
    this.avatarUrl,
    required this.fallbackText,
    this.radius = 20,
    this.isGroup = false,
  }) : super(key: key);

  @override
  State<UserAvatar> createState() => _UserAvatarState();
}

class _UserAvatarState extends State<UserAvatar> {
  final _avatarService = AvatarService();
  String? _fetchedAvatarUrl;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _loadAvatar();
  }

  @override
  void didUpdateWidget(UserAvatar oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Reload if userId changed
    if (oldWidget.userId != widget.userId || oldWidget.avatarUrl != widget.avatarUrl) {
      _loadAvatar();
    }
  }

  Future<void> _loadAvatar() async {
    // If avatarUrl is directly provided, use it
    if (widget.avatarUrl != null) {
      setState(() {
        _fetchedAvatarUrl = widget.avatarUrl;
      });
      return;
    }

    // If userId provided, fetch avatar
    if (widget.userId != null) {
      setState(() => _isLoading = true);
      
      try {
        final url = await _avatarService.getAvatarUrl(widget.userId!);
        if (mounted) {
          setState(() {
            _fetchedAvatarUrl = url;
            _isLoading = false;
          });
        }
      } catch (e) {
        if (mounted) {
          setState(() => _isLoading = false);
        }
        // Silently fail - fallback will be shown
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    // Show loading indicator
    if (_isLoading) {
      return CircleAvatar(
        radius: widget.radius,
        backgroundColor: theme.colorScheme.primary.withOpacity(0.2),
        child: SizedBox(
          width: widget.radius,
          height: widget.radius,
          child: const CircularProgressIndicator(strokeWidth: 2),
        ),
      );
    }

    // Show avatar image if available
    if (_fetchedAvatarUrl != null && _fetchedAvatarUrl!.isNotEmpty) {
      return CircleAvatar(
        radius: widget.radius,
        backgroundColor: theme.colorScheme.primary,
        backgroundImage: NetworkImage(_fetchedAvatarUrl!),
        // Error handling: show fallback if image fails to load
        onBackgroundImageError: (exception, stackTrace) {
          print('Error loading avatar: $exception');
        },
        child: Container(), // Empty container as placeholder
      );
    }

    // Fallback: Show initial or group icon
    return CircleAvatar(
      radius: widget.radius,
      backgroundColor: theme.colorScheme.primary,
      child: widget.isGroup
          ? Icon(
              Icons.group,
              color: Colors.white,
              size: widget.radius * 1.2,
            )
          : Text(
              _getInitial(widget.fallbackText),
              style: TextStyle(
                fontSize: widget.radius * 0.9,
                fontWeight: FontWeight.bold,
                color: Colors.white,
              ),
            ),
    );
  }

  /// Get first letter of name for fallback
  String _getInitial(String text) {
    if (text.isEmpty) return '?';
    return text[0].toUpperCase();
  }
}
</file>

<file path="frontend/Makefile">
contracts/gen: ; npm --prefix ../contracts run gen:dart
fmt: ; dart format .
dev: ; flutter run --dart-define-from-file=.env.dev.json
test: ; flutter test
</file>

<file path="frontend/test/models/action_item_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/action_item.dart';

void main() {
  group('ActionItem', () {
    test('fromJson creates correct instance', () {
      final json = {
        'id': 'action-123',
        'follow_up_item_id': 'follow-456',
        'action_type': 'send',
        'action_target': 'quarterly report',
        'commitment_text': "I'll send you the quarterly report by Friday",
        'mentioned_deadline': 'by Friday',
        'extracted_deadline': 1640000000,
      };

      final action = ActionItem.fromJson(json);

      expect(action.id, 'action-123');
      expect(action.followUpItemId, 'follow-456');
      expect(action.actionType, 'send');
      expect(action.actionTarget, 'quarterly report');
      expect(action.commitmentText, "I'll send you the quarterly report by Friday");
      expect(action.mentionedDeadline, 'by Friday');
      expect(action.extractedDeadline, 1640000000);
    });

    test('fromJson handles null optional fields', () {
      final json = {
        'id': 'action-123',
        'follow_up_item_id': 'follow-456',
        'action_type': 'call',
        'commitment_text': "I'll call you later",
      };

      final action = ActionItem.fromJson(json);

      expect(action.actionTarget, isNull);
      expect(action.mentionedDeadline, isNull);
      expect(action.extractedDeadline, isNull);
    });

    group('getActionEmoji', () {
      test('returns correct emoji for send', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'send',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), 'üì§');
      });

      test('returns correct emoji for call', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'call',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), 'üìû');
      });

      test('returns correct emoji for meet', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'meet',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), 'ü§ù');
      });

      test('returns correct emoji for review', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'review',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), 'üìã');
      });

      test('returns correct emoji for decide', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'decide',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), 'ü§î');
      });

      test('returns correct emoji for follow_up', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'follow_up',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), 'üîÑ');
      });

      test('returns correct emoji for check', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'check',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '‚úÖ');
      });

      test('returns correct emoji for schedule', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'schedule',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), 'üìÖ');
      });

      test('returns default emoji for unknown type', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'unknown',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), 'üìå');
      });

      test('handles case insensitive action types', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'SEND',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), 'üì§');
      });
    });
  });
}
</file>

<file path="frontend/test/models/ai_analysis_enhanced_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('AIAnalysis Enhanced Fields', () {
    test('parses complete enhanced analysis from JSON', () {
      final json = {
        'id': 'test-id-123',
        'message_id': 'msg-456',
        'tone': 'Overwhelmed',
        'urgency_level': 'High',
        'intent': 'expressing severe stress',
        'confidence_score': 0.92,
        'analysis_timestamp': 1234567890,
        'intensity': 'very_high',
        'secondary_tones': ['Frustrated', 'Concerned'],
        'context_flags': {
          'tone_indicator_present': true,
          'sarcasm_detected': false,
          'ambiguous': false,
        },
        'anxiety_assessment': {
          'risk_level': 'high',
          'mitigation_suggestions': [
            'Urgent tone detected. Consider asking for a specific timeline.'
          ],
        },
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.id, 'test-id-123');
      expect(analysis.messageId, 'msg-456');
      expect(analysis.tone, 'Overwhelmed');
      expect(analysis.urgencyLevel, 'High');
      expect(analysis.intent, 'expressing severe stress');
      expect(analysis.confidenceScore, 0.92);
      expect(analysis.intensity, 'very_high');
      expect(analysis.secondaryTones, ['Frustrated', 'Concerned']);
      expect(analysis.contextFlags?['tone_indicator_present'], true);
      expect(analysis.anxietyAssessment?['risk_level'], 'high');
    });

    test('parses analysis without enhanced fields (backward compatibility)', () {
      final json = {
        'id': 'test-id-123',
        'message_id': 'msg-456',
        'tone': 'Friendly',
        'urgency_level': 'Low',
        'intent': 'greeting',
        'confidence_score': 0.85,
        'analysis_timestamp': 1234567890,
        // No enhanced fields
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.tone, 'Friendly');
      expect(analysis.intensity, null);
      expect(analysis.secondaryTones, null);
      expect(analysis.contextFlags, null);
      expect(analysis.anxietyAssessment, null);
    });

    test('toJson includes all enhanced fields', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Playful',
        urgencyLevel: 'Low',
        intent: 'joking around',
        confidenceScore: 0.88,
        analysisTimestamp: 1234567890,
        intensity: 'medium',
        secondaryTones: ['Friendly'],
        contextFlags: {'tone_indicator_present': true},
        anxietyAssessment: {'risk_level': 'low'},
      );

      final json = analysis.toJson();

      expect(json['tone'], 'Playful');
      expect(json['intensity'], 'medium');
      expect(json['secondary_tones'], ['Friendly']);
      expect(json['context_flags'], {'tone_indicator_present': true});
      expect(json['anxiety_assessment'], {'risk_level': 'low'});
    });

    test('toJson excludes null enhanced fields', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Neutral',
        analysisTimestamp: 1234567890,
        // All optional fields are null
      );

      final json = analysis.toJson();

      expect(json.containsKey('intensity'), false);
      expect(json.containsKey('secondary_tones'), false);
      expect(json.containsKey('context_flags'), false);
      expect(json.containsKey('anxiety_assessment'), false);
    });

    test('toString includes intensity field', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Excited',
        intensity: 'high',
        analysisTimestamp: 1234567890,
      );

      final str = analysis.toString();

      expect(str.contains('Excited'), true);
      expect(str.contains('high'), true);
    });

    test('handles all 23 tone types', () {
      final tones = [
        'Friendly', 'Professional', 'Urgent', 'Casual', 'Formal', 'Concerned',
        'Excited', 'Neutral', 'Apologetic', 'Appreciative', 'Frustrated', 'Playful',
        'Sarcastic', 'Empathetic', 'Inquisitive', 'Assertive', 'Tentative', 'Defensive',
        'Encouraging', 'Disappointed', 'Overwhelmed', 'Relieved', 'Confused'
      ];

      for (final tone in tones) {
        final json = {
          'id': 'test-id',
          'message_id': 'msg-id',
          'tone': tone,
          'analysis_timestamp': 1234567890,
        };

        final analysis = AIAnalysis.fromJson(json);
        expect(analysis.tone, tone);
      }
    });

    test('handles all 5 intensity levels', () {
      final intensities = ['very_low', 'low', 'medium', 'high', 'very_high'];

      for (final intensity in intensities) {
        final json = {
          'id': 'test-id',
          'message_id': 'msg-id',
          'tone': 'Friendly',
          'intensity': intensity,
          'analysis_timestamp': 1234567890,
        };

        final analysis = AIAnalysis.fromJson(json);
        expect(analysis.intensity, intensity);
      }
    });

    test('parses complex context flags', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-id',
        'tone': 'Sarcastic',
        'analysis_timestamp': 1234567890,
        'context_flags': {
          'sarcasm_detected': true,
          'tone_indicator_present': true,
          'ambiguous': false,
          'figurative_language': true,
        },
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.contextFlags?['sarcasm_detected'], true);
      expect(analysis.contextFlags?['tone_indicator_present'], true);
      expect(analysis.contextFlags?['ambiguous'], false);
      expect(analysis.contextFlags?['figurative_language'], true);
    });

    test('parses anxiety assessment with suggestions', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-id',
        'tone': 'Urgent',
        'analysis_timestamp': 1234567890,
        'anxiety_assessment': {
          'risk_level': 'high',
          'mitigation_suggestions': [
            'Urgent tone detected. Consider asking for a specific timeline.',
            'Take a deep breath before responding.',
          ],
        },
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.anxietyAssessment?['risk_level'], 'high');
      final suggestions = analysis.anxietyAssessment?['mitigation_suggestions'] as List;
      expect(suggestions.length, 2);
      expect(suggestions[0], contains('Urgent tone'));
    });
  });
}
</file>

<file path="frontend/test/models/ai_analysis_phase1_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('AIAnalysis Phase 1 Integration Tests', () {
    test('fromJson parses Phase 1 fields correctly', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-123',
        'tone': 'Neutral',
        'urgency_level': 'Low',
        'intent': 'Quick acknowledgment',
        'confidence_score': 0.85,
        'analysis_timestamp': 1234567890,
        'rsd_triggers': [
          {
            'pattern': 'ok',
            'severity': 'high',
            'explanation': 'Single-word responses can trigger RSD',
            'reassurance': 'This is likely just a quick acknowledgment',
          }
        ],
        'alternative_interpretations': [
          {
            'interpretation': 'Simple acknowledgment',
            'tone': 'Neutral',
            'likelihood': 70,
            'reasoning': 'Most common use',
            'context_clues': ['No conflict'],
          }
        ],
        'evidence': [
          {
            'type': 'length',
            'quote': 'ok',
            'supports': 'brevity',
            'reasoning': 'Very short message',
          }
        ],
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.id, 'test-id');
      expect(analysis.messageId, 'msg-123');
      expect(analysis.tone, 'Neutral');
      
      // Check Phase 1 fields
      expect(analysis.rsdTriggers, isNotNull);
      expect(analysis.rsdTriggers!.length, 1);
      expect(analysis.rsdTriggers![0].pattern, 'ok');
      expect(analysis.rsdTriggers![0].severity, 'high');
      
      expect(analysis.alternativeInterpretations, isNotNull);
      expect(analysis.alternativeInterpretations!.length, 1);
      expect(analysis.alternativeInterpretations![0].interpretation, 'Simple acknowledgment');
      expect(analysis.alternativeInterpretations![0].likelihood, 70);
      
      expect(analysis.evidence, isNotNull);
      expect(analysis.evidence!.length, 1);
      expect(analysis.evidence![0].type, 'length');
      expect(analysis.evidence![0].quote, 'ok');
    });

    test('toJson serializes Phase 1 fields correctly', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-123',
        tone: 'Neutral',
        urgencyLevel: 'Low',
        intent: 'Test',
        confidenceScore: 0.85,
        analysisTimestamp: 1234567890,
        rsdTriggers: [
          const RSDTrigger(
            pattern: 'ok',
            severity: 'high',
            explanation: 'test',
            reassurance: 'test',
          )
        ],
        alternativeInterpretations: [
          const MessageInterpretation(
            interpretation: 'test',
            tone: 'Neutral',
            likelihood: 70,
            reasoning: 'test',
            contextClues: [],
          )
        ],
        evidence: [
          const Evidence(
            type: 'keyword',
            quote: 'ASAP',
            supports: 'urgency',
            reasoning: 'test',
          )
        ],
      );

      final json = analysis.toJson();

      expect(json['rsd_triggers'], isNotNull);
      expect(json['rsd_triggers'], isList);
      expect((json['rsd_triggers'] as List).length, 1);
      
      expect(json['alternative_interpretations'], isNotNull);
      expect(json['alternative_interpretations'], isList);
      expect((json['alternative_interpretations'] as List).length, 1);
      
      expect(json['evidence'], isNotNull);
      expect(json['evidence'], isList);
      expect((json['evidence'] as List).length, 1);
    });

    test('fromJson handles null Phase 1 fields', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-123',
        'tone': 'Neutral',
        'analysis_timestamp': 1234567890,
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.rsdTriggers, null);
      expect(analysis.alternativeInterpretations, null);
      expect(analysis.evidence, null);
    });

    test('fromJson handles empty Phase 1 arrays', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-123',
        'tone': 'Neutral',
        'analysis_timestamp': 1234567890,
        'rsd_triggers': [],
        'alternative_interpretations': [],
        'evidence': [],
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.rsdTriggers, isNotNull);
      expect(analysis.rsdTriggers!.isEmpty, true);
      expect(analysis.alternativeInterpretations, isNotNull);
      expect(analysis.alternativeInterpretations!.isEmpty, true);
      expect(analysis.evidence, isNotNull);
      expect(analysis.evidence!.isEmpty, true);
    });
  });
}
</file>

<file path="frontend/test/models/ai_analysis_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('AIAnalysis Model', () {
    test('fromJson creates valid object with all fields', () {
      final json = {
        'id': 'test-id-123',
        'message_id': 'msg-456',
        'tone': 'Professional',
        'urgency_level': 'Medium',
        'intent': 'requesting information',
        'confidence_score': 0.85,
        'analysis_timestamp': 1234567890,
      };
      
      final analysis = AIAnalysis.fromJson(json);
      
      expect(analysis.id, equals('test-id-123'));
      expect(analysis.messageId, equals('msg-456'));
      expect(analysis.tone, equals('Professional'));
      expect(analysis.urgencyLevel, equals('Medium'));
      expect(analysis.intent, equals('requesting information'));
      expect(analysis.confidenceScore, equals(0.85));
      expect(analysis.analysisTimestamp, equals(1234567890));
    });
    
    test('fromJson handles null optional fields', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-id',
        'tone': 'Neutral',
        'analysis_timestamp': 1234567890,
      };
      
      final analysis = AIAnalysis.fromJson(json);
      
      expect(analysis.tone, equals('Neutral'));
      expect(analysis.urgencyLevel, isNull);
      expect(analysis.intent, isNull);
      expect(analysis.confidenceScore, isNull);
    });
    
    test('toJson creates correct map', () {
      final analysis = AIAnalysis(
        id: 'id-1',
        messageId: 'msg-1',
        tone: 'Friendly',
        urgencyLevel: 'Low',
        intent: 'greeting',
        confidenceScore: 0.9,
        analysisTimestamp: 9876543210,
      );
      
      final json = analysis.toJson();
      
      expect(json['id'], equals('id-1'));
      expect(json['message_id'], equals('msg-1'));
      expect(json['tone'], equals('Friendly'));
      expect(json['urgency_level'], equals('Low'));
      expect(json['intent'], equals('greeting'));
      expect(json['confidence_score'], equals(0.9));
      expect(json['analysis_timestamp'], equals(9876543210));
    });
    
    test('equality works correctly', () {
      final a1 = AIAnalysis(
        id: 'same-id',
        messageId: 'same-msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );
      
      final a2 = AIAnalysis(
        id: 'same-id',
        messageId: 'same-msg',
        tone: 'Professional', // Different tone
        analysisTimestamp: 456, // Different timestamp
      );
      
      final a3 = AIAnalysis(
        id: 'different-id',
        messageId: 'same-msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );
      
      expect(a1, equals(a2)); // Same ID and message ID
      expect(a1, isNot(equals(a3))); // Different ID
    });
    
    test('hashCode is consistent', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Casual',
        analysisTimestamp: 123,
      );
      
      final hash1 = analysis.hashCode;
      final hash2 = analysis.hashCode;
      
      expect(hash1, equals(hash2));
    });
    
    test('toString includes key information', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Urgent',
        urgencyLevel: 'High',
        intent: 'needs response',
        confidenceScore: 0.95,
        analysisTimestamp: 123456,
      );
      
      final str = analysis.toString();
      
      expect(str, contains('test-id'));
      expect(str, contains('msg-id'));
      expect(str, contains('Urgent'));
      expect(str, contains('High'));
    });
    
    test('handles double and int confidence scores', () {
      // Test with integer
      final json1 = {
        'id': 'id-1',
        'message_id': 'msg-1',
        'tone': 'Neutral',
        'confidence_score': 1,
        'analysis_timestamp': 123,
      };
      
      final analysis1 = AIAnalysis.fromJson(json1);
      expect(analysis1.confidenceScore, equals(1.0));
      
      // Test with double
      final json2 = {
        'id': 'id-2',
        'message_id': 'msg-2',
        'tone': 'Neutral',
        'confidence_score': 0.75,
        'analysis_timestamp': 123,
      };
      
      final analysis2 = AIAnalysis.fromJson(json2);
      expect(analysis2.confidenceScore, equals(0.75));
    });
    
    test('round-trip JSON serialization preserves data', () {
      final original = AIAnalysis(
        id: 'round-trip-id',
        messageId: 'round-trip-msg',
        tone: 'Excited',
        urgencyLevel: 'Medium',
        intent: 'celebration',
        confidenceScore: 0.88,
        analysisTimestamp: 1111111111,
      );
      
      final json = original.toJson();
      final reconstructed = AIAnalysis.fromJson(json);
      
      expect(reconstructed, equals(original));
      expect(reconstructed.id, equals(original.id));
      expect(reconstructed.messageId, equals(original.messageId));
      expect(reconstructed.tone, equals(original.tone));
      expect(reconstructed.urgencyLevel, equals(original.urgencyLevel));
      expect(reconstructed.intent, equals(original.intent));
      expect(reconstructed.confidenceScore, equals(original.confidenceScore));
      expect(reconstructed.analysisTimestamp, equals(original.analysisTimestamp));
    });
  });
}
</file>

<file path="frontend/test/models/conversation_context_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/conversation_context.dart';

void main() {
  group('KeyPoint', () {
    test('fromJson creates KeyPoint correctly', () {
      final json = {
        'text': 'Discussed project deadline',
        'timestamp': 1640000000,
      };

      final keyPoint = KeyPoint.fromJson(json);

      expect(keyPoint.text, 'Discussed project deadline');
      expect(keyPoint.timestamp, 1640000000);
    });

    test('getTimeAgo returns "just now" for recent timestamps', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final keyPoint = KeyPoint(
        text: 'Test',
        timestamp: now - 30, // 30 seconds ago
      );

      expect(keyPoint.getTimeAgo(), 'just now');
    });

    test('getTimeAgo returns minutes for timestamps < 1 hour', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final keyPoint = KeyPoint(
        text: 'Test',
        timestamp: now - 600, // 10 minutes ago
      );

      expect(keyPoint.getTimeAgo(), '10m ago');
    });

    test('getTimeAgo returns hours for timestamps < 1 day', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final keyPoint = KeyPoint(
        text: 'Test',
        timestamp: now - 7200, // 2 hours ago
      );

      expect(keyPoint.getTimeAgo(), '2h ago');
    });

    test('getTimeAgo returns days for timestamps < 1 week', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final keyPoint = KeyPoint(
        text: 'Test',
        timestamp: now - 259200, // 3 days ago
      );

      expect(keyPoint.getTimeAgo(), '3d ago');
    });

    test('getTimeAgo returns weeks for older timestamps', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final keyPoint = KeyPoint(
        text: 'Test',
        timestamp: now - 1209600, // 2 weeks ago
      );

      expect(keyPoint.getTimeAgo(), '2w ago');
    });
  });

  group('ConversationContext', () {
    test('fromJson creates ConversationContext correctly', () {
      final json = {
        'conversation_id': 'conv-123',
        'last_discussed': 'Project deadline and budget',
        'key_points': [
          {'text': 'Deadline is next Friday', 'timestamp': 1640000000},
          {'text': 'Budget approved', 'timestamp': 1640001000},
        ],
        'pending_questions': ['When can we start?', 'Who is the lead?'],
        'from_cache': true,
        'cache_age': 120,
      };

      final context = ConversationContext.fromJson(json);

      expect(context.conversationId, 'conv-123');
      expect(context.lastDiscussed, 'Project deadline and budget');
      expect(context.keyPoints.length, 2);
      expect(context.keyPoints[0].text, 'Deadline is next Friday');
      expect(context.keyPoints[1].text, 'Budget approved');
      expect(context.pendingQuestions.length, 2);
      expect(context.pendingQuestions[0], 'When can we start?');
      expect(context.fromCache, true);
      expect(context.cacheAge, 120);
    });

    test('fromJson handles missing optional fields', () {
      final json = {
        'conversation_id': 'conv-123',
        'last_discussed': 'Project deadline',
        'key_points': [],
      };

      final context = ConversationContext.fromJson(json);

      expect(context.conversationId, 'conv-123');
      expect(context.keyPoints.isEmpty, true);
      expect(context.pendingQuestions.isEmpty, true);
      expect(context.fromCache, false);
      expect(context.cacheAge, null);
    });

    test('fromJson defaults conversation_id to empty string if null', () {
      final json = {
        'last_discussed': 'Test',
        'key_points': [],
      };

      final context = ConversationContext.fromJson(json);

      expect(context.conversationId, '');
    });

    test('handles empty key_points and pending_questions lists', () {
      final json = {
        'conversation_id': 'conv-123',
        'last_discussed': 'Test',
        'key_points': [],
        'pending_questions': [],
      };

      final context = ConversationContext.fromJson(json);

      expect(context.keyPoints.isEmpty, true);
      expect(context.pendingQuestions.isEmpty, true);
    });
  });
}
</file>

<file path="frontend/test/models/evidence_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('Evidence Model Tests', () {
    test('fromJson parses correctly', () {
      final json = {
        'type': 'keyword',
        'quote': 'ASAP',
        'supports': 'urgency',
        'reasoning': 'Explicit urgency marker',
      };

      final evidence = Evidence.fromJson(json);

      expect(evidence.type, 'keyword');
      expect(evidence.quote, 'ASAP');
      expect(evidence.supports, 'urgency');
      expect(evidence.reasoning, 'Explicit urgency marker');
    });

    test('toJson serializes correctly', () {
      const evidence = Evidence(
        type: 'punctuation',
        quote: '!!!',
        supports: 'high intensity',
        reasoning: 'Multiple exclamation marks show strong emotion',
      );

      final json = evidence.toJson();

      expect(json['type'], 'punctuation');
      expect(json['quote'], '!!!');
      expect(json['supports'], 'high intensity');
      expect(json['reasoning'], 'Multiple exclamation marks show strong emotion');
    });

    test('isKeywordEvidence returns true for keyword type', () {
      const evidence = Evidence(
        type: 'keyword',
        quote: 'ASAP',
        supports: 'urgency',
        reasoning: 'test',
      );

      expect(evidence.isKeywordEvidence, true);
      expect(evidence.isPunctuationEvidence, false);
      expect(evidence.isEmojiEvidence, false);
    });

    test('isPunctuationEvidence returns true for punctuation type', () {
      const evidence = Evidence(
        type: 'punctuation',
        quote: '!!!',
        supports: 'intensity',
        reasoning: 'test',
      );

      expect(evidence.isKeywordEvidence, false);
      expect(evidence.isPunctuationEvidence, true);
      expect(evidence.isEmojiEvidence, false);
    });

    test('isEmojiEvidence returns true for emoji type', () {
      const evidence = Evidence(
        type: 'emoji',
        quote: 'üòä',
        supports: 'friendly tone',
        reasoning: 'test',
      );

      expect(evidence.isKeywordEvidence, false);
      expect(evidence.isPunctuationEvidence, false);
      expect(evidence.isEmojiEvidence, true);
    });
  });
}
</file>

<file path="frontend/test/models/follow_up_item_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/follow_up_item.dart';

void main() {
  group('FollowUpItemType', () {
    test('fromString returns correct enum', () {
      expect(
        FollowUpItemType.fromString('action_item'),
        FollowUpItemType.actionItem,
      );
      expect(
        FollowUpItemType.fromString('unanswered_question'),
        FollowUpItemType.unansweredQuestion,
      );
    });

    test('fromString returns default for invalid value', () {
      expect(
        FollowUpItemType.fromString('invalid'),
        FollowUpItemType.pendingResponse,
      );
    });

    test('getColor returns correct colors', () {
      expect(
        FollowUpItemType.actionItem.getColor().value,
        greaterThan(0),
      );
    });

    test('enum has correct values', () {
      expect(FollowUpItemType.actionItem.value, 'action_item');
      expect(FollowUpItemType.actionItem.displayName, 'Action Item');
    });
  });

  group('FollowUpStatus', () {
    test('fromString returns correct enum', () {
      expect(FollowUpStatus.fromString('pending'), FollowUpStatus.pending);
      expect(FollowUpStatus.fromString('completed'), FollowUpStatus.completed);
    });

    test('fromString returns default for invalid value', () {
      expect(FollowUpStatus.fromString('invalid'), FollowUpStatus.pending);
    });
  });

  group('FollowUpItem', () {
    late FollowUpItem item;

    setUp(() {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      item = FollowUpItem(
        id: 'test-id',
        userId: 'user-123',
        conversationId: 'conv-456',
        itemType: FollowUpItemType.actionItem,
        title: 'Send report',
        description: 'Send quarterly report to client',
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now - 3600, // 1 hour ago
        dueAt: now + 7200, // 2 hours from now
      );
    });

    test('fromJson creates correct instance', () {
      final json = {
        'id': 'test-id',
        'user_id': 'user-123',
        'conversation_id': 'conv-456',
        'item_type': 'action_item',
        'title': 'Test',
        'status': 'pending',
        'priority': 50,
        'detected_at': 1000,
      };

      final item = FollowUpItem.fromJson(json);

      expect(item.id, 'test-id');
      expect(item.userId, 'user-123');
      expect(item.conversationId, 'conv-456');
      expect(item.itemType, FollowUpItemType.actionItem);
      expect(item.status, FollowUpStatus.pending);
    });

    test('isOverdue returns false for future due date', () {
      expect(item.isOverdue, false);
    });

    test('isOverdue returns true for past due date', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final overdueItem = FollowUpItem(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        itemType: FollowUpItemType.actionItem,
        title: 'Overdue',
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now - 7200,
        dueAt: now - 3600, // 1 hour ago
      );

      expect(overdueItem.isOverdue, true);
    });

    test('isDueSoon returns true for items due within 24h', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final dueSoonItem = FollowUpItem(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        itemType: FollowUpItemType.actionItem,
        title: 'Due Soon',
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now,
        dueAt: now + (12 * 3600), // 12 hours from now
      );

      expect(dueSoonItem.isDueSoon, true);
    });

    test('isDueSoon returns false for items due later', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final laterItem = FollowUpItem(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        itemType: FollowUpItemType.actionItem,
        title: 'Later',
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now,
        dueAt: now + (48 * 3600), // 48 hours from now
      );

      expect(laterItem.isDueSoon, false);
    });

    test('getTimeUntilDue returns correct format', () {
      expect(item.getTimeUntilDue(), isNotEmpty);
    });

    test('getTimeUntilDue returns "Overdue" for past due', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final overdueItem = FollowUpItem(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        itemType: FollowUpItemType.actionItem,
        title: 'Overdue',
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now - 7200,
        dueAt: now - 3600,
      );

      expect(overdueItem.getTimeUntilDue(), 'Overdue');
    });

    test('getTimeSinceDetected returns correct format', () {
      expect(item.getTimeSinceDetected(), contains('ago'));
    });

    test('fromJson handles item_id or id field', () {
      final json1 = {
        'item_id': 'test-1',
        'user_id': 'user',
        'conversation_id': 'conv',
        'item_type': 'action_item',
        'title': 'Test',
        'status': 'pending',
        'priority': 50,
        'detected_at': 1000,
      };

      final json2 = {
        'id': 'test-2',
        'user_id': 'user',
        'conversation_id': 'conv',
        'item_type': 'action_item',
        'title': 'Test',
        'status': 'pending',
        'priority': 50,
        'detected_at': 1000,
      };

      expect(FollowUpItem.fromJson(json1).id, 'test-1');
      expect(FollowUpItem.fromJson(json2).id, 'test-2');
    });
  });
}
</file>

<file path="frontend/test/models/message_interpretation_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('MessageInterpretation Model Tests', () {
    test('fromJson parses correctly', () {
      final json = {
        'interpretation': 'Simple acknowledgment',
        'tone': 'Neutral',
        'likelihood': 70,
        'reasoning': 'Most common use of ok',
        'context_clues': ['No prior conflict', 'Normal conversation flow'],
      };

      final interp = MessageInterpretation.fromJson(json);

      expect(interp.interpretation, 'Simple acknowledgment');
      expect(interp.tone, 'Neutral');
      expect(interp.likelihood, 70);
      expect(interp.reasoning, 'Most common use of ok');
      expect(interp.contextClues.length, 2);
      expect(interp.contextClues[0], 'No prior conflict');
    });

    test('toJson serializes correctly', () {
      const interp = MessageInterpretation(
        interpretation: 'Mildly annoyed',
        tone: 'Frustrated',
        likelihood: 20,
        reasoning: 'Brief response could indicate frustration',
        contextClues: ['Shorter than usual', 'No warmth markers'],
      );

      final json = interp.toJson();

      expect(json['interpretation'], 'Mildly annoyed');
      expect(json['tone'], 'Frustrated');
      expect(json['likelihood'], 20);
      expect(json['reasoning'], 'Brief response could indicate frustration');
      expect((json['context_clues'] as List).length, 2);
    });

    test('isLikely returns true for likelihood >= 60', () {
      const interp = MessageInterpretation(
        interpretation: 'test',
        tone: 'test',
        likelihood: 70,
        reasoning: 'test',
        contextClues: [],
      );

      expect(interp.isLikely, true);
      expect(interp.isPossible, false);
      expect(interp.isUnlikely, false);
    });

    test('isPossible returns true for likelihood 30-59', () {
      const interp = MessageInterpretation(
        interpretation: 'test',
        tone: 'test',
        likelihood: 45,
        reasoning: 'test',
        contextClues: [],
      );

      expect(interp.isLikely, false);
      expect(interp.isPossible, true);
      expect(interp.isUnlikely, false);
    });

    test('isUnlikely returns true for likelihood < 30', () {
      const interp = MessageInterpretation(
        interpretation: 'test',
        tone: 'test',
        likelihood: 10,
        reasoning: 'test',
        contextClues: [],
      );

      expect(interp.isLikely, false);
      expect(interp.isPossible, false);
      expect(interp.isUnlikely, true);
    });

    test('edge case: likelihood = 60 is likely', () {
      const interp = MessageInterpretation(
        interpretation: 'test',
        tone: 'test',
        likelihood: 60,
        reasoning: 'test',
        contextClues: [],
      );

      expect(interp.isLikely, true);
    });

    test('edge case: likelihood = 30 is possible', () {
      const interp = MessageInterpretation(
        interpretation: 'test',
        tone: 'test',
        likelihood: 30,
        reasoning: 'test',
        contextClues: [],
      );

      expect(interp.isPossible, true);
    });
  });
}
</file>

<file path="frontend/test/models/relationship_profile_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/relationship_profile.dart';

void main() {
  group('RelationshipProfile', () {
    test('fromJson creates RelationshipProfile correctly', () {
      final json = {
        'profile_id': 'profile-123',
        'user_id': 'user-456',
        'conversation_id': 'conv-789',
        'participant_name': 'John Doe',
        'participant_user_id': 'user-999',
        'relationship_type': 'colleague',
        'relationship_notes': 'Works in marketing',
        'conversation_summary': 'We discuss project updates',
        'safe_topics': ['work', 'sports', 'weather'],
        'topics_to_avoid': ['politics', 'religion'],
        'communication_style': 'Direct and professional',
        'typical_response_time': 3600, // 1 hour
        'total_messages': 150,
        'first_message_at': 1640000000,
        'last_message_at': 1650000000,
      };

      final profile = RelationshipProfile.fromJson(json);

      expect(profile.id, 'profile-123');
      expect(profile.userId, 'user-456');
      expect(profile.conversationId, 'conv-789');
      expect(profile.participantName, 'John Doe');
      expect(profile.participantUserId, 'user-999');
      expect(profile.relationshipType, 'colleague');
      expect(profile.relationshipNotes, 'Works in marketing');
      expect(profile.conversationSummary, 'We discuss project updates');
      expect(profile.safeTopics, ['work', 'sports', 'weather']);
      expect(profile.topicsToAvoid, ['politics', 'religion']);
      expect(profile.communicationStyle, 'Direct and professional');
      expect(profile.typicalResponseTime, 3600);
      expect(profile.totalMessages, 150);
      expect(profile.firstMessageAt, 1640000000);
      expect(profile.lastMessageAt, 1650000000);
    });

    test('fromJson handles id field if profile_id is missing', () {
      final json = {
        'id': 'profile-123',
        'user_id': 'user-456',
        'conversation_id': 'conv-789',
        'participant_name': 'Jane Doe',
      };

      final profile = RelationshipProfile.fromJson(json);

      expect(profile.id, 'profile-123');
    });

    test('fromJson handles missing optional fields', () {
      final json = {
        'profile_id': 'profile-123',
        'user_id': 'user-456',
        'conversation_id': 'conv-789',
        'participant_name': 'John Doe',
      };

      final profile = RelationshipProfile.fromJson(json);

      expect(profile.participantUserId, null);
      expect(profile.relationshipType, null);
      expect(profile.safeTopics, []);
      expect(profile.topicsToAvoid, []);
      expect(profile.totalMessages, 0);
    });

    test('getRelationshipEmoji returns correct emoji for each type', () {
      final testCases = {
        'boss': 'üëî',
        'colleague': 'ü§ù',
        'friend': 'üòä',
        'family': 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶',
        'client': 'üíº',
        'unknown': 'üë§',
      };

      testCases.forEach((type, expectedEmoji) {
        final profile = RelationshipProfile(
          id: 'test',
          userId: 'user',
          conversationId: 'conv',
          participantName: 'Test',
          relationshipType: type == 'unknown' ? null : type,
        );

        expect(profile.getRelationshipEmoji(), expectedEmoji);
      });
    });

    test('getRelationshipEmoji is case-insensitive', () {
      final profile = RelationshipProfile(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        participantName: 'Test',
        relationshipType: 'BOSS',
      );

      expect(profile.getRelationshipEmoji(), 'üëî');
    });

    test('formatResponseTime returns "Unknown" for null', () {
      final profile = RelationshipProfile(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        participantName: 'Test',
      );

      expect(profile.formatResponseTime(), 'Unknown');
    });

    test('formatResponseTime returns minutes for < 1 hour', () {
      final profile = RelationshipProfile(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        participantName: 'Test',
        typicalResponseTime: 1800, // 30 minutes
      );

      expect(profile.formatResponseTime(), '30 min');
    });

    test('formatResponseTime returns hours for < 1 day', () {
      final profile = RelationshipProfile(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        participantName: 'Test',
        typicalResponseTime: 7200, // 2 hours
      );

      expect(profile.formatResponseTime(), '2 hr');
    });

    test('formatResponseTime returns days for >= 1 day', () {
      final profile = RelationshipProfile(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        participantName: 'Test',
        typicalResponseTime: 172800, // 2 days
      );

      expect(profile.formatResponseTime(), '2 days');
    });
  });
}
</file>

<file path="frontend/test/models/rsd_trigger_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('RSDTrigger Model Tests', () {
    test('fromJson parses correctly', () {
      final json = {
        'pattern': 'ok',
        'severity': 'high',
        'explanation': 'Single-word responses can trigger RSD',
        'reassurance': 'This is likely just a quick acknowledgment',
      };

      final trigger = RSDTrigger.fromJson(json);

      expect(trigger.pattern, 'ok');
      expect(trigger.severity, 'high');
      expect(trigger.explanation, 'Single-word responses can trigger RSD');
      expect(trigger.reassurance, 'This is likely just a quick acknowledgment');
    });

    test('toJson serializes correctly', () {
      const trigger = RSDTrigger(
        pattern: 'fine',
        severity: 'high',
        explanation: 'Fine can feel passive-aggressive',
        reassurance: 'They might genuinely mean it',
      );

      final json = trigger.toJson();

      expect(json['pattern'], 'fine');
      expect(json['severity'], 'high');
      expect(json['explanation'], 'Fine can feel passive-aggressive');
      expect(json['reassurance'], 'They might genuinely mean it');
    });

    test('isHighSeverity returns true for high severity', () {
      const trigger = RSDTrigger(
        pattern: 'ok',
        severity: 'high',
        explanation: 'test',
        reassurance: 'test',
      );

      expect(trigger.isHighSeverity, true);
      expect(trigger.isMediumSeverity, false);
      expect(trigger.isLowSeverity, false);
    });

    test('isMediumSeverity returns true for medium severity', () {
      const trigger = RSDTrigger(
        pattern: 'sure',
        severity: 'medium',
        explanation: 'test',
        reassurance: 'test',
      );

      expect(trigger.isHighSeverity, false);
      expect(trigger.isMediumSeverity, true);
      expect(trigger.isLowSeverity, false);
    });

    test('isLowSeverity returns true for low severity', () {
      const trigger = RSDTrigger(
        pattern: 'no worries',
        severity: 'low',
        explanation: 'test',
        reassurance: 'test',
      );

      expect(trigger.isHighSeverity, false);
      expect(trigger.isMediumSeverity, false);
      expect(trigger.isLowSeverity, true);
    });
  });
}
</file>

<file path="frontend/test/models/safe_topic_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/safe_topic.dart';

void main() {
  group('SafeTopic', () {
    test('fromJson creates SafeTopic correctly', () {
      final json = {
        'id': 'topic-123',
        'topic_name': 'Project Updates',
        'topic_keywords': ['deadline', 'status', 'progress'],
        'message_count': 25,
        'avg_response_time': 1800,
        'positive_tone_rate': 0.85,
        'is_safe': true,
        'last_discussed': 1640000000,
      };

      final topic = SafeTopic.fromJson(json);

      expect(topic.id, 'topic-123');
      expect(topic.topicName, 'Project Updates');
      expect(topic.keywords, ['deadline', 'status', 'progress']);
      expect(topic.messageCount, 25);
      expect(topic.avgResponseTime, 1800);
      expect(topic.positiveToneRate, 0.85);
      expect(topic.isSafe, true);
      expect(topic.lastDiscussed, 1640000000);
    });

    test('fromJson handles missing optional fields', () {
      final json = {
        'id': 'topic-123',
        'topic_name': 'General',
        'message_count': 10,
      };

      final topic = SafeTopic.fromJson(json);

      expect(topic.keywords, []);
      expect(topic.avgResponseTime, null);
      expect(topic.positiveToneRate, null);
      expect(topic.isSafe, true);
      expect(topic.lastDiscussed, null);
    });

    test('getTopicColor returns green for high positive rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.9,
      );

      expect(topic.getTopicColor(), Colors.green);
    });

    test('getTopicColor returns blue for medium positive rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.7,
      );

      expect(topic.getTopicColor(), Colors.blue);
    });

    test('getTopicColor returns orange for low positive rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.5,
      );

      expect(topic.getTopicColor(), Colors.orange);
    });

    test('getTopicColor returns grey for null positive rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
      );

      expect(topic.getTopicColor(), Colors.grey);
    });

    test('getEngagementLabel returns "Great topic!" for high rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.85,
      );

      expect(topic.getEngagementLabel(), 'Great topic!');
    });

    test('getEngagementLabel returns "Good topic" for medium rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.65,
      );

      expect(topic.getEngagementLabel(), 'Good topic');
    });

    test('getEngagementLabel returns "Neutral" for low rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.5,
      );

      expect(topic.getEngagementLabel(), 'Neutral');
    });

    test('getEngagementLabel returns "Unknown" for null rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
      );

      expect(topic.getEngagementLabel(), 'Unknown');
    });

    test('isSafe defaults to true', () {
      final json = {
        'id': 'topic-123',
        'topic_name': 'Test',
        'message_count': 10,
      };

      final topic = SafeTopic.fromJson(json);

      expect(topic.isSafe, true);
    });
  });
}
</file>

<file path="frontend/test/services/ai_analysis_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  // Note: Service tests that require Supabase client are skipped in unit tests
  // These should be tested in integration tests with proper Supabase setup
  
  group('AIAnalysisService - Unit Tests', () {
    test('service requires Supabase initialization', () {
      // This test documents that the service requires Supabase
      // Full service tests should be done in integration tests
      expect(true, isTrue);
    });
  });
  
  group('AIAnalysis Model Integration', () {
    test('AIAnalysis can be stored and retrieved', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-123',
        tone: 'Friendly',
        urgencyLevel: 'Low',
        intent: 'greeting',
        confidenceScore: 0.9,
        analysisTimestamp: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );
      
      expect(analysis.id, equals('test-id'));
      expect(analysis.messageId, equals('msg-123'));
      expect(analysis.tone, equals('Friendly'));
    });
    
    test('Multiple AIAnalysis objects can coexist', () {
      final analysis1 = AIAnalysis(
        id: 'id-1',
        messageId: 'msg-1',
        tone: 'Professional',
        analysisTimestamp: 123,
      );
      
      final analysis2 = AIAnalysis(
        id: 'id-2',
        messageId: 'msg-2',
        tone: 'Casual',
        analysisTimestamp: 456,
      );
      
      expect(analysis1.id, isNot(equals(analysis2.id)));
      expect(analysis1.tone, isNot(equals(analysis2.tone)));
    });
  });
}
</file>

<file path="frontend/test/services/context_preloader_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/services/context_preloader_service.dart';

/// Phase 3: ContextPreloaderService Tests
void main() {
  group('ContextPreloaderService', () {
    late ContextPreloaderService service;

    setUp(() {
      service = ContextPreloaderService();
    });

    group('Singleton Pattern', () {
      test('returns same instance', () {
        final instance1 = ContextPreloaderService();
        final instance2 = ContextPreloaderService();
        expect(identical(instance1, instance2), isTrue);
      });
    });

    group('loadContext', () {
      test('accepts conversationId parameter', () async {
        try {
          final context = await service.loadContext(
            conversationId: 'test-conv-123',
          );
          
          expect(context, isNotNull);
        } catch (e) {
          // Expected to fail without auth/backend
          expect(e.toString(), isNotEmpty);
        }
      });

      test('handles invalid conversation ID', () async {
        try {
          final context = await service.loadContext(conversationId: '');
          expect(context, isNotNull);
        } catch (e) {
          // Expected - should handle gracefully
          expect(e.toString(), isNotEmpty);
        }
      });

      test('handles non-existent conversation', () async {
        try {
          final context = await service.loadContext(
            conversationId: 'non-existent-conv',
          );
          expect(context, isNotNull);
        } catch (e) {
          // Expected
          expect(e.toString(), isNotEmpty);
        }
      });
    });

    group('Cache Management', () {
      test('invalidate method exists', () {
        expect(service.invalidate, isA<Function>());
      });

      test('invalidate accepts conversationId', () {
        expect(
          () => service.invalidate('test-conv-123'),
          returnsNormally,
        );
      });

      test('invalidate handles null/empty conversationId', () {
        expect(() => service.invalidate(''), returnsNormally);
        expect(() => service.invalidate(null), returnsNormally);
      });
    });

    group('Performance', () {
      test('caches results for performance', () async {
        final conversationId = 'test-conv-cache';
        
        try {
          // First load
          final start1 = DateTime.now();
          await service.loadContext(conversationId: conversationId);
          final duration1 = DateTime.now().difference(start1);

          // Second load (should be cached)
          final start2 = DateTime.now();
          await service.loadContext(conversationId: conversationId);
          final duration2 = DateTime.now().difference(start2);

          // Cache should be faster (or at least not slower)
          expect(duration2.inMilliseconds, lessThanOrEqualTo(duration1.inMilliseconds + 100));
        } catch (e) {
          // Expected without backend
        }
      });

      test('invalidate clears cache', () async {
        final conversationId = 'test-conv-invalidate';
        
        try {
          // Load and cache
          await service.loadContext(conversationId: conversationId);
          
          // Invalidate
          service.invalidate(conversationId);
          
          // Load again (should not be cached)
          final context = await service.loadContext(conversationId: conversationId);
          expect(context, isNotNull);
        } catch (e) {
          // Expected without backend
        }
      });
    });

    group('Error Handling', () {
      test('handles network errors gracefully', () async {
        expect(
          () => service.loadContext(conversationId: 'test'),
          returnsNormally,
        );
      });

      test('handles authentication errors', () async {
        // Without auth, should throw or return null
        try {
          await service.loadContext(conversationId: 'test');
        } catch (e) {
          expect(e.toString(), isNotEmpty);
        }
      });
    });

    group('API Methods', () {
      test('has all required methods', () {
        expect(service.loadContext, isA<Function>());
        expect(service.invalidate, isA<Function>());
      });
    });
  });
}
</file>

<file path="frontend/test/services/follow_up_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/services/follow_up_service.dart';
import 'package:messageai/models/follow_up_item.dart';

/// Phase 4: FollowUpService Tests
/// Note: These tests require Supabase authentication to be mocked or a test environment
void main() {
  group('FollowUpService', () {
    late FollowUpService service;

    setUp(() {
      service = FollowUpService();
    });

    group('Singleton Pattern', () {
      test('returns same instance', () {
        final instance1 = FollowUpService();
        final instance2 = FollowUpService();
        expect(identical(instance1, instance2), isTrue);
      });
    });

    group('getPendingFollowUps', () {
      test('returns list of follow-up items', () async {
        // Note: This will fail without authentication
        // In a real test, we'd mock the Supabase client
        try {
          final items = await service.getPendingFollowUps();
          expect(items, isList);
          
          // All items should be pending
          for (final item in items) {
            expect(item.status, equals(FollowUpStatus.pending));
          }
        } catch (e) {
          // Expected to fail without auth - skip test
          expect(e.toString(), contains(['auth', 'user', 'session']));
        }
      });

      test('returns empty list when no user authenticated', () async {
        final items = await service.getPendingFollowUps();
        expect(items, isEmpty);
      });
    });

    group('getConversationFollowUps', () {
      test('returns items for specific conversation', () async {
        try {
          final conversationId = 'test-conv-123';
          final items = await service.getConversationFollowUps(conversationId);
          
          expect(items, isList);
          
          // All items should be for the specified conversation
          for (final item in items) {
            expect(item.conversationId, equals(conversationId));
          }
        } catch (e) {
          // Expected to fail without auth
          expect(e.toString(), contains(['auth', 'user', 'session']));
        }
      });

      test('returns empty list for non-existent conversation', () async {
        final items = await service.getConversationFollowUps('non-existent');
        expect(items, isEmpty);
      });
    });

    group('Duration Parameter', () {
      test('snoozeFollowUp accepts Duration object', () async {
        // Test that the method signature accepts Duration
        expect(
          () => service.snoozeFollowUp('test-id', const Duration(hours: 1)),
          returnsNormally,
        );
      });

      test('Duration is converted to seconds correctly', () {
        const duration = Duration(hours: 2, minutes: 30);
        expect(duration.inSeconds, equals(9000));
      });
    });

    group('Error Handling', () {
      test('handles network errors gracefully', () async {
        // Without auth, should return empty list instead of throwing
        final items = await service.getPendingFollowUps();
        expect(items, isEmpty);
      });

      test('handles invalid conversation ID', () async {
        final items = await service.getConversationFollowUps('');
        expect(items, isEmpty);
      });
    });

    group('API Methods', () {
      test('has all required CRUD methods', () {
        expect(service.getPendingFollowUps, isA<Function>());
        expect(service.getConversationFollowUps, isA<Function>());
        expect(service.extractFollowUps, isA<Function>());
        expect(service.completeFollowUp, isA<Function>());
        expect(service.snoozeFollowUp, isA<Function>());
        expect(service.dismissFollowUp, isA<Function>());
      });
    });
  });
}
</file>

<file path="frontend/test/services/message_formatter_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/services/message_formatter_service.dart';

/// Phase 2: MessageFormatterService Tests
void main() {
  group('MessageFormatterService', () {
    late MessageFormatterService service;

    setUp(() {
      service = MessageFormatterService(userId: 'test-user-123');
    });

    group('Initialization', () {
      test('requires userId parameter', () {
        expect(() => MessageFormatterService(userId: ''), returnsNormally);
        expect(() => MessageFormatterService(userId: 'user-123'), returnsNormally);
      });

      test('stores userId correctly', () {
        final service = MessageFormatterService(userId: 'test-user-456');
        expect(service, isNotNull);
      });
    });

    group('formatMessage', () {
      test('accepts required message parameter', () async {
        try {
          final result = await service.formatMessage(
            message: "I can't make it to the party",
          );
          
          expect(result, isNotNull);
          expect(result.formattedMessage, isNotEmpty);
        } catch (e) {
          // May fail without backend - that's OK
          expect(e.toString(), isNotEmpty);
        }
      });

      test('handles empty message', () async {
        try {
          final result = await service.formatMessage(message: '');
          expect(result, isNotNull);
        } catch (e) {
          // Expected - empty messages should be handled
          expect(e.toString(), isNotEmpty);
        }
      });

      test('handles long messages', () async {
        final longMessage = 'This is a very long message. ' * 50;
        
        try {
          final result = await service.formatMessage(message: longMessage);
          expect(result, isNotNull);
          expect(result.formattedMessage, isNotEmpty);
        } catch (e) {
          // May fail without backend
          expect(e.toString(), isNotEmpty);
        }
      });
    });

    group('Message Types', () {
      test('handles declining messages', () async {
        final messages = [
          "I can't make it",
          "Sorry, I have to decline",
          "I won't be able to attend",
        ];

        for (final message in messages) {
          try {
            final result = await service.formatMessage(message: message);
            expect(result, isNotNull);
          } catch (e) {
            // Expected without backend
          }
        }
      });

      test('handles boundary messages', () async {
        final messages = [
          "I need you to stop calling me after 9pm",
          "Please respect my time off",
          "I'm not comfortable with that",
        ];

        for (final message in messages) {
          try {
            final result = await service.formatMessage(message: message);
            expect(result, isNotNull);
          } catch (e) {
            // Expected without backend
          }
        }
      });

      test('handles apology messages', () async {
        final messages = [
          "I'm sorry for the delay",
          "I apologize for the mistake",
          "Sorry about that",
        ];

        for (final message in messages) {
          try {
            final result = await service.formatMessage(message: message);
            expect(result, isNotNull);
          } catch (e) {
            // Expected without backend
          }
        }
      });
    });

    group('Error Handling', () {
      test('handles network errors gracefully', () async {
        expect(
          () => service.formatMessage(message: 'test'),
          returnsNormally,
        );
      });

      test('handles authentication errors', () async {
        final unauthService = MessageFormatterService(userId: 'invalid');
        
        expect(
          () => unauthService.formatMessage(message: 'test'),
          returnsNormally,
        );
      });
    });
  });
}
</file>

<file path="frontend/test/services/relationship_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/services/relationship_service.dart';

void main() {
  group('RelationshipService', () {
    late RelationshipService service;

    setUp(() {
      service = RelationshipService();
    });

    test('is singleton', () {
      final instance1 = RelationshipService();
      final instance2 = RelationshipService();

      expect(identical(instance1, instance2), true);
    });

    group('getProfile', () {
      test('returns null when user not authenticated', () async {
        // This requires mocking Supabase client
        // In a real test, we'd inject a mock Supabase client
        // For now, document this as needing integration testing
        expect(true, true); // Placeholder
      });

      test('returns null when no profile exists', () async {
        // Would test with mocked Supabase returning null/empty response
        expect(true, true); // Placeholder
      });
    });

    group('getSafeTopics', () {
      test('returns empty list when user not authenticated', () async {
        // Would test with mocked Supabase client
        expect(true, true); // Placeholder
      });

      test('returns empty list when no topics exist', () async {
        // Would test with mocked Supabase returning empty list
        expect(true, true); // Placeholder
      });
    });

    group('updateNotes', () {
      test('updates notes successfully', () async {
        // Would test with mocked Supabase client
        expect(true, true); // Placeholder
      });

      test('handles errors gracefully', () async {
        // Would test error handling
        expect(true, true); // Placeholder
      });
    });

    group('updateRelationshipType', () {
      test('updates relationship type successfully', () async {
        // Would test with mocked Supabase client
        expect(true, true); // Placeholder
      });

      test('handles errors gracefully', () async {
        // Would test error handling
        expect(true, true); // Placeholder
      });
    });
  });
}

// NOTE: These service tests are placeholders. Full implementation requires:
// 1. Mocking Supabase client (could use mockito or create a test double)
// 2. Injecting dependencies through constructor or factory
// 3. Testing actual RPC calls and responses
//
// For a production app, consider:
// - Creating an abstract interface for Supabase operations
// - Using dependency injection to provide mock implementations
// - Writing integration tests that use a test Supabase instance
</file>

<file path="frontend/test/widgets/context_preview_card_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/features/conversations/widgets/context_preview_card.dart';
import 'package:messageai/models/conversation_context.dart';

void main() {
  group('ContextPreviewCard', () {
    testWidgets('displays last discussed topic', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project deadline and budget',
        keyPoints: [],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('Last Conversation'), findsOneWidget);
      expect(find.text('Project deadline and budget'), findsOneWidget);
    });

    testWidgets('displays key points', (tester) async {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [
          KeyPoint(text: 'Deadline is Friday', timestamp: now - 3600),
          KeyPoint(text: 'Budget approved', timestamp: now - 7200),
          KeyPoint(text: 'Team meeting scheduled', timestamp: now - 10800),
        ],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('Recent topics:'), findsOneWidget);
      expect(find.text('Deadline is Friday'), findsOneWidget);
      expect(find.text('Budget approved'), findsOneWidget);
      expect(find.text('Team meeting scheduled'), findsOneWidget);
    });

    testWidgets('limits key points to 3', (tester) async {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [
          KeyPoint(text: 'Point 1', timestamp: now),
          KeyPoint(text: 'Point 2', timestamp: now),
          KeyPoint(text: 'Point 3', timestamp: now),
          KeyPoint(text: 'Point 4', timestamp: now),
          KeyPoint(text: 'Point 5', timestamp: now),
        ],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('Point 1'), findsOneWidget);
      expect(find.text('Point 2'), findsOneWidget);
      expect(find.text('Point 3'), findsOneWidget);
      expect(find.text('Point 4'), findsNothing);
      expect(find.text('Point 5'), findsNothing);
    });

    testWidgets('displays pending questions badge', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: ['When do we start?', 'Who is the lead?'],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('2 unanswered questions'), findsOneWidget);
      expect(find.byIcon(Icons.help_outline), findsOneWidget);
    });

    testWidgets('displays singular form for single question', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: ['When do we start?'],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('1 unanswered question'), findsOneWidget);
    });

    testWidgets('displays cached indicator when fromCache is true',
        (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
        fromCache: true,
        cacheAge: 120,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('cached'), findsOneWidget);
    });

    testWidgets('does not display cached indicator when fromCache is false',
        (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
        fromCache: false,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('cached'), findsNothing);
    });

    testWidgets('calls onTap callback when tapped', (tester) async {
      bool tapped = false;
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(
              context: context,
              onTap: () => tapped = true,
            ),
          ),
        ),
      );

      await tester.tap(find.byType(ContextPreviewCard));
      expect(tapped, true);
    });

    testWidgets('does not crash when onTap is null', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      await tester.tap(find.byType(ContextPreviewCard));
      // Should not crash
      expect(find.byType(ContextPreviewCard), findsOneWidget);
    });

    testWidgets('hides key points section when empty', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('Recent topics:'), findsNothing);
    });

    testWidgets('hides pending questions section when empty', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.byIcon(Icons.help_outline), findsNothing);
    });
  });
}
</file>

<file path="frontend/test/widgets/follow_up_card_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/follow_up_item.dart';
import 'package:messageai/features/followups/widgets/follow_up_card.dart';

/// Phase 4: FollowUpCard Widget Tests
void main() {
  group('FollowUpCard Widget', () {
    late FollowUpItem testItem;
    bool completeCalled = false;
    bool snoozeCalled = false;
    bool dismissCalled = false;

    setUp(() {
      completeCalled = false;
      snoozeCalled = false;
      dismissCalled = false;

      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      testItem = FollowUpItem(
        id: 'test-123',
        userId: 'user-456',
        conversationId: 'conv-789',
        itemType: FollowUpItemType.actionItem,
        title: 'Send quarterly report',
        description: 'Review and send Q4 financial report to client',
        extractedText: "I'll send you the Q4 report by Friday",
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now - 3600,
        dueAt: now + 7200,
      );
    });

    testWidgets('renders all basic elements', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () => completeCalled = true,
              onSnooze: () => snoozeCalled = true,
              onDismiss: () => dismissCalled = true,
            ),
          ),
        ),
      );

      // Check title is displayed
      expect(find.text('Send quarterly report'), findsOneWidget);

      // Check description is displayed
      expect(find.text('Review and send Q4 financial report to client'), findsOneWidget);

      // Check action buttons exist
      expect(find.text('Done'), findsOneWidget);
      expect(find.text('Snooze'), findsOneWidget);
      expect(find.widgetWithIcon(IconButton, Icons.close), findsOneWidget);
    });

    testWidgets('displays type icon', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () {},
              onSnooze: () {},
              onDismiss: () {},
            ),
          ),
        ),
      );

      // Action item should have task_alt icon
      expect(find.byIcon(Icons.task_alt), findsOneWidget);
    });

    testWidgets('displays extracted text for action items', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () {},
              onSnooze: () {},
              onDismiss: () {},
            ),
          ),
        ),
      );

      // Should show quote icon and extracted text
      expect(find.byIcon(Icons.format_quote), findsOneWidget);
      expect(find.text("I'll send you the Q4 report by Friday"), findsOneWidget);
    });

    testWidgets('displays priority and time metadata', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () {},
              onSnooze: () {},
              onDismiss: () {},
            ),
          ),
        ),
      );

      // Should show priority
      expect(find.textContaining('Priority: 80'), findsOneWidget);

      // Should show time since detected
      expect(find.textContaining('ago'), findsOneWidget);
    });

    testWidgets('displays due date badge when present', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () {},
              onSnooze: () {},
              onDismiss: () {},
            ),
          ),
        ),
      );

      // Should show time until due
      final timeUntilDue = testItem.getTimeUntilDue();
      expect(find.text(timeUntilDue), findsOneWidget);
    });

    testWidgets('highlights overdue items in red', (tester) async {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final overdueItem = FollowUpItem(
        id: 'overdue-123',
        userId: 'user-456',
        conversationId: 'conv-789',
        itemType: FollowUpItemType.actionItem,
        title: 'Overdue task',
        status: FollowUpStatus.pending,
        priority: 90,
        detectedAt: now - 7200,
        dueAt: now - 3600, // 1 hour ago
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: overdueItem,
              onComplete: () {},
              onSnooze: () {},
              onDismiss: () {},
            ),
          ),
        ),
      );

      // Should display "Overdue"
      expect(find.text('Overdue'), findsOneWidget);

      // Card should have red background (from Colors.red.shade50)
      final card = tester.widget<Card>(find.byType(Card));
      expect(card.color, equals(Colors.red.shade50));
    });

    testWidgets('calls onComplete when Done button tapped', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () => completeCalled = true,
              onSnooze: () => snoozeCalled = true,
              onDismiss: () => dismissCalled = true,
            ),
          ),
        ),
      );

      // Tap Done button
      await tester.tap(find.text('Done'));
      await tester.pumpAndSettle();

      expect(completeCalled, isTrue);
      expect(snoozeCalled, isFalse);
      expect(dismissCalled, isFalse);
    });

    testWidgets('calls onSnooze when Snooze button tapped', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () => completeCalled = true,
              onSnooze: () => snoozeCalled = true,
              onDismiss: () => dismissCalled = true,
            ),
          ),
        ),
      );

      // Tap Snooze button
      await tester.tap(find.text('Snooze'));
      await tester.pumpAndSettle();

      expect(snoozeCalled, isTrue);
      expect(completeCalled, isFalse);
      expect(dismissCalled, isFalse);
    });

    testWidgets('calls onDismiss when close button tapped', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () => completeCalled = true,
              onSnooze: () => snoozeCalled = true,
              onDismiss: () => dismissCalled = true,
            ),
          ),
        ),
      );

      // Tap close button
      await tester.tap(find.widgetWithIcon(IconButton, Icons.close));
      await tester.pumpAndSettle();

      expect(dismissCalled, isTrue);
      expect(completeCalled, isFalse);
      expect(snoozeCalled, isFalse);
    });

    testWidgets('renders without description', (tester) async {
      final itemWithoutDescription = FollowUpItem(
        id: 'test-123',
        userId: 'user-456',
        conversationId: 'conv-789',
        itemType: FollowUpItemType.actionItem,
        title: 'Simple task',
        status: FollowUpStatus.pending,
        priority: 50,
        detectedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: itemWithoutDescription,
              onComplete: () {},
              onSnooze: () {},
              onDismiss: () {},
            ),
          ),
        ),
      );

      expect(find.text('Simple task'), findsOneWidget);
    });

    testWidgets('renders different item types with correct icons', (tester) async {
      final types = [
        FollowUpItemType.actionItem,
        FollowUpItemType.unansweredQuestion,
        FollowUpItemType.pendingResponse,
        FollowUpItemType.scheduledFollowup,
      ];

      for (final type in types) {
        final item = FollowUpItem(
          id: 'test-${type.value}',
          userId: 'user',
          conversationId: 'conv',
          itemType: type,
          title: 'Test ${type.displayName}',
          status: FollowUpStatus.pending,
          priority: 50,
          detectedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
        );

        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: FollowUpCard(
                item: item,
                onComplete: () {},
                onSnooze: () {},
                onDismiss: () {},
              ),
            ),
          ),
        );

        // Should have the correct icon (at least one, may appear in multiple places)
        expect(find.byIcon(type.icon), findsWidgets);

        await tester.pumpAndSettle();
      }
    });
  });
}
</file>

<file path="frontend/test/widgets/tone_badge_enhanced_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('ToneBadge Enhanced Features', () {
    testWidgets('displays all 23 tones with correct emojis', (tester) async {
      final toneEmojiMap = {
        'Friendly': 'üòä',
        'Professional': 'üíº',
        'Urgent': '‚ö†Ô∏è',
        'Casual': 'üòé',
        'Formal': 'üé©',
        'Concerned': 'üòü',
        'Excited': 'üéâ',
        'Neutral': 'üòê',
        'Apologetic': 'üôè',
        'Appreciative': 'üôå',
        'Frustrated': 'üò§',
        'Playful': 'üòú',
        'Sarcastic': 'üôÑ',
        'Empathetic': 'ü§ó',
        'Inquisitive': 'ü§î',
        'Assertive': 'üí™',
        'Tentative': 'üò¨',
        'Defensive': 'üõ°Ô∏è',
        'Encouraging': 'üíö',
        'Disappointed': 'üòû',
        'Overwhelmed': 'üòµ',
        'Relieved': 'üòå',
        'Confused': 'üòï',
      };

      for (final entry in toneEmojiMap.entries) {
        final analysis = AIAnalysis(
          id: 'test',
          messageId: 'msg',
          tone: entry.key,
          analysisTimestamp: 123,
        );

        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: ToneBadge(analysis: analysis),
            ),
          ),
        );

        expect(find.text(entry.value), findsOneWidget, reason: 'Emoji for ${entry.key}');
        expect(find.text(entry.key), findsOneWidget, reason: 'Label for ${entry.key}');
      }
    });

    testWidgets('displays intensity indicator dot', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        intensity: 'high',
        analysisTimestamp: 123,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      // Should have 2 containers: main badge container + intensity dot
      expect(find.byType(Container), findsWidgets);
      
      // Verify the intensity dot exists (6x6 size)
      final containers = tester.widgetList<Container>(find.byType(Container)).toList();
      final hasDot = containers.any((container) {
        final decoration = container.decoration;
        if (decoration is BoxDecoration) {
          return decoration.shape == BoxShape.circle;
        }
        return false;
      });
      expect(hasDot, true, reason: 'Should have intensity dot');
    });

    testWidgets('displays both intensity and urgency dots', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Overwhelmed',
        intensity: 'very_high',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      // Should have circular indicators for both intensity and urgency
      final containers = tester.widgetList<Container>(find.byType(Container)).toList();
      final circleDots = containers.where((container) {
        final decoration = container.decoration;
        if (decoration is BoxDecoration) {
          return decoration.shape == BoxShape.circle;
        }
        return false;
      }).toList();
      
      expect(circleDots.length, greaterThanOrEqualTo(2), reason: 'Should have both dots');
    });

    testWidgets('does not show intensity dot when intensity is null', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Neutral',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
        // intensity is null
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      // Should only have urgency dot, not intensity
      final containers = tester.widgetList<Container>(find.byType(Container)).toList();
      final circleDots = containers.where((container) {
        final decoration = container.decoration;
        if (decoration is BoxDecoration) {
          return decoration.shape == BoxShape.circle;
        }
        return false;
      }).toList();
      
      expect(circleDots.length, 1, reason: 'Should only have urgency dot');
    });

    testWidgets('calls onTap callback when tapped', (tester) async {
      bool tapped = false;
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(
              analysis: analysis,
              onTap: () => tapped = true,
            ),
          ),
        ),
      );

      await tester.tap(find.byType(ToneBadge));
      expect(tapped, true);
    });

    testWidgets('handles case-insensitive tone matching', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'FRIENDLY', // uppercase
        analysisTimestamp: 123,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      expect(find.text('üòä'), findsOneWidget);
    });

    testWidgets('uses default emoji for unknown tone', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'UnknownTone',
        analysisTimestamp: 123,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      expect(find.text('üí¨'), findsOneWidget, reason: 'Default emoji');
    });
  });
}
</file>

<file path="frontend/test/widgets/tone_badge_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('ToneBadge Widget', () {
    testWidgets('displays Friendly tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        urgencyLevel: 'Low',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('üòä'), findsOneWidget);
      expect(find.text('Friendly'), findsOneWidget);
    });
    
    testWidgets('displays Professional tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Professional',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('üíº'), findsOneWidget);
      expect(find.text('Professional'), findsOneWidget);
    });
    
    testWidgets('displays Urgent tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Urgent',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('‚ö°'), findsOneWidget);
      expect(find.text('Urgent'), findsOneWidget);
    });
    
    testWidgets('displays Casual tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Casual',
        urgencyLevel: 'Low',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('üòé'), findsOneWidget);
      expect(find.text('Casual'), findsOneWidget);
    });
    
    testWidgets('displays Formal tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Formal',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('üëî'), findsOneWidget);
      expect(find.text('Formal'), findsOneWidget);
    });
    
    testWidgets('displays Excited tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Excited',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('üéâ'), findsOneWidget);
      expect(find.text('Excited'), findsOneWidget);
    });
    
    testWidgets('displays Concerned tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Concerned',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('üòü'), findsOneWidget);
      expect(find.text('Concerned'), findsOneWidget);
    });
    
    testWidgets('displays Neutral tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Neutral',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('üí¨'), findsOneWidget);
      expect(find.text('Neutral'), findsOneWidget);
    });
    
    testWidgets('shows urgency indicator for High urgency', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Urgent',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      // Urgency dot should be present (multiple Containers exist)
      expect(find.byType(Container), findsWidgets);
      expect(find.text('Urgent'), findsOneWidget);
    });
    
    testWidgets('shows urgency indicator for Critical urgency', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Professional',
        urgencyLevel: 'Critical',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.byType(Container), findsWidgets);
      expect(find.text('Professional'), findsOneWidget);
    });
    
    testWidgets('does not show urgency indicator for Low urgency', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Casual',
        urgencyLevel: 'Low',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('Casual'), findsOneWidget);
    });
    
    testWidgets('calls onTap callback when tapped', (tester) async {
      bool wasTapped = false;
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Excited',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(
              analysis: analysis,
              onTap: () => wasTapped = true,
            ),
          ),
        ),
      );
      
      await tester.tap(find.byType(ToneBadge));
      await tester.pump();
      
      expect(wasTapped, isTrue);
    });
    
    testWidgets('can be tapped without onTap callback', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      // Should not throw when tapped without callback
      await tester.tap(find.byType(ToneBadge));
      await tester.pump();
      
      expect(find.byType(ToneBadge), findsOneWidget);
    });
    
    testWidgets('handles case-insensitive tone names', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'FRIENDLY', // Uppercase
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      // Should still show the emoji (case handling in _getToneInfo)
      expect(find.text('üòä'), findsOneWidget);
    });
  });
}
</file>

<file path="frontend/test/widgets/who_is_this_button_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/features/conversations/widgets/who_is_this_button.dart';

void main() {
  group('WhoIsThisButton', () {
    testWidgets('displays icon button in compact mode', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: WhoIsThisButton(
              conversationId: 'conv-123',
              compact: true,
            ),
          ),
        ),
      );

      expect(find.byType(IconButton), findsOneWidget);
      expect(find.byIcon(Icons.info_outline), findsOneWidget);
      expect(find.text('Who is this?'), findsNothing);
    });

    testWidgets('displays outlined button in non-compact mode',
        (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: WhoIsThisButton(
              conversationId: 'conv-123',
              compact: false,
            ),
          ),
        ),
      );

      // OutlinedButton.icon creates a complex widget tree, just check for text and icon
      expect(find.text('Who is this?'), findsOneWidget);
      expect(find.byIcon(Icons.info_outline), findsOneWidget);
      expect(find.byType(IconButton), findsNothing);
    });

    testWidgets('defaults to compact=false', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: WhoIsThisButton(
              conversationId: 'conv-123',
            ),
          ),
        ),
      );

      // Should show text label (not compact mode)
      expect(find.text('Who is this?'), findsOneWidget);
    });

    testWidgets('has correct tooltip in compact mode', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: WhoIsThisButton(
              conversationId: 'conv-123',
              compact: true,
            ),
          ),
        ),
      );

      final iconButton = tester.widget<IconButton>(find.byType(IconButton));
      expect(iconButton.tooltip, 'Who is this?');
    });

    // Skipping tests that require Supabase initialization
    // These would be better tested in integration tests with proper setup
    
    testWidgets('tapping compact button does not crash', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: WhoIsThisButton(
              conversationId: 'conv-123',
              compact: true,
            ),
          ),
        ),
      );

      // Just verify the button exists and is tappable
      expect(find.byType(IconButton), findsOneWidget);
      
      // Note: Actually tapping would open RelationshipSummarySheet which
      // requires Supabase initialization. Skipping for unit test.
    });

    testWidgets('widget renders without crashing', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: Column(
              children: [
                WhoIsThisButton(
                  conversationId: 'conv-123',
                  compact: false,
                ),
                WhoIsThisButton(
                  conversationId: 'conv-123',
                  compact: true,
                ),
              ],
            ),
          ),
        ),
      );

      // Just verify both modes render without crashing
      expect(find.byType(WhoIsThisButton), findsNWidgets(2));
      expect(find.text('Who is this?'), findsOneWidget); // Only in non-compact
      expect(find.byIcon(Icons.info_outline), findsNWidgets(2)); // In both
    });
  });
}
</file>

<file path="frontend/web/index.html">
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="messageai">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>messageai</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>
</file>

<file path="frontend/web/manifest.json">
{
    "name": "messageai",
    "short_name": "messageai",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}
</file>

<file path="frontend/windows/.gitignore">
flutter/ephemeral/

# Visual Studio user-specific files.
*.suo
*.user
*.userosscache
*.sln.docstates

# Visual Studio build-related files.
x64/
x86/

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/
</file>

<file path="frontend/windows/CMakeLists.txt">
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(messageai LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "messageai")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)
</file>

<file path="frontend/windows/flutter/CMakeLists.txt">
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)
</file>

<file path="frontend/windows/runner/CMakeLists.txt">
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)
</file>

<file path="frontend/windows/runner/flutter_window.cpp">
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}
</file>

<file path="frontend/windows/runner/flutter_window.h">
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_
</file>

<file path="frontend/windows/runner/main.cpp">
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"messageai", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}
</file>

<file path="frontend/windows/runner/resource.h">
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
</file>

<file path="frontend/windows/runner/runner.exe.manifest">
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>
</file>

<file path="frontend/windows/runner/Runner.rc">
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "com.example" "\0"
            VALUE "FileDescription", "messageai" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "messageai" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2025 com.example. All rights reserved." "\0"
            VALUE "OriginalFilename", "messageai.exe" "\0"
            VALUE "ProductName", "messageai" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
</file>

<file path="frontend/windows/runner/utils.cpp">
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}
</file>

<file path="frontend/windows/runner/utils.h">
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_
</file>

<file path="frontend/windows/runner/win32_window.cpp">
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}
</file>

<file path="frontend/windows/runner/win32_window.h">
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_
</file>

<file path="package.json">
{
  "dependencies": {
    "supabase": "^2.51.0"
  }
}
</file>

<file path="backend/Makefile">
.PHONY: db/start db/migrate db/test funcs/dev contracts/validate contracts/gen

db/start:
	npx supabase start

db/migrate:
	npx supabase db reset

db/test:
	pg_prove supabase/db/test/*.sql

funcs/dev:
	npx supabase functions serve --env-file backend/.env

contracts/validate:
	npm --prefix ../contracts ci && npm --prefix ../contracts run validate

contracts/gen:
	npm --prefix ../contracts run gen:dart
</file>

<file path="backend/package.json">
{
  "name": "messageai-backend",
  "version": "1.0.0",
  "description": "MessageAI Backend Diagnostic Tests",
  "scripts": {
    "test": "node test_diagnostics.js"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.39.0",
    "dotenv": "^16.3.1",
    "uuid": "^13.0.0"
  }
}
</file>

<file path="backend/supabase/functions/_shared/openai-client.ts">
/**
 * OpenAI API Client
 * Provides type-safe wrapper for GPT-4 interactions
 */

export interface OpenAIMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

export interface OpenAIResponse {
  id: string;
  object: string;
  created: number;
  model: string;
  choices: Array<{
    index: number;
    message: {
      role: string;
      content: string;
    };
    finish_reason: string;
  }>;
  usage: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

export interface OpenAIRequestOptions {
  model?: string;
  temperature?: number;
  max_tokens?: number;
  response_format?: { type: 'json_object' };
}

export class OpenAIClient {
  private apiKey: string;
  private baseUrl = 'https://api.openai.com/v1/chat/completions';
  private defaultModel = 'gpt-4-turbo-preview';

  constructor(apiKey: string) {
    if (!apiKey) {
      throw new Error('OpenAI API key is required');
    }
    this.apiKey = apiKey;
  }

  /**
   * Send messages to GPT-4 and get a response
   */
  async sendMessages(
    messages: OpenAIMessage[],
    options: OpenAIRequestOptions = {}
  ): Promise<OpenAIResponse> {
    const {
      model = this.defaultModel,
      temperature = 0.7,
      max_tokens = 1000,
      response_format,
    } = options;

    const requestBody: any = {
      model,
      messages,
      temperature,
      max_tokens,
    };

    if (response_format) {
      requestBody.response_format = response_format;
    }

    try {
      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`,
        },
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(
          `OpenAI API error (${response.status}): ${errorBody}`
        );
      }

      const data: OpenAIResponse = await response.json();
      return data;
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to call OpenAI API: ${error.message}`);
      }
      throw error;
    }
  }

  /**
   * Extract text content from the response
   */
  extractTextContent(response: OpenAIResponse): string {
    const content = response.choices[0]?.message?.content || '';
    if (!content) {
      console.warn("‚ö†Ô∏è Empty response content from OpenAI");
    }
    return content;
  }

  /**
   * Send a simple single-turn message and get text response
   */
  async sendSimpleMessage(
    userMessage: string,
    systemPrompt?: string,
    options: Partial<OpenAIRequestOptions> = {}
  ): Promise<string> {
    const messages: OpenAIMessage[] = [];
    
    if (systemPrompt) {
      messages.push({
        role: 'system',
        content: systemPrompt,
      });
    }
    
    messages.push({
      role: 'user',
      content: userMessage,
    });

    const response = await this.sendMessages(messages, options);
    return this.extractTextContent(response);
  }

  /**
   * Parse JSON from GPT's response
   * Handles cases where GPT wraps JSON in markdown code blocks
   */
  parseJSONResponse<T>(responseText: string): T {
    // Remove markdown code blocks if present
    let cleaned = responseText.trim();
    
    // Log the raw response for debugging
    console.log("üîç Raw response from OpenAI:", cleaned.substring(0, 200) + (cleaned.length > 200 ? "..." : ""));
    
    // Remove ```json and ``` markers
    if (cleaned.startsWith('```json')) {
      cleaned = cleaned.slice(7);
    } else if (cleaned.startsWith('```')) {
      cleaned = cleaned.slice(3);
    }
    
    if (cleaned.endsWith('```')) {
      cleaned = cleaned.slice(0, -3);
    }
    
    cleaned = cleaned.trim();
    
    console.log("‚ú® Cleaned response:", cleaned.substring(0, 200) + (cleaned.length > 200 ? "..." : ""));
    
    try {
      const parsed = JSON.parse(cleaned) as T;
      console.log("‚úÖ JSON parsed successfully");
      return parsed;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      const contextSize = 500;
      const errorContext = cleaned.length > contextSize 
        ? cleaned.substring(0, contextSize) + "\n... [truncated]"
        : cleaned;
      
      console.error("‚ùå JSON parsing failed!");
      console.error("Error:", errorMsg);
      console.error("Response context:", errorContext);
      
      throw new Error(
        `Failed to parse JSON response: ${errorMsg}\n` +
        `Response preview: ${errorContext}`
      );
    }
  }

  /**
   * Send a message and parse JSON response
   * Uses OpenAI's structured JSON output mode for reliable formatting
   */
  async sendMessageForJSON<T>(
    userMessage: string,
    systemPrompt: string,
    options: Partial<OpenAIRequestOptions> = {}
  ): Promise<T> {
    try {
      console.log("üì§ Preparing JSON request to OpenAI...");
      console.log("System prompt length:", systemPrompt.length);
      console.log("User message length:", userMessage.length);
      
      const responseText = await this.sendSimpleMessage(
        userMessage,
        systemPrompt,
        {
          ...options,
          temperature: 0.3, // Lower temperature for more consistent JSON
          response_format: { type: 'json_object' }, // Request JSON format
        }
      );

      console.log("üì• Received response from OpenAI, attempting to parse...");
      const result = this.parseJSONResponse<T>(responseText);
      console.log("üéØ Successfully parsed JSON response");
      return result;
    } catch (error) {
      console.error("üí• Failed to get JSON response:", error);
      throw error;
    }
  }
}

/**
 * Create an OpenAI client with API key from environment
 */
export function createOpenAIClient(): OpenAIClient {
  const apiKey = Deno.env.get('OPENAI_API_KEY');
  
  if (!apiKey) {
    throw new Error(
      'OPENAI_API_KEY environment variable is not set. ' +
      'Please configure it in Supabase Edge Function secrets.'
    );
  }

  return new OpenAIClient(apiKey);
}
</file>

<file path="backend/supabase/functions/_shared/prompts/enhanced-tone-analysis.ts">
/**
 * Enhanced Tone Analysis System for Neurodivergent Communication
 * Based on 2025 research: GoEmotions, Plutchik, neurodivergent communication studies
 */

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

export type IntensityLevel = 'very_low' | 'low' | 'medium' | 'high' | 'very_high' | 'High' | 'Medium' | 'Low' | 'Very Low';
export type UrgencyLevel = 'Low' | 'Medium' | 'High' | 'Critical' | 'critical' | 'low' | 'high' | 'medium';
export type EmotionalShift = 'escalating' | 'de-escalating' | 'stable' ;
export type NeurodivergentProfile = 'ADHD' | 'autism' | 'both' | 'social_anxiety' | 'none';

export interface ToneAnalysisResult {
  tone: string;
  intensity?: IntensityLevel;
  urgency_level: UrgencyLevel;
  intent: string;
  confidence_score: number;
  reasoning?: string;
  secondary_tones?: string[];
  emotion_blend?: EmotionCombination;
  context_flags?: ContextFlags;
  is_ambiguous?: boolean;
  alternative_interpretations?: AlternativeInterpretation[];
  response_anxiety_assessment?: ResponseAnxietyAssessment;
  figurative_language_detected?: FigurativeLanguageDetection;
}

export interface EmotionCombination {
  primary_emotion: string;
  secondary_emotion?: string;
  plutchik_blend?: string; // e.g., "love" = joy + trust
}

export interface ContextFlags {
  sarcasm_detected?: boolean;
  figurative_language?: boolean;
  tone_indicator_present?: boolean;
  ambiguous?: boolean;
  implicit_emotion?: boolean;
  emotional_shift?: EmotionalShift;
  urgency_mismatch?: boolean;
}

export interface AlternativeInterpretation {
  tone: string;
  intensity: IntensityLevel;
  probability: number;
  reasoning: string;
}

export interface ResponseAnxietyAssessment {
  risk_level: 'low' | 'medium' | 'high';
  mitigation_suggestions: string[];
}

export interface FigurativeLanguageDetection {
  has_figurative_language: boolean;
  examples: string[];
}

export interface ConversationMessage {
  message: string;
  timestamp: Date;
  tone_analysis?: ToneAnalysisResult;
  sender: 'user' | 'other';
}

export interface UserEmotionalBaseline {
  typical_tones: string[];
  average_intensity: IntensityLevel;
  neurodivergent_profile?: NeurodivergentProfile;
  preferences: string;
  baseline_indicators: string[];
}

export interface ToneDefinition {
  description: string;
  markers?: string[];
  intensity_variants?: string[];
  neurodivergent_consideration?: string;
}

// ============================================================================
// ENHANCED TONE CATEGORIES (23 TOTAL)
// ============================================================================

export const VALID_TONES = [
  'Friendly', 'Professional', 'Urgent', 'Casual', 'Formal', 'Concerned',
  'Excited', 'Neutral', 'Apologetic', 'Appreciative', 'Frustrated', 'Playful',
  'Sarcastic', 'Empathetic', 'Inquisitive', 'Assertive', 'Tentative', 'Defensive',
  'Encouraging', 'Disappointed', 'Overwhelmed', 'Relieved', 'Confused'
] as const;

export type ToneName = typeof VALID_TONES[number];

export const TONE_DEFINITIONS: Record<ToneName, ToneDefinition> = {
  Friendly: { description: "Warm, welcoming, personable" },
  Professional: { description: "Business-like, formal, respectful" },
  Urgent: { description: "Time-sensitive, pressing, immediate" },
  Casual: { description: "Relaxed, informal, conversational" },
  Formal: { description: "Structured, official, ceremonious" },
  Concerned: { description: "Worried, distressed, seeking support" },
  Excited: { description: "Enthusiastic, energetic, animated" },
  Neutral: { description: "Balanced, objective, matter-of-fact" },
  Apologetic: { description: "Expressing regret or sorry" },
  Appreciative: { description: "Showing gratitude or recognition" },
  Frustrated: { description: "Annoyed or irritated by obstacles" },
  Playful: { description: "Teasing, joking, lighthearted" },
  Sarcastic: { description: "Mocking tone with opposite meaning" },
  Empathetic: { description: "Understanding and supportive" },
  Inquisitive: { description: "Curious and seeking information" },
  Assertive: { description: "Confident and direct" },
  Tentative: { description: "Uncertain or hesitant" },
  Defensive: { description: "Protective or justifying actions" },
  Encouraging: { description: "Supportive and motivating" },
  Disappointed: { description: "Let down or dissatisfied" },
  Overwhelmed: { description: "Feeling excessive pressure or emotion" },
  Relieved: { description: "Feeling reassured or unburdened" },
  Confused: { description: "Unclear or uncertain about meaning" }
};

// ============================================================================
// TONE INDICATOR MAPPINGS
// ============================================================================

export const TONE_INDICATOR_MAP: Record<string, string> = {
  '/j': 'Playful',
  '/joking': 'Playful',
  '/srs': 'Assertive',
  '/serious': 'Assertive',
  '/s': 'Sarcastic',
  '/sarcasm': 'Sarcastic',
  '/nm': 'Neutral',
  '/notmad': 'Neutral',
  '/lh': 'Friendly',
  '/lighthearted': 'Friendly',
  '/gen': 'Inquisitive'
};

// ============================================================================
// VALIDATION FUNCTIONS
// ============================================================================

export function validateToneAnalysis(result: any): ToneAnalysisResult {
  const validIntensities: IntensityLevel[] = ['very_low', 'low', 'medium', 'high', 'very_high'];
  const validUrgencyLevels: UrgencyLevel[] = ['Low', 'Medium', 'High', 'Critical'];
  
  console.log("üîç Validating tone analysis result...");
  console.log("Received result:", JSON.stringify(result, null, 2));
  
  // üîß FIXED: Normalize tone to correct capitalization (case-insensitive matching)
  let tone = result.tone;
  if (typeof tone === 'string') {
    // Try to find matching tone (case-insensitive)
    const matchedTone = VALID_TONES.find((t) => t.toLowerCase() === tone.toLowerCase());
    if (matchedTone) {
      tone = matchedTone; // Use correctly capitalized version
      console.log(`‚úÖ Tone normalized: "${result.tone}" -> "${tone}"`);
    }
  }
  
  if (!tone || !VALID_TONES.includes(tone)) {
    console.error(`‚ùå Invalid tone: "${result.tone}"`);
    console.error(`Valid tones: ${VALID_TONES.join(', ')}`);
    throw new Error(`Invalid tone: ${result.tone}. Valid tones: ${VALID_TONES.join(', ')}`);
  }
  
  if (!result.urgency_level || !validUrgencyLevels.includes(result.urgency_level)) {
    console.error(`‚ùå Invalid urgency level: "${result.urgency_level}"`);
    console.error(`Valid urgency levels: ${validUrgencyLevels.join(', ')}`);
    throw new Error(`Invalid urgency level: ${result.urgency_level}.`);
  }
  if (!result.intent || typeof result.intent !== 'string') {
    console.error("‚ùå Invalid intent - must be non-empty string");
    throw new Error('Intent must be a non-empty string.');
  }
  if (
    typeof result.confidence_score !== 'number' ||
    result.confidence_score < 0 ||
    result.confidence_score > 1
  ) {
    console.error(`‚ùå Invalid confidence score: ${result.confidence_score}`);
    throw new Error('Confidence score must be a number between 0 and 1.');
  }
  if (result.intensity !== undefined && !validIntensities.includes(result.intensity)) {
    console.error(`‚ùå Invalid intensity: "${result.intensity}"`);
    console.error(`Valid intensities: ${validIntensities.join(', ')}`);
    throw new Error(`Invalid intensity: ${result.intensity}`);
  }
  
  // üîß FIXED: Normalize secondary tones too
  let secondaryTones = result.secondary_tones;
  if (result.secondary_tones) {
    if (!Array.isArray(result.secondary_tones)) {
      console.error("‚ùå Secondary tones must be an array");
      throw new Error('secondary_tones must be an array');
    }
    secondaryTones = result.secondary_tones.map((secondaryTone: string) => {
      const matchedTone = VALID_TONES.find((t) => t.toLowerCase() === secondaryTone.toLowerCase());
      return matchedTone || secondaryTone;
    });
    
    for (const secondaryTone of secondaryTones) {
      if (!VALID_TONES.includes(secondaryTone)) {
        console.error(`‚ùå Invalid secondary tone: "${secondaryTone}"`);
        throw new Error(`Invalid secondary tone: ${secondaryTone}`);
      }
    }
  }
  
  console.log("‚úÖ Validation passed!");
  return {
    ...result,
    tone, // Use normalized tone
    secondary_tones: secondaryTones, // Use normalized secondary tones
  };
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Extracts explicit tone indicators (e.g., /j, /s) from a message
export function extractToneIndicators(message: string): string[] {
  const toneIndicatorRegex = /\/([a-zA-Z]+)/g;
  const matches = message.match(toneIndicatorRegex) || [];
  return matches;
}

// Detects known figurative language idioms
export function detectFigurativeLanguage(message: string): { has_figurative_language: boolean, examples: string[] } {
  const idioms = ['break the ice', 'piece of cake', 'under the weather', 'spill the beans'];
  const detected: string[] = [];
  for (const idiom of idioms) {
    if (message.toLowerCase().includes(idiom)) {
      detected.push(`Idiom: "${idiom}"`);
    }
  }
  return { has_figurative_language: detected.length > 0, examples: detected };
}

// Assesses anxiety risk for neurodivergent users based on tone analysis
export function assessResponseAnxietyRisk(
  analysis: ToneAnalysisResult
): { risk_level: 'low' | 'medium' | 'high'; mitigation_suggestions: string[] } {
  let risk_level: 'low' | 'medium' | 'high' = 'low';
  const suggestions: string[] = [];
  if (analysis.urgency_level === 'High' || analysis.urgency_level === 'Critical') {
    risk_level = 'high';
    suggestions.push('Urgent tone detected. Consider asking for a specific timeline.');
  }
  if (analysis.context_flags?.sarcasm_detected) {
    risk_level = 'medium';
    suggestions.push('Sarcasm detected. Literal meaning may differ.');
  }
  return { risk_level, mitigation_suggestions: suggestions };
}

// Basic prompt generation, context optional
export function generateAnalysisPrompt(messageBody: string, conversationContext?: string[]): string {
  let prompt = `Analyze the following message:\n\n"${messageBody}"\n\n`;
  if (conversationContext && conversationContext.length > 0) {
    prompt += `**Conversation Context** (recent messages for context):\n`;
    conversationContext.forEach((msg, idx) => {
      prompt += `${idx + 1}. "${msg}"\n`;
    });
    prompt += '\n';
  }
  prompt += `Provide your analysis in JSON format as specified.`;
  return prompt;
}

// ============================================================================
// ENHANCED SYSTEM PROMPT
// ============================================================================

/**
 * Enhanced system prompt with 23 tones and neurodivergent support
 */
export const ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT = `You are an expert communication analyst specializing in understanding tone, intent, and urgency in messages, with specific expertise in neurodivergent communication patterns.

**CRITICAL: RESPONSE FORMAT REQUIREMENTS**

You MUST respond with ONLY valid JSON (no markdown, no extra text). The response must be exactly:

{
  "tone": "one of 23 valid categories ONLY",
  "urgency_level": "one of exactly: Low, Medium, High, Critical",
  "intent": "3-8 word description of what sender is trying to accomplish",
  "confidence_score": 0.85,
  "intensity": "one of: very_low, low, medium, high, very_high",
  "secondary_tones": ["optional", "array", "of", "valid", "tones"],
  "context_flags": {
    "sarcasm_detected": false,
    "tone_indicator_present": false,
    "ambiguous": false
  },
  "reasoning": "Explanation citing specific phrases and context"
}

**VALID TONE CATEGORIES (Choose ONE primary tone):**

Friendly, Professional, Urgent, Casual, Formal, Concerned, Excited, Neutral, Apologetic, Appreciative, Frustrated, Playful, Sarcastic, Empathetic, Inquisitive, Assertive, Tentative, Defensive, Encouraging, Disappointed, Overwhelmed, Relieved, Confused

**VALID URGENCY LEVELS (Choose ONE - exact capitalization required):**
- Low (no time pressure)
- Medium (should be addressed soon)
- High (important and time-sensitive)  
- Critical (extremely urgent, immediate action needed)

**VALID INTENSITY LEVELS (Choose ONE - lowercase required):**
- very_low (minimal expression)
- low (mild expression)
- medium (moderate expression)
- high (strong expression)
- very_high (extreme expression)

**CRITICAL PRIORITY: Neurodivergent Communication Considerations**

1. **Tone Indicator Detection** (HIGHEST PRIORITY):
   - If message contains /tone tags (e.g., "/j", "/srs", "/nm"), ALWAYS respect and cite them
   - These are explicit intent markers used by neurodivergent communities

2. **When in doubt**:
   - Default to lower intensity/urgency if message is ambiguous
   - Mark "ambiguous": true if meaning is unclear
   - Provide reassurance in reasoning if no clear negative indicators

3. **Response Quality Checks**:
   - tone: MUST match exactly one from the 23 categories above
   - urgency_level: MUST be exactly one of: Low, Medium, High, Critical
   - confidence_score: MUST be a number between 0 and 1
   - intensity: MUST be one of: very_low, low, medium, high, very_high
   - DO NOT use alternative spellings or capitalization
   - DO NOT include markdown code blocks
   - DO NOT add any text outside the JSON`;

// ============================================================================
// RSD & ALTERNATIVE INTERPRETATIONS (Feature 1 Enhancement)
// ============================================================================

import { 
  detectRSDTriggers, 
  generateRSDPromptAddition,
  type RSDTrigger 
} from './rsd-detection.ts';

import {
  shouldGenerateAlternatives,
  ALTERNATIVE_INTERPRETATIONS_PROMPT,
  type MessageInterpretation
} from './alternative-interpretations.ts';

import {
  EVIDENCE_EXTRACTION_PROMPT,
  formatEvidence,
  type Evidence
} from './evidence-extractor.ts';

// Extended result type with RSD/alternatives/evidence
export interface EnhancedToneAnalysisResult extends ToneAnalysisResult {
  rsd_triggers?: RSDTrigger[];
  message_interpretations?: MessageInterpretation[];
  evidence?: Evidence[];
}

// Enhanced system prompt that includes RSD detection
export const SMART_MESSAGE_INTERPRETER_PROMPT = `
${ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT}

${ALTERNATIVE_INTERPRETATIONS_PROMPT}

${EVIDENCE_EXTRACTION_PROMPT}

**NEURODIVERGENT-SPECIFIC ENHANCEMENTS:**

1. **RSD (Rejection Sensitive Dysphoria) Awareness:**
   - If analyzing short/ambiguous messages, explicitly address RSD concerns
   - Provide reassurance when messages are likely benign
   - Highlight lack of negative evidence when appropriate

2. **Literal Language Support:**
   - Explain idioms, metaphors, sarcasm literally
   - Flag when meaning differs from literal words
   - Provide "what they probably mean" translation

3. **Multiple Interpretations:**
   - For ambiguous messages, provide 2-3 interpretations
   - Rank by likelihood
   - Explain what context clues support each

4. **Evidence-Based:**
   - Always cite specific evidence
   - If no evidence exists, say so
   - Don't infer meaning without textual support

**Response Format:**
{
  "tone": "one of 23 categories",
  "intensity": "one of 5 levels",
  "urgency_level": "one of 4 levels",
  "intent": "3-8 word description",
  "confidence_score": 0.85,
  "context_flags": {...},
  "reasoning": "explanation",
  "rsd_triggers": [...], // If any detected
  "message_interpretations": [...], // If ambiguous
  "evidence": [...] // Always include
}
`;

// Enhanced prompt generator
export function generateSmartInterpretationPrompt(
  messageBody: string,
  conversationContext?: string[]
): string {
  // Detect RSD triggers
  const rsdTriggers = detectRSDTriggers(messageBody);
  const rsdAddition = generateRSDPromptAddition(rsdTriggers);

  let prompt = `Analyze the following message with RSD awareness:\n\n`;
  prompt += `**Message:** "${messageBody}"\n\n`;
  
  if (rsdAddition) {
    prompt += rsdAddition + '\n\n';
  }
  
  if (conversationContext && conversationContext.length > 0) {
    prompt += `**Conversation Context:**\n`;
    conversationContext.forEach((msg, idx) => {
      prompt += `${idx + 1}. "${msg}"\n`;
    });
    prompt += '\n';
  }
  
  prompt += `Provide comprehensive analysis including tone, RSD considerations, alternative interpretations (if ambiguous), and specific evidence.`;
  
  return prompt;
}

// Validation for enhanced result
export function validateEnhancedToneAnalysis(result: any): EnhancedToneAnalysisResult {
  // First validate base tone analysis
  const baseValidation = validateToneAnalysis(result);
  
  // Return with additional fields
  return {
    ...baseValidation,
    rsd_triggers: result.rsd_triggers || [],
    message_interpretations: result.message_interpretations || [],
    evidence: result.evidence || [],
  };
}

// ============================================================================
// EXPORT DEFAULTS
// ============================================================================

export default {
  VALID_TONES,
  TONE_DEFINITIONS,
  TONE_INDICATOR_MAP,
  validateToneAnalysis,
  extractToneIndicators,
  detectFigurativeLanguage,
  assessResponseAnxietyRisk,
  generateAnalysisPrompt,
  // Enhanced exports
  generateSmartInterpretationPrompt,
  validateEnhancedToneAnalysis,
};
</file>

<file path="backend/supabase/functions/_shared/templates/index.ts">
/**
 * Central export for all response templates
 */

import { DECLINING_TEMPLATES } from './declining-templates.ts';
import { BOUNDARY_TEMPLATES } from './boundary-templates.ts';
import { INFO_DUMP_TEMPLATES } from './info-dump-templates.ts';
import { APOLOGIZING_TEMPLATES } from './apologizing-templates.ts';
import { CLARIFYING_TEMPLATES } from './clarifying-templates.ts';

export type { ResponseTemplate } from './declining-templates.ts';
export { DECLINING_TEMPLATES } from './declining-templates.ts';
export { BOUNDARY_TEMPLATES } from './boundary-templates.ts';
export { INFO_DUMP_TEMPLATES } from './info-dump-templates.ts';
export { APOLOGIZING_TEMPLATES } from './apologizing-templates.ts';
export { CLARIFYING_TEMPLATES } from './clarifying-templates.ts';

// Re-export all templates as a single array
export const ALL_TEMPLATES = [
  ...DECLINING_TEMPLATES,
  ...BOUNDARY_TEMPLATES,
  ...INFO_DUMP_TEMPLATES,
  ...APOLOGIZING_TEMPLATES,
  ...CLARIFYING_TEMPLATES,
];
</file>

<file path="backend/supabase/functions/ai_analyze_tone/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";
import { createOpenAIClient } from "../_shared/openai-client.ts";
import {
  ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT,
  generateAnalysisPrompt,
  validateToneAnalysis,
  extractToneIndicators,
  detectFigurativeLanguage,
  assessResponseAnxietyRisk,
  type ToneAnalysisResult,
} from "../_shared/prompts/enhanced-tone-analysis.ts";
import {
  BOUNDARY_ANALYSIS_SYSTEM_PROMPT,
  generateBoundaryAnalysisPrompt,
  validateBoundaryAnalysis,
  type BoundaryAnalysisResult,
} from "../_shared/prompts/boundary-analysis.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

interface AnalyzeRequest {
  message_id: string;
  message_body: string;
  conversation_context?: string[];
  // üÜï PHASE 1: Boundary detection parameters
  isFromCurrentUser?: boolean;
  timestamp?: string;
  includeBoundaryAnalysis?: boolean;
  skipDatabaseStorage?: boolean; // üÜï NEW: Skip DB storage for auto-analysis
}

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Get the authorization header
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      throw new Error("Missing authorization header");
    }

    // Create Supabase client
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Verify the user's token
    const token = authHeader.replace("Bearer ", "");
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser(token);

    if (authError || !user) {
      throw new Error("Invalid authorization token");
    }

    // Parse request body
    const requestBody: AnalyzeRequest = await req.json();
    const { message_id, message_body, conversation_context, includeBoundaryAnalysis, timestamp, skipDatabaseStorage } = requestBody;

    if (!message_id || !message_body) {
      throw new Error("message_id and message_body are required");
    }

    console.log(`üîç Analyzing message ${message_id.substring(0, 8)}...`);

    // Verify user has access to this message
    const { data: message, error: messageError } = await supabase
      .from("messages")
      .select("id, conversation_id")
      .eq("id", message_id)
      .single();

    if (messageError || !message) {
      throw new Error("Message not found");
    }

    // Verify user is a participant in the conversation
    const { data: participant, error: participantError } = await supabase
      .from("conversation_participants")
      .select("user_id")
      .eq("conversation_id", message.conversation_id)
      .eq("user_id", user.id)
      .single();

    if (participantError || !participant) {
      throw new Error("Access denied to this conversation");
    }

    // Create OpenAI client
    const openai = createOpenAIClient();

    // Extract tone indicators and figurative language
    const toneIndicators = extractToneIndicators(message_body);
    const figurativeLanguage = detectFigurativeLanguage(message_body);
    
    console.log("üè∑Ô∏è  Tone indicators found:", toneIndicators);
    console.log("üí≠ Figurative language:", figurativeLanguage);

    // Generate the analysis prompt
    const userPrompt = generateAnalysisPrompt(
      message_body,
      conversation_context
    );

    console.log("üì§ Sending request to OpenAI...");

    // Call OpenAI API with enhanced prompt
    const analysisResult = await openai.sendMessageForJSON<ToneAnalysisResult>(
      userPrompt,
      ENHANCED_TONE_ANALYSIS_SYSTEM_PROMPT
    );

    console.log("üì• Received response from OpenAI");
    console.log("Analysis result structure:", {
      tone: analysisResult.tone,
      urgency_level: analysisResult.urgency_level,
      intent: analysisResult.intent,
      confidence_score: analysisResult.confidence_score,
      intensity: analysisResult.intensity,
      secondary_tones: analysisResult.secondary_tones?.length || 0,
      hasContextFlags: !!analysisResult.context_flags,
    });

    // Validate the result
    console.log("üîç Validating analysis result...");
    const validatedResult = validateToneAnalysis(analysisResult);
    console.log("‚úÖ Validation successful");

    // Assess response anxiety risk for neurodivergent users
    const anxietyAssessment = assessResponseAnxietyRisk(validatedResult);
    console.log("üß† Anxiety assessment:", anxietyAssessment);

    console.log(`‚úÖ Analysis complete: ${validatedResult.tone} (${validatedResult.urgency_level})`);

    // üÜï PHASE 1: Analyze for boundary violations (only for incoming messages)
    let boundaryAnalysis: BoundaryAnalysisResult | null = null;
    if (includeBoundaryAnalysis) {
      try {
        console.log("üö® Analyzing for boundary violations...");
        const boundaryPrompt = generateBoundaryAnalysisPrompt(
          message_body,
          timestamp
        );

        const boundaryResult = await openai.sendMessageForJSON<BoundaryAnalysisResult>(
          boundaryPrompt,
          BOUNDARY_ANALYSIS_SYSTEM_PROMPT
        );

        boundaryAnalysis = validateBoundaryAnalysis(boundaryResult);
        console.log("üõ°Ô∏è Boundary analysis:", boundaryAnalysis);
      } catch (boundaryError) {
        console.warn("‚ö†Ô∏è Boundary analysis failed, continuing:", boundaryError);
        // Don't fail the entire request if boundary analysis fails
        boundaryAnalysis = {
          hasViolation: false,
          type: "none",
          explanation: "",
          suggestedResponses: [],
          severity: 1,
        };
      }
    }

    // üÜï CONDITIONAL STORAGE: Only store if not auto-analysis
    let storedAnalysis: any = null; // üîß FIXED: Declare outside conditional
    if (!skipDatabaseStorage) {
      // Store the analysis in the database
      const now = Math.floor(Date.now() / 1000);

      const { data: insertedData, error: insertError } = await supabase
        .from("message_ai_analysis")
        .insert({
          message_id,
          tone: validatedResult.tone,
          urgency_level: validatedResult.urgency_level,
          intent: validatedResult.intent,
          confidence_score: validatedResult.confidence_score,
          analysis_timestamp: now,
          // ‚úÖ NEW ENHANCED FIELDS
          intensity: validatedResult.intensity,
          secondary_tones: validatedResult.secondary_tones,
          context_flags: validatedResult.context_flags,
          anxiety_assessment: anxietyAssessment,
          // üÜï PHASE 1: Boundary analysis
          boundary_analysis: boundaryAnalysis,
        })
        .select()
        .single();

      if (insertError) {
        console.error("‚ùå Failed to store analysis:", insertError);
        throw new Error(`Failed to store analysis: ${insertError.message}`);
      }

      storedAnalysis = insertedData; // üîß FIXED: Assign to outer variable
      console.log("üíæ Analysis stored successfully");
    } else {
      console.log("‚è≠Ô∏è Skipping database storage (auto-analysis mode)");
    }

    // Return the analysis result
    return new Response(
      JSON.stringify({
        success: true,
        analysis: {
          id: storedAnalysis?.id, // üîß FIXED: Now safely handles undefined
          message_id,
          tone: validatedResult.tone,
          urgency_level: validatedResult.urgency_level,
          intent: validatedResult.intent,
          confidence_score: validatedResult.confidence_score,
          reasoning: validatedResult.reasoning,
          // Enhanced fields
          intensity: validatedResult.intensity,
          secondary_tones: validatedResult.secondary_tones,
          context_flags: validatedResult.context_flags,
          anxiety_assessment: anxietyAssessment,
          // üÜï PHASE 1: Boundary analysis
          boundary_analysis: boundaryAnalysis,
          figurative_language_detected: figurativeLanguage,
        },
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200,
      }
    );
  } catch (error) {
    console.error("‚ùå Error in ai_analyze_tone:", error);

    const errorMessage = error instanceof Error ? error.message : "Unknown error";

    return new Response(
      JSON.stringify({
        success: false,
        error: errorMessage,
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 400,
      }
    );
  }
});
</file>

<file path="backend/supabase/functions/ai-context-preloader/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { createOpenAIClient } from '../_shared/openai-client.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('Missing authorization header');
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      throw new Error('Unauthorized');
    }

    const body = await req.json();
    const { conversation_id } = body;

    if (!conversation_id) {
      throw new Error('Missing conversation_id');
    }

    console.log(`üìã Loading context for conversation ${conversation_id}, user ${user.id}`);

    // üîß FIXED: Skip RPC cache check and generate context directly
    // This avoids the 400 error from missing RPC functions
    console.log('üîÑ Generating fresh context (skipping cache)');

    // Get recent messages
    const { data: recentMessages } = await supabase
      .from('messages')
      .select('body, created_at, sender_id')
      .eq('conversation_id', conversation_id)
      .order('created_at', { ascending: false })
      .limit(20);

    if (!recentMessages || recentMessages.length === 0) {
      throw new Error('No messages found');
    }

    console.log(`Found ${recentMessages.length} recent messages`);

    // Use AI to extract context
    const openai = createOpenAIClient();
    
    const prompt = `Analyze these recent messages and extract:
1. What was last discussed (1 sentence)
2. 3-5 key points from the conversation
3. Any pending questions that need answers

**Recent Messages (newest first):**
${recentMessages.map((m, i) => `${i + 1}. ${m.body}`).join('\n')}

**Response Format (JSON):**
{
  "last_discussed": "brief summary of last topic",
  "key_points": [
    "key point 1",
    "key point 2",
    "key point 3"
  ],
  "pending_questions": [
    "unanswered question 1",
    "unanswered question 2"
  ]
}`;

    const result = await openai.sendMessageForJSON(
      prompt,
      'You are extracting conversation context. Be concise and helpful.',
      { temperature: 0.3, max_tokens: 500 }
    );

    const context = {
      last_discussed: result.last_discussed || 'Recent conversation',
      key_points: Array.isArray(result.key_points) ? result.key_points : [],
      pending_questions: Array.isArray(result.pending_questions) ? result.pending_questions : [],
    };

    console.log('‚úÖ Context generated');

    // üîß TODO: Cache storage skipped for now (table may not exist yet)
    // TODO: Implement caching in future version
    
    return new Response(
      JSON.stringify({
        success: true,
        context,
        from_cache: false,
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('‚ùå Error loading context:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
    );
  }
});
</file>

<file path="backend/supabase/functions/ai-interpret-message/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { OpenAIClient } from '../_shared/openai-client.ts';
import {
  SMART_MESSAGE_INTERPRETER_PROMPT,
  generateSmartInterpretationPrompt,
  validateEnhancedToneAnalysis,
  type EnhancedToneAnalysisResult,
} from '../_shared/prompts/enhanced-tone-analysis.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('Missing authorization header');
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      throw new Error('Unauthorized');
    }

    const body = await req.json();
    const { message_id, message_body, conversation_context } = body;

    if (!message_body) {
      throw new Error('Missing message_body');
    }

    console.log(`Interpreting message for user ${user.id}`);

    // Generate smart interpretation prompt
    const userPrompt = generateSmartInterpretationPrompt(
      message_body,
      conversation_context
    );

    // Call OpenAI with enhanced prompt
    const openai = new OpenAIClient(Deno.env.get('OPENAI_API_KEY')!);
    const analysisResult = await openai.sendMessageForJSON<EnhancedToneAnalysisResult>(
      userPrompt,
      SMART_MESSAGE_INTERPRETER_PROMPT,
      { temperature: 0.3, max_tokens: 1000 } // More tokens for detailed analysis
    );

    console.log('Analysis complete:', analysisResult);

    // Validate result
    const validatedResult = validateEnhancedToneAnalysis(analysisResult);

    // Store in database if message_id provided
    if (message_id) {
      const now = Math.floor(Date.now() / 1000);
      // üîß FIXED: Removed non-existent user_id column, added missing fields
      await supabase
        .from('message_ai_analysis')
        .upsert({
          message_id,
          // Core fields
          tone: validatedResult.tone,
          urgency_level: validatedResult.urgency_level,
          intent: validatedResult.intent,
          confidence_score: validatedResult.confidence_score,
          // Enhanced fields
          intensity: validatedResult.intensity,
          context_flags: validatedResult.context_flags,
          secondary_tones: validatedResult.secondary_tones,
          anxiety_assessment: validatedResult.response_anxiety_assessment,
          // Phase 1: Smart Message Interpreter fields
          rsd_triggers: validatedResult.rsd_triggers,
          alternative_interpretations: validatedResult.message_interpretations,
          evidence: validatedResult.evidence,
          figurative_language_detected: validatedResult.figurative_language_detected,
          // Metadata
          analysis_timestamp: now,
          updated_at: now,
        });
      
      console.log(`Stored analysis for message ${message_id}`);
    }

    return new Response(
      JSON.stringify({
        success: true,
        interpretation: validatedResult,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    console.error('Error interpreting message:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      }
    );
  }
});
</file>

<file path="backend/supabase/functions/push_notify/index.ts">
// @ts-nocheck - Deno Edge Function (disable all TypeScript checks for VS Code)
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.38.0";

interface PushNotifyPayload {
  message_id: string;
  conversation_id: string;
  sender_id: string;
  sender_name: string;
  title: string;
  body: string;
}

interface PushNotifyResponse {
  success: boolean;
  message_id: string;
  notifications_sent: number;
  recipients: Array<{
    user_id: string;
    device_count: number;
  }>;
}

interface ErrorResponse {
  error: string;
  status: number;
}

// CORS headers
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Content-Type": "application/json",
};

// Helper function to generate Firebase OAuth2 access token
async function getFirebaseAccessToken(
  privateKey: string,
  clientEmail: string
): Promise<string> {
  const jwtHeader = btoa(JSON.stringify({ alg: "RS256", typ: "JWT" }));
  
  const now = Math.floor(Date.now() / 1000);
  const jwtClaimSet = {
    iss: clientEmail,
    scope: "https://www.googleapis.com/auth/firebase.messaging",
    aud: "https://oauth2.googleapis.com/token",
    exp: now + 3600,
    iat: now,
  };
  const jwtClaimSetEncoded = btoa(JSON.stringify(jwtClaimSet));
  
  // Import private key
  const pemHeader = "-----BEGIN PRIVATE KEY-----";
  const pemFooter = "-----END PRIVATE KEY-----";
  const pemContents = privateKey
    .replace(pemHeader, "")
    .replace(pemFooter, "")
    .replace(/\\n/g, "")
    .replace(/\s/g, "");
  
  const binaryDer = Uint8Array.from(atob(pemContents), c => c.charCodeAt(0));
  
  const cryptoKey = await crypto.subtle.importKey(
    "pkcs8",
    binaryDer,
    { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
    false,
    ["sign"]
  );
  
  // Sign JWT
  const signatureInput = `${jwtHeader}.${jwtClaimSetEncoded}`;
  const signature = await crypto.subtle.sign(
    "RSASSA-PKCS1-v1_5",
    cryptoKey,
    new TextEncoder().encode(signatureInput)
  );
  
  const signatureBase64 = btoa(String.fromCharCode(...new Uint8Array(signature)))
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=/g, "");
  
  const jwt = `${signatureInput}.${signatureBase64}`;
  
  // Exchange JWT for access token
  const tokenResponse = await fetch("https://oauth2.googleapis.com/token", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({
      grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
      assertion: jwt,
    }),
  });
  
  if (!tokenResponse.ok) {
    throw new Error(`Failed to get access token: ${await tokenResponse.text()}`);
  }
  
  const tokenData = await tokenResponse.json();
  return tokenData.access_token;
}

serve(async (req) => {
  console.log("üîî Push notify function called");
  
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Get authenticated user
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      console.error("‚ùå No authorization header");
      return new Response(
        JSON.stringify({ error: "Unauthorized" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Create Supabase client
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Get user ID from JWT token
    const token = authHeader.replace("Bearer ", "");
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: "Invalid token" }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Parse request body
    const payload: PushNotifyPayload = await req.json();
    console.log("üì¨ Payload received:", { 
      message_id: payload.message_id,
      conversation_id: payload.conversation_id,
      sender_id: payload.sender_id 
    });

    // Validate required fields
    if (!payload.conversation_id || !payload.message_id) {
      console.error("‚ùå Missing required fields");
      return new Response(
        JSON.stringify({
          error: "Missing required fields: conversation_id, message_id",
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Get all conversation participants
    console.log("üë• Fetching conversation participants...");
    const { data: participants, error: participantError } = await supabase
      .from("conversation_participants")
      .select("user_id")
      .eq("conversation_id", payload.conversation_id)
      .neq("user_id", user.id); // Exclude sender

    if (participantError) {
      console.error("Error fetching participants:", participantError);
      return new Response(
        JSON.stringify({ error: "Failed to fetch participants" }),
        { status: 500, headers: corsHeaders }
      );
    }

    if (!participants || participants.length === 0) {
      console.log("‚ÑπÔ∏è No other participants to notify");
      return new Response(
        JSON.stringify({
          success: true,
          message_id: payload.message_id,
          notifications_sent: 0,
          recipients: [],
        }),
        { status: 200, headers: corsHeaders }
      );
    }

    const recipientUserIds = participants.map((p) => p.user_id);
    console.log(`üì± Found ${recipientUserIds.length} recipient(s):`, recipientUserIds);

    // Get all devices for participants
    // No timeout check - push notifications should work even if user hasn't opened app in days
    // FCM will handle invalid/uninstalled tokens automatically
    console.log(`üì≤ Fetching all devices for recipients...`);
    
    const { data: devices, error: deviceError } = await supabase
      .from("profile_devices")
      .select("user_id, fcm_token, platform, last_seen")
      .in("user_id", recipientUserIds);

    if (deviceError) {
      console.error("‚ùå Error fetching devices:", deviceError);
      // Continue without devices - not critical
    }
    
    console.log(`üì≤ Found ${devices?.length || 0} device(s)`);
    if (devices && devices.length > 0) {
      devices.forEach(d => {
        const daysSinceLastSeen = Math.floor((Date.now() - new Date(d.last_seen).getTime()) / (1000 * 60 * 60 * 24));
        console.log(`   - User: ${d.user_id}, Platform: ${d.platform}, Last seen: ${daysSinceLastSeen} days ago, Token: ${d.fcm_token.substring(0, 20)}...`);
      });
    } else {
      console.log("‚ö†Ô∏è No devices found! Check:");
      console.log(`   - Are recipient user_ids correct? ${recipientUserIds.join(', ')}`);
      console.log(`   - Are devices registered in profile_devices table?`);
    }

    // Group devices by user
    const devicesByUser = new Map<string, Array<{ fcm_token: string; platform: string }>>();
    (devices || []).forEach((device) => {
      if (!devicesByUser.has(device.user_id)) {
        devicesByUser.set(device.user_id, []);
      }
      devicesByUser.get(device.user_id)!.push({
        fcm_token: device.fcm_token,
        platform: device.platform,
      });
    });

    // Get Firebase credentials from environment
    const firebaseProjectId = Deno.env.get("FIREBASE_PROJECT_ID");
    const firebasePrivateKey = Deno.env.get("FIREBASE_PRIVATE_KEY");
    const firebaseClientEmail = Deno.env.get("FIREBASE_CLIENT_EMAIL");

    console.log("üî• Firebase config check:", {
      projectId: firebaseProjectId ? "‚úÖ Set" : "‚ùå Missing",
      privateKey: firebasePrivateKey ? "‚úÖ Set" : "‚ùå Missing",
      clientEmail: firebaseClientEmail ? "‚úÖ Set" : "‚ùå Missing"
    });

    // Check if Firebase is configured
    if (!firebaseProjectId || !firebasePrivateKey || !firebaseClientEmail) {
      console.warn("‚ö†Ô∏è Firebase not configured - skipping notifications");
      return new Response(
        JSON.stringify({
          success: true,
          message_id: payload.message_id,
          notifications_sent: 0,
          recipients: Array.from(devicesByUser.keys()).map((userId) => ({
            user_id: userId,
            device_count: devicesByUser.get(userId)?.length || 0,
          })),
        }),
        { status: 200, headers: corsHeaders }
      );
    }

    // Send notifications to each device
    console.log(`üöÄ Sending notifications to ${devicesByUser.size} user(s)...`);
    let totalNotificationsSent = 0;
    const recipientsSummary: Array<{ user_id: string; device_count: number }> = [];

    for (const [userId, userDevices] of devicesByUser.entries()) {
      for (const device of userDevices) {
        try {
          console.log(`üì§ Sending to ${device.platform}: ${device.fcm_token.substring(0, 20)}...`);
          
          // Prepare FCM message
          const fcmMessage = {
            message: {
              token: device.fcm_token,
              notification: {
                title: payload.title || "New message",
                body: payload.body || `${payload.sender_name} sent a message`,
              },
              data: {
                conversation_id: payload.conversation_id,
                message_id: payload.message_id,
                sender_id: payload.sender_id,
                sender_name: payload.sender_name,
              },
              // Android-specific
              android: {
                priority: "high",
                notification: {
                  sound: "default",
                  click_action: "FLUTTER_NOTIFICATION_CLICK",
                },
              },
              // iOS-specific
              apns: {
                payload: {
                  aps: {
                    alert: {
                      title: payload.title || "New message",
                      body: payload.body || `${payload.sender_name} sent a message`,
                    },
                    sound: "default",
                    badge: 1,
                  },
                },
              },
            },
          };

          // Get OAuth2 access token for FCM
          console.log("üîë Getting Firebase access token...");
          const accessToken = await getFirebaseAccessToken(
            firebasePrivateKey,
            firebaseClientEmail
          );
          console.log("‚úÖ Got access token");

          // Call Firebase Cloud Messaging API
          console.log(`üì° Calling FCM API for project: ${firebaseProjectId}`);
          const fcmResponse = await fetch(
            `https://fcm.googleapis.com/v1/projects/${firebaseProjectId}/messages:send`,
            {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(fcmMessage),
            }
          );

          if (fcmResponse.ok) {
            totalNotificationsSent++;
            console.log(`‚úÖ SUCCESS! Notification sent to ${device.platform} device`);
          } else {
            const errorText = await fcmResponse.text();
            console.error(`‚ùå FCM API error ${fcmResponse.status}: ${errorText}`);
          }
        } catch (error) {
          console.error(
            `Error sending notification to ${device.fcm_token}:`,
            error
          );
        }
      }

      recipientsSummary.push({
        user_id: userId,
        device_count: userDevices.length,
      });
    }

    const response: PushNotifyResponse = {
      success: true,
      message_id: payload.message_id,
      notifications_sent: totalNotificationsSent,
      recipients: recipientsSummary,
    };

    return new Response(JSON.stringify(response), {
      status: 200,
      headers: corsHeaders,
    });
  } catch (error) {
    console.error("Error in push_notify:", error);
    return new Response(
      JSON.stringify({ error: "Internal server error" }),
      { status: 500, headers: corsHeaders }
    );
  }
});
</file>

<file path="backend/supabase/seed_showcase_data.sql">
-- ============================================================
-- SHOWCASE DATA SEEDING SCRIPT
-- Populates database with realistic conversations for demo/testing
-- ============================================================

-- HOW TO RUN:
-- 1. First, get your user ID:
--    SELECT id, email FROM auth.users;
--    
-- 2. Copy your user ID and replace it in the line below
--
-- 3. Run this file:
--    cd backend
--    npx supabase db reset    (resets and runs all migrations)
--    psql $DATABASE_URL -f supabase/seed_showcase_data.sql
--
--    OR use Supabase Studio SQL Editor to run this entire file
--
-- ============================================================

DO $$
DECLARE
  -- ‚ö†Ô∏è REPLACE THIS WITH YOUR ACTUAL USER ID FROM auth.users ‚ö†Ô∏è
  v_user_id UUID := '34742825-3fad-4e51-a103-ccd649806660';
  
  -- Create stable UUIDs for fake users (so we can create profiles)
  v_boss_id UUID := 'a0000000-0000-0000-0000-000000000001';
  v_friend_id UUID := 'a0000000-0000-0000-0000-000000000002';
  v_mom_id UUID := 'a0000000-0000-0000-0000-000000000003';
  v_client_id UUID := 'a0000000-0000-0000-0000-000000000004';
  
  v_conv_boss UUID;
  v_conv_friend UUID;
  v_conv_mom UUID;
  v_conv_client UUID;
  
  v_msg1 UUID;
  v_msg2 UUID;
  v_msg3 UUID;
  v_msg4 UUID;
  v_msg5 UUID;
  v_msg6 UUID;
  v_msg7 UUID;
  v_msg8 UUID;
  v_msg9 UUID;
  v_msg10 UUID;
  v_msg11 UUID;
  v_msg12 UUID;
  v_msg13 UUID;
  v_msg14 UUID;
  v_msg15 UUID;
  
  v_now TIMESTAMPTZ;
  v_yesterday TIMESTAMPTZ;
  v_last_week TIMESTAMPTZ;
  v_two_weeks TIMESTAMPTZ;
BEGIN
  v_now := NOW();
  v_yesterday := v_now - INTERVAL '1 day';
  v_last_week := v_now - INTERVAL '7 days';
  v_two_weeks := v_now - INTERVAL '14 days';

  -- ============================================================
  -- CLEANUP: Remove existing seed data to prevent duplicates
  -- ============================================================
  -- Delete conversations created by this user (these are the showcase conversations)
  DELETE FROM conversations 
  WHERE created_by = v_user_id 
    AND title IN ('Sarah Chen (Manager)', 'Alex Thompson', 'Mom', 'Marcus Williams (TechCorp)');
  
  -- ============================================================
  -- CREATE FAKE USER PROFILES
  -- ============================================================
  -- These fake users need to exist in profiles table for foreign key constraints
  
  INSERT INTO profiles (user_id, username)
  VALUES 
    (v_boss_id, 'Sarah Chen'),
    (v_friend_id, 'Alex Thompson'),
    (v_mom_id, 'Mom'),
    (v_client_id, 'Marcus Williams')
  ON CONFLICT (user_id) DO NOTHING;

  -- ============================================================
  -- 1. BOSS CONVERSATION - Formal, stressful, RSD triggers
  -- ============================================================
  v_conv_boss := gen_random_uuid();
  
  INSERT INTO conversations (id, title, description, created_by, created_at, updated_at, is_group)
  VALUES (
    v_conv_boss,
    'Sarah Chen (Manager)',
    'Work - Project Manager',
    v_user_id,
    v_two_weeks,
    v_now - INTERVAL '1 hour',
    false
  );
  
  INSERT INTO conversation_participants (id, conversation_id, user_id, joined_at)
  VALUES 
    (gen_random_uuid(), v_conv_boss, v_user_id, v_two_weeks),
    (gen_random_uuid(), v_conv_boss, v_boss_id, v_two_weeks);
  
  -- Long conversation history (for RAG context - 15+ messages)
  -- Week 2: Initial onboarding
  v_msg1 := gen_random_uuid();
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (v_msg1, v_conv_boss, v_boss_id, 
    'Hi! Welcome to the team. I wanted to touch base about the Q1 project timeline. Can you have the initial designs ready by Friday?',
    v_two_weeks, v_two_weeks);
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_boss, v_user_id,
    'Thanks! Yes, I should be able to get those done by Friday.',
    v_two_weeks + INTERVAL '30 minutes', v_two_weeks + INTERVAL '30 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_boss, v_boss_id,
    'Perfect. Also, remember we have team standup every morning at 9am. It''s pretty casual, just a quick check-in.',
    v_two_weeks + INTERVAL '45 minutes', v_two_weeks + INTERVAL '45 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_boss, v_user_id,
    'Got it, I''ll be there!',
    v_two_weeks + INTERVAL '50 minutes', v_two_weeks + INTERVAL '50 minutes');
  
  -- Week 2: Missed standup incident
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_boss, v_boss_id,
    'Great. Also, I noticed you missed the team standup yesterday. Everything okay?',
    v_two_weeks + INTERVAL '2 days', v_two_weeks + INTERVAL '2 days');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_boss, v_user_id,
    'Oh I''m so sorry! I completely forgot. It won''t happen again.',
    v_two_weeks + INTERVAL '2 days 5 minutes', v_two_weeks + INTERVAL '2 days 5 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_boss, v_boss_id,
    'No worries, it happens. Just try to let me know in advance if you can''t make it.',
    v_two_weeks + INTERVAL '2 days 10 minutes', v_two_weeks + INTERVAL '2 days 10 minutes');
  
  -- Week 2: Design review
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_boss, v_user_id,
    'Hi Sarah, I have the initial designs ready for your review. Should I send them now or wait until our meeting tomorrow?',
    v_two_weeks + INTERVAL '5 days', v_two_weeks + INTERVAL '5 days');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_boss, v_boss_id,
    'Great! Send them now so I can review before our meeting. That way we can discuss any changes tomorrow.',
    v_two_weeks + INTERVAL '5 days 15 minutes', v_two_weeks + INTERVAL '5 days 15 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_boss, v_user_id,
    'Just sent! Let me know if you have any questions.',
    v_two_weeks + INTERVAL '5 days 30 minutes', v_two_weeks + INTERVAL '5 days 30 minutes');
  
  -- Week 1: Client presentation success
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_boss, v_boss_id,
    'The client really liked your presentation last week. Nice work on the animations.',
    v_last_week, v_last_week);
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_boss, v_user_id,
    'Thank you! I spent a lot of time on those.',
    v_last_week + INTERVAL '10 minutes', v_last_week + INTERVAL '10 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_boss, v_boss_id,
    'It shows. They specifically mentioned the loading animations. Keep up the good work!',
    v_last_week + INTERVAL '15 minutes', v_last_week + INTERVAL '15 minutes');
  
  -- Week 1: Question about vacation days
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_boss, v_user_id,
    'Quick question - what''s the process for requesting time off? I''d like to take a few days in March.',
    v_last_week + INTERVAL '3 days', v_last_week + INTERVAL '3 days');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_boss, v_boss_id,
    'Just put it in the HR system and cc me. As long as it doesn''t conflict with major deadlines, should be fine!',
    v_last_week + INTERVAL '3 days 20 minutes', v_last_week + INTERVAL '3 days 20 minutes');
  
  -- Recent concerning message (RSD trigger)
  v_msg2 := gen_random_uuid();
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (v_msg2, v_conv_boss, v_boss_id,
    'We need to talk about the project status. I expected this to be further along by now. Can we meet tomorrow at 10am?',
    v_now - INTERVAL '2 hours', v_now - INTERVAL '2 hours');
  
  -- Unanswered question (follow-up)
  v_msg3 := gen_random_uuid();
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (v_msg3, v_conv_boss, v_boss_id,
    'Also, did you get a chance to review the updated requirements doc I sent on Monday?',
    v_now - INTERVAL '1 hour', v_now - INTERVAL '1 hour');
  
  -- AI Analysis for RSD trigger message
  INSERT INTO message_ai_analysis (
    message_id,
    tone, intent, urgency_level, confidence_score,
    intensity,
    rsd_triggers, alternative_interpretations, evidence,
    analysis_timestamp
  ) VALUES (
    v_msg2,
    'Critical/Disappointed', 'Criticism', 'high', 0.82,
    7,
    '[{"trigger": "I expected this to be further along", "severity": "high", "explanation": "Implies disappointment with your progress"}]'::jsonb,
    '[{"interpretation": "Boss is genuinely concerned about timeline", "likelihood": "high"}, {"interpretation": "Boss is under pressure from higher-ups", "likelihood": "medium"}]'::jsonb,
    '["We need to talk", "expected this to be further along"]'::jsonb,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '2 hours'))::INTEGER
  );
  
  -- AI Analysis for unanswered question
  INSERT INTO message_ai_analysis (
    message_id,
    tone, intent, urgency_level, confidence_score,
    intensity,
    analysis_timestamp
  ) VALUES (
    v_msg3,
    'Neutral/Inquiring', 'Follow-up', 'medium', 0.75,
    5,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '1 hour'))::INTEGER
  );
  
  -- Follow-up items
  INSERT INTO follow_up_items (
    id, user_id, conversation_id, message_id,
    item_type, title, description, extracted_text,
    status, priority,
    detected_at, remind_at,
    created_at, updated_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_boss, v_msg2,
    'pending_response', 'Meeting request from Sarah',
    'Boss wants to meet tomorrow at 10am to discuss project status',
    'Can we meet tomorrow at 10am?',
    'pending', 85,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '2 hours'))::INTEGER,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '1 hour'))::INTEGER,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '2 hours'))::INTEGER,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '2 hours'))::INTEGER
  );
  
  INSERT INTO follow_up_items (
    id, user_id, conversation_id, message_id,
    item_type, title, description, extracted_text,
    status, priority,
    detected_at, remind_at,
    created_at, updated_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_boss, v_msg3,
    'unanswered_question', 'Did you review the requirements doc?',
    'Boss asked if you reviewed the requirements document from Monday',
    'did you get a chance to review the updated requirements doc',
    'pending', 75,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '1 hour'))::INTEGER,
    EXTRACT(EPOCH FROM v_now)::INTEGER,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '1 hour'))::INTEGER,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '1 hour'))::INTEGER
  );
  
  -- Relationship profile
  INSERT INTO relationship_profiles (
    id, user_id, conversation_id,
    participant_name, relationship_type, relationship_notes,
    conversation_summary, communication_style,
    safe_topics, topics_to_avoid,
    typical_response_time, total_messages,
    first_message_at, last_message_at,
    created_at, updated_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_boss,
    'Sarah Chen', 'boss', 'Project Manager - Direct but fair',
    'Work conversation focused on Q1 project. Boss has high expectations but gives credit when deserved. Be responsive and proactive.',
    'Direct and professional. Appreciates quick responses and proactive updates.',
    '["project updates", "completed work", "design feedback", "time off requests", "standup meetings"]'::jsonb,
    '["excuses", "missed meetings"]'::jsonb,
    7200, 19,
    v_two_weeks, v_now - INTERVAL '1 hour',
    NOW(), NOW()
  );
  
  -- ============================================================
  -- 2. BEST FRIEND CONVERSATION - Casual, supportive, long history
  -- ============================================================
  v_conv_friend := gen_random_uuid();
  
  INSERT INTO conversations (id, title, description, created_by, created_at, updated_at, is_group)
  VALUES (
    v_conv_friend,
    'Alex Thompson',
    'Best Friend',
    v_user_id,
    v_two_weeks - INTERVAL '1 day',
    v_now - INTERVAL '10 minutes',
    false
  );
  
  INSERT INTO conversation_participants (id, conversation_id, user_id, joined_at)
  VALUES 
    (gen_random_uuid(), v_conv_friend, v_user_id, v_two_weeks - INTERVAL '1 day'),
    (gen_random_uuid(), v_conv_friend, v_friend_id, v_two_weeks - INTERVAL '1 day');
  
  -- Long conversation with various topics (RAG showcase - 25+ messages)
  -- Week 2: TV show discussion
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_friend_id,
    'omg did you see the new episode last night?? ü§Ø',
    v_two_weeks, v_two_weeks);
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_user_id,
    'YES! That plot twist was insane!',
    v_two_weeks + INTERVAL '3 minutes', v_two_weeks + INTERVAL '3 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_friend_id,
    'Right?! I did NOT see that coming. Want to meet up this weekend to watch the next one together?',
    v_two_weeks + INTERVAL '6 minutes', v_two_weeks + INTERVAL '6 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_user_id,
    'Absolutely! Saturday work for you?',
    v_two_weeks + INTERVAL '9 minutes', v_two_weeks + INTERVAL '9 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_friend_id,
    'Perfect! Come over around 7? I''ll order pizza from that place on Main Street you love',
    v_two_weeks + INTERVAL '12 minutes', v_two_weeks + INTERVAL '12 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_user_id,
    'Omg yes! The one with the garlic knots? You''re the best üçï',
    v_two_weeks + INTERVAL '14 minutes', v_two_weeks + INTERVAL '14 minutes');
  
  -- Week 2: Later that day - checking in
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_friend_id,
    'Hey how did that presentation go today? The one you were stressing about?',
    v_two_weeks + INTERVAL '8 hours', v_two_weeks + INTERVAL '8 hours');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_user_id,
    'It went okay! I definitely rambled a bit but nobody seemed to mind',
    v_two_weeks + INTERVAL '8 hours 20 minutes', v_two_weeks + INTERVAL '8 hours 20 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_friend_id,
    'That''s great! You always think you did worse than you actually did. I bet they loved it',
    v_two_weeks + INTERVAL '8 hours 22 minutes', v_two_weeks + INTERVAL '8 hours 22 minutes');
  
  -- Week 2: Weekend plans discussion
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_user_id,
    'Thanks for believing in me. Also, random question - do you remember the name of that book you recommended last month? The one about neurodivergence?',
    v_two_weeks + INTERVAL '1 day', v_two_weeks + INTERVAL '1 day');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_friend_id,
    'Oh! "Divergent Mind" by Jenara Nerenberg? That one really helped me understand ADHD better',
    v_two_weeks + INTERVAL '1 day 5 minutes', v_two_weeks + INTERVAL '1 day 5 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_user_id,
    'Yes that''s the one! I want to read it. I''ve been thinking a lot about why I get so overwhelmed by criticism',
    v_two_weeks + INTERVAL '1 day 8 minutes', v_two_weeks + INTERVAL '1 day 8 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_friend_id,
    'The RSD chapter is really eye-opening. It helped me understand why you shut down sometimes when you think someone''s upset with you',
    v_two_weeks + INTERVAL '1 day 10 minutes', v_two_weeks + INTERVAL '1 day 10 minutes');
  
  -- Week 1: Work stress deepens
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_friend_id,
    'Saturday is perfect! How''s work going btw? You seemed stressed last week.',
    v_last_week, v_last_week);
  
  v_msg4 := gen_random_uuid();
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (v_msg4, v_conv_friend, v_user_id,
    'Ugh yeah, my boss has been on my case about this project. I feel like I''m not doing enough even though I''m working really hard.',
    v_last_week + INTERVAL '5 minutes', v_last_week + INTERVAL '5 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_friend_id,
    'Hey, I know you. You''re doing amazing. Your boss literally praised your work last month. Don''t let the RSD brain lie to you ‚ù§Ô∏è',
    v_last_week + INTERVAL '8 minutes', v_last_week + INTERVAL '8 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_user_id,
    'I know you''re right. It''s just hard to remember that when Sarah sends me those "we need to talk" messages',
    v_last_week + INTERVAL '12 minutes', v_last_week + INTERVAL '12 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_friend_id,
    'Sarah needs to learn that "we need to talk" is literally the worst possible phrase for someone with RSD. Like, just SAY what you need to say!',
    v_last_week + INTERVAL '14 minutes', v_last_week + INTERVAL '14 minutes');
  
  -- Week 1: Coffee shop incident (for context testing)
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_user_id,
    'Remember that coffee shop we went to last time? The one near the park?',
    v_last_week + INTERVAL '2 days', v_last_week + INTERVAL '2 days');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_friend_id,
    'Brew Haven? Yeah why?',
    v_last_week + INTERVAL '2 days 3 minutes', v_last_week + INTERVAL '2 days 3 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_user_id,
    'I think they''re closed now üò¢ I tried to go there this morning and there was a "for lease" sign',
    v_last_week + INTERVAL '2 days 5 minutes', v_last_week + INTERVAL '2 days 5 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_friend_id,
    'NOOO! That was our spot! Their lavender latte was literally the best thing ever',
    v_last_week + INTERVAL '2 days 7 minutes', v_last_week + INTERVAL '2 days 7 minutes');
  
  -- Mid-week: Gaming discussion
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_friend_id,
    'Hey did you end up buying that game you were obsessing over?',
    v_last_week + INTERVAL '4 days', v_last_week + INTERVAL '4 days');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_user_id,
    'YES and I stayed up until 3am playing it üòÖ My sleep schedule is destroyed',
    v_last_week + INTERVAL '4 days 5 minutes', v_last_week + INTERVAL '4 days 5 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_friend_id,
    'Classic hyperfocus moment lol. Was it worth it though?',
    v_last_week + INTERVAL '4 days 8 minutes', v_last_week + INTERVAL '4 days 8 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_user_id,
    'SO worth it. The storyline is incredible. Want to come over this weekend and I can show you?',
    v_last_week + INTERVAL '4 days 10 minutes', v_last_week + INTERVAL '4 days 10 minutes');
  
  -- Recent info-dump message (needs formatting support)
  v_msg5 := gen_random_uuid();
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (v_msg5, v_conv_friend, v_user_id,
    'So I''ve been thinking about this problem with the authentication system and I realized we could use JWT tokens instead of session cookies which would make it stateless and then we could scale horizontally more easily plus it would work better with our mobile app and we wouldn''t have to worry about CORS issues anymore and also I found this really cool library that handles token refresh automatically so users won''t get logged out in the middle of using the app which was super annoying before',
    v_yesterday, v_yesterday);
  
  v_msg6 := gen_random_uuid();
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (v_msg6, v_conv_friend, v_friend_id,
    'Haha there''s the hyperfocus! That actually sounds really smart though. You should pitch it to your team.',
    v_yesterday + INTERVAL '10 minutes', v_yesterday + INTERVAL '10 minutes');
  
  -- Recent supportive message
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_friend, v_friend_id,
    'Hey! Hope your meeting with Sarah went okay today. Remember, you got this! üí™',
    v_now - INTERVAL '10 minutes', v_now - INTERVAL '10 minutes');
  
  -- AI Analysis for info-dump
  INSERT INTO message_ai_analysis (
    message_id,
    tone, intent, urgency_level, confidence_score,
    intensity,
    analysis_timestamp
  ) VALUES (
    v_msg5,
    'Enthusiastic/Excited', 'Sharing', 'low', 0.88,
    8,
    EXTRACT(EPOCH FROM v_yesterday)::INTEGER
  );
  
  -- Relationship profile
  INSERT INTO relationship_profiles (
    id, user_id, conversation_id,
    participant_name, relationship_type, relationship_notes,
    conversation_summary, communication_style,
    safe_topics, topics_to_avoid,
    typical_response_time, total_messages,
    first_message_at, last_message_at,
    created_at, updated_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_friend,
    'Alex Thompson', 'friend', 'Best friend since college - very supportive',
    'Long-time friend who understands ADHD/RSD. Very supportive and encouraging. Safe to share work stress and hyperfocus interests.',
    'Casual, supportive, uses emojis. Responds quickly. Very understanding.',
    '["TV shows", "work venting", "tech deep-dives", "mental health", "gaming", "coffee shops", "books"]'::jsonb,
    '[]'::jsonb,
    600, 30,
    v_two_weeks, v_now - INTERVAL '10 minutes',
    NOW(), NOW()
  );
  
  -- ============================================================
  -- 3. MOM CONVERSATION - Caring but can trigger anxiety
  -- ============================================================
  v_conv_mom := gen_random_uuid();
  
  INSERT INTO conversations (id, title, description, created_by, created_at, updated_at, is_group)
  VALUES (
    v_conv_mom,
    'Mom',
    'Family',
    v_user_id,
    v_two_weeks - INTERVAL '5 days',
    v_now - INTERVAL '30 minutes',
    false
  );
  
  INSERT INTO conversation_participants (id, conversation_id, user_id, joined_at)
  VALUES 
    (gen_random_uuid(), v_conv_mom, v_user_id, v_two_weeks - INTERVAL '5 days'),
    (gen_random_uuid(), v_conv_mom, v_mom_id, v_two_weeks - INTERVAL '5 days');
  
  -- Messages with caring but potentially anxiety-inducing content
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_mom, v_mom_id,
    'Hi honey! Just checking in. How are you doing?',
    v_last_week, v_last_week);
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_mom, v_user_id,
    'Hey Mom! I''m good, just busy with work.',
    v_last_week + INTERVAL '1 hour', v_last_week + INTERVAL '1 hour');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_mom, v_mom_id,
    'That''s good! Are you eating properly? Getting enough sleep? You know how you get when you''re stressed.',
    v_last_week + INTERVAL '65 minutes', v_last_week + INTERVAL '65 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_mom, v_user_id,
    'Yes Mom, I''m taking care of myself. üòä',
    v_last_week + INTERVAL '70 minutes', v_last_week + INTERVAL '70 minutes');
  
  -- Multiple questions (follow-up items)
  v_msg7 := gen_random_uuid();
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (v_msg7, v_conv_mom, v_mom_id,
    'Your aunt Linda''s birthday is next month. Are you going to be able to make it to the party? It would mean a lot to her.',
    v_yesterday, v_yesterday);
  
  v_msg8 := gen_random_uuid();
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (v_msg8, v_conv_mom, v_mom_id,
    'Also, have you scheduled your dentist appointment yet? I know you''ve been putting it off.',
    v_now - INTERVAL '30 minutes', v_now - INTERVAL '30 minutes');
  
  -- Follow-up items
  INSERT INTO follow_up_items (
    id, user_id, conversation_id, message_id,
    item_type, title, description, extracted_text,
    status, priority,
    detected_at, remind_at,
    created_at, updated_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_mom, v_msg7,
    'unanswered_question', 'Aunt Linda''s birthday party',
    'Mom asking if you can attend Aunt Linda''s birthday party next month',
    'Are you going to be able to make it to the party?',
    'pending', 60,
    EXTRACT(EPOCH FROM v_yesterday)::INTEGER,
    EXTRACT(EPOCH FROM (v_now + INTERVAL '12 hours'))::INTEGER,
    EXTRACT(EPOCH FROM v_yesterday)::INTEGER,
    EXTRACT(EPOCH FROM v_yesterday)::INTEGER
  );
  
  INSERT INTO follow_up_items (
    id, user_id, conversation_id, message_id,
    item_type, title, description, extracted_text,
    status, priority,
    detected_at, remind_at,
    created_at, updated_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_mom, v_msg8,
    'action_item', 'Schedule dentist appointment',
    'Mom reminding you to schedule dentist appointment',
    'have you scheduled your dentist appointment yet',
    'pending', 65,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '30 minutes'))::INTEGER,
    EXTRACT(EPOCH FROM (v_now + INTERVAL '1 day'))::INTEGER,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '30 minutes'))::INTEGER,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '30 minutes'))::INTEGER
  );
  
  -- Relationship profile
  INSERT INTO relationship_profiles (
    id, user_id, conversation_id,
    participant_name, relationship_type, relationship_notes,
    conversation_summary, communication_style,
    safe_topics, topics_to_avoid,
    typical_response_time, total_messages,
    first_message_at, last_message_at,
    created_at, updated_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_mom,
    'Mom', 'family', 'Mother - very caring, can be a bit much sometimes',
    'Mom checks in regularly. Very caring but can ask a lot of questions at once. Means well but can trigger anxiety about adulting tasks.',
    'Caring but can be overwhelming. Asks multiple questions. Appreciates updates.',
    '["work achievements", "positive life updates", "family events"]'::jsonb,
    '["detailed health info", "relationship drama"]'::jsonb,
    7200, 7,
    v_two_weeks - INTERVAL '5 days', v_now - INTERVAL '30 minutes',
    NOW(), NOW()
  );
  
  -- ============================================================
  -- 4. CLIENT CONVERSATION - Professional, needs careful responses
  -- ============================================================
  v_conv_client := gen_random_uuid();
  
  INSERT INTO conversations (id, title, description, created_by, created_at, updated_at, is_group)
  VALUES (
    v_conv_client,
    'Marcus Williams (TechCorp)',
    'Client - Lead Developer',
    v_user_id,
    v_last_week,
    v_now - INTERVAL '15 minutes',
    false
  );
  
  INSERT INTO conversation_participants (id, conversation_id, user_id, joined_at)
  VALUES 
    (gen_random_uuid(), v_conv_client, v_user_id, v_last_week),
    (gen_random_uuid(), v_conv_client, v_client_id, v_last_week);
  
  -- Professional conversation
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_client, v_client_id,
    'Hi! Thanks for taking on this project. We''re excited to work with you.',
    v_last_week, v_last_week);
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_client, v_user_id,
    'Thank you! I''m excited too. Looking forward to seeing the requirements.',
    v_last_week + INTERVAL '30 minutes', v_last_week + INTERVAL '30 minutes');
  
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (gen_random_uuid(), v_conv_client, v_client_id,
    'I''ve sent over the initial specs. Let me know if you have any questions.',
    v_last_week + INTERVAL '2 hours', v_last_week + INTERVAL '2 hours');
  
  -- Boundary-testing request
  v_msg9 := gen_random_uuid();
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (v_msg9, v_conv_client, v_client_id,
    'Quick question - would it be possible to have the beta ready by end of this week instead of next week? Our stakeholders are getting antsy.',
    v_yesterday, v_yesterday);
  
  -- Action item with deadline
  v_msg10 := gen_random_uuid();
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES (v_msg10, v_conv_client, v_client_id,
    'Also, I''ll need you to join our team meeting next Tuesday at 2pm to present the progress so far.',
    v_now - INTERVAL '15 minutes', v_now - INTERVAL '15 minutes');
  
  -- AI Analysis
  INSERT INTO message_ai_analysis (
    message_id,
    tone, intent, urgency_level, confidence_score,
    intensity,
    rsd_triggers,
    analysis_timestamp
  ) VALUES (
    v_msg9,
    'Polite/Urgent', 'Request', 'high', 0.79,
    6,
    '[{"trigger": "stakeholders are getting antsy", "severity": "medium", "explanation": "Implies external pressure and urgency"}]'::jsonb,
    EXTRACT(EPOCH FROM v_yesterday)::INTEGER
  );
  
  -- Follow-up items
  INSERT INTO follow_up_items (
    id, user_id, conversation_id, message_id,
    item_type, title, description, extracted_text,
    status, priority,
    detected_at, due_at, remind_at,
    created_at, updated_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_client, v_msg9,
    'pending_response', 'Early beta deadline request',
    'Client asking if beta can be ready by end of this week (earlier than planned)',
    'would it be possible to have the beta ready by end of this week',
    'pending', 80,
    EXTRACT(EPOCH FROM v_yesterday)::INTEGER,
    EXTRACT(EPOCH FROM (v_now + INTERVAL '3 days'))::INTEGER,
    EXTRACT(EPOCH FROM (v_now + INTERVAL '12 hours'))::INTEGER,
    EXTRACT(EPOCH FROM v_yesterday)::INTEGER,
    EXTRACT(EPOCH FROM v_yesterday)::INTEGER
  );
  
  INSERT INTO follow_up_items (
    id, user_id, conversation_id, message_id,
    item_type, title, description, extracted_text,
    status, priority,
    detected_at, due_at, remind_at,
    created_at, updated_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_client, v_msg10,
    'action_item', 'Team meeting presentation - Tuesday 2pm',
    'Need to prepare and present project progress at client team meeting',
    'I''ll need you to join our team meeting next Tuesday at 2pm',
    'pending', 90,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '15 minutes'))::INTEGER,
    EXTRACT(EPOCH FROM (v_now + INTERVAL '5 days 14 hours'))::INTEGER,
    EXTRACT(EPOCH FROM (v_now + INTERVAL '4 days'))::INTEGER,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '15 minutes'))::INTEGER,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '15 minutes'))::INTEGER
  );
  
  -- Action item details
  INSERT INTO action_items (
    id, follow_up_item_id,
    action_type, action_target, commitment_text,
    mentioned_deadline, extracted_deadline,
    created_at
  ) VALUES (
    gen_random_uuid(),
    (SELECT id FROM follow_up_items WHERE message_id = v_msg10),
    'meet', 'Team presentation',
    'join our team meeting next Tuesday at 2pm to present the progress',
    'next Tuesday at 2pm',
    EXTRACT(EPOCH FROM (v_now + INTERVAL '5 days 14 hours'))::INTEGER,
    EXTRACT(EPOCH FROM (v_now - INTERVAL '15 minutes'))::INTEGER
  );
  
  -- Relationship profile
  INSERT INTO relationship_profiles (
    id, user_id, conversation_id,
    participant_name, relationship_type, relationship_notes,
    conversation_summary, communication_style,
    safe_topics, topics_to_avoid,
    typical_response_time, total_messages,
    first_message_at, last_message_at,
    created_at, updated_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_client,
    'Marcus Williams', 'client', 'TechCorp Lead Developer - Professional client',
    'New client project. Professional and polite. Can be pushy about deadlines due to stakeholder pressure. Important to set clear boundaries.',
    'Professional and direct. Responds during business hours. Expects timely responses to requests.',
    '["project updates", "technical discussions", "timeline clarifications"]'::jsonb,
    '["personal topics", "negative feedback about stakeholders"]'::jsonb,
    14400, 5,
    v_last_week, v_now - INTERVAL '15 minutes',
    NOW(), NOW()
  );
  
  -- ============================================================
  -- CONTEXT CACHE (for quick context loading)
  -- ============================================================
  
  INSERT INTO conversation_context_cache (
    id, user_id, conversation_id,
    last_discussed, key_points, pending_questions,
    generated_at, expires_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_boss,
    'Project timeline and progress concerns',
    '["Boss wants meeting tomorrow at 10am", "Missed standup incident resolved", "Client loved animations presentation", "Requesting time off in March", "Q1 project designs approved"]'::jsonb,
    '["Did you review the requirements doc from Monday?"]'::jsonb,
    NOW(), NOW() + INTERVAL '24 hours'
  );
  
  INSERT INTO conversation_context_cache (
    id, user_id, conversation_id,
    last_discussed, key_points, pending_questions,
    generated_at, expires_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_friend,
    'Work stress, gaming, and supportive friendship',
    '["Watching TV show together Saturday at 7pm", "Pizza from Main Street place", "Brew Haven coffee shop closed", "Gaming hyperfocus session until 3am", "Book recommendation: Divergent Mind", "Friend understands RSD and ADHD", "JWT authentication idea excited about", "Presentation went well despite rambling"]'::jsonb,
    '[]'::jsonb,
    NOW(), NOW() + INTERVAL '24 hours'
  );
  
  INSERT INTO conversation_context_cache (
    id, user_id, conversation_id,
    last_discussed, key_points, pending_questions,
    generated_at, expires_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_client,
    'Project deadlines and presentation request',
    '["Client wants beta earlier than planned", "Presentation needed Tuesday 2pm", "Stakeholders getting impatient"]'::jsonb,
    '["Can you deliver beta by end of this week?"]'::jsonb,
    NOW(), NOW() + INTERVAL '24 hours'
  );
  
  -- ============================================================
  -- SAFE TOPICS TRACKING
  -- ============================================================
  
  INSERT INTO safe_topics (
    id, user_id, conversation_id,
    topic_name, topic_keywords,
    message_count, avg_response_time, positive_tone_rate,
    is_safe, last_discussed,
    created_at, updated_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_boss,
    'design work', '["animations", "presentation", "designs"]'::jsonb,
    3, 1800, 0.85,
    true, v_last_week,
    NOW(), NOW()
  );
  
  INSERT INTO safe_topics (
    id, user_id, conversation_id,
    topic_name, topic_keywords,
    message_count, avg_response_time, positive_tone_rate,
    is_safe, last_discussed,
    created_at, updated_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_friend,
    'TV shows', '["episode", "plot twist", "watching"]'::jsonb,
    4, 300, 0.95,
    true, v_two_weeks,
    NOW(), NOW()
  );
  
  INSERT INTO safe_topics (
    id, user_id, conversation_id,
    topic_name, topic_keywords,
    message_count, avg_response_time, positive_tone_rate,
    is_safe, last_discussed,
    created_at, updated_at
  ) VALUES (
    gen_random_uuid(), v_user_id, v_conv_friend,
    'tech deep-dives', '["authentication", "JWT", "library", "hyperfocus"]'::jsonb,
    2, 600, 0.90,
    true, v_yesterday,
    NOW(), NOW()
  );
  
  RAISE NOTICE '‚úÖ Showcase data seeded successfully!';
  RAISE NOTICE 'üìä Created:';
  RAISE NOTICE '   ‚Ä¢ 4 fake user profiles (Sarah Chen, Alex Thompson, Mom, Marcus Williams)';
  RAISE NOTICE '   ‚Ä¢ 4 conversations with 70+ messages (enhanced for RAG)';
  RAISE NOTICE '   ‚Ä¢ 6 follow-up items (action items, questions)';
  RAISE NOTICE '   ‚Ä¢ 4 relationship profiles with context';
  RAISE NOTICE '   ‚Ä¢ 3 conversation context caches';
  RAISE NOTICE '   ‚Ä¢ 3 safe topic entries';
  RAISE NOTICE '';
  RAISE NOTICE 'ü§ñ RAG Feature Showcase:';
  RAISE NOTICE '   ‚Ä¢ Boss conversation: 19 messages over 2 weeks';
  RAISE NOTICE '   ‚Ä¢ Friend conversation: 30 messages with rich context';
  RAISE NOTICE '   ‚Ä¢ Multiple topics: work, gaming, coffee shops, books, mental health';
  RAISE NOTICE '   ‚Ä¢ Relationship details for context retrieval';
  RAISE NOTICE '';
  RAISE NOTICE 'üßπ To clean up: DELETE FROM profiles WHERE user_id IN (';
  RAISE NOTICE '     ''a0000000-0000-0000-0000-000000000001'',';
  RAISE NOTICE '     ''a0000000-0000-0000-0000-000000000002'',';
  RAISE NOTICE '     ''a0000000-0000-0000-0000-000000000003'',';
  RAISE NOTICE '     ''a0000000-0000-0000-0000-000000000004''';
  RAISE NOTICE '   );';
  
  -- ============================================================
  -- EXTENDED SEED DATA: More conversations for filter showcase
  -- ============================================================
  
  -- Add more unanalyzed messages to boss conversation (no tone badges)
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES 
    (gen_random_uuid(), v_conv_boss, v_boss_id, 'Do you have the latest metrics?', v_now - INTERVAL '30 minutes', v_now - INTERVAL '30 minutes'),
    (gen_random_uuid(), v_conv_boss, v_user_id, 'I''ll get them for you by EOD', v_now - INTERVAL '25 minutes', v_now - INTERVAL '25 minutes'),
    (gen_random_uuid(), v_conv_boss, v_boss_id, 'Great, thanks. Also need Q4 planning docs.', v_now - INTERVAL '20 minutes', v_now - INTERVAL '20 minutes');
  
  -- Add more unanalyzed messages to friend conversation (no tone badges)
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES
    (gen_random_uuid(), v_conv_friend, v_friend_id, 'Did you finish that book yet?', v_now - INTERVAL '15 minutes', v_now - INTERVAL '15 minutes'),
    (gen_random_uuid(), v_conv_friend, v_user_id, 'Almost done! It''s so good', v_now - INTERVAL '12 minutes', v_now - INTERVAL '12 minutes'),
    (gen_random_uuid(), v_conv_friend, v_friend_id, 'Right? The twist at the end was insane', v_now - INTERVAL '10 minutes', v_now - INTERVAL '10 minutes'),
    (gen_random_uuid(), v_conv_friend, v_user_id, 'No spoilers but YES', v_now - INTERVAL '8 minutes', v_now - INTERVAL '8 minutes');
  
  -- Add more messages to mom conversation (no tone badges)
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES
    (gen_random_uuid(), v_conv_mom, v_mom_id, 'How was your day honey?', v_now - INTERVAL '2 hours', v_now - INTERVAL '2 hours'),
    (gen_random_uuid(), v_conv_mom, v_user_id, 'Pretty good! Got a lot done', v_now - INTERVAL '1 hour 55 minutes', v_now - INTERVAL '1 hour 55 minutes'),
    (gen_random_uuid(), v_conv_mom, v_mom_id, 'That''s wonderful sweetheart', v_now - INTERVAL '1 hour 50 minutes', v_now - INTERVAL '1 hour 50 minutes'),
    (gen_random_uuid(), v_conv_mom, v_user_id, 'Thanks for asking!', v_now - INTERVAL '1 hour 45 minutes', v_now - INTERVAL '1 hour 45 minutes');
  
  -- Add more messages to client conversation (no tone badges)
  INSERT INTO messages (id, conversation_id, sender_id, body, created_at, updated_at)
  VALUES
    (gen_random_uuid(), v_conv_client, v_client_id, 'When can we schedule the design review?', v_now - INTERVAL '3 hours', v_now - INTERVAL '3 hours'),
    (gen_random_uuid(), v_conv_client, v_user_id, 'How about Thursday at 2pm?', v_now - INTERVAL '2 hours 50 minutes', v_now - INTERVAL '2 hours 50 minutes'),
    (gen_random_uuid(), v_conv_client, v_client_id, 'Perfect! I''ll send the agenda tomorrow', v_now - INTERVAL '2 hours 45 minutes', v_now - INTERVAL '2 hours 45 minutes'),
    (gen_random_uuid(), v_conv_client, v_user_id, 'Sounds good, looking forward to it', v_now - INTERVAL '2 hours 40 minutes', v_now - INTERVAL '2 hours 40 minutes');
  
  RAISE NOTICE '';
  RAISE NOTICE '‚ú® Extended showcase data added:';
  RAISE NOTICE '   ‚Ä¢ Added 16 new unanalyzed messages across all conversations';
  RAISE NOTICE '   ‚Ä¢ These demonstrate filter functionality and message discovery';
  RAISE NOTICE '';

END $$;
</file>

<file path="contracts/events/message_inserted.schema.json">
{
  "$id": "message_inserted.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Message Inserted Event",
  "description": "Event emitted when a new message is inserted into a conversation (via database trigger)",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Unique message identifier"
    },
    "conversation_id": {
      "type": "string",
      "format": "uuid",
      "description": "ID of the conversation this message belongs to"
    },
    "sender_id": {
      "type": "string",
      "format": "uuid",
      "description": "ID of the user who sent this message"
    },
    "body": {
      "type": "string",
      "description": "Message text content",
      "minLength": 1
    },
    "media_url": {
      "type": ["string", "null"],
      "format": "uri",
      "description": "Optional URL to attached media (image, video, file)"
    },
    "created_at": {
      "type": "string",
      "format": "date-time",
      "description": "ISO 8601 timestamp when the message was created"
    },
    "updated_at": {
      "type": "string",
      "format": "date-time",
      "description": "ISO 8601 timestamp of last update"
    }
  },
  "required": [
    "id",
    "conversation_id",
    "sender_id",
    "body",
    "created_at"
  ],
  "additionalProperties": false
}
</file>

<file path="contracts/events/receipt_inserted.schema.json">
{
  "$id": "receipt_inserted.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Receipt Inserted Event",
  "description": "Event emitted when a message receipt (read/delivered status) is recorded (via database trigger)",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Unique receipt identifier"
    },
    "message_id": {
      "type": "string",
      "format": "uuid",
      "description": "ID of the message this receipt is for"
    },
    "user_id": {
      "type": "string",
      "format": "uuid",
      "description": "ID of the user who received/read the message"
    },
    "status": {
      "type": "string",
      "enum": [
        "delivered",
        "read"
      ],
      "description": "Receipt status: 'delivered' = message received, 'read' = message read by user"
    },
    "at": {
      "type": "string",
      "format": "date-time",
      "description": "ISO 8601 timestamp when the receipt was recorded"
    }
  },
  "required": [
    "id",
    "message_id",
    "user_id",
    "status",
    "at"
  ],
  "additionalProperties": false
}
</file>

<file path="contracts/scripts/generate_dart.sh">
#!/usr/bin/env bash
set -e
npm --prefix contracts run validate
npm --prefix contracts run gen:dart
echo "Generated Dart client to /frontend/lib/gen/api"
</file>

<file path="frontend/android/app/build.gradle.kts">
plugins {
    id("com.android.application")
    // START: FlutterFire Configuration
    id("com.google.gms.google-services")
    // END: FlutterFire Configuration
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.messageai"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
        isCoreLibraryDesugaringEnabled = true
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_11.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.example.messageai"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
        multiDexEnabled = true
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}

dependencies {
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.1.4")
    
    // Exclude sign_in_with_apple which uses deprecated Flutter APIs
    configurations.all {
        exclude(group = "com.aboutyou.dart_packages", module = "sign_in_with_apple")
    }
}
</file>

<file path="frontend/android/settings.gradle.kts">
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.9.1" apply false
    // START: FlutterFire Configuration
    id("com.google.gms.google-services") version("4.3.15") apply false
    // END: FlutterFire Configuration
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
}

include(":app")
</file>

<file path="frontend/lib/data/drift/daos/conversation_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'conversation_dao.g.dart';

@DriftAccessor(tables: [Conversations])
class ConversationDao extends DatabaseAccessor<AppDb> with _$ConversationDaoMixin {
  ConversationDao(AppDb db) : super(db);

  /// Get all conversations ordered by last message
  Future<List<Conversation>> getAllConversations() async {
    final query = select(conversations)
      ..orderBy([(c) => OrderingTerm(expression: c.lastMessageAt, mode: OrderingMode.desc)]);
    return query.get();
  }

  /// Get conversation by ID
  Future<Conversation?> getConversationById(String id) async {
    return (select(conversations)..where((c) => c.id.equals(id)))
        .getSingleOrNull();
  }

  /// Insert or update conversation
  Future<void> upsertConversation(Conversation conversation) async {
    await into(conversations).insert(
      conversation,
      onConflict: DoUpdate((_) => conversation),
    );
  }

  /// Batch insert conversations
  Future<void> insertConversations(List<Conversation> convs) async {
    await batch((batch) {
      batch.insertAll(conversations, convs, mode: InsertMode.insertOrReplace);
    });
  }

  /// Delete conversation by ID
  Future<int> deleteConversation(String id) async {
    return (delete(conversations)..where((c) => c.id.equals(id))).go();
  }

  /// Update conversation sync status
  Future<void> markConversationAsSynced(String id) async {
    await (update(conversations)..where((c) => c.id.equals(id)))
        .write(const ConversationsCompanion(isSynced: Value(true)));
  }

  /// Get unsynced conversations
  Future<List<Conversation>> getUnsyncedConversations() async {
    return (select(conversations)..where((c) => c.isSynced.equals(false)))
        .get();
  }

  /// Update last message time
  Future<void> updateLastMessageTime(String conversationId) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    await (update(conversations)..where((c) => c.id.equals(conversationId)))
        .write(ConversationsCompanion(
          updatedAt: Value(now),
          lastMessageAt: Value(now),
        ));
  }

  /// Get recent conversations (for list)
  Future<List<Conversation>> getRecentConversations({int limit = 20}) async {
    return (select(conversations)
          ..orderBy([(c) => OrderingTerm(expression: c.lastMessageAt, mode: OrderingMode.desc)])
          ..limit(limit))
        .get();
  }

  /// Count total conversations
  Future<int> getConversationCount() async {
    final result = await select(conversations).get();
    return result.length;
  }
}
</file>

<file path="frontend/lib/data/drift/daos/receipt_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'receipt_dao.g.dart';

@DriftAccessor(tables: [Receipts, Messages])
class ReceiptDao extends DatabaseAccessor<AppDb> with _$ReceiptDaoMixin {
  ReceiptDao(AppDb db) : super(db);

  /// Get all receipts for a message
  Future<List<Receipt>> getReceiptsByMessage(String messageId) async {
    return (select(receipts)
          ..where((r) => r.messageId.equals(messageId)))
        .get();
  }

  /// Get receipt by ID
  Future<Receipt?> getReceiptById(String id) async {
    return (select(receipts)..where((r) => r.id.equals(id)))
        .getSingleOrNull();
  }

  /// Get receipt by message ID and user ID
  Future<Receipt?> getReceipt(String messageId, String userId) async {
    return (select(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.userId.equals(userId)))
        .getSingleOrNull();
  }

  /// Add receipt
  Future<void> addReceipt(Receipt receipt) async {
    await into(receipts).insert(receipt);
  }

  /// Batch add receipts
  Future<void> addReceipts(List<Receipt> recs) async {
    await batch((batch) {
      batch.insertAll(receipts, recs, mode: InsertMode.insertOrReplace);
    });
  }

  /// Update receipt status
  Future<void> updateReceiptStatus(String messageId, String userId, String status) async {
    await (update(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.userId.equals(userId)))
        .write(ReceiptsCompanion(
          status: Value(status),
          updatedAt: Value(DateTime.now().millisecondsSinceEpoch ~/ 1000),
        ));
  }

  /// Mark receipt as synced
  Future<void> markReceiptAsSynced(String id) async {
    await (update(receipts)..where((r) => r.id.equals(id)))
        .write(const ReceiptsCompanion(isSynced: Value(true)));
  }

  /// Mark multiple receipts as synced
  Future<void> markReceiptsAsSynced(List<String> ids) async {
    await batch((batch) {
      for (final id in ids) {
        batch.update(receipts, const ReceiptsCompanion(isSynced: Value(true)),
            where: (r) => r.id.equals(id));
      }
    });
  }

  /// Delete receipt
  Future<int> deleteReceipt(String id) async {
    return (delete(receipts)..where((r) => r.id.equals(id))).go();
  }

  /// Get unsynced receipts
  Future<List<Receipt>> getUnsyncedReceipts() async {
    return (select(receipts)..where((r) => r.isSynced.equals(false)))
        .get();
  }

  /// Get read count for a message
  Future<int> getReadCount(String messageId) async {
    final countResult = await (select(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.status.equals('read')))
        .get();
    return countResult.length;
  }

  /// Get delivered count for a message
  Future<int> getDeliveredCount(String messageId) async {
    final countResult = await (select(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.status.equals('delivered')))
        .get();
    return countResult.length;
  }

  /// Get all receipts for messages in conversation
  Future<List<Receipt>> getReceiptsByConversation(String conversationId) async {
    return (select(receipts).join([
      innerJoin(messages, messages.id.equalsExp(receipts.messageId)),
    ])
      ..where(messages.conversationId.equals(conversationId)))
        .map((row) => row.readTable(receipts))
        .get();
  }

  /// Check if message is read by all participants
  Future<bool> isReadByAll(String messageId, int expectedCount) async {
    final readCount = await getReadCount(messageId);
    return readCount >= expectedCount;
  }

  /// Get unsynced receipt count
  Future<int> getUnsyncedReceiptCount() async {
    final countResult = await (select(receipts)
          ..where((r) => r.isSynced.equals(false)))
        .get();
    return countResult.length;
  }
}
</file>

<file path="frontend/lib/data/drift/entities/conversation.drift">
CREATE TABLE conversations (
  id TEXT PRIMARY KEY NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  is_group BOOLEAN NOT NULL DEFAULT 0,
  last_message_at INTEGER,
  is_synced BOOLEAN NOT NULL DEFAULT 0
) AS Conversation;

CREATE TABLE messages (
  id TEXT PRIMARY KEY NOT NULL,
  conversation_id TEXT NOT NULL,
  sender_id TEXT NOT NULL,
  body TEXT NOT NULL,
  media_url TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  is_synced BOOLEAN NOT NULL DEFAULT 0,
  FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
) AS Message;

CREATE TABLE participants (
  id TEXT PRIMARY KEY NOT NULL,
  conversation_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  joined_at INTEGER NOT NULL,
  is_admin BOOLEAN NOT NULL DEFAULT 0,
  is_synced BOOLEAN NOT NULL DEFAULT 0,
  FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE,
  UNIQUE(conversation_id, user_id)
) AS Participant;

CREATE TABLE receipts (
  id TEXT PRIMARY KEY NOT NULL,
  message_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  status TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  is_synced BOOLEAN NOT NULL DEFAULT 0,
  FOREIGN KEY(message_id) REFERENCES messages(id) ON DELETE CASCADE,
  UNIQUE(message_id, user_id)
) AS Receipt;

CREATE TABLE pending_outbox (
  id TEXT PRIMARY KEY NOT NULL,
  operation TEXT NOT NULL,
  payload TEXT NOT NULL,
  conversation_id TEXT,
  created_at INTEGER NOT NULL,
  retry_count INTEGER NOT NULL DEFAULT 0,
  last_error TEXT,
  FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
) AS PendingOutboxItem;
</file>

<file path="frontend/lib/features/conversations/widgets/relationship_summary_sheet.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/models/relationship_profile.dart';
import 'package:messageai/models/safe_topic.dart';
import 'package:messageai/services/relationship_service.dart';
import 'package:messageai/state/ai_providers.dart';

/// Bottom sheet showing relationship profile
class RelationshipSummarySheet extends ConsumerStatefulWidget {
  final String conversationId;

  const RelationshipSummarySheet({
    Key? key,
    required this.conversationId,
  }) : super(key: key);

  @override
  ConsumerState<RelationshipSummarySheet> createState() =>
      _RelationshipSummarySheetState();
}

class _RelationshipSummarySheetState
    extends ConsumerState<RelationshipSummarySheet> {
  final relationshipService = RelationshipService();

  RelationshipProfile? profile;
  List<SafeTopic>? safeTopics;
  bool isLoading = true;
  bool isGenerating = false;

  @override
  void initState() {
    super.initState();
    _loadProfile();
  }

  Future<void> _loadProfile() async {
    setState(() => isLoading = true);

    try {
      final results = await Future.wait([
        relationshipService.getProfile(widget.conversationId),
        relationshipService.getSafeTopics(widget.conversationId),
      ]);

      setState(() {
        profile = results[0] as RelationshipProfile?;
        safeTopics = results[1] as List<SafeTopic>?;
        isLoading = false;
      });
    } catch (e) {
      setState(() => isLoading = false);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error loading profile: $e')),
        );
      }
    }
  }

  /// Generate relationship summary using AI
  Future<void> _generateSummary({bool forceRegenerate = false}) async {
    setState(() => isGenerating = true);

    try {
      // Use provider to generate summary
      final newProfile = await ref.read(
        generateRelationshipSummaryProvider(widget.conversationId).future,
      );

      if (mounted) {
        setState(() {
          profile = newProfile;
          isGenerating = false;
        });

        // Reload safe topics
        final topics = await relationshipService.getSafeTopics(widget.conversationId);
        setState(() {
          safeTopics = topics;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('‚ú® Relationship summary generated!'),
            duration: Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        setState(() => isGenerating = false);

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to generate summary: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
      ),
      child: isLoading
          ? const Center(child: CircularProgressIndicator())
          : profile == null
              ? Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.person_outline,
                        size: 64,
                        color: Colors.grey[400],
                      ),
                      const SizedBox(height: 16),
                      const Text(
                        'No relationship profile yet',
                        style: TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'Generate an AI profile to understand\nthis relationship better',
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          fontSize: 14,
                          color: Colors.grey[600],
                        ),
                      ),
                      const SizedBox(height: 24),
                      ElevatedButton.icon(
                        onPressed: isGenerating ? null : _generateSummary,
                        icon: isGenerating
                            ? const SizedBox(
                                width: 16,
                                height: 16,
                                child: CircularProgressIndicator(strokeWidth: 2),
                              )
                            : const Icon(Icons.auto_awesome),
                        label: Text(
                          isGenerating ? 'Generating...' : 'Generate Profile',
                        ),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.purple,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(
                            horizontal: 24,
                            vertical: 12,
                          ),
                        ),
                      ),
                    ],
                  ),
                )
              : SingleChildScrollView(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // Header
                      Row(
                        children: [
                          Text(
                            profile!.getRelationshipEmoji(),
                            style: const TextStyle(fontSize: 32),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  profile!.participantName,
                                  style: const TextStyle(
                                    fontSize: 20,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                                if (profile!.relationshipType != null)
                                  Text(
                                    profile!.relationshipType!,
                                    style: TextStyle(
                                      fontSize: 14,
                                      color: Colors.grey,
                                    ),
                                  ),
                              ],
                            ),
                          ),
                          // ‚úÖ PHASE 3: Refresh button
                          IconButton(
                            icon: isGenerating
                                ? const SizedBox(
                                    width: 20,
                                    height: 20,
                                    child: CircularProgressIndicator(strokeWidth: 2),
                                  )
                                : const Icon(Icons.refresh),
                            onPressed: isGenerating ? null : () => _generateSummary(forceRegenerate: true),
                            tooltip: 'Refresh profile',
                          ),
                          IconButton(
                            icon: const Icon(Icons.close),
                            onPressed: () => Navigator.pop(context),
                          ),
                        ],
                      ),
                      const SizedBox(height: 16),

                      // Summary
                      if (profile!.conversationSummary != null) ...[
                        _buildSection('About This Relationship', [
                          Text(
                            profile!.conversationSummary!,
                            style: const TextStyle(fontSize: 14),
                          ),
                        ]),
                        const SizedBox(height: 16),
                      ],

                      // Communication style
                      if (profile!.communicationStyle != null) ...[
                        _buildSection('Communication Style', [
                          Text(
                            profile!.communicationStyle!,
                            style: const TextStyle(fontSize: 14),
                          ),
                        ]),
                        const SizedBox(height: 16),
                      ],

                      // Response time
                      if (profile!.typicalResponseTime != null) ...[
                        _buildSection('Typical Response Time', [
                          Row(
                            children: [
                              const Icon(Icons.schedule, size: 20),
                              const SizedBox(width: 8),
                              Text(
                                profile!.formatResponseTime(),
                                style: const TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ],
                          ),
                        ]),
                        const SizedBox(height: 16),
                      ],

                      // Safe topics
                      if (profile!.safeTopics.isNotEmpty) ...[
                        _buildSection('Safe Topics', [
                          Wrap(
                            spacing: 8,
                            runSpacing: 8,
                            children: profile!.safeTopics.map((topic) {
                              return Chip(
                                label: Text(
                                  topic,
                                  style: const TextStyle(fontSize: 12),
                                ),
                                backgroundColor: Colors.green.withOpacity(0.1),
                                side: BorderSide(
                                  color: Colors.green.withOpacity(0.3),
                                ),
                              );
                            }).toList(),
                          ),
                        ]),
                        const SizedBox(height: 16),
                      ],

                      // Topics to avoid
                      if (profile!.topicsToAvoid.isNotEmpty) ...[
                        _buildSection('Topics to Avoid', [
                          Wrap(
                            spacing: 8,
                            runSpacing: 8,
                            children: profile!.topicsToAvoid.map((topic) {
                              return Chip(
                                label: Text(
                                  topic,
                                  style: const TextStyle(fontSize: 12),
                                ),
                                backgroundColor: Colors.red.withOpacity(0.1),
                                side: BorderSide(
                                  color: Colors.red.withOpacity(0.3),
                                ),
                              );
                            }).toList(),
                          ),
                        ]),
                        const SizedBox(height: 16),
                      ],

                      // Detailed safe topics
                      if (safeTopics != null && safeTopics!.isNotEmpty) ...[
                        _buildSection('Topic Engagement', [
                          ...safeTopics!.map((topic) => Padding(
                                padding: const EdgeInsets.only(bottom: 8),
                                child: Row(
                                  children: [
                                    Container(
                                      width: 8,
                                      height: 8,
                                      decoration: BoxDecoration(
                                        color: topic.getTopicColor(),
                                        shape: BoxShape.circle,
                                      ),
                                    ),
                                    const SizedBox(width: 8),
                                    Expanded(
                                      child: Text(
                                        topic.topicName,
                                        style: const TextStyle(fontSize: 13),
                                      ),
                                    ),
                                    Text(
                                      topic.getEngagementLabel(),
                                      style: TextStyle(
                                        fontSize: 11,
                                        color: topic.getTopicColor(),
                                        fontWeight: FontWeight.w500,
                                      ),
                                    ),
                                  ],
                                ),
                              )),
                        ]),
                      ],

                      // Stats
                      const SizedBox(height: 16),
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.grey.withOpacity(0.1),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.spaceAround,
                          children: [
                            _buildStat(
                              '${profile!.totalMessages}',
                              'messages',
                            ),
                            if (profile!.firstMessageAt != null)
                              _buildStat(
                                _getTimeSince(profile!.firstMessageAt!),
                                'talking',
                              ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
    );
  }

  Widget _buildSection(String title, List<Widget> children) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.bold,
            color: Colors.grey,
          ),
        ),
        const SizedBox(height: 8),
        ...children,
      ],
    );
  }

  Widget _buildStat(String value, String label) {
    return Column(
      children: [
        Text(
          value,
          style: const TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
        ),
        Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: Colors.grey,
          ),
        ),
      ],
    );
  }

  String _getTimeSince(int timestamp) {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final diff = now - timestamp;

    final days = diff ~/ 86400;
    if (days < 30) return '${days}d';

    final months = days ~/ 30;
    if (months < 12) return '${months}mo';

    final years = months ~/ 12;
    return '${years}yr';
  }
}

/// Show relationship summary sheet
void showRelationshipSummary(BuildContext context, String conversationId) {
  showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    builder: (context) => SizedBox(
      height: MediaQuery.of(context).size.height * 0.8,
      child: RelationshipSummarySheet(conversationId: conversationId),
    ),
  );
}
</file>

<file path="frontend/lib/features/messages/widgets/draft_feedback_panel.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/draft_analysis.dart';
import 'package:messageai/features/messages/widgets/template_picker.dart';
import 'package:messageai/features/messages/widgets/message_formatter_panel.dart';

/// Collapsible feedback panel for draft message analysis
/// Shows confidence score prominently with progressive disclosure
class DraftFeedbackPanel extends StatefulWidget {
  final DraftAnalysis? analysis;
  final bool isLoading;
  final String? draftMessage; // NEW: For formatting long messages
  final Function(String)? onApplySuggestion;
  final Function(String)? onTemplateSelected; // NEW: For templates
  final VoidCallback? onClose;

  const DraftFeedbackPanel({
    Key? key,
    required this.analysis,
    this.isLoading = false,
    this.draftMessage,
    this.onApplySuggestion,
    this.onTemplateSelected,
    this.onClose,
  }) : super(key: key);

  @override
  State<DraftFeedbackPanel> createState() => _DraftFeedbackPanelState();
}

class _DraftFeedbackPanelState extends State<DraftFeedbackPanel> {
  bool _isExpanded = true;
  bool _strengthsExpanded = true; // Always show strengths
  bool _warningsExpanded = true; // Always show warnings
  bool _suggestionsExpanded = false;
  bool _situationExpanded = false;
  bool _templatesExpanded = false;
  bool _formattingExpanded = false;
  bool _reasoningExpanded = false;

  @override
  Widget build(BuildContext context) {
    if (widget.isLoading) {
      return _buildLoadingState(context);
    }

    if (widget.analysis == null) {
      return const SizedBox.shrink();
    }

    if (!_isExpanded) {
      return _buildCollapsedState(context, widget.analysis!);
    }

    return _buildExpandedState(context, widget.analysis!);
  }

  Widget _buildLoadingState(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: (isDark ? AppTheme.darkGray200 : AppTheme.gray100),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          const SizedBox(
            width: 20,
            height: 20,
            child: CircularProgressIndicator(strokeWidth: 2),
          ),
          const SizedBox(width: AppTheme.spacingS),
          Text(
            'Checking message...',
            style: theme.textTheme.bodyMedium?.copyWith(
              fontWeight: AppTheme.fontWeightMedium,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCollapsedState(BuildContext context, DraftAnalysis analysis) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final confidenceColor = analysis.getConfidenceColor();

    return GestureDetector(
      onTap: () => setState(() => _isExpanded = true),
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: AppTheme.spacingM,
          vertical: AppTheme.spacingS,
        ),
        decoration: BoxDecoration(
          color: confidenceColor.withOpacity(0.1),
          borderRadius: BorderRadius.circular(AppTheme.radiusM),
          border: Border.all(color: confidenceColor.withOpacity(0.3)),
        ),
        child: Row(
          children: [
            Icon(
              analysis.getAppropriatenessIcon(),
              color: confidenceColor,
              size: 20,
            ),
            const SizedBox(width: AppTheme.spacingS),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    '${analysis.confidenceScore}% Confidence',
                    style: theme.textTheme.titleSmall?.copyWith(
                      color: confidenceColor,
                      fontWeight: AppTheme.fontWeightBold,
                    ),
                  ),
                  Text(
                    analysis.getStatusMessage(),
                    style: theme.textTheme.bodySmall,
                  ),
                ],
              ),
            ),
            Icon(
              Icons.expand_more,
              color: isDark ? AppTheme.gray500 : AppTheme.gray600,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildExpandedState(BuildContext context, DraftAnalysis analysis) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final confidenceColor = analysis.getConfidenceColor();

    return Container(
      constraints: const BoxConstraints(maxHeight: 600),
      decoration: BoxDecoration(
        color: confidenceColor.withOpacity(0.1),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(color: confidenceColor.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          // Header with title and controls
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingM),
            decoration: BoxDecoration(
              border: Border(
                bottom: BorderSide(
                  color: confidenceColor.withOpacity(0.3),
                  width: 1,
                ),
              ),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Icon(
                      Icons.analytics_outlined,
                      color: confidenceColor,
                      size: 20,
                    ),
                    const SizedBox(width: AppTheme.spacingXS),
                    Text(
                      'Draft Analysis',
                      style: theme.textTheme.titleSmall?.copyWith(
                        fontWeight: AppTheme.fontWeightBold,
                        color: isDark ? AppTheme.gray200 : AppTheme.gray800,
                      ),
                    ),
                    const Spacer(),
                    IconButton(
                      icon: const Icon(Icons.expand_less, size: 20),
                      onPressed: () => setState(() => _isExpanded = false),
                      tooltip: 'Minimize',
                      padding: EdgeInsets.zero,
                      constraints: const BoxConstraints(),
                    ),
                    if (widget.onClose != null) ...[
                      const SizedBox(width: AppTheme.spacingXS),
                      IconButton(
                        icon: const Icon(Icons.close, size: 20),
                        onPressed: widget.onClose,
                        tooltip: 'Close',
                        padding: EdgeInsets.zero,
                        constraints: const BoxConstraints(),
                      ),
                    ],
                  ],
                ),
                const SizedBox(height: AppTheme.spacingS),
                Row(
                  children: [
                    Icon(
                      analysis.getAppropriatenessIcon(),
                      color: confidenceColor,
                      size: 20,
                    ),
                    const SizedBox(width: AppTheme.spacingXS),
                    Text(
                      '${analysis.confidenceScore}% Confidence',
                      style: theme.textTheme.titleMedium?.copyWith(
                        color: confidenceColor,
                        fontWeight: AppTheme.fontWeightBold,
                      ),
                    ),
                    const SizedBox(width: AppTheme.spacingS),
                    Expanded(
                      child: Text(
                        '${analysis.tone} ‚Ä¢ ${analysis.appropriateness.displayName}',
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),

          // Scrollable content with invisible scrollbar
          Flexible(
            child: Scrollbar(
              thumbVisibility: false,
              child: SingleChildScrollView(
                padding: const EdgeInsets.all(AppTheme.spacingM),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    // Strengths (collapsible)
                    if (analysis.strengths.isNotEmpty) ...[
                      _buildCollapsibleSection(
                        context,
                        '‚úÖ Strengths',
                        analysis.strengths,
                        Colors.green,
                        _strengthsExpanded,
                        (expanded) => setState(() => _strengthsExpanded = expanded),
                        showApplyButton: false,
                      ),
                      const SizedBox(height: AppTheme.spacingS),
                    ],

                    // Warnings (collapsible)
                    if (analysis.warnings.isNotEmpty) ...[
                      _buildCollapsibleSection(
                        context,
                        '‚ö†Ô∏è Watch Out',
                        analysis.warnings,
                        Colors.orange,
                        _warningsExpanded,
                        (expanded) => setState(() => _warningsExpanded = expanded),
                        showApplyButton: false,
                      ),
                      const SizedBox(height: AppTheme.spacingS),
                    ],

                    // Suggestions (collapsible)
                    if (analysis.suggestions.isNotEmpty) ...[
                      _buildCollapsibleSection(
                        context,
                        'üí° Suggestions',
                        analysis.suggestions,
                        Colors.blue,
                        _suggestionsExpanded,
                        (expanded) => setState(() => _suggestionsExpanded = expanded),
                        showApplyButton: widget.onApplySuggestion != null,
                      ),
                      const SizedBox(height: AppTheme.spacingS),
                    ],

                    // Situation Detection (collapsible)
                    if (analysis.situationDetection != null) ...[
                      _buildCollapsibleSituationSection(context, analysis),
                      const SizedBox(height: AppTheme.spacingS),
                    ],

                    // Suggested Templates (collapsible)
                    if (analysis.suggestedTemplates != null &&
                        analysis.suggestedTemplates!.isNotEmpty) ...[
                      _buildCollapsibleTemplatesSection(context, analysis),
                      const SizedBox(height: AppTheme.spacingS),
                    ],

                    // Message Formatting (collapsible)
                    if (widget.draftMessage != null && widget.draftMessage!.length > 500) ...[
                      _buildCollapsibleFormattingSection(context),
                      const SizedBox(height: AppTheme.spacingS),
                    ],

                    // Reasoning (collapsible)
                    if (analysis.reasoning != null && analysis.reasoning!.isNotEmpty) ...[
                      _buildCollapsibleReasoningSection(context, analysis),
                    ],
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  // Collapsible section for list items
  Widget _buildCollapsibleSection(
    BuildContext context,
    String title,
    List<String> items,
    Color color,
    bool isExpanded,
    Function(bool) onExpansionChanged, {
    required bool showApplyButton,
  }) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      decoration: BoxDecoration(
        color: color.withOpacity(0.05),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(color: color.withOpacity(0.2)),
      ),
      child: Theme(
        data: Theme.of(context).copyWith(dividerColor: Colors.transparent),
        child: ExpansionTile(
          tilePadding: const EdgeInsets.symmetric(
            horizontal: AppTheme.spacingS,
            vertical: AppTheme.spacingXXS,
          ),
          childrenPadding: const EdgeInsets.only(
            left: AppTheme.spacingS,
            right: AppTheme.spacingS,
            bottom: AppTheme.spacingS,
          ),
          initiallyExpanded: isExpanded,
          onExpansionChanged: onExpansionChanged,
          leading: Icon(Icons.check_circle_outline, size: 16, color: color),
          title: Row(
            children: [
              Expanded(
                child: Text(
                  title,
                  style: theme.textTheme.labelMedium?.copyWith(
                    color: isDark ? AppTheme.gray300 : AppTheme.gray800,
                    fontWeight: AppTheme.fontWeightBold,
                  ),
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppTheme.spacingXS,
                  vertical: 2,
                ),
                decoration: BoxDecoration(
                  color: color.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(AppTheme.radiusXS),
                ),
                child: Text(
                  '${items.length}',
                  style: theme.textTheme.labelSmall?.copyWith(
                    color: color,
                    fontWeight: AppTheme.fontWeightBold,
                  ),
                ),
              ),
            ],
          ),
          children: items.map((item) => Padding(
            padding: const EdgeInsets.only(top: AppTheme.spacingXXS),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: const EdgeInsets.only(top: 2),
                  child: Icon(
                    Icons.circle,
                    size: 6,
                    color: color,
                  ),
                ),
                const SizedBox(width: AppTheme.spacingXS),
                Expanded(
                  child: Text(
                    item,
                    style: theme.textTheme.bodySmall,
                  ),
                ),
                if (showApplyButton && widget.onApplySuggestion != null) ...[
                  const SizedBox(width: AppTheme.spacingXS),
                  TextButton(
                    onPressed: () => widget.onApplySuggestion!(item),
                    style: TextButton.styleFrom(
                      padding: const EdgeInsets.symmetric(
                        horizontal: AppTheme.spacingS,
                        vertical: AppTheme.spacingXXS,
                      ),
                      minimumSize: Size.zero,
                      tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    ),
                    child: Text(
                      'Apply',
                      style: TextStyle(
                        fontSize: AppTheme.fontSizeXS,
                        color: color,
                      ),
                    ),
                  ),
                ],
              ],
            ),
          )).toList(),
        ),
      ),
    );
  }

  // Collapsible situation detection section
  Widget _buildCollapsibleSituationSection(BuildContext context, DraftAnalysis analysis) {
    final detection = analysis.situationDetection!;
    final color = detection.situationType.getColor();
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      decoration: BoxDecoration(
        color: color.withOpacity(0.05),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(color: color.withOpacity(0.2)),
      ),
      child: Theme(
        data: Theme.of(context).copyWith(dividerColor: Colors.transparent),
        child: ExpansionTile(
          tilePadding: const EdgeInsets.symmetric(
            horizontal: AppTheme.spacingS,
            vertical: AppTheme.spacingXXS,
          ),
          childrenPadding: const EdgeInsets.only(
            left: AppTheme.spacingS,
            right: AppTheme.spacingS,
            bottom: AppTheme.spacingS,
          ),
          initiallyExpanded: _situationExpanded,
          onExpansionChanged: (expanded) => setState(() => _situationExpanded = expanded),
          leading: Icon(detection.situationType.icon, size: 16, color: color),
          title: Text(
            '${detection.situationType.displayName} Detected',
            style: theme.textTheme.labelMedium?.copyWith(
              color: isDark ? AppTheme.gray300 : AppTheme.gray800,
              fontWeight: AppTheme.fontWeightBold,
            ),
          ),
          trailing: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppTheme.spacingXS,
                  vertical: 2,
                ),
                decoration: BoxDecoration(
                  color: color.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(AppTheme.radiusXS),
                ),
                child: Text(
                  '${(detection.confidence * 100).toInt()}%',
                  style: theme.textTheme.labelSmall?.copyWith(
                    color: color,
                    fontWeight: AppTheme.fontWeightBold,
                  ),
                ),
              ),
              Icon(
                _situationExpanded ? Icons.expand_less : Icons.expand_more,
                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
              ),
            ],
          ),
          children: [
            Text(
              detection.reasoning,
              style: theme.textTheme.bodySmall?.copyWith(
                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
              ),
            ),
          ],
        ),
      ),
    );
  }

  // Collapsible templates section
  Widget _buildCollapsibleTemplatesSection(BuildContext context, DraftAnalysis analysis) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final color = Colors.blue;
    final templates = analysis.suggestedTemplates!;

    return Container(
      decoration: BoxDecoration(
        color: color.withOpacity(0.05),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(color: color.withOpacity(0.2)),
      ),
      child: Theme(
        data: Theme.of(context).copyWith(dividerColor: Colors.transparent),
        child: ExpansionTile(
          tilePadding: const EdgeInsets.symmetric(
            horizontal: AppTheme.spacingS,
            vertical: AppTheme.spacingXXS,
          ),
          childrenPadding: const EdgeInsets.only(
            left: AppTheme.spacingS,
            right: AppTheme.spacingS,
            bottom: AppTheme.spacingS,
          ),
          initiallyExpanded: _templatesExpanded,
          onExpansionChanged: (expanded) => setState(() => _templatesExpanded = expanded),
          leading: const Icon(Icons.lightbulb_outline, size: 16, color: Colors.blue),
          title: Row(
            children: [
              Expanded(
                child: Text(
                  'Response Templates',
                  style: theme.textTheme.labelMedium?.copyWith(
                    color: isDark ? AppTheme.gray300 : AppTheme.gray800,
                    fontWeight: AppTheme.fontWeightBold,
                  ),
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppTheme.spacingXS,
                  vertical: 2,
                ),
                decoration: BoxDecoration(
                  color: color.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(AppTheme.radiusXS),
                ),
                child: Text(
                  '${templates.length}',
                  style: theme.textTheme.labelSmall?.copyWith(
                    color: color,
                    fontWeight: AppTheme.fontWeightBold,
                  ),
                ),
              ),
            ],
          ),
          children: [
            ...templates.take(3).map((template) => Padding(
              padding: const EdgeInsets.only(top: AppTheme.spacingXXS),
              child: InkWell(
                onTap: () {
                  if (widget.onTemplateSelected != null) {
                    widget.onTemplateSelected!(template.template);
                  }
                },
                child: Container(
                  padding: const EdgeInsets.all(AppTheme.spacingXS),
                  decoration: BoxDecoration(
                    color: isDark ? AppTheme.darkGray300 : AppTheme.gray100,
                    borderRadius: BorderRadius.circular(AppTheme.radiusXS),
                  ),
                  child: Row(
                    children: [
                      Icon(
                        Icons.check_circle_outline,
                        size: 14,
                        color: color,
                      ),
                      const SizedBox(width: AppTheme.spacingXS),
                      Expanded(
                        child: Text(
                          template.name,
                          style: theme.textTheme.bodySmall?.copyWith(
                            fontWeight: AppTheme.fontWeightMedium,
                          ),
                        ),
                      ),
                      Icon(
                        Icons.arrow_forward,
                        size: 14,
                        color: color,
                      ),
                    ],
                  ),
                ),
              ),
            )),
            const SizedBox(height: AppTheme.spacingS),
            SizedBox(
              width: double.infinity,
              child: OutlinedButton(
                onPressed: () {
                  showTemplatePicker(
                    context,
                    analysis.situationDetection?.situationType,
                    (selectedText) {
                      if (widget.onTemplateSelected != null) {
                        widget.onTemplateSelected!(selectedText);
                      }
                    },
                  );
                },
                style: OutlinedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(
                    vertical: AppTheme.spacingXS,
                  ),
                  side: BorderSide(color: color),
                ),
                child: const Text(
                  'Browse All Templates',
                  style: TextStyle(fontSize: AppTheme.fontSizeXS),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  // Collapsible formatting section
  Widget _buildCollapsibleFormattingSection(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final color = Colors.orange;

    return Container(
      decoration: BoxDecoration(
        color: color.withOpacity(0.05),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(color: color.withOpacity(0.2)),
      ),
      child: Theme(
        data: Theme.of(context).copyWith(dividerColor: Colors.transparent),
        child: ExpansionTile(
          tilePadding: const EdgeInsets.symmetric(
            horizontal: AppTheme.spacingS,
            vertical: AppTheme.spacingXXS,
          ),
          childrenPadding: const EdgeInsets.only(
            left: AppTheme.spacingS,
            right: AppTheme.spacingS,
            bottom: AppTheme.spacingS,
          ),
          initiallyExpanded: _formattingExpanded,
          onExpansionChanged: (expanded) => setState(() => _formattingExpanded = expanded),
          leading: const Icon(Icons.format_list_bulleted, size: 16, color: Colors.orange),
          title: Text(
            'Message Formatting',
            style: theme.textTheme.labelMedium?.copyWith(
              color: isDark ? AppTheme.gray300 : AppTheme.gray800,
              fontWeight: AppTheme.fontWeightBold,
            ),
          ),
          children: [
            Text(
              'This message is quite long (${widget.draftMessage!.length} characters). Consider breaking it into sections or using bullet points to make it easier to read.',
              style: theme.textTheme.bodySmall?.copyWith(
                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
              ),
            ),
            const SizedBox(height: AppTheme.spacingS),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: () {
                  showDialog(
                    context: context,
                    builder: (context) => Dialog(
                      child: MessageFormatterPanel(
                        originalMessage: widget.draftMessage!,
                        onFormatted: (formatted) {
                          if (widget.onTemplateSelected != null) {
                            widget.onTemplateSelected!(formatted);
                          }
                          Navigator.pop(context);
                        },
                      ),
                    ),
                  );
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: color,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(
                    vertical: AppTheme.spacingS,
                  ),
                ),
                icon: const Icon(Icons.auto_fix_high, size: 16),
                label: const Text(
                  'Auto-Format Message',
                  style: TextStyle(fontSize: AppTheme.fontSizeS),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  // NEW: Collapsible reasoning section
  Widget _buildCollapsibleReasoningSection(BuildContext context, DraftAnalysis analysis) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      decoration: BoxDecoration(
        color: (isDark ? AppTheme.darkGray300 : AppTheme.gray100),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(
          color: isDark ? AppTheme.darkGray400 : AppTheme.gray300,
        ),
      ),
      child: Theme(
        data: Theme.of(context).copyWith(dividerColor: Colors.transparent),
        child: ExpansionTile(
          tilePadding: const EdgeInsets.symmetric(
            horizontal: AppTheme.spacingS,
            vertical: AppTheme.spacingXXS,
          ),
          childrenPadding: const EdgeInsets.only(
            left: AppTheme.spacingS,
            right: AppTheme.spacingS,
            bottom: AppTheme.spacingS,
          ),
          initiallyExpanded: _reasoningExpanded,
          onExpansionChanged: (expanded) => setState(() => _reasoningExpanded = expanded),
          leading: Icon(
            Icons.info_outline,
            size: 16,
            color: isDark ? AppTheme.gray500 : AppTheme.gray600,
          ),
          title: Text(
            'Why This Score?',
            style: theme.textTheme.labelMedium?.copyWith(
              color: isDark ? AppTheme.gray400 : AppTheme.gray700,
              fontWeight: AppTheme.fontWeightMedium,
            ),
          ),
          children: [
            Text(
              analysis.reasoning!,
              style: theme.textTheme.bodySmall?.copyWith(
                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
              ),
            ),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/message_list_panel.dart">
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/features/messages/widgets/draft_feedback_panel.dart';
import 'package:messageai/features/messages/widgets/message_bubble.dart';
import 'package:messageai/features/messages/widgets/tone_detail_sheet.dart';
import 'package:messageai/state/ai_providers.dart';
import 'package:messageai/services/ai_analysis_service.dart';
import 'package:messageai/widgets/user_avatar.dart';

/// Panel containing the message list and compose bar
/// This widget slides up and down over the AI insights background
class MessageListPanel extends ConsumerWidget {
  final List<Message>? messages;
  final String? currentUserId;
  final Map<String, List<Receipt>>? receiptsCache;
  final Set<String>? typingUsers;
  final Set<String>? onlineUsers;
  final TextEditingController messageController;
  final bool isSending;
  final bool isUploadingImage;
  final XFile? selectedImage;
  final VoidCallback onSendMessage;
  final VoidCallback onPickImage;
  final VoidCallback onClearImage;
  final ScrollController? scrollController; // For DraggableScrollableSheet
  final bool showComposeBar; // Whether to show the compose bar
  final bool _composeBarOnly; // Internal flag for compose bar only mode

  const MessageListPanel({
    Key? key,
    required this.messages,
    required this.currentUserId,
    required this.receiptsCache,
    required this.typingUsers,
    required this.onlineUsers,
    required this.messageController,
    required this.isSending,
    required this.isUploadingImage,
    required this.selectedImage,
    required this.onSendMessage,
    required this.onPickImage,
    required this.onClearImage,
    this.scrollController,
    this.showComposeBar = true,
  })  : _composeBarOnly = false,
        super(key: key);

  // Constructor for compose bar only (pinned at bottom)
  const MessageListPanel.composeBarOnly({
    Key? key,
    required this.messageController,
    required this.isSending,
    required this.isUploadingImage,
    required this.selectedImage,
    required this.onSendMessage,
    required this.onPickImage,
    required this.onClearImage,
  })  : messages = null,
        currentUserId = null,
        receiptsCache = null,
        typingUsers = null,
        onlineUsers = null,
        scrollController = null,
        showComposeBar = true,
        _composeBarOnly = true,
        super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    // If compose bar only mode, just return the compose bar
    if (_composeBarOnly) {
      return _buildComposeBar(context, ref, isDark);
    }
    
    // Otherwise, show message list and optionally compose bar
    return Column(
      children: [
        // Message list
        Expanded(
          child: messages == null || messages!.isEmpty
              ? Center(
                  child: Text(
                    'No messages yet. Start the conversation!',
                    style: theme.textTheme.bodyMedium,
                  ),
                )
              : ListView.builder(
                  controller: scrollController, // Use provided scroll controller for dragging
                  reverse: true,
                  padding: const EdgeInsets.symmetric(
                    vertical: AppTheme.spacingS,
                    horizontal: AppTheme.spacingXS,
                  ),
                  itemCount: messages!.length + ((typingUsers?.isNotEmpty ?? false) ? 1 : 0),
                  itemBuilder: (context, index) {
                    // Show typing indicator as first item (at bottom)
                    if (index == 0 && (typingUsers?.isNotEmpty ?? false)) {
                      return _buildTypingIndicator(context, isDark);
                    }
                    
                    // Adjust index if typing indicator is showing
                    final messageIndex = (typingUsers?.isNotEmpty ?? false) ? index - 1 : index;
                    final message = messages![messages!.length - 1 - messageIndex];
                    final isOwn = message.senderId == currentUserId;
                    final isOnline = onlineUsers?.contains(message.senderId) ?? false;

                    // üîß FIXED: Add key based on message ID to prevent unnecessary rebuilds
                    return KeyedSubtree(
                      key: ValueKey(message.id),
                      child: _buildMessageBubble(
                        context,
                        ref,
                        message,
                        isOwn,
                        isOnline,
                        isDark,
                      ),
                    );
                  },
                ),
        ),
        
        // Compose bar (conditionally shown)
        if (showComposeBar)
          _buildComposeBar(context, ref, isDark),
      ],
    );
  }
  
  Widget _buildMessageBubble(
    BuildContext context,
    WidgetRef ref,
    Message message,
    bool isOwn,
    bool isOnline,
    bool isDark,
  ) {
    // üîß FIXED: Use the actual MessageBubble widget instead of inline building!
    // This ensures all the analysis event listeners and UI updates work
    
    return Align(
      alignment: isOwn ? Alignment.centerRight : Alignment.centerLeft,
      child: Row(
        mainAxisAlignment: isOwn ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          // Show avatar for other users' messages (left side)
          if (!isOwn) ...[
            Padding(
              padding: const EdgeInsets.only(
                left: AppTheme.spacingS,
                right: AppTheme.spacingXXS,
                bottom: AppTheme.spacingXXS,
              ),
              child: Stack(
                children: [
                  UserAvatar(
                    userId: message.senderId,
                    fallbackText: message.senderId.substring(0, 1).toUpperCase(),
                    radius: 16,
                  ),
                  Positioned(
                    right: 0,
                    bottom: 0,
                    child: Container(
                      width: 12,
                      height: 12,
                      decoration: BoxDecoration(
                        color: isOnline ? AppTheme.accentGreen : AppTheme.gray500,
                        shape: BoxShape.circle,
                        border: Border.all(
                          color: isDark ? AppTheme.black : AppTheme.white,
                          width: 2,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
          
          // üîß FIXED: Use MessageBubble widget instead of inline GestureDetector
          // üü£ UPDATED: Add sparkle indicator to the most recent received message
          Flexible(
            child: MessageBubble(
              message: message,
              isFromCurrentUser: isOwn,
              isMostRecentReceived: !isOwn && messages != null && messages!.isNotEmpty && messages!.last.id == message.id,
            ),
          ),
        ],
      ),
    );
  }
  
  /// Show context menu with AI features and copy/paste options
  void _showMessageContextMenu(
    BuildContext context,
    WidgetRef ref,
    Message message,
    bool isOwn,
    bool isDark,
  ) {
    showDialog(
      context: context,
      barrierColor: Colors.transparent,
      builder: (context) => GestureDetector(
        onTap: () => Navigator.pop(context),
        child: Material(
          color: Colors.transparent,
          child: Stack(
            children: [
              // Blur background
              Positioned.fill(
                child: Container(
                  color: Colors.black.withOpacity(0.1),
                ),
              ),
              // Center popup
              Center(
                child: Container(
                  margin: const EdgeInsets.symmetric(horizontal: 40),
                  decoration: BoxDecoration(
                    color: isDark ? AppTheme.darkGray100.withOpacity(0.95) : AppTheme.white.withOpacity(0.95),
                    borderRadius: BorderRadius.circular(14),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.3),
                        blurRadius: 30,
                        spreadRadius: 5,
                      ),
                    ],
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // AI Features (for received messages)
                      if (!isOwn) ...[
                        _buildPopupOption(
                          context,
                          ref,
                          message,
                          icon: Icons.psychology_outlined,
                          label: 'Analyze Message',
                          color: const Color(0xFF7C3AED), // Purple - interpreter
                          isDark: isDark,
                          isFirst: true,
                        ),
                        Divider(height: 1, color: isDark ? AppTheme.darkGray300 : AppTheme.gray300),
                      ],
                      
                      // Copy
                      _buildCopyOption(
                        context,
                        message,
                        isDark: isDark,
                        isFirst: isOwn,
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildPopupOption(
    BuildContext context,
    WidgetRef ref,
    Message message, {
    required IconData icon,
    required String label,
    required Color color,
    required bool isDark,
    bool isFirst = false,
  }) {
    return InkWell(
      onTap: () async {
        Navigator.pop(context);
        
        // Show loading indicator
        showDialog(
          context: context,
          barrierDismissible: false,
          builder: (context) => const Center(
            child: CircularProgressIndicator(),
          ),
        );
        
        try {
          // Trigger analysis if it doesn't exist
          final requestAnalysis = ref.read(requestAnalysisProvider);
          final analysis = await requestAnalysis(message.id, message.body);
          
          if (context.mounted) {
            Navigator.pop(context); // Close loading
            
            if (analysis != null) {
              // üÜï Removed: Provider invalidation no longer needed
              // Analysis is now handled in MessageBubble widget for manual long-press only
              
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Analysis complete - view in message details'),
                  duration: Duration(seconds: 2),
                ),
              );
            } else {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Failed to analyze message. Please try again.'),
                  backgroundColor: Colors.red,
                ),
              );
            }
          }
        } catch (e) {
          if (context.mounted) {
            Navigator.pop(context); // Close loading
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Error: $e'),
                backgroundColor: Colors.red,
              ),
            );
          }
        }
      },
      borderRadius: BorderRadius.vertical(
        top: isFirst ? const Radius.circular(14) : Radius.zero,
      ),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 22, color: color),
            const SizedBox(width: 12),
            Text(
              label,
              style: TextStyle(
                fontSize: 17,
                fontWeight: FontWeight.w500,
                color: color,
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildCopyOption(
    BuildContext context,
    Message message, {
    required bool isDark,
    bool isFirst = false,
  }) {
    return InkWell(
      onTap: () {
        Clipboard.setData(ClipboardData(text: message.body));
        Navigator.pop(context);
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Copied to clipboard'),
            behavior: SnackBarBehavior.floating,
            duration: Duration(seconds: 1),
          ),
        );
      },
      borderRadius: BorderRadius.vertical(
        top: isFirst ? const Radius.circular(14) : Radius.zero,
        bottom: const Radius.circular(14),
      ),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.content_copy, size: 22, color: isDark ? AppTheme.gray400 : AppTheme.gray700),
            const SizedBox(width: 12),
            Text(
              'Copy',
              style: TextStyle(
                fontSize: 17,
                fontWeight: FontWeight.w500,
                color: isDark ? AppTheme.gray400 : AppTheme.gray700,
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildTypingIndicator(BuildContext context, bool isDark) {
    final count = typingUsers?.length ?? 0;
    final text = count == 1 
        ? 'Someone is typing...' 
        : '$count people are typing...';
    
    return Padding(
      padding: const EdgeInsets.symmetric(
        horizontal: AppTheme.spacingM,
        vertical: AppTheme.spacingS,
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.symmetric(
              horizontal: AppTheme.spacingS,
              vertical: AppTheme.spacingS,
            ),
            decoration: BoxDecoration(
              color: isDark ? AppTheme.darkGray100 : AppTheme.white,
              borderRadius: BorderRadius.circular(AppTheme.radiusM),
              border: Border.all(
                color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                width: 1,
              ),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  text,
                  style: TextStyle(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                    fontSize: AppTheme.fontSizeS,
                    fontStyle: FontStyle.italic,
                  ),
                ),
                const SizedBox(width: AppTheme.spacingS),
                SizedBox(
                  width: 20,
                  height: 20,
                  child: _TypingAnimation(isDark: isDark),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildComposeBar(BuildContext context, WidgetRef ref, bool isDark) {
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingS),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        border: Border(
          top: BorderSide(
            color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
            width: 1,
          ),
        ),
      ),
      child: SafeArea(
        top: false,
        child: Column(
          children: [
            // ‚úÖ PHASE 2: Draft Feedback Panel
            Consumer(
              builder: (context, ref, child) {
                final draftAnalysis = ref.watch(draftAnalysisProvider);
                
                return draftAnalysis.when(
                  data: (analysis) {
                    if (analysis == null) return const SizedBox.shrink();
                    
                    return DraftFeedbackPanel(
                      analysis: analysis,
                      draftMessage: messageController.text,
                      onApplySuggestion: (suggestion) {
                        messageController.text = suggestion;
                      },
                      onTemplateSelected: (template) {
                        messageController.text = template;
                      },
                      onClose: () {
                        ref.read(draftAnalysisProvider.notifier).clear();
                      },
                    );
                  },
                  loading: () => const LinearProgressIndicator(
                    backgroundColor: Colors.transparent,
                  ),
                  error: (_, __) => const SizedBox.shrink(),
                );
              },
            ),
            
            // Show selected image preview
            if (selectedImage != null) ...[
              Container(
                padding: const EdgeInsets.all(AppTheme.spacingS),
                child: Stack(
                  children: [
                    ClipRRect(
                      borderRadius: BorderRadius.circular(AppTheme.radiusS),
                      child: Image.file(
                        File(selectedImage!.path),
                        height: 150,
                        width: 150,
                        fit: BoxFit.cover,
                      ),
                    ),
                    Positioned(
                      top: AppTheme.spacingXXS,
                      right: AppTheme.spacingXXS,
                      child: GestureDetector(
                        onTap: onClearImage,
                        child: Container(
                          decoration: BoxDecoration(
                            color: AppTheme.black.withOpacity(0.6),
                            shape: BoxShape.circle,
                          ),
                          padding: const EdgeInsets.all(AppTheme.spacingXXS),
                          child: const Icon(
                            Icons.close,
                            color: AppTheme.white,
                            size: 20,
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
            
            // Input row
            Row(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                // Image picker button
                IconButton(
                  onPressed: isUploadingImage || isSending ? null : onPickImage,
                  icon: Icon(
                    Icons.image,
                    color: isUploadingImage || isSending
                        ? (isDark ? AppTheme.gray600 : AppTheme.gray400)
                        : AppTheme.accentBlue,
                  ),
                  padding: const EdgeInsets.all(AppTheme.spacingS),
                ),
                
                const SizedBox(width: AppTheme.spacingXXS),
                
                // Text input
                Expanded(
                  child: Container(
                    decoration: BoxDecoration(
                      color: isDark ? AppTheme.darkGray200 : AppTheme.gray100,
                      borderRadius: BorderRadius.circular(AppTheme.radiusXL),
                      border: Border.all(
                        color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                        width: 1,
                      ),
                    ),
                    padding: const EdgeInsets.symmetric(
                      horizontal: AppTheme.spacingM,
                    ),
                    child: TextField(
                      controller: messageController,
                      enabled: !isSending && !isUploadingImage,
                      decoration: const InputDecoration(
                        hintText: 'Message',
                        border: InputBorder.none,
                        contentPadding: EdgeInsets.symmetric(
                          vertical: AppTheme.spacingS,
                        ),
                      ),
                      maxLines: 5,
                      minLines: 1,
                      textCapitalization: TextCapitalization.sentences,
                      style: TextStyle(
                        color: isDark ? AppTheme.white : AppTheme.black,
                      ),
                    ),
                  ),
                ),
                
                const SizedBox(width: AppTheme.spacingXXS),
                
                // ‚úÖ PHASE 2: Check Message Button (Draft Analysis)
                Consumer(
                  builder: (context, ref, child) {
                    final hasText = messageController.text.trim().isNotEmpty;
                    
                    return IconButton(
                      onPressed: !hasText ? null : () {
                        ref.read(draftAnalysisProvider.notifier).analyzeDraft(
                          draftMessage: messageController.text,
                        );
                      },
                      icon: Icon(
                        Icons.auto_awesome,
                        color: !hasText
                            ? (isDark ? AppTheme.gray600 : AppTheme.gray400)
                            : Colors.blue, // Blue - Adaptive Response Assistant feature
                      ),
                      tooltip: 'Check message confidence',
                      padding: const EdgeInsets.all(AppTheme.spacingS),
                    );
                  },
                ),
                
                // Send button
                Container(
                  decoration: BoxDecoration(
                    color: isDark ? AppTheme.white : AppTheme.black,
                    shape: BoxShape.circle,
                  ),
                  child: IconButton(
                    onPressed: (isSending || isUploadingImage) ? null : onSendMessage,
                    icon: (isSending || isUploadingImage)
                        ? SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              color: isDark ? AppTheme.black : AppTheme.white,
                            ),
                          )
                        : Icon(
                            Icons.send,
                            size: 20,
                            color: isDark ? AppTheme.black : AppTheme.white,
                          ),
                    padding: const EdgeInsets.all(AppTheme.spacingS),
                    constraints: const BoxConstraints(),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildDeliveryIndicator(Message message) {
    // Default to single checkmark if no receipts
    final receipts = receiptsCache?[message.id] ?? [];
    
    // Filter out own receipts (shouldn't exist for sent messages, but just in case)
    final otherReceipts = receipts.where((r) => r.userId != currentUserId).toList();
    
    // Check receipt statuses (case-insensitive to be safe)
    final hasRead = otherReceipts.any((r) => r.status.toLowerCase() == 'read');
    final hasDelivered = otherReceipts.any((r) => r.status.toLowerCase() == 'delivered');

    IconData icon;
    Color color;

    // Always show at least a single checkmark for sent messages
    if (hasRead) {
      icon = Icons.done_all; // Double checkmark for read
      color = AppTheme.accentBlue;
    } else if (hasDelivered || receipts.isNotEmpty) {
      icon = Icons.done_all; // Double checkmark for delivered
      color = AppTheme.gray600;
    } else {
      icon = Icons.done; // Single checkmark for sent (default)
      color = AppTheme.gray600;
    }

    return Icon(
      icon,
      size: 16, // Slightly larger for better visibility
      color: color,
    );
  }
  
  String _formatTime(int timestamp) {
    final dateTime = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);
    final hour = dateTime.hour.toString().padLeft(2, '0');
    final minute = dateTime.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }
}

/// Animated typing indicator dots
class _TypingAnimation extends StatefulWidget {
  final bool isDark;
  
  const _TypingAnimation({required this.isDark});

  @override
  State<_TypingAnimation> createState() => _TypingAnimationState();
}

class _TypingAnimationState extends State<_TypingAnimation>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1000),
    )..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return Row(
          mainAxisSize: MainAxisSize.min,
          children: List.generate(3, (index) {
            final delay = index * 0.2;
            final value = (_controller.value - delay) % 1.0;
            final opacity = value < 0.5 ? value * 2 : (1 - value) * 2;
            
            return Container(
              width: 4,
              height: 4,
              margin: const EdgeInsets.symmetric(horizontal: 1),
              decoration: BoxDecoration(
                color: (widget.isDark ? AppTheme.gray600 : AppTheme.gray600)
                    .withOpacity(opacity),
                shape: BoxShape.circle,
              ),
            );
          }),
        );
      },
    );
  }
}
</file>

<file path="frontend/lib/features/messages/widgets/tone_badge.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/ai_analysis.dart';

/// A small badge widget that displays tone analysis for a message
/// Appears at the bottom-right of message bubbles
class ToneBadge extends StatelessWidget {
  final AIAnalysis analysis;
  final VoidCallback? onTap;

  const ToneBadge({
    Key? key,
    required this.analysis,
    this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    final toneInfo = _getToneInfo(analysis.tone);
    final urgencyColor = _getUrgencyColor(analysis.urgencyLevel);
    final hasBoundary = analysis.boundaryAnalysis?.hasViolation == true;

    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: AppTheme.spacingXS,
          vertical: AppTheme.spacingXXS,
        ),
        decoration: BoxDecoration(
          color: (isDark ? AppTheme.darkGray200 : AppTheme.gray100)
              .withOpacity(0.9),
          borderRadius: BorderRadius.circular(AppTheme.radiusS),
          border: Border.all(
            color: (hasBoundary 
                ? _getBoundaryColor(analysis.boundaryAnalysis!.severity)
                : urgencyColor).withOpacity(0.3),
            width: 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              toneInfo.emoji,
              style: const TextStyle(fontSize: 12),
            ),
            const SizedBox(width: AppTheme.spacingXXS),
            Text(
              toneInfo.label,
              style: TextStyle(
                fontSize: AppTheme.fontSizeXXS,
                fontWeight: AppTheme.fontWeightMedium,
                color: isDark ? AppTheme.white : AppTheme.black,
              ),
            ),
            // üÜï PHASE 1: Boundary violation indicator
            if (hasBoundary) ...[
              const SizedBox(width: AppTheme.spacingXXS),
              Container(
                width: 6,
                height: 6,
                decoration: BoxDecoration(
                  color: _getBoundaryColor(analysis.boundaryAnalysis!.severity),
                  shape: BoxShape.circle,
                ),
              ),
            ],
            // ‚úÖ NEW: Show intensity dot
            if (analysis.intensity != null) ...[
              const SizedBox(width: AppTheme.spacingXXS),
              Container(
                width: 6,
                height: 6,
                decoration: BoxDecoration(
                  color: _getIntensityColor(analysis.intensity!),
                  shape: BoxShape.circle,
                ),
              ),
            ],
            // Existing urgency dot
            if (analysis.urgencyLevel != null && analysis.urgencyLevel != 'Low' && !hasBoundary) ...[
              const SizedBox(width: AppTheme.spacingXXS),
              Container(
                width: 6,
                height: 6,
                decoration: BoxDecoration(
                  color: urgencyColor,
                  shape: BoxShape.circle,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  ToneInfo _getToneInfo(String tone) {
    switch (tone.toLowerCase()) {
      // Original 8
      case 'friendly':
        return ToneInfo(emoji: 'üòä', label: 'Friendly');
      case 'professional':
        return ToneInfo(emoji: 'üíº', label: 'Professional');
      case 'urgent':
        return ToneInfo(emoji: '‚ö†Ô∏è', label: 'Urgent');
      case 'casual':
        return ToneInfo(emoji: 'üòé', label: 'Casual');
      case 'formal':
        return ToneInfo(emoji: 'üé©', label: 'Formal');
      case 'concerned':
        return ToneInfo(emoji: 'üòü', label: 'Concerned');
      case 'excited':
        return ToneInfo(emoji: 'üéâ', label: 'Excited');
      case 'neutral':
        return ToneInfo(emoji: 'üòê', label: 'Neutral');
      
      // ‚úÖ NEW: 15 additional tones
      case 'apologetic':
        return ToneInfo(emoji: 'üôè', label: 'Apologetic');
      case 'appreciative':
        return ToneInfo(emoji: 'üôå', label: 'Appreciative');
      case 'frustrated':
        return ToneInfo(emoji: 'üò§', label: 'Frustrated');
      case 'playful':
        return ToneInfo(emoji: 'üòú', label: 'Playful');
      case 'sarcastic':
        return ToneInfo(emoji: 'üôÑ', label: 'Sarcastic');
      case 'empathetic':
        return ToneInfo(emoji: 'ü§ó', label: 'Empathetic');
      case 'inquisitive':
        return ToneInfo(emoji: 'ü§î', label: 'Inquisitive');
      case 'assertive':
        return ToneInfo(emoji: 'üí™', label: 'Assertive');
      case 'tentative':
        return ToneInfo(emoji: 'üò¨', label: 'Tentative');
      case 'defensive':
        return ToneInfo(emoji: 'üõ°Ô∏è', label: 'Defensive');
      case 'encouraging':
        return ToneInfo(emoji: 'üíö', label: 'Encouraging');
      case 'disappointed':
        return ToneInfo(emoji: 'üòû', label: 'Disappointed');
      case 'overwhelmed':
        return ToneInfo(emoji: 'üòµ', label: 'Overwhelmed');
      case 'relieved':
        return ToneInfo(emoji: 'üòå', label: 'Relieved');
      case 'confused':
        return ToneInfo(emoji: 'üòï', label: 'Confused');
      
      default:
        return ToneInfo(emoji: 'üí¨', label: 'Neutral');
    }
  }

  Color _getUrgencyColor(String? urgencyLevel) {
    if (urgencyLevel == null) return AppTheme.gray500;
    
    switch (urgencyLevel.toLowerCase()) {
      case 'critical':
        return AppTheme.accentRed;
      case 'high':
        return AppTheme.accentOrange;
      case 'medium':
        return AppTheme.accentBlue;
      case 'low':
      default:
        return AppTheme.accentGreen;
    }
  }

  // ‚úÖ NEW: Helper for intensity colors
  Color _getIntensityColor(int intensity) {
    // Map intensity (1-10) to colors
    if (intensity >= 8) {
      return Colors.red;
    } else if (intensity >= 6) {
      return Colors.orange;
    } else if (intensity >= 4) {
      return Colors.blue;
    } else if (intensity >= 2) {
      return Colors.green;
    } else {
      return Colors.grey;
    }
  }

  // ‚úÖ NEW: Helper for boundary colors
  Color _getBoundaryColor(int severity) {
    switch (severity) {
      case 3:
        return AppTheme.accentRed;
      case 2:
        return AppTheme.accentOrange;
      case 1:
      default:
        return AppTheme.accentBlue;
    }
  }
}

class ToneInfo {
  final String emoji;
  final String label;

  ToneInfo({required this.emoji, required this.label});
}
</file>

<file path="frontend/lib/features/messages/widgets/tone_detail_sheet.dart">
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dart:async'; // üîß Added for TimeoutException
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/features/messages/widgets/rsd_alert_card.dart';
import 'package:messageai/features/messages/widgets/interpretation_options.dart';
import 'package:messageai/features/messages/widgets/evidence_viewer.dart';
import 'package:messageai/state/ai_providers.dart';

/// Bottom sheet showing detailed tone analysis
class ToneDetailSheet extends ConsumerStatefulWidget {
  final AIAnalysis analysis;
  final String messageBody;
  final String messageId;

  const ToneDetailSheet({
    Key? key,
    required this.analysis,
    required this.messageBody,
    required this.messageId,
  }) : super(key: key);

  @override
  ConsumerState<ToneDetailSheet> createState() => _ToneDetailSheetState();

  /// Static method to show the sheet
  static void show(
    BuildContext context,
    AIAnalysis analysis,
    String messageBody,
    String messageId,
  ) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => DraggableScrollableSheet(
        initialChildSize: 0.9,
        minChildSize: 0.5,
        maxChildSize: 0.95,
        builder: (context, scrollController) => SingleChildScrollView(
          controller: scrollController,
          child: ToneDetailSheet(
            analysis: analysis,
            messageBody: messageBody,
            messageId: messageId,
          ),
        ),
      ),
    );
  }
}

class _ToneDetailSheetState extends ConsumerState<ToneDetailSheet> {
  bool _isLoadingInterpretation = false;
  AIAnalysis? _enhancedAnalysis;
  bool _boundaryExpanded = false; // NEW: Track boundary section expansion

  @override
  void initState() {
    super.initState();
    _enhancedAnalysis = widget.analysis;
  }

  /// Trigger deeper interpretation with RSD detection and alternatives
  Future<void> _interpretMessage() async {
    if (_isLoadingInterpretation) return;

    setState(() {
      _isLoadingInterpretation = true;
    });

    try {
      final service = ref.read(messageInterpreterServiceProvider);
      
      // üîß Add timeout here too, with a 20s total timeout (15s from service + buffer)
      final analysis = await service.interpretMessage(
        widget.messageId,
        widget.messageBody,
      ).timeout(
        const Duration(seconds: 20),
        onTimeout: () {
          throw TimeoutException('Deeper interpretation took too long');
        },
      );

      if (mounted) {
        setState(() {
          _enhancedAnalysis = analysis;
          _isLoadingInterpretation = false;
        });

        // Show success message
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('‚ú® Deeper interpretation complete!'),
            duration: Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoadingInterpretation = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to interpret message: $e'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final analysis = _enhancedAnalysis ?? widget.analysis;

    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppTheme.spacingL,
        vertical: AppTheme.spacingM,
      ),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(AppTheme.radiusXL),
          topRight: Radius.circular(AppTheme.radiusXL),
        ),
      ),
      child: SafeArea(
        top: false,
        bottom: false,
        child: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Handle bar
              Center(
                child: Container(
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                    borderRadius: BorderRadius.circular(AppTheme.radiusPill),
                  ),
                ),
              ),
              
              const SizedBox(height: AppTheme.spacingL),
              
              // üü£ PRIMARY: Tone - The headline
              Row(
                children: [
                  Icon(
                    Icons.auto_awesome,
                    size: 24,
                    color: Colors.purple,
                  ),
                  const SizedBox(width: AppTheme.spacingS),
                  Text(
                    analysis.tone,
                    style: theme.textTheme.displaySmall?.copyWith(
                      color: Colors.purple,
                      fontWeight: AppTheme.fontWeightBold,
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: AppTheme.spacingXS),
              
              // Subtle secondary info
              if (analysis.urgencyLevel != null)
                Text(
                  'Urgency: ${analysis.urgencyLevel}',
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                  ),
                ),
              
              if (analysis.intent != null) ...[
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  analysis.intent!,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                    fontStyle: FontStyle.italic,
                  ),
                ),
              ],
              
              const SizedBox(height: AppTheme.spacingL),
              
              // ‚ö†Ô∏è WARNINGS FIRST (RSD, Boundary Issues) - Always visible
              if (analysis.rsdTriggers != null && analysis.rsdTriggers!.isNotEmpty) ...[
                RSDAlertCard(triggers: analysis.rsdTriggers!),
                const SizedBox(height: AppTheme.spacingM),
              ],
              
              // üîç COLLAPSIBLE ACCORDION SECTIONS
              Theme(
                data: Theme.of(context).copyWith(dividerColor: Colors.transparent),
                child: Column(
                  children: [
                    // Boundary Alert Section (collapsed by default)
                    if (analysis.boundaryAnalysis?.hasViolation == true) ...[
                      _buildAccordionSection(
                        context,
                        'Boundary Alert',
                        Icons.shield_outlined,
                        isDark,
                        showWarning: true,
                        children: [
                          _buildBoundarySection(context, analysis.boundaryAnalysis!, isDark),
                        ],
                      ),
                      const SizedBox(height: AppTheme.spacingS),
                    ],
                    
                    // Details Section
                    _buildAccordionSection(
                      context,
                      'Details',
                      Icons.info_outline,
                      isDark,
                      children: [
                        if (analysis.confidenceScore != null) ...[
                          _buildConfidenceBar(context, analysis.confidenceScore!, isDark),
                          const SizedBox(height: AppTheme.spacingM),
                        ],
                        
                        if (analysis.intensity != null) ...[
                          _buildSubtleRow(
                            'Intensity',
                            _formatIntensity(analysis.intensity!),
                            isDark,
                          ),
                          const SizedBox(height: AppTheme.spacingM),
                        ],
                        
                        if (analysis.secondaryTones != null && analysis.secondaryTones!.isNotEmpty) ...[
                          _buildSubtleRow(
                            'Secondary Tones',
                            analysis.secondaryTones!.join(', '),
                            isDark,
                          ),
                          const SizedBox(height: AppTheme.spacingM),
                        ],
                      ],
                    ),
                    
                    // Context Flags Section
                    if (analysis.contextFlags != null && analysis.contextFlags!.isNotEmpty) ...[
                      const SizedBox(height: AppTheme.spacingS),
                      _buildAccordionSection(
                        context,
                        'Context',
                        Icons.tag_outlined,
                        isDark,
                        children: [
                          _buildContextFlags(context, analysis.contextFlags!, isDark),
                        ],
                      ),
                    ],
                    
                    // Anxiety Assessment Section
                    if (analysis.anxietyAssessment != null) ...[
                      const SizedBox(height: AppTheme.spacingS),
                      _buildAccordionSection(
                        context,
                        'Anxiety Assessment',
                        Icons.psychology_outlined,
                        isDark,
                        children: [
                          _buildAnxietyAssessment(context, analysis.anxietyAssessment!, isDark),
                        ],
                      ),
                    ],
                    
                    // Interpretations Section
                    if (analysis.alternativeInterpretations != null ||
                        !_isLoadingInterpretation) ...[
                      const SizedBox(height: AppTheme.spacingS),
                      _buildAccordionSection(
                        context,
                        'Deeper Interpretation',
                        Icons.lightbulb_outlined,
                        isDark,
                        children: [
                          if (analysis.alternativeInterpretations == null ||
                              analysis.alternativeInterpretations!.isEmpty)
                            SizedBox(
                              width: double.infinity,
                              child: ElevatedButton.icon(
                                onPressed: _isLoadingInterpretation ? null : _interpretMessage,
                                icon: _isLoadingInterpretation
                                    ? const SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2))
                                    : const Icon(Icons.auto_awesome, size: 18),
                                label: Text(_isLoadingInterpretation ? 'Analyzing...' : 'Analyze'),
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: Colors.purple,
                                  foregroundColor: Colors.white,
                                ),
                              ),
                            )
                          else
                            InterpretationOptions(interpretations: analysis.alternativeInterpretations!),
                        ],
                      ),
                    ],
                    
                    // Evidence Section
                    if (analysis.evidence != null && analysis.evidence!.isNotEmpty) ...[
                      const SizedBox(height: AppTheme.spacingS),
                      _buildAccordionSection(
                        context,
                        'Evidence',
                        Icons.dataset_outlined,
                        isDark,
                        children: [
                          EvidenceViewer(evidence: analysis.evidence!),
                        ],
                      ),
                    ],
                  ],
                ),
              ),
              
              const SizedBox(height: AppTheme.spacingL),
              
              // Close button
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () => Navigator.pop(context),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.purple,
                    padding: const EdgeInsets.symmetric(vertical: 12),
                  ),
                  child: const Text('Close'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  /// Build an accordion section with subtle styling like context panel
  Widget _buildAccordionSection(
    BuildContext context,
    String title,
    IconData icon,
    bool isDark, {
    required List<Widget> children,
    bool showWarning = false,
  }) {
    final theme = Theme.of(context);
    
    return ExpansionTile(
      tilePadding: const EdgeInsets.symmetric(horizontal: AppTheme.spacingS, vertical: 0),
      childrenPadding: const EdgeInsets.symmetric(
        horizontal: AppTheme.spacingM,
        vertical: AppTheme.spacingM,
      ),
      title: Row(
        children: [
          Icon(
            icon,
            size: 18,
            color: isDark ? AppTheme.gray500 : AppTheme.gray600,
          ),
          const SizedBox(width: AppTheme.spacingS),
          Text(
            title,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: isDark ? AppTheme.gray400 : AppTheme.gray700,
              fontWeight: AppTheme.fontWeightMedium,
            ),
          ),
          if (showWarning) ...[
            const SizedBox(width: AppTheme.spacingXS),
            Icon(
              Icons.warning_outlined,
              size: 16,
              color: AppTheme.accentOrange,
            ),
          ],
        ],
      ),
      trailing: Icon(
        Icons.expand_more,
        size: 20,
        color: isDark ? AppTheme.gray500 : AppTheme.gray600,
      ),
      children: children,
    );
  }

  /// Build a subtle row for simple text info
  Widget _buildSubtleRow(
    String label,
    String value,
    bool isDark,
  ) {
    final theme = Theme.of(context);
    
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          label,
          style: theme.textTheme.bodySmall?.copyWith(
            color: isDark ? AppTheme.gray500 : AppTheme.gray600,
          ),
        ),
        Text(
          value,
          style: theme.textTheme.bodySmall?.copyWith(
            fontWeight: AppTheme.fontWeightMedium,
            color: isDark ? AppTheme.gray300 : AppTheme.gray800,
          ),
        ),
      ],
    );
  }

  Widget _buildSection(
    BuildContext context,
    String label,
    String value,
    IconData icon,
    bool isDark, {
    bool highlight = false,
    Color? color,
  }) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: highlight
            ? (isDark ? AppTheme.darkGray200 : AppTheme.gray100)
            : (isDark ? AppTheme.darkGray200.withOpacity(0.5) : AppTheme.gray50),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: color ?? (isDark ? AppTheme.darkGray300 : AppTheme.gray300),
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingS),
            decoration: BoxDecoration(
              color: (color ?? (isDark ? AppTheme.darkGray300 : AppTheme.gray200))
                  .withOpacity(0.3),
              borderRadius: BorderRadius.circular(AppTheme.radiusS),
            ),
            child: Icon(
              icon,
              size: 20,
              color: color ?? (isDark ? AppTheme.white : AppTheme.black),
            ),
          ),
          const SizedBox(width: AppTheme.spacingM),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  label,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                    fontWeight: AppTheme.fontWeightMedium,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  value,
                  style: theme.textTheme.bodyLarge?.copyWith(
                    fontWeight: AppTheme.fontWeightSemibold,
                    color: color,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildConfidenceBar(
    BuildContext context,
    double confidence,
    bool isDark,
  ) {
    final theme = Theme.of(context);
    final percentage = (confidence * 100).round();
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Confidence',
              style: theme.textTheme.bodySmall?.copyWith(
                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                fontWeight: AppTheme.fontWeightMedium,
              ),
            ),
            Text(
              '$percentage%',
              style: theme.textTheme.bodySmall?.copyWith(
                fontWeight: AppTheme.fontWeightBold,
              ),
            ),
          ],
        ),
        const SizedBox(height: AppTheme.spacingXS),
        ClipRRect(
          borderRadius: BorderRadius.circular(AppTheme.radiusPill),
          child: LinearProgressIndicator(
            value: confidence,
            minHeight: 8,
            backgroundColor: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
            valueColor: AlwaysStoppedAnimation<Color>(
              confidence > 0.8
                  ? AppTheme.accentGreen
                  : confidence > 0.6
                      ? AppTheme.accentBlue
                      : AppTheme.accentOrange,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildFeedbackSection(BuildContext context, bool isDark) {
    final theme = Theme.of(context);
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Was this analysis helpful?',
          style: theme.textTheme.bodySmall?.copyWith(
            color: isDark ? AppTheme.gray500 : AppTheme.gray600,
            fontWeight: AppTheme.fontWeightMedium,
          ),
        ),
        const SizedBox(height: AppTheme.spacingXS),
        Row(
          children: [
            OutlinedButton.icon(
              onPressed: () {
                // TODO: Implement feedback logic
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Thanks for your feedback!')),
                );
              },
              icon: const Icon(Icons.thumb_up_outlined, size: 18),
              label: const Text('Helpful'),
              style: OutlinedButton.styleFrom(
                side: BorderSide(
                  color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                ),
              ),
            ),
            const SizedBox(width: AppTheme.spacingS),
            OutlinedButton.icon(
              onPressed: () {
                // TODO: Implement feedback logic
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Thanks for your feedback!')),
                );
              },
              icon: const Icon(Icons.thumb_down_outlined, size: 18),
              label: const Text('Not helpful'),
              style: OutlinedButton.styleFrom(
                side: BorderSide(
                  color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                ),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Color _getUrgencyColor(String? urgencyLevel) {
    if (urgencyLevel == null) return AppTheme.gray500;
    
    switch (urgencyLevel.toLowerCase()) {
      case 'critical':
        return AppTheme.accentRed;
      case 'high':
        return AppTheme.accentOrange;
      case 'medium':
        return AppTheme.accentBlue;
      case 'low':
      default:
        return AppTheme.accentGreen;
    }
  }

  // ‚úÖ NEW: Helper methods for enhanced fields
  String _formatIntensity(int intensity) {
    // Convert number (1-10) to descriptive text
    if (intensity >= 9) {
      return 'Very High';
    } else if (intensity >= 7) {
      return 'High';
    } else if (intensity >= 5) {
      return 'Medium';
    } else if (intensity >= 3) {
      return 'Low';
    } else {
      return 'Very Low';
    }
  }

  Widget _buildContextFlags(BuildContext context, Map<String, dynamic> flags, bool isDark) {
    final activeFlags = flags.entries
        .where((e) => e.value == true)
        .map((e) => _formatFlag(e.key))
        .toList();
    
    if (activeFlags.isEmpty) return const SizedBox.shrink();
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: Colors.blue.withOpacity(0.1),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: Colors.blue.withOpacity(0.3),
        ),
      ),
      child: Row(
        children: [
          Icon(
            Icons.info_outline,
            size: 20,
            color: Colors.blue,
          ),
          const SizedBox(width: AppTheme.spacingS),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Context Flags',
                  style: TextStyle(
                    fontSize: AppTheme.fontSizeXS,
                    fontWeight: AppTheme.fontWeightBold,
                    color: Colors.blue,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  activeFlags.join(', '),
                  style: TextStyle(fontSize: AppTheme.fontSizeXS),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  String _formatFlag(String flag) {
    return flag.replaceAll('_', ' ').split(' ').map((word) => 
      word[0].toUpperCase() + word.substring(1)
    ).join(' ');
  }

  Widget _buildAnxietyAssessment(BuildContext context, Map<String, dynamic> assessment, bool isDark) {
    final riskLevel = assessment['risk_level'] as String?;
    final suggestions = (assessment['mitigation_suggestions'] as List<dynamic>?)
        ?.map((e) => e as String)
        .toList() ?? [];
    
    if (riskLevel == null) return const SizedBox.shrink();
    
    final riskColor = _getRiskColor(riskLevel);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: riskColor.withOpacity(0.1),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(color: riskColor),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.psychology, size: 20, color: riskColor),
              const SizedBox(width: AppTheme.spacingS),
              Text(
                'Response Anxiety: ${riskLevel.toUpperCase()}',
                style: TextStyle(
                  fontWeight: AppTheme.fontWeightBold,
                  color: riskColor,
                ),
              ),
            ],
          ),
          if (suggestions.isNotEmpty) ...[
            const SizedBox(height: AppTheme.spacingS),
            ...suggestions.map((s) => Padding(
              padding: const EdgeInsets.only(top: AppTheme.spacingXXS),
              child: Text(
                '‚Ä¢ $s',
                style: TextStyle(fontSize: AppTheme.fontSizeXS),
              ),
            )),
          ],
        ],
      ),
    );
  }

  Color _getRiskColor(String level) {
    switch (level.toLowerCase()) {
      case 'high':
        return Colors.red;
      case 'medium':
        return Colors.orange;
      case 'low':
        return Colors.green;
      default:
        return Colors.grey;
    }
  }

  Widget _buildBoundarySection(BuildContext context, BoundaryAnalysis boundary, bool isDark) {
    final color = _getBoundaryColor(boundary.severity);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: color,
          width: 2,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Row(
            children: [
              Icon(
                Icons.shield_outlined,
                color: color,
                size: 24,
              ),
              const SizedBox(width: AppTheme.spacingM),
              Text(
                '‚ö†Ô∏è Boundary Alert',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: AppTheme.fontWeightBold,
                  color: color,
                ),
              ),
            ],
          ),
          
          const SizedBox(height: AppTheme.spacingM),
          
          // Type badge
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: color.withOpacity(0.2),
              borderRadius: BorderRadius.circular(6),
            ),
            child: Text(
              _getBoundaryTypeLabel(boundary.type),
              style: TextStyle(
                fontSize: 12,
                fontWeight: AppTheme.fontWeightBold,
                color: color,
              ),
            ),
          ),
          
          const SizedBox(height: AppTheme.spacingM),
          
          // Explanation
          Text(
            boundary.explanation,
            style: TextStyle(
              fontSize: 14,
              height: 1.5,
              color: isDark ? AppTheme.gray300 : AppTheme.gray800,
            ),
          ),
          
          const SizedBox(height: AppTheme.spacingM),
          
          // Suggested responses
          Text(
            'Boundary-Respecting Responses:',
            style: TextStyle(
              fontSize: 14,
              fontWeight: AppTheme.fontWeightBold,
              color: isDark ? AppTheme.gray200 : AppTheme.gray800,
            ),
          ),
          
          const SizedBox(height: AppTheme.spacingS),
          
          ...boundary.suggestedResponses.asMap().entries.map((entry) {
            final index = entry.key;
            final response = entry.value;
            
            return Container(
              margin: const EdgeInsets.only(bottom: 8),
              child: InkWell(
                onTap: () {
                  Clipboard.setData(ClipboardData(text: response));
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Response copied to clipboard'),
                      duration: Duration(seconds: 2),
                    ),
                  );
                },
                borderRadius: BorderRadius.circular(8),
                child: Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: isDark ? AppTheme.darkGray200 : AppTheme.white,
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(
                      color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                    ),
                  ),
                  child: Row(
                    children: [
                      CircleAvatar(
                        radius: 12,
                        backgroundColor: color.withOpacity(0.2),
                        child: Text(
                          '${index + 1}',
                          style: TextStyle(
                            fontSize: 12,
                            fontWeight: AppTheme.fontWeightBold,
                            color: color,
                          ),
                        ),
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Text(
                          response,
                          style: TextStyle(
                            fontSize: 14,
                            color: isDark ? AppTheme.gray300 : AppTheme.gray800,
                          ),
                        ),
                      ),
                      Icon(
                        Icons.copy,
                        size: 16,
                        color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                      ),
                    ],
                  ),
                ),
              ),
            );
          }).toList(),
        ],
      ),
    );
  }
  
  Color _getBoundaryColor(int severity) {
    switch (severity) {
      case 3:
        return AppTheme.accentRed;
      case 2:
        return AppTheme.accentOrange;
      case 1:
      default:
        return AppTheme.accentBlue;
    }
  }
  
  String _getBoundaryTypeLabel(BoundaryViolationType type) {
    switch (type) {
      case BoundaryViolationType.afterHours:
        return 'After Hours';
      case BoundaryViolationType.urgentPressure:
        return 'Urgent Pressure';
      case BoundaryViolationType.guiltTripping:
        return 'Guilt Trip';
      case BoundaryViolationType.overstepping:
        return 'Overstepping';
      case BoundaryViolationType.repeated:
        return 'Repeated Pattern';
      default:
        return 'Boundary Issue';
    }
  }

  /// Highlight card for the main tone
  Widget _buildHighlightCard(
    BuildContext context,
    String label,
    String value,
    IconData icon,
    Color color,
    bool isDark,
  ) {
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(AppTheme.radiusL),
        border: Border.all(color: color.withOpacity(0.3), width: 2),
      ),
      child: Row(
        children: [
          Icon(icon, size: 32, color: color),
          const SizedBox(width: AppTheme.spacingM),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(label, style: Theme.of(context).textTheme.labelSmall?.copyWith(color: color)),
                Text(value, style: Theme.of(context).textTheme.headlineSmall?.copyWith(color: color, fontWeight: FontWeight.bold)),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  /// Small info card for secondary info
  Widget _buildSmallCard(
    BuildContext context,
    String label,
    String value,
    Color color,
    bool isDark,
  ) {
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingS),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(label, style: Theme.of(context).textTheme.labelSmall?.copyWith(color: color, fontWeight: FontWeight.w500)),
          const SizedBox(height: 4),
          Text(value, style: Theme.of(context).textTheme.bodySmall?.copyWith(fontWeight: FontWeight.w600)),
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/notifications/widgets/notification_widgets.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/notification_providers.dart';
import 'package:messageai/services/notification_service.dart' hide notificationServiceProvider;

/// Widget to request notification permissions
class NotificationPermissionRequest extends ConsumerWidget {
  final VoidCallback? onPermissionGranted;
  final VoidCallback? onPermissionDenied;

  const NotificationPermissionRequest({
    Key? key,
    this.onPermissionGranted,
    this.onPermissionDenied,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final hasPermission = ref.watch(notificationPermissionProvider);

    return hasPermission.when(
      data: (hasPermission) {
        if (hasPermission) {
          return const SizedBox.shrink();
        }
        return _PermissionBanner(
          onGranted: onPermissionGranted,
          onDenied: onPermissionDenied,
        );
      },
      loading: () => const SizedBox.shrink(),
      error: (error, st) => const SizedBox.shrink(),
    );
  }
}

/// Permission request banner
class _PermissionBanner extends ConsumerWidget {
  final VoidCallback? onGranted;
  final VoidCallback? onDenied;

  const _PermissionBanner({
    this.onGranted,
    this.onDenied,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Container(
      color: Colors.blue.shade50,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      child: Row(
        children: [
          Icon(
            Icons.notifications_none,
            color: Colors.blue.shade700,
            size: 24,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  'Enable Notifications',
                  style: Theme.of(context).textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                ),
                Text(
                  'Get notified when you receive messages',
                  style: Theme.of(context).textTheme.bodySmall,
                ),
              ],
            ),
          ),
          const SizedBox(width: 12),
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextButton(
                onPressed: () {
                  onDenied?.call();
                },
                child: const Text('Not Now'),
              ),
              const SizedBox(width: 8),
              ElevatedButton(
                onPressed: () async {
                  final service = ref.read(notificationServiceProvider);
                  final granted = await service.areNotificationsEnabled();
                  if (granted) {
                    onGranted?.call();
                  } else {
                    onDenied?.call();
                  }
                },
                child: const Text('Enable'),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

/// Notification status indicator
class NotificationStatusIndicator extends ConsumerWidget {
  const NotificationStatusIndicator({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);

    if (!notificationState.isInitialized) {
      return const SizedBox.shrink();
    }

    final hasPermission = notificationState.hasPermission;

    return Tooltip(
      message: hasPermission ? 'Notifications enabled' : 'Notifications disabled',
      child: Icon(
        hasPermission ? Icons.notifications_active : Icons.notifications_off,
        color: hasPermission ? Colors.green : Colors.grey,
        size: 24,
      ),
    );
  }
}

/// Notification settings tile
class NotificationSettingsTile extends ConsumerWidget {
  final VoidCallback? onPressed;

  const NotificationSettingsTile({
    Key? key,
    this.onPressed,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);
    final hasPermission = notificationState.hasPermission;

    return ListTile(
      leading: Icon(
        hasPermission ? Icons.notifications_active : Icons.notifications_off,
        color: hasPermission ? Colors.green : Colors.grey,
      ),
      title: const Text('Notifications'),
      subtitle: Text(
        hasPermission ? 'Enabled' : 'Disabled',
        style: TextStyle(
          color: hasPermission ? Colors.green : Colors.grey,
        ),
      ),
      trailing: Icon(
        Icons.chevron_right,
        color: Theme.of(context).dividerColor,
      ),
      onTap: onPressed,
    );
  }
}

/// Unread notification badge
class NotificationBadge extends ConsumerWidget {
  final Widget child;
  final Color? backgroundColor;
  final TextStyle? textStyle;

  const NotificationBadge({
    Key? key,
    required this.child,
    this.backgroundColor,
    this.textStyle,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);
    final unreadCount = notificationState.unreadCount;

    if (unreadCount == 0) {
      return child;
    }

    return Badge(
      label: Text(
        unreadCount > 99 ? '99+' : '$unreadCount',
        style: textStyle,
      ),
      backgroundColor: backgroundColor ?? Colors.red,
      child: child,
    );
  }
}

/// Notification bottom sheet
class NotificationSettingsBottomSheet extends ConsumerWidget {
  const NotificationSettingsBottomSheet({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);
    final hasPermission = notificationState.hasPermission;
    final deviceToken = notificationState.deviceToken;

    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Text(
            'Notification Settings',
            style: Theme.of(context).textTheme.headlineSmall,
          ),
          const SizedBox(height: 24),

          // Permission status
          ListTile(
            leading: Icon(
              hasPermission ? Icons.check_circle : Icons.cancel,
              color: hasPermission ? Colors.green : Colors.red,
            ),
            title: const Text('Notifications'),
            subtitle: Text(
              hasPermission ? 'Enabled' : 'Disabled',
              style: TextStyle(
                color: hasPermission ? Colors.green : Colors.red,
              ),
            ),
          ),
          const Divider(),

          // Device token info
          if (deviceToken != null)
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 8.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Device Token',
                    style: Theme.of(context).textTheme.labelMedium,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    deviceToken.substring(0, 20) + '...',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          fontFamily: 'monospace',
                        ),
                  ),
                ],
              ),
            ),
          const SizedBox(height: 24),

          // Close button
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Close'),
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/firebase_options.dart">
// File generated by FlutterFire CLI.
// This is a placeholder file. To use Firebase, you need to:
// 1. Install FlutterFire CLI: dart pub global activate flutterfire_cli
// 2. Run: flutterfire configure
// 3. Follow the prompts to select your Firebase project
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import firebase_options.dart;
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyABa-DcxTR4T4CHlfJuy-7DKG1F_hDRNcg',
    appId: '1:397483513751:web:3121cbb846ddd8381c56d2',
    messagingSenderId: '397483513751',
    projectId: 'messageai-e2e9e',
    authDomain: 'messageai-e2e9e.firebaseapp.com',
    storageBucket: 'messageai-e2e9e.firebasestorage.app',
    measurementId: 'G-VCVQDFPTLV',
  );

  // Placeholder values - replace with your actual Firebase configuration

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyBBc-17a_EvWPvCutNSTEV9QEB2w2DUM_4',
    appId: '1:397483513751:android:bb838799a2cd3f7f1c56d2',
    messagingSenderId: '397483513751',
    projectId: 'messageai-e2e9e',
    storageBucket: 'messageai-e2e9e.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIza...',  // Replace with your iOS API key
    appId: '1:...',     // Replace with your iOS app ID
    messagingSenderId: '...',  // Replace with your sender ID
    projectId: 'your-project-id',  // Replace with your project ID
    storageBucket: 'your-project-id.appspot.com',
    iosBundleId: 'com.example.messageai',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIza...',  // Replace with your macOS API key
    appId: '1:...',     // Replace with your macOS app ID
    messagingSenderId: '...',  // Replace with your sender ID
    projectId: 'your-project-id',  // Replace with your project ID
    storageBucket: 'your-project-id.appspot.com',
    iosBundleId: 'com.example.messageai',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyABa-DcxTR4T4CHlfJuy-7DKG1F_hDRNcg',
    appId: '1:397483513751:web:ba73c764d577f4f51c56d2',
    messagingSenderId: '397483513751',
    projectId: 'messageai-e2e9e',
    authDomain: 'messageai-e2e9e.firebaseapp.com',
    storageBucket: 'messageai-e2e9e.firebasestorage.app',
    measurementId: 'G-C6R3PHYG95',
  );

}
</file>

<file path="frontend/lib/models/ai_analysis.dart">
/// Simple AI Analysis model - no Drift dependency
/// Fetched directly from Supabase with in-memory session caching
class AIAnalysis {
  final String id;
  final String messageId;
  final String tone;
  final String? urgencyLevel;
  final String? intent;
  final double? confidenceScore;
  final int analysisTimestamp;
  
  // ‚úÖ NEW ENHANCED FIELDS
  final int? intensity;
  final List<String>? secondaryTones;
  final Map<String, dynamic>? contextFlags;
  final Map<String, dynamic>? anxietyAssessment;
  final BoundaryAnalysis? boundaryAnalysis;
  
  // ‚úÖ PHASE 1: Smart Message Interpreter fields
  final List<RSDTrigger>? rsdTriggers;
  final List<MessageInterpretation>? alternativeInterpretations;
  final List<Evidence>? evidence;
  
  const AIAnalysis({
    required this.id,
    required this.messageId,
    required this.tone,
    this.urgencyLevel,
    this.intent,
    this.confidenceScore,
    required this.analysisTimestamp,
    // ‚úÖ NEW
    this.intensity,
    this.secondaryTones,
    this.contextFlags,
    this.anxietyAssessment,
    this.boundaryAnalysis,
    // ‚úÖ PHASE 1
    this.rsdTriggers,
    this.alternativeInterpretations,
    this.evidence,
  });
  
  /// Create from Supabase JSON response
  factory AIAnalysis.fromJson(Map<String, dynamic> json) {
    try {
      // Handle both direct table columns and RPC function results
      final id = json['id'] as String? ?? json['analysis_id'] as String?;
      final messageId = json['message_id'] as String?;
      final tone = json['tone'] as String?;
      
      if (id == null || messageId == null || tone == null) {
        throw FormatException(
          'Missing required fields in AI analysis JSON: '
          'id=$id, message_id=$messageId, tone=$tone. '
          'Full JSON: $json'
        );
      }
      
      // Helper function to safely parse numbers
      num? parseNum(dynamic value) {
        if (value == null) return null;
        if (value is num) return value;
        if (value is String) return num.tryParse(value);
        return null;
      }
      
      // üîß Helper to parse JSONB arrays from Supabase
      List<String>? _parseJsonbArray(dynamic value) {
        if (value == null) return null;
        if (value is List) {
          // Already a list
          return value.map((e) => e.toString()).toList();
        }
        // If it's not a list, return null (shouldn't happen with our JSONB setup)
        return null;
      }
      
      return AIAnalysis(
        id: id,
        messageId: messageId,
        tone: tone,
        urgencyLevel: json['urgency_level'] as String?,
        intent: json['intent'] as String?,
        confidenceScore: parseNum(json['confidence_score'])?.toDouble(),
        analysisTimestamp: parseNum(json['analysis_timestamp'])?.toInt() ?? 
                           DateTime.now().millisecondsSinceEpoch ~/ 1000,
        // ‚úÖ Parse new fields
        // üîß FIXED: intensity is TEXT in database, not INT
        intensity: null, // intensity field is now TEXT in DB (very_low, low, medium, high, very_high)
        // üîß FIXED: secondaryTones is JSONB array in database
        secondaryTones: _parseJsonbArray(json['secondary_tones']),
        contextFlags: json['context_flags'] as Map<String, dynamic>?,
        anxietyAssessment: json['anxiety_assessment'] as Map<String, dynamic>?,
        boundaryAnalysis: json['boundary_analysis'] != null
            ? BoundaryAnalysis.fromJson(json['boundary_analysis'] as Map<String, dynamic>)
            : null,
        // ‚úÖ PHASE 1: Parse RSD, interpretations, evidence (with error handling)
        rsdTriggers: (json['rsd_triggers'] as List<dynamic>?)
            ?.map((e) {
              try {
                return RSDTrigger.fromJson(e as Map<String, dynamic>);
              } catch (err) {
                print('‚ö†Ô∏è Failed to parse RSD trigger: $err');
                return null;
              }
            })
            .whereType<RSDTrigger>()
            .toList(),
        alternativeInterpretations: (json['alternative_interpretations'] as List<dynamic>?)
            ?.map((e) {
              try {
                return MessageInterpretation.fromJson(e as Map<String, dynamic>);
              } catch (err) {
                print('‚ö†Ô∏è Failed to parse interpretation: $err');
                return null;
              }
            })
            .whereType<MessageInterpretation>()
            .toList(),
        evidence: (json['evidence'] as List<dynamic>?)
            ?.map((e) {
              try {
                return Evidence.fromJson(e);
              } catch (err) {
                print('‚ö†Ô∏è Failed to parse evidence: $err');
                return null;
              }
            })
            .whereType<Evidence>()
            .toList(),
      );
    } catch (e) {
      throw FormatException('Failed to parse AIAnalysis from JSON: $e\nJSON: $json');
    }
  }
  
  /// Convert to JSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'message_id': messageId,
      'tone': tone,
      'urgency_level': urgencyLevel,
      'intent': intent,
      'confidence_score': confidenceScore,
      'analysis_timestamp': analysisTimestamp,
      // ‚úÖ Include new fields
      if (intensity != null) 'intensity': intensity,
      if (secondaryTones != null) 'secondary_tones': secondaryTones,
      if (contextFlags != null) 'context_flags': contextFlags,
      if (anxietyAssessment != null) 'anxiety_assessment': anxietyAssessment,
      if (boundaryAnalysis != null) 'boundary_analysis': boundaryAnalysis!.toJson(),
      // ‚úÖ PHASE 1 fields
      if (rsdTriggers != null) 'rsd_triggers': rsdTriggers!.map((e) => e.toJson()).toList(),
      if (alternativeInterpretations != null) 'alternative_interpretations': 
          alternativeInterpretations!.map((e) => e.toJson()).toList(),
      if (evidence != null) 'evidence': evidence!.map((e) => e.toJson()).toList(),
    };
  }
  
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AIAnalysis &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          messageId == other.messageId;
  
  @override
  int get hashCode => id.hashCode ^ messageId.hashCode;
  
  @override
  String toString() {
    return 'AIAnalysis(id: $id, messageId: $messageId, tone: $tone, '
           'urgency: $urgencyLevel, intensity: $intensity, intent: $intent, confidence: $confidenceScore)';
  }
}

// ============================================================================
// PHASE 1: Smart Message Interpreter - Helper Classes
// ============================================================================

/// Boundary violation analysis
class BoundaryAnalysis {
  final bool hasViolation;
  final BoundaryViolationType type;
  final String explanation;
  final List<String> suggestedResponses;
  final int severity; // 1 = low, 2 = medium, 3 = high
  
  const BoundaryAnalysis({
    required this.hasViolation,
    required this.type,
    required this.explanation,
    required this.suggestedResponses,
    required this.severity,
  });
  
  factory BoundaryAnalysis.fromJson(Map<String, dynamic> json) {
    final typeStr = json['type'] as String? ?? 'none';
    final typeEnum = BoundaryViolationType.values.firstWhere(
      (e) => e.toString() == 'BoundaryViolationType.$typeStr',
      orElse: () => BoundaryViolationType.none,
    );
    
    return BoundaryAnalysis(
      hasViolation: json['hasViolation'] as bool? ?? false,
      type: typeEnum,
      explanation: json['explanation'] as String? ?? '',
      suggestedResponses: (json['suggestedResponses'] as List<dynamic>?)
          ?.map((e) => e.toString())
          .toList() ?? [],
      severity: (json['severity'] as num?)?.toInt() ?? 1,
    );
  }
  
  Map<String, dynamic> toJson() {
    return {
      'hasViolation': hasViolation,
      'type': type.toString().split('.').last,
      'explanation': explanation,
      'suggestedResponses': suggestedResponses,
      'severity': severity,
    };
  }
}

enum BoundaryViolationType {
  none,
  afterHours,        // Messages outside work hours
  urgentPressure,    // Pressure language ("need this NOW")
  guiltTripping,     // Manipulation tactics
  overstepping,      // Asking too much/too personal
  repeated,          // Pattern of boundary pushing
}

/// RSD Trigger model
class RSDTrigger {
  final String pattern;
  final String severity; // high, medium, low
  final String explanation;
  final String reassurance;

  const RSDTrigger({
    required this.pattern,
    required this.severity,
    required this.explanation,
    required this.reassurance,
  });

  factory RSDTrigger.fromJson(Map<String, dynamic> json) {
    return RSDTrigger(
      pattern: (json['pattern'] ?? json['trigger']) as String,
      severity: json['severity'] as String,
      explanation: json['explanation'] as String,
      reassurance: (json['reassurance'] ?? 'This is a common concern and doesn\'t reflect your worth.') as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'pattern': pattern,
      'severity': severity,
      'explanation': explanation,
      'reassurance': reassurance,
    };
  }

  bool get isHighSeverity => severity == 'high';
  bool get isMediumSeverity => severity == 'medium';
  bool get isLowSeverity => severity == 'low';
}

/// Alternative Interpretation model
class MessageInterpretation {
  final String interpretation;
  final String tone;
  final int likelihood; // 0-100
  final String reasoning;
  final List<String> contextClues;

  const MessageInterpretation({
    required this.interpretation,
    required this.tone,
    required this.likelihood,
    required this.reasoning,
    required this.contextClues,
  });

  factory MessageInterpretation.fromJson(Map<String, dynamic> json) {
    // Handle both 'likelihood' as string or int
    int parsedLikelihood;
    final likelihoodValue = json['likelihood'];
    if (likelihoodValue is int) {
      parsedLikelihood = likelihoodValue;
    } else if (likelihoodValue is String) {
      // Map text likelihood to percentage
      switch (likelihoodValue.toLowerCase()) {
        case 'high':
          parsedLikelihood = 80;
          break;
        case 'medium':
          parsedLikelihood = 50;
          break;
        case 'low':
          parsedLikelihood = 20;
          break;
        default:
          parsedLikelihood = 50;
      }
    } else {
      parsedLikelihood = 50;
    }
    
    return MessageInterpretation(
      interpretation: json['interpretation'] as String,
      tone: (json['tone'] ?? 'neutral') as String,
      likelihood: parsedLikelihood,
      reasoning: (json['reasoning'] ?? json['explanation'] ?? '') as String,
      contextClues: (json['context_clues'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ?? [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'interpretation': interpretation,
      'tone': tone,
      'likelihood': likelihood,
      'reasoning': reasoning,
      'context_clues': contextClues,
    };
  }

  bool get isLikely => likelihood >= 60;
  bool get isPossible => likelihood >= 30 && likelihood < 60;
  bool get isUnlikely => likelihood < 30;
}

/// Evidence model
class Evidence {
  final String type; // keyword, punctuation, emoji, etc.
  final String quote;
  final String supports;
  final String reasoning;

  const Evidence({
    required this.type,
    required this.quote,
    required this.supports,
    required this.reasoning,
  });

  factory Evidence.fromJson(dynamic json) {
    // Handle evidence as either object or simple string
    if (json is String) {
      return Evidence(
        type: 'keyword',
        quote: json,
        supports: 'tone',
        reasoning: 'Key phrase in message',
      );
    }
    
    final jsonMap = json as Map<String, dynamic>;
    return Evidence(
      type: (jsonMap['type'] ?? 'keyword') as String,
      quote: (jsonMap['quote'] ?? jsonMap.toString()) as String,
      supports: (jsonMap['supports'] ?? 'tone') as String,
      reasoning: (jsonMap['reasoning'] ?? '') as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'type': type,
      'quote': quote,
      'supports': supports,
      'reasoning': reasoning,
    };
  }

  bool get isKeywordEvidence => type == 'keyword';
  bool get isPunctuationEvidence => type == 'punctuation';
  bool get isEmojiEvidence => type == 'emoji';
}
</file>

<file path="frontend/lib/models/conversation_context.dart">
/// Model for conversation context
class ConversationContext {
  final String conversationId;
  final String lastDiscussed;
  final List<KeyPoint> keyPoints;
  final List<String> pendingQuestions;
  final List<SafeTopic>? safeTopics;
  final String? relationshipType;
  final bool fromCache;
  final int? cacheAge;

  ConversationContext({
    required this.conversationId,
    required this.lastDiscussed,
    required this.keyPoints,
    required this.pendingQuestions,
    this.safeTopics,
    this.relationshipType,
    this.fromCache = false,
    this.cacheAge,
  });

  factory ConversationContext.fromJson(Map<String, dynamic> json) {
    // üîß FIXED: Handle key_points that come as List<String> from backend
    List<KeyPoint> parseKeyPoints(dynamic keyPointsData) {
      if (keyPointsData == null) return [];
      
      if (keyPointsData is List<dynamic>) {
        return keyPointsData.map((e) {
          if (e is Map<String, dynamic>) {
            // Already a KeyPoint map
            return KeyPoint.fromJson(e);
          } else if (e is String) {
            // String from backend - create KeyPoint with current timestamp
            return KeyPoint(
              text: e,
              timestamp: DateTime.now().millisecondsSinceEpoch ~/ 1000,
            );
          }
          return null;
        }).whereType<KeyPoint>().toList();
      }
      return [];
    }
    
    return ConversationContext(
      conversationId: json['conversation_id'] as String? ?? '',
      lastDiscussed: json['last_discussed'] as String,
      keyPoints: parseKeyPoints(json['key_points']),
      pendingQuestions: (json['pending_questions'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ??
          [],
      safeTopics: (json['safe_topics'] as List<dynamic>?)
          ?.map((e) => SafeTopic.fromJson(e as Map<String, dynamic>))
          .toList(),
      relationshipType: json['relationship_type'] as String?,
      fromCache: json['from_cache'] as bool? ?? false,
      cacheAge: json['cache_age'] as int?,
    );
  }
}

/// Key point from conversation
class KeyPoint {
  final String text;
  final int timestamp;

  KeyPoint({
    required this.text,
    required this.timestamp,
  });

  factory KeyPoint.fromJson(Map<String, dynamic> json) {
    return KeyPoint(
      text: json['text'] as String,
      timestamp: json['timestamp'] as int,
    );
  }

  String getTimeAgo() {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final diff = now - timestamp;

    if (diff < 60) return 'just now';
    if (diff < 3600) return '${diff ~/ 60}m ago';
    if (diff < 86400) return '${diff ~/ 3600}h ago';
    if (diff < 604800) return '${diff ~/ 86400}d ago';
    return '${diff ~/ 604800}w ago';
  }
}

/// Safe topic model
class SafeTopic {
  final String id;
  final String name;
  final String emoji;
  final int frequency;

  SafeTopic({
    required this.id,
    required this.name,
    required this.emoji,
    required this.frequency,
  });

  factory SafeTopic.fromJson(Map<String, dynamic> json) {
    return SafeTopic(
      id: json['id'] as String? ?? '',
      name: json['name'] as String? ?? json['topic_name'] as String? ?? 'Topic',
      emoji: json['emoji'] as String? ?? 'üó£Ô∏è',
      frequency: json['frequency'] as int? ?? 0,
    );
  }
}
</file>

<file path="frontend/lib/services/ai_analysis_service.dart">
import 'dart:async';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/models/ai_analysis.dart';

/// üîî Event emitted when analysis starts or completes
class AnalysisEvent {
  final String messageId;
  final bool isStarting;
  
  AnalysisEvent({required this.messageId, required this.isStarting});
  
  @override
  String toString() => '${isStarting ? '‚ñ∂Ô∏è Starting' : '‚úÖ Completed'} analysis for $messageId';
}

/// Simple AI Analysis Service - Supabase only, no local persistence
/// Uses in-memory cache for current session to reduce API calls
class AIAnalysisService {
  static final AIAnalysisService _instance = AIAnalysisService._internal();
  
  final _supabase = SupabaseClientProvider.client;
  
  /// In-memory cache (cleared on app restart)
  final Map<String, AIAnalysis> _sessionCache = {};
  
  /// Pending requests to avoid duplicate API calls
  final Map<String, Future<AIAnalysis?>> _pendingRequests = {};
  
  /// üîî NEW: Stream controller for analysis completion events
  final _analysisCompletionController = StreamController<AnalysisEvent>.broadcast();
  
  /// Public stream that notifies when an analysis starts or completes
  /// Emits AnalysisEvent with messageId and whether it's starting or completed
  Stream<AnalysisEvent> get analysisEventStream => _analysisCompletionController.stream;

  AIAnalysisService._internal();
  
  factory AIAnalysisService() {
    return _instance;
  }
  
  void dispose() {
    _analysisCompletionController.close();
  }
  
  /// Request AI analysis for a message
  /// Returns cached result if available, otherwise calls Edge Function
  /// Set [skipDatabaseStorage] to true for auto-analysis (caches locally only, no DB write)
  Future<AIAnalysis?> requestAnalysis(
    String messageId,
    String messageBody, {
    List<String>? conversationContext,
    bool isFromCurrentUser = false,
    int? messageTimestamp,
    bool skipDatabaseStorage = false, // üÜï ADDED
  }) async {
    // Check session cache first
    if (_sessionCache.containsKey(messageId)) {
      print('üìä Using cached analysis for $messageId');
      final cachedAnalysis = _sessionCache[messageId];
      
      // üîî FIX: Emit completion event for cached analyses too!
      // Schedule the event to be emitted after return to avoid race conditions
      Future.microtask(() {
        print('üîî [SERVICE] Emitting completion event for cached: $messageId');
        _analysisCompletionController.add(AnalysisEvent(messageId: messageId, isStarting: false));
        print('‚úÖ [SERVICE] Event emitted! Stream has ${_analysisCompletionController.stream} listeners');
      });
      
      return cachedAnalysis;
    }
    
    // Check if request is already in progress
    if (_pendingRequests.containsKey(messageId)) {
      print('‚è≥ Analysis already in progress for $messageId');
      return _pendingRequests[messageId];
    }
    
    // Make new request
    print('ü§ñ Requesting new analysis for $messageId');
    
    // üîî NEW: Emit starting event
    print('üîî [SERVICE] Emitting starting event for: $messageId');
    _analysisCompletionController.add(AnalysisEvent(messageId: messageId, isStarting: true));
    print('‚úÖ [SERVICE] Starting event emitted!');
    
    final future = _callAnalysisAPI(
      messageId,
      messageBody,
      conversationContext,
      isFromCurrentUser,
      messageTimestamp,
      skipDatabaseStorage, // üÜï PASS THROUGH
    );
    _pendingRequests[messageId] = future;
    
    try {
      final result = await future;
      if (result != null) {
        _sessionCache[messageId] = result;
        // üîî NEW: Emit completion event for listeners
        print('üîî [SERVICE] Emitting completion event for: $messageId');
        _analysisCompletionController.add(AnalysisEvent(messageId: messageId, isStarting: false));
        print('‚úÖ [SERVICE] Completion event emitted!');
      }
      return result;
    } finally {
      _pendingRequests.remove(messageId);
    }
  }
  
  /// Call the Edge Function to analyze a message
  Future<AIAnalysis?> _callAnalysisAPI(
    String messageId,
    String messageBody,
    List<String>? conversationContext,
    bool isFromCurrentUser,
    int? messageTimestamp,
    bool skipDatabaseStorage, // üÜï ADDED
  ) async {
    try {
      final response = await _supabase.functions.invoke(
        'ai_analyze_tone', // üîß FIXED: Added missing function name
        body: {
          'message_id': messageId,
          'message_body': messageBody,
          if (conversationContext != null)
            'conversation_context': conversationContext,
          'isFromCurrentUser': isFromCurrentUser,
          // üÜï PHASE 1: Include boundary detection for incoming messages
          if (!isFromCurrentUser && messageTimestamp != null)
            'timestamp': DateTime.fromMillisecondsSinceEpoch(messageTimestamp * 1000).toIso8601String(),
          'includeBoundaryAnalysis': !isFromCurrentUser,
          'skipDatabaseStorage': skipDatabaseStorage, // üÜï NEW FLAG
        },
      );
      
      if (response.status != 200) {
        throw Exception('API returned status ${response.status}');
      }
      
      final data = response.data;
      if (data == null || !data['success']) {
        throw Exception(data?['error'] ?? 'Unknown error');
      }
      
      return AIAnalysis.fromJson(data['analysis']);
    } catch (e) {
      print('‚ùå Analysis request failed: $e');
      return null;
    }
  }
  
  /// Fetch existing analysis from Supabase
  Future<AIAnalysis?> getAnalysis(String messageId) async {
    // Check cache
    if (_sessionCache.containsKey(messageId)) {
      return _sessionCache[messageId];
    }
    
    try {
      final response = await _supabase.rpc(
        'get_message_ai_analysis',
        params: {'p_message_id': messageId},
      );
      
      if (response == null || (response as List).isEmpty) {
        return null;
      }
      
      final analysis = AIAnalysis.fromJson(response[0]);
      _sessionCache[messageId] = analysis;
      return analysis;
    } catch (e) {
      print('‚ùå Failed to fetch analysis: $e');
      return null;
    }
  }
  
  /// Fetch all analyses for a conversation
  Future<Map<String, AIAnalysis>> getConversationAnalyses(
    String conversationId,
  ) async {
    try {
      final response = await _supabase.rpc(
        'get_conversation_ai_analysis',
        params: {'p_conversation_id': conversationId},
      );
      
      if (response == null || (response as List).isEmpty) {
        return {};
      }
      
      final Map<String, AIAnalysis> analyses = {};
      for (final item in response) {
        final analysis = AIAnalysis.fromJson(item);
        analyses[analysis.messageId] = analysis;
        _sessionCache[analysis.messageId] = analysis; // Cache it
      }
      
      return analyses;
    } catch (e) {
      print('‚ùå Failed to fetch conversation analyses: $e');
      return {};
    }
  }
  
  /// Clear the session cache
  void clearCache() {
    _sessionCache.clear();
    print('üßπ Analysis cache cleared');
  }
  
  /// Get cache statistics
  Map<String, dynamic> getCacheStats() {
    return {
      'cached_count': _sessionCache.length,
      'pending_count': _pendingRequests.length,
    };
  }
}
</file>

<file path="frontend/lib/services/auth_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/services/device_registration_service.dart';
import 'package:messageai/services/notification_service.dart';
import 'package:messageai/core/errors/error_handler.dart';

class AuthService {
  static final AuthService _instance = AuthService._internal();

  factory AuthService() {
    return _instance;
  }

  AuthService._internal();

  final _supabase = SupabaseClientProvider.client;
  final _deviceRegistrationService = DeviceRegistrationService();
  final _notificationService = NotificationService();
  final _errorHandler = ErrorHandler();

  /// Sign up with email and password
  Future<AuthResponse> signUp({
    required String email,
    required String password,
  }) async {
    try {
      print('üìù Attempting sign up for: $email');
      
      final response = await _supabase.auth.signUp(
        email: email,
        password: password,
      );
      
      print('‚úÖ Sign up successful: ${response.user?.id}');
      return response;
    } catch (error, stackTrace) {
      print('‚ùå Sign up failed: $error');
      throw _errorHandler.handleError(error, stackTrace: stackTrace, context: 'Sign Up');
    }
  }

  /// Sign in with email and password
  Future<AuthResponse> signIn({
    required String email,
    required String password,
  }) async {
    try {
      print('üîê Attempting sign in for: $email');
      
      final response = await _supabase.auth.signInWithPassword(
        email: email,
        password: password,
      );
      
      print('‚úÖ Sign in successful: ${response.user?.id}');
      return response;
    } catch (error, stackTrace) {
      print('‚ùå Sign in failed: $error');
      throw _errorHandler.handleError(error, stackTrace: stackTrace, context: 'Sign In');
    }
  }

  /// Sign out
  Future<void> signOut() async {
    try {
      print('üëã Attempting sign out');
      
      // Unregister device token before signing out
      final token = await _notificationService.getDeviceToken();
      if (token != null) {
        try {
          await _deviceRegistrationService.unregisterDeviceToken(token);
          print('‚úÖ Device token unregistered on sign out');
        } catch (e) {
          print('‚ö†Ô∏è  Failed to unregister device token: $e');
          // Continue with sign out even if unregistration fails
        }
      }
      
      await _supabase.auth.signOut();
      print('‚úÖ Sign out successful');
    } catch (error, stackTrace) {
      print('‚ùå Sign out failed: $error');
      throw _errorHandler.handleError(error, stackTrace: stackTrace, context: 'Sign Out');
    }
  }

  /// Get current user
  User? getCurrentUser() {
    return _supabase.auth.currentUser;
  }

  /// Check if user is authenticated
  bool isAuthenticated() {
    return _supabase.auth.currentUser != null;
  }

  /// Get current session
  Session? getCurrentSession() {
    return _supabase.auth.currentSession;
  }
}
</file>

<file path="frontend/lib/services/context_preloader_service.dart">
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/models/conversation_context.dart';

/// Service for loading conversation context
class ContextPreloaderService {
  static final ContextPreloaderService _instance =
      ContextPreloaderService._internal();
  factory ContextPreloaderService() => _instance;
  ContextPreloaderService._internal();

  static String get baseUrl {
    final supabaseUrl = SupabaseClientProvider.client.supabaseUrl;
    return '$supabaseUrl/functions/v1';
  }

  // In-memory cache
  final Map<String, ConversationContext> _cache = {};

  /// Load context for a conversation
  Future<ConversationContext> loadContext(String conversationId) async {
    // Check in-memory cache first
    if (_cache.containsKey(conversationId)) {
      final cached = _cache[conversationId]!;
      // Return if less than 5 minutes old
      if (cached.cacheAge != null && cached.cacheAge! < 300) {
        return cached;
      }
    }

    try {
      final token =
          SupabaseClientProvider.client.auth.currentSession?.accessToken;
      if (token == null) {
        throw Exception('Not authenticated');
      }

      final response = await http.post(
        Uri.parse('$baseUrl/ai-context-preloader'),
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
        body: jsonEncode({
          'conversation_id': conversationId,
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true) {
          final context = ConversationContext.fromJson({
            'conversation_id': conversationId,
            ...data['context'],
            'from_cache': data['from_cache'],
          });

          // Update in-memory cache
          _cache[conversationId] = context;

          return context;
        } else {
          throw Exception(data['error'] ?? 'Failed to load context');
        }
      } else {
        // Log more details for 400+ errors
        print('‚ùå Context preloader error: HTTP ${response.statusCode}');
        print('   Response body: ${response.body}');
        throw Exception('HTTP ${response.statusCode}: ${response.body}');
      }
    } catch (e) {
      print('Error loading context: $e');
      rethrow;
    }
  }

  /// Preload context for multiple conversations
  Future<void> preloadContexts(List<String> conversationIds) async {
    // Load in parallel with rate limiting
    final futures = conversationIds.take(5).map((id) => loadContext(id));
    await Future.wait(futures, eagerError: false);
  }

  /// Preload context for a conversation (alias for loadContext)
  Future<ConversationContext> preloadContext(String conversationId) async {
    return loadContext(conversationId);
  }

  /// Search for similar messages using semantic search
  Future<List<Map<String, dynamic>>> searchSimilarMessages({
    required String query,
    String? conversationId,
    int limit = 5,
  }) async {
    try {
      final token =
          SupabaseClientProvider.client.auth.currentSession?.accessToken;
      if (token == null) {
        throw Exception('Not authenticated');
      }

      final response = await http.post(
        Uri.parse('$baseUrl/ai-generate-embeddings'),
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
        body: jsonEncode({
          'query': query,
          'conversation_id': conversationId,
          'limit': limit,
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true) {
          return List<Map<String, dynamic>>.from(data['results'] ?? []);
        } else {
          throw Exception(data['error'] ?? 'Search failed');
        }
      } else {
        throw Exception('HTTP ${response.statusCode}: ${response.body}');
      }
    } catch (e) {
      print('Error searching similar messages: $e');
      return [];
    }
  }

  /// Generate embedding for text
  Future<List<double>> generateEmbedding(String text) async {
    try {
      final token =
          SupabaseClientProvider.client.auth.currentSession?.accessToken;
      if (token == null) {
        throw Exception('Not authenticated');
      }

      final response = await http.post(
        Uri.parse('$baseUrl/ai-generate-embeddings'),
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
        body: jsonEncode({
          'text': text,
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true && data['embedding'] != null) {
          return List<double>.from(data['embedding']);
        } else {
          throw Exception(data['error'] ?? 'Embedding generation failed');
        }
      } else {
        throw Exception('HTTP ${response.statusCode}: ${response.body}');
      }
    } catch (e) {
      print('Error generating embedding: $e');
      return [];
    }
  }

  /// Invalidate cache for a conversation
  void invalidateCache([String? conversationId]) {
    if (conversationId != null) {
      _cache.remove(conversationId);
    } else {
      _cache.clear();
    }
  }

  /// Clear cache (alias for backwards compatibility)
  void clearCache() {
    _cache.clear();
  }
}
</file>

<file path="frontend/lib/services/conversation_service.dart">
import 'package:uuid/uuid.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';

class ConversationService {
  static final ConversationService _instance =
      ConversationService._internal();

  factory ConversationService() {
    return _instance;
  }

  ConversationService._internal();

  final _db = AppDb.instance;
  final _supabase = SupabaseClientProvider.client;

  /// Create a new conversation
  Future<Conversation> createConversation({
    required String title,
    String? description,
    bool isGroup = false,
  }) async {
    final currentUser = _supabase.auth.currentUser;
    if (currentUser == null) {
      throw 'User not authenticated';
    }

    final now = DateTime.now();
    final timestamp = now.millisecondsSinceEpoch ~/ 1000;
    final conversationId = const Uuid().v4();
    
    final conversation = Conversation(
      id: conversationId,
      title: title,
      description: description,
      createdAt: timestamp,
      updatedAt: timestamp,
      isGroup: isGroup,
      lastMessageAt: timestamp,
      isSynced: false,
    );

    // Save to local database first (optimistic UI)
    await _db.conversationDao.upsertConversation(conversation);

    // Sync to backend
    try {
      // Create conversation in backend
      await _supabase.from('conversations').insert({
        'id': conversationId,
        'title': title,
        'description': description,
        'is_group': isGroup,
        'created_by': currentUser.id,
        'created_at': DateTime.fromMillisecondsSinceEpoch(timestamp * 1000).toIso8601String(),
        'updated_at': DateTime.fromMillisecondsSinceEpoch(timestamp * 1000).toIso8601String(),
      });

      // Add current user as participant
      final participantId = const Uuid().v4();
      await _supabase.from('conversation_participants').insert({
        'id': participantId,
        'conversation_id': conversationId,
        'user_id': currentUser.id,
        'joined_at': DateTime.fromMillisecondsSinceEpoch(timestamp * 1000).toIso8601String(),
      });

      // Save participant locally
      await _db.participantDao.addParticipant(Participant(
        id: participantId,
        conversationId: conversationId,
        userId: currentUser.id,
        joinedAt: timestamp,
        isAdmin: true,
        isSynced: true,
      ));

      // Mark conversation as synced
      await _db.conversationDao.markConversationAsSynced(conversationId);
      
      print('Conversation synced to backend: $conversationId');
    } catch (e) {
      print('Error syncing conversation to backend: $e');
      // Conversation stays in local DB with isSynced=false for retry later
    }

    return conversation;
  }

  /// Sync conversations from backend
  Future<void> syncConversations() async {
    try {
      print('üîÑ Syncing conversations from backend...');
      
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        print('‚ùå User not authenticated, skipping sync');
        return;
      }

      // Fetch conversations where user is a participant
      final response = await _supabase
          .from('conversation_participants')
          .select('conversation_id')
          .eq('user_id', currentUser.id);

      final conversationIds = (response as List)
          .map((p) => p['conversation_id'] as String)
          .toList();

      if (conversationIds.isEmpty) {
        print('‚ÑπÔ∏è  No conversations found for user');
        return;
      }

      // Fetch full conversation details
      final conversationsResponse = await _supabase
          .from('conversations')
          .select('*')
          .in_('id', conversationIds);

      print('üì• Fetched ${(conversationsResponse as List).length} conversations from backend');

      // Save to local database
      for (final convData in conversationsResponse) {
        final conversation = Conversation(
          id: convData['id'] as String,
          title: convData['title'] as String,
          description: convData['description'] as String?,
          createdAt: DateTime.parse(convData['created_at'] as String)
              .millisecondsSinceEpoch ~/
              1000,
          updatedAt: DateTime.parse(convData['updated_at'] as String)
              .millisecondsSinceEpoch ~/
              1000,
          isGroup: convData['is_group'] as bool? ?? false,
          lastMessageAt: convData['last_message_at'] != null
              ? DateTime.parse(convData['last_message_at'] as String)
                  .millisecondsSinceEpoch ~/
                  1000
              : DateTime.parse(convData['created_at'] as String)
                  .millisecondsSinceEpoch ~/
                  1000,
          isSynced: true,
        );

        await _db.conversationDao.upsertConversation(conversation);
      }

      print('‚úÖ Conversations synced successfully');
    } catch (e) {
      print('‚ùå Error syncing conversations: $e');
    }
  }

  /// Get all conversations (with optional sync)
  Future<List<Conversation>> getAllConversations({bool syncFirst = true}) async {
    if (syncFirst) {
      await syncConversations();
    }
    return _db.conversationDao.getAllConversations();
  }

  /// Get recent conversations
  Future<List<Conversation>> getRecentConversations({int limit = 20}) async {
    return _db.conversationDao.getRecentConversations(limit: limit);
  }

  /// Get conversation by ID
  Future<Conversation?> getConversationById(String id) async {
    return _db.conversationDao.getConversationById(id);
  }

  /// Delete conversation (local and remote)
  Future<void> deleteConversation(String id) async {
    final currentUser = _supabase.auth.currentUser;
    print('‚îÅ' * 60);
    print('üóëÔ∏è DELETING CONVERSATION');
    print('‚îÅ' * 60);
    print('Conversation ID: $id');
    print('User ID: ${currentUser?.id}');
    
    // Delete from local database first
    await _db.conversationDao.deleteConversation(id);
    print('‚úÖ Deleted from local database');
    
    // Try to delete from Supabase
    try {
      print('Attempting to delete from Supabase...');
      
      // Delete from Supabase (CASCADE will delete participants and messages)
      await _supabase
          .from('conversations')
          .delete()
          .eq('id', id);
      
      print('‚úÖ Conversation deleted from backend: $id');
      print('‚îÅ' * 60);
    } catch (e) {
      print('‚îÅ' * 60);
      print('‚ùå ERROR DELETING FROM BACKEND');
      print('‚îÅ' * 60);
      print('Error: $e');
      print('Error Type: ${e.runtimeType}');
      
      if (e.toString().contains('row-level security')) {
        print('üîí RLS POLICY BLOCKING DELETE!');
        print('Solution: Run the SQL in FIX_DELETE_CONVERSATION.md');
      }
      
      print('‚îÅ' * 60);
      // Already deleted locally, so this is non-critical
      // But we should rethrow so the UI can show the error
      rethrow;
    }
  }

  /// Update conversation title
  Future<void> updateConversationTitle(String id, String title) async {
    final conv = await getConversationById(id);
    if (conv != null) {
      final updated = conv.copyWith(
        title: title,
        updatedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );
      await _db.conversationDao.upsertConversation(updated);
    }
  }

  /// Count conversations
  Future<int> getConversationCount() async {
    return _db.conversationDao.getConversationCount();
  }

  /// Sync participants from backend
  Future<void> syncParticipants(String conversationId) async {
    try {
      print('üîÑ Syncing participants for conversation: $conversationId');
      
      // Fetch participants from backend
      final response = await _supabase
          .from('conversation_participants')
          .select('*')
          .eq('conversation_id', conversationId);

      print('üì• Fetched ${(response as List).length} participants from backend');

      // Save participants to local database
      for (final partData in response) {
        final participant = Participant(
          id: partData['id'] as String,
          conversationId: partData['conversation_id'] as String,
          userId: partData['user_id'] as String,
          joinedAt: DateTime.parse(partData['joined_at'] as String)
              .millisecondsSinceEpoch ~/
              1000,
          isAdmin: partData['is_admin'] as bool? ?? false,
          isSynced: true,
        );
        
        await _db.participantDao.addParticipant(participant);
      }

      print('‚úÖ Participants synced successfully');
    } catch (e) {
      print('‚ùå Error syncing participants: $e');
    }
  }

  /// Get participants in a conversation
  Future<List<Participant>> getParticipants(String conversationId, {bool syncFirst = true}) async {
    if (syncFirst) {
      await syncParticipants(conversationId);
    }
    return _db.participantDao.getParticipantsByConversation(conversationId);
  }
  
  /// Get participant profile from Supabase by user ID
  Future<Map<String, dynamic>?> getParticipantProfile(String userId) async {
    try {
      final response = await _supabase
          .from('profiles')
          .select('user_id, username, email, avatar_url, display_name')
          .eq('user_id', userId)
          .single();
      
      return response as Map<String, dynamic>;
    } catch (e) {
      print('Error fetching profile for $userId: $e');
      return null;
    }
  }

  /// Add participant to conversation
  Future<void> addParticipant({
    required String conversationId,
    required String userId,
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final participantId = const Uuid().v4();
    
    final participant = Participant(
      id: participantId,
      conversationId: conversationId,
      userId: userId,
      joinedAt: now,
      isAdmin: false,
      isSynced: false,
    );
    
    // Save to local database first (optimistic UI)
    await _db.participantDao.addParticipant(participant);
    
    // Sync to backend
    try {
      await _supabase.from('conversation_participants').insert({
        'id': participantId,
        'conversation_id': conversationId,
        'user_id': userId,
        'joined_at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
      });
      
      print('Participant added to backend: $userId');
    } catch (e) {
      print('Error syncing participant to backend: $e');
    }
  }

  /// Remove participant from conversation
  Future<void> removeParticipant(String conversationId, String userId) async {
    await _db.participantDao.removeParticipant(conversationId, userId);
  }

  /// Add current user as participant to conversation
  Future<void> addCurrentUserAsParticipant(String conversationId) async {
    // This would typically be called after creating a conversation
    // For now, we'll add the creator automatically in createConversation
  }

  /// Get the latest message for a conversation
  Future<Message?> getLatestMessage(String conversationId) async {
    return _db.messageDao.getLatestMessageForConversation(conversationId);
  }
}
</file>

<file path="frontend/lib/services/device_registration_service.dart">
import 'dart:io' show Platform;
import 'package:messageai/data/remote/supabase_client.dart';

/// Service for registering and managing device tokens with the backend
class DeviceRegistrationService {
  /// Register or update device token in Supabase
  Future<void> registerDeviceToken(String token) async {
    try {
      final supabase = SupabaseClientProvider.client;
      final userId = supabase.auth.currentUser?.id;
      
      if (userId == null) {
        print('‚ö†Ô∏è Cannot register device: user not authenticated');
        throw Exception('User not authenticated');
      }
      
      // Determine platform
      String platform;
      if (Platform.isIOS) {
        platform = 'ios';
      } else if (Platform.isAndroid) {
        platform = 'android';
      } else {
        platform = 'web';
      }
      
      print('üì± Registering device token...');
      print('   User ID: $userId');
      print('   Platform: $platform');
      print('   Token: ${token.substring(0, 20)}...');
      
      // Use secure function to bypass RLS issues
      await supabase.rpc('upsert_device_token', params: {
        'p_fcm_token': token,
        'p_platform': platform,
      });
      
      print('‚úÖ Device token registered successfully!');
    } catch (e) {
      print('‚ùå Failed to register device token: $e');
      rethrow;
    }
  }
  
  /// Unregister device token (e.g., on logout)
  Future<void> unregisterDeviceToken(String token) async {
    try {
      final supabase = SupabaseClientProvider.client;
      
      print('üóëÔ∏è Unregistering device token...');
      
      await supabase
          .from('profile_devices')
          .delete()
          .eq('fcm_token', token);
      
      print('‚úÖ Device token unregistered');
    } catch (e) {
      print('‚ùå Failed to unregister device token: $e');
      rethrow;
    }
  }
  
  /// Update last seen timestamp for device
  Future<void> updateDeviceLastSeen(String token) async {
    try {
      final supabase = SupabaseClientProvider.client;
      
      print('üîÑ Updating last_seen for token: ${token.substring(0, 20)}...');
      
      final response = await supabase
          .from('profile_devices')
          .update({
            'last_seen': DateTime.now().toIso8601String(),
          })
          .eq('fcm_token', token)
          .select();
      
      if (response.isEmpty) {
        print('‚ö†Ô∏è No device found with that token - device may not be registered');
      } else {
        print('‚úÖ Device last_seen updated successfully');
      }
    } catch (e) {
      print('‚ùå Failed to update device last_seen: $e');
      // Don't rethrow - this is not critical
    }
  }
}
</file>

<file path="frontend/lib/services/local_notification_service.dart">
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter/material.dart';

/// Local notification service for displaying notifications in foreground
class LocalNotificationService {
  static const String _channelId = 'messages';
  static const String _channelName = 'Message Notifications';
  
  final FlutterLocalNotificationsPlugin _plugin;

  LocalNotificationService({FlutterLocalNotificationsPlugin? plugin})
      : _plugin = plugin ?? FlutterLocalNotificationsPlugin();

  /// Initialize local notifications
  Future<void> initialize() async {
    try {
      // Android initialization
      const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');

      // iOS initialization
      const iosSettings = DarwinInitializationSettings(
        requestAlertPermission: true,
        requestBadgePermission: true,
        requestSoundPermission: true,
      );

      const settings = InitializationSettings(
        android: androidSettings,
        iOS: iosSettings,
      );

      await _plugin.initialize(settings);
      print('Local notifications initialized');
    } catch (e) {
      print('Error initializing local notifications: $e');
    }
  }

  /// Show a notification
  Future<void> showNotification({
    required int id,
    required String title,
    required String body,
    String? payload,
  }) async {
    try {
      // Android notification details
      const androidDetails = AndroidNotificationDetails(
        _channelId,
        _channelName,
        channelDescription: 'Notifications for incoming messages',
        importance: Importance.max,
        priority: Priority.high,
        showWhen: true,
        enableVibration: true,
        playSound: true,
        icon: '@mipmap/ic_launcher',
      );

      // iOS notification details
      const iosDetails = DarwinNotificationDetails(
        presentAlert: true,
        presentBadge: true,
        presentSound: true,
        badgeNumber: 1,
      );

      const details = NotificationDetails(
        android: androidDetails,
        iOS: iosDetails,
      );

      await _plugin.show(
        id,
        title,
        body,
        details,
        payload: payload,
      );

      print('Notification shown: $title - $body');
    } catch (e) {
      print('Error showing notification: $e');
    }
  }

  /// Show message notification
  Future<void> showMessageNotification({
    required String conversationId,
    required String senderName,
    required String messageBody,
  }) async {
    final id = conversationId.hashCode % 100000;
    await showNotification(
      id: id,
      title: senderName,
      body: messageBody,
      payload: conversationId,
    );
  }

  /// Cancel a notification
  Future<void> cancelNotification(int id) async {
    try {
      await _plugin.cancel(id);
    } catch (e) {
      print('Error canceling notification: $e');
    }
  }

  /// Cancel all notifications
  Future<void> cancelAllNotifications() async {
    try {
      await _plugin.cancelAll();
    } catch (e) {
      print('Error canceling all notifications: $e');
    }
  }

  /// Get pending notifications
  Future<List<PendingNotificationRequest>> getPendingNotifications() async {
    try {
      return await _plugin.pendingNotificationRequests();
    } catch (e) {
      print('Error getting pending notifications: $e');
      return [];
    }
  }

  /// Setup notification response handler
  void setupNotificationResponseHandler({
    required Function(String) onNotificationTapped,
  }) {
    _plugin.getNotificationAppLaunchDetails().then((details) {
      if (details?.didNotificationLaunchApp ?? false) {
        final payload = details?.notificationResponse?.payload;
        if (payload != null) {
          onNotificationTapped(payload);
        }
      }
    });

    // Listen for notification taps in foreground
  }

  /// Request notification permissions (Android 13+)
  Future<bool> requestPermissions() async {
    try {
      final result = await _plugin
          .resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin>()
          ?.requestNotificationsPermission();
      return result ?? false;
    } catch (e) {
      print('Error requesting permissions: $e');
      return false;
    }
  }
}
</file>

<file path="frontend/lib/services/message_interpreter_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'dart:async';

/// Service for interpreting messages (Phase 1: Smart Message Interpreter)
/// Calls ai-interpret-message Edge Function which returns enhanced tone analysis
/// with RSD triggers, alternative interpretations, and evidence
class MessageInterpreterService {
  final SupabaseClient _supabase;

  MessageInterpreterService(this._supabase);

  /// Interpret a message with alternative meanings, RSD detection, and evidence
  /// Returns full AIAnalysis with enhanced interpretation fields
  Future<AIAnalysis> interpretMessage(String messageId, String messageBody) async {
    try {
      print('üîç Interpreting message...');
      
      // üîß Add timeout to prevent hanging
      final response = await _supabase.functions.invoke(
        'ai-interpret-message',
        body: {
          'message_id': messageId,
          'message_body': messageBody,
        },
      ).timeout(
        const Duration(seconds: 15), // üÜï 15 second timeout for deeper interpretation
        onTimeout: () {
          throw TimeoutException('Message interpretation timed out');
        },
      );

      if (response.data == null) {
        throw Exception('No response from message interpreter service');
      }

      final data = response.data as Map<String, dynamic>;
      
      if (data['success'] != true) {
        throw Exception(data['error'] ?? 'Message interpretation failed');
      }

      // Backend returns full enhanced tone analysis with interpretations
      final analysis = AIAnalysis.fromJson(
        data['interpretation'] as Map<String, dynamic>,
      );
      
      print('‚úÖ Message interpreted: '
            '${analysis.alternativeInterpretations?.length ?? 0} alternatives, '
            '${analysis.rsdTriggers?.length ?? 0} RSD triggers');
      
      return analysis;
    } catch (e) {
      print('‚ùå Error interpreting message: $e');
      rethrow;
    }
  }

  /// Quick check: does message have RSD triggers?
  Future<bool> hasRsdTriggers(String messageId, String messageBody) async {
    final analysis = await interpretMessage(messageId, messageBody);
    return analysis.rsdTriggers?.isNotEmpty ?? false;
  }

  /// Get alternative interpretations for a message
  Future<List<MessageInterpretation>> getAlternativeInterpretations(
    String messageId, 
    String messageBody,
  ) async {
    final analysis = await interpretMessage(messageId, messageBody);
    return analysis.alternativeInterpretations ?? [];
  }

  /// Get RSD triggers for a message
  Future<List<RSDTrigger>> getRsdTriggers(
    String messageId,
    String messageBody,
  ) async {
    final analysis = await interpretMessage(messageId, messageBody);
    return analysis.rsdTriggers ?? [];
  }

  /// Get evidence points for interpretation
  Future<List<Evidence>> getEvidence(
    String messageId,
    String messageBody,
  ) async {
    final analysis = await interpretMessage(messageId, messageBody);
    return analysis.evidence ?? [];
  }
}
</file>

<file path="frontend/lib/services/relationship_summary_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/models/relationship_profile.dart';

/// Service for generating relationship summaries (Phase 3: Context System)
class RelationshipSummaryService {
  final SupabaseClient _supabase;

  RelationshipSummaryService(this._supabase);

  /// Generate or update relationship summary
  Future<RelationshipProfile> generateSummary({
    required String conversationId,
    bool forceRegenerate = false,
  }) async {
    try {
      print('üë• Generating relationship summary...');
      
      final response = await _supabase.functions.invoke(
        'ai-relationship-summary',
        body: {
          'conversation_id': conversationId,
          'force_regenerate': forceRegenerate,
        },
      );

      if (response.data == null) {
        throw Exception('No response from relationship summary service');
      }

      final data = response.data as Map<String, dynamic>;
      
      if (data['success'] != true) {
        throw Exception(data['error'] ?? 'Summary generation failed');
      }

      final profile = RelationshipProfile.fromJson(
        data['profile'] as Map<String, dynamic>,
      );
      
      print('‚úÖ Relationship summary generated');
      
      return profile;
    } catch (e) {
      print('‚ùå Error generating relationship summary: $e');
      rethrow;
    }
  }

  /// Refresh relationship summary (force regenerate)
  Future<RelationshipProfile> refreshSummary({
    required String conversationId,
  }) async {
    return generateSummary(
      conversationId: conversationId,
      forceRegenerate: true,
    );
  }
}
</file>

<file path="frontend/lib/state/ai_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart' hide Provider;
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/models/draft_analysis.dart';
import 'package:messageai/models/relationship_profile.dart';
import 'package:messageai/models/follow_up_item.dart';
import 'package:messageai/services/ai_analysis_service.dart';
import 'package:messageai/services/draft_analysis_service.dart';
import 'package:messageai/services/message_interpreter_service.dart';
import 'package:messageai/services/response_template_service.dart';
import 'package:messageai/services/message_formatter_service.dart';
import 'package:messageai/services/relationship_service.dart';
import 'package:messageai/services/relationship_summary_service.dart';
import 'package:messageai/services/context_preloader_service.dart';
import 'package:messageai/services/follow_up_service.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/state/providers.dart';

/// Provider for AI Analysis Service singleton
final aiAnalysisServiceProvider = Provider<AIAnalysisService>((ref) {
  return AIAnalysisService();
});

/// Provider for Message Interpreter Service (Phase 1: Smart Message Interpreter)
final messageInterpreterServiceProvider = Provider<MessageInterpreterService>((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  return MessageInterpreterService(supabase);
});

// =============================================================================
// PHASE 2: Adaptive Response Assistant Providers
// =============================================================================

/// Provider for Response Template Service (Phase 2)
final responseTemplateServiceProvider = Provider<ResponseTemplateService>((ref) {
  final service = ResponseTemplateService();
  // Initialize templates on first access
  service.loadTemplates();
  return service;
});

/// Provider for Message Formatter Service (Phase 2)
final messageFormatterServiceProvider = Provider<MessageFormatterService>((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  return MessageFormatterService(supabase);
});

/// StateNotifier to track when to refresh analysis
class AnalysisRefreshNotifier extends StateNotifier<int> {
  AnalysisRefreshNotifier() : super(0);
  
  void refresh() {
    state++;
  }
}

final analysisRefreshProvider = StateNotifierProvider<AnalysisRefreshNotifier, int>((ref) {
  final notifier = AnalysisRefreshNotifier();
  
  // Listen to realtime updates on message_ai_analysis table
  final supabase = SupabaseClientProvider.client;
  final channel = supabase.realtime.channel('ai_analysis_updates');
  
  channel.on(
    RealtimeListenTypes.postgresChanges,
    ChannelFilter(
      event: 'INSERT',
      schema: 'public',
      table: 'message_ai_analysis',
    ),
    (payload, [ref]) {
      print('üîÑ AI analysis updated, refreshing providers...');
      notifier.refresh();
    },
  );
  
  channel.subscribe(
    (status, [error]) {
      if (status == 'SUBSCRIBED') {
        print('‚úÖ AI analysis realtime listener subscribed');
      } else if (error != null) {
        print('‚ùå AI analysis realtime error: $error');
      }
    },
  );
  
  ref.onDispose(() {
    channel.unsubscribe();
  });
  
  return notifier;
});

/// Fetch analysis for a single message (auto-refreshes on realtime updates)
final messageAnalysisProvider = FutureProvider.family<AIAnalysis?, String>(
  (ref, messageId) async {
    // Watch the refresh notifier to trigger rebuilds
    ref.watch(analysisRefreshProvider);
    
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getAnalysis(messageId);
  },
);

/// Fetch all analyses for a conversation (auto-refreshes on realtime updates)
final conversationAnalysisProvider = FutureProvider.family<Map<String, AIAnalysis>, String>(
  (ref, conversationId) async {
    // Watch the refresh notifier to trigger rebuilds
    ref.watch(analysisRefreshProvider);
    
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getConversationAnalyses(conversationId);
  },
);

/// Provider for triggering analysis requests
final requestAnalysisProvider = Provider((ref) {
  final service = ref.watch(aiAnalysisServiceProvider);
  return (String messageId, String messageBody) => 
      service.requestAnalysis(messageId, messageBody);
});

// =============================================================================
// DRAFT ANALYSIS PROVIDERS (for outgoing messages)
// =============================================================================

/// Provider for Draft Analysis Service
final draftAnalysisServiceProvider = Provider<DraftAnalysisService>((ref) {
  final supabase = SupabaseClientProvider.client;
  return DraftAnalysisService(supabase);
});

/// State notifier for managing draft analysis state (manual trigger)
class DraftAnalysisNotifier extends StateNotifier<AsyncValue<DraftAnalysis?>> {
  final DraftAnalysisService _service;

  DraftAnalysisNotifier(this._service) : super(const AsyncValue.data(null));

  /// Analyze a draft (called when user clicks "Check Message" button)
  Future<void> analyzeDraft({
    required String draftMessage,
    String? conversationId,
    RelationshipType? relationshipType,
    List<String>? conversationHistory,
  }) async {
    // Clear if draft is empty
    if (draftMessage.trim().isEmpty) {
      state = const AsyncValue.data(null);
      return;
    }

    // Set loading state
    state = const AsyncValue.loading();

    try {
      final analysis = await _service.analyzeDraft(
        draftMessage: draftMessage,
        conversationId: conversationId,
        relationshipType: relationshipType,
        conversationHistory: conversationHistory,
      );
      state = AsyncValue.data(analysis);
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  /// Clear current analysis
  void clear() {
    state = const AsyncValue.data(null);
  }
}

/// Provider for draft analysis state (manual trigger)
final draftAnalysisProvider =
    StateNotifierProvider<DraftAnalysisNotifier, AsyncValue<DraftAnalysis?>>(
  (ref) {
    final service = ref.watch(draftAnalysisServiceProvider);
    return DraftAnalysisNotifier(service);
  },
);

// =============================================================================
// PHASE 3: Smart Inbox with Context Providers
// =============================================================================

/// Provider for Relationship Service (Phase 3)
final relationshipServiceProvider = Provider<RelationshipService>((ref) {
  return RelationshipService();
});

/// Provider for Relationship Summary Service (Phase 3)
final relationshipSummaryServiceProvider = Provider<RelationshipSummaryService>((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  return RelationshipSummaryService(supabase);
});

/// Provider for Context Preloader Service (Phase 3)
final contextPreloaderServiceProvider = Provider<ContextPreloaderService>((ref) {
  return ContextPreloaderService();
});

/// Provider to fetch relationship profile for a conversation
final relationshipProfileProvider = FutureProvider.family<RelationshipProfile?, String>(
  (ref, conversationId) async {
    final service = ref.watch(relationshipServiceProvider);
    return await service.getProfile(conversationId);
  },
);

/// Provider to generate/refresh relationship summary
/// This is a manual trigger - call ref.refresh(generateRelationshipSummaryProvider(conversationId))
final generateRelationshipSummaryProvider = FutureProvider.family<RelationshipProfile, String>(
  (ref, conversationId) async {
    final service = ref.watch(relationshipSummaryServiceProvider);
    return await service.generateSummary(conversationId: conversationId);
  },
);

// =============================================================================
// PHASE 4: Smart Follow-up System Providers
// =============================================================================

/// Provider for Follow-Up Service (Phase 4)
final followUpServiceProvider = Provider<FollowUpService>((ref) {
  return FollowUpService();
});

/// Provider to get all pending follow-ups for the user
final pendingFollowUpsProvider = FutureProvider<List<FollowUpItem>>((ref) async {
  final service = ref.watch(followUpServiceProvider);
  return await service.getPendingFollowUps();
});

/// Provider to get follow-ups for a specific conversation
final conversationFollowUpsProvider = FutureProvider.family<List<FollowUpItem>, String>(
  (ref, conversationId) async {
    final service = ref.watch(followUpServiceProvider);
    return await service.getConversationFollowUps(conversationId);
  },
);

/// State notifier for managing follow-up extraction
class FollowUpExtractionNotifier extends StateNotifier<AsyncValue<void>> {
  final FollowUpService _service;

  FollowUpExtractionNotifier(this._service) : super(const AsyncValue.data(null));

  /// Extract follow-ups from a conversation
  Future<void> extractFollowUps(String conversationId, {bool scanAll = false}) async {
    state = const AsyncValue.loading();
    
    try {
      await _service.extractFollowUps(conversationId, scanAll: scanAll);
      state = const AsyncValue.data(null);
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }
}

/// Provider for follow-up extraction (manual trigger)
final followUpExtractionProvider = StateNotifierProvider<FollowUpExtractionNotifier, AsyncValue<void>>(
  (ref) {
    final service = ref.watch(followUpServiceProvider);
    return FollowUpExtractionNotifier(service);
  },
);
</file>

<file path="frontend/lib/state/database_provider.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/conversation_dao.dart';
import 'package:messageai/data/drift/daos/message_dao.dart';
import 'package:messageai/data/drift/daos/participant_dao.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';

/// Provides the main database instance
final appDbProvider = Provider<AppDb>((ref) {
  return AppDb.instance;
});

/// Provides the ConversationDao
final conversationDaoProvider = Provider<ConversationDao>((ref) {
  final db = ref.watch(appDbProvider);
  return ConversationDao(db);
});

/// Provides the MessageDao
final messageDaoProvider = Provider<MessageDao>((ref) {
  final db = ref.watch(appDbProvider);
  return MessageDao(db);
});

/// Provides the ParticipantDao
final participantDaoProvider = Provider<ParticipantDao>((ref) {
  final db = ref.watch(appDbProvider);
  return ParticipantDao(db);
});

/// Provides the ReceiptDao
final receiptDaoProvider = Provider<ReceiptDao>((ref) {
  final db = ref.watch(appDbProvider);
  return ReceiptDao(db);
});

/// Provides the PendingOutboxDao
final pendingOutboxDaoProvider = Provider<PendingOutboxDao>((ref) {
  final db = ref.watch(appDbProvider);
  return PendingOutboxDao(db);
});

/// Stream of all conversations (watching for changes)
final conversationsStreamProvider = StreamProvider<List<Conversation>>((ref) async* {
  final dao = ref.watch(conversationDaoProvider);
  
  // Initial load
  yield await dao.getAllConversations();
  
  // TODO: Set up watch stream for real-time updates
  // For now, update every time this is accessed
});

/// Stream of messages for a specific conversation
final messagesStreamProvider = StreamProvider.family<List<Message>, String>((ref, conversationId) async* {
  final dao = ref.watch(messageDaoProvider);
  
  // Initial load
  yield await dao.getMessagesByConversation(conversationId);
  
  // TODO: Set up watch stream for real-time updates
});

/// Stream of pending operations count (for UI indicators)
final pendingOperationsCountProvider = StreamProvider<int>((ref) async* {
  final dao = ref.watch(pendingOutboxDaoProvider);
  
  // Initial load
  yield await dao.getPendingOperationCount();
  
  // TODO: Set up periodic check or subscription
});

/// Check if there are any pending operations
final hasPendingOperationsProvider = FutureProvider<bool>((ref) async {
  final dao = ref.watch(pendingOutboxDaoProvider);
  return dao.hasPendingOperations();
});
</file>

<file path="frontend/lib/state/notification_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/services/notification_service.dart';
import 'package:messageai/services/local_notification_service.dart';
import 'package:messageai/services/deep_link_handler.dart';
import 'package:messageai/services/device_registration_service.dart';
import 'package:messageai/app.dart' show navigatorKey;

/// Device token state
final deviceTokenProvider = StateProvider<String?>((ref) {
  return null;
});

/// Notification service provider
final notificationServiceProvider = Provider<NotificationService>((ref) {
  return NotificationService();
});

/// Local notification service provider
final localNotificationServiceProvider = Provider<LocalNotificationService>((ref) {
  return LocalNotificationService();
});

/// Device registration service provider
final deviceRegistrationServiceProvider = Provider<DeviceRegistrationService>((ref) {
  return DeviceRegistrationService();
});

/// Initialize notifications (Firebase + Local)
final initializeNotificationsProvider = FutureProvider<void>((ref) async {
  print('üì¢ ========================================');
  print('üì¢ STARTING NOTIFICATION INITIALIZATION');
  print('üì¢ ========================================');
  
  final fcmService = ref.watch(notificationServiceProvider);
  final localService = ref.watch(localNotificationServiceProvider);
  final deviceRegistrationService = ref.watch(deviceRegistrationServiceProvider);

  print('üì± Initializing local notifications...');
  // Initialize local notifications first
  await localService.initialize();
  print('‚úÖ Local notifications initialized');

  print('üî• Initializing Firebase Messaging...');
  // Initialize Firebase Messaging
  await fcmService.initialize(
    onMessageReceived: (payload) {
      // Handle foreground message
      _handleForegroundMessage(ref, payload, localService);
    },
    onTokenRefresh: (token) async {
      // Update device token state
      ref.read(deviceTokenProvider.notifier).state = token;
      print('üîÑ Device token refreshed: ${token.substring(0, 20)}...');
      
      // Register refreshed token with backend
      try {
        await deviceRegistrationService.registerDeviceToken(token);
        print('‚úÖ Refreshed token registered with backend');
      } catch (e) {
        print('‚ùå Failed to register refreshed token: $e');
      }
    },
  );

  // Setup notification tap handler
  await fcmService.setupNotificationTapHandler(
    onNotificationTapped: (conversationId) {
      _handleNotificationTap(ref, conversationId);
    },
  );

  // Get initial device token
  final token = await fcmService.getDeviceToken();
  if (token != null) {
    ref.read(deviceTokenProvider.notifier).state = token;
    
    // Register token with backend
    try {
      await deviceRegistrationService.registerDeviceToken(token);
      print('‚úÖ Initial token registered with backend');
    } catch (e) {
      print('‚ùå Failed to register initial token: $e');
      // Don't fail initialization if registration fails
    }
  }

  print('Notifications initialized successfully');
});

/// Handle foreground notification message
void _handleForegroundMessage(
  Ref ref,
  NotificationPayload payload,
  LocalNotificationService localService,
) async {
  try {
    final conversationId = payload.conversationId;
    final senderName = payload.data['sender_name'] as String? ?? 'New Message';
    final messageBody = payload.messageBody ?? payload.body ?? '';

    if (conversationId != null && messageBody.isNotEmpty) {
      await localService.showMessageNotification(
        conversationId: conversationId,
        senderName: senderName,
        messageBody: messageBody,
      );
    }
  } catch (e) {
    print('Error handling foreground message: $e');
  }
}

/// Handle notification tap
void _handleNotificationTap(Ref ref, String conversationId) {
  print('üì± Notification tapped: $conversationId');
  
  try {
    // Use the global navigator key to navigate
    final navigator = navigatorKey.currentState;
    
    if (navigator == null) {
      print('‚ùå Navigator not available');
      return;
    }
    
    // Navigate to conversation detail screen
    navigator.pushNamed(
      '/conversation/$conversationId',
      arguments: {'title': 'Conversation'},
    );
    
    print('‚úÖ Navigated to conversation: $conversationId');
  } catch (e) {
    print('‚ùå Error navigating to conversation: $e');
  }
}

/// Notification permission state
final notificationPermissionProvider = FutureProvider<bool>((ref) async {
  final fcmService = ref.watch(notificationServiceProvider);
  return fcmService.areNotificationsEnabled();
});

/// Subscribe to conversation topic for group notifications
final subscribeToConversationTopicProvider = FutureProvider.autoDispose
    .family<void, String>((ref, conversationId) async {
  final fcmService = ref.watch(notificationServiceProvider);
  await fcmService.subscribeToTopic('conversation_$conversationId');
});

/// Unsubscribe from conversation topic
final unsubscribeFromConversationTopicProvider = FutureProvider.autoDispose
    .family<void, String>((ref, conversationId) async {
  final fcmService = ref.watch(notificationServiceProvider);
  await fcmService.unsubscribeFromTopic('conversation_$conversationId');
});

/// Subscribe to user topic for direct messages
final subscribeToUserTopicProvider = FutureProvider<void>((ref) async {
  final fcmService = ref.watch(notificationServiceProvider);
  // Subscribe to user's personal notification topic
  // (would use current user ID in real app)
  await fcmService.subscribeToTopic('user_direct_messages');
});

/// Notification state for UI
final notificationStateProvider = StateProvider<NotificationState>((ref) {
  return const NotificationState();
});

/// Notification state model
class NotificationState {
  final bool isInitialized;
  final bool hasPermission;
  final String? deviceToken;
  final int unreadCount;
  final List<String> subscribedTopics;

  const NotificationState({
    this.isInitialized = false,
    this.hasPermission = false,
    this.deviceToken,
    this.unreadCount = 0,
    this.subscribedTopics = const [],
  });

  NotificationState copyWith({
    bool? isInitialized,
    bool? hasPermission,
    String? deviceToken,
    int? unreadCount,
    List<String>? subscribedTopics,
  }) {
    return NotificationState(
      isInitialized: isInitialized ?? this.isInitialized,
      hasPermission: hasPermission ?? this.hasPermission,
      deviceToken: deviceToken ?? this.deviceToken,
      unreadCount: unreadCount ?? this.unreadCount,
      subscribedTopics: subscribedTopics ?? this.subscribedTopics,
    );
  }
}

/// Initialize notification system
final notificationInitializerProvider = FutureProvider<void>((ref) async {
  try {
    // Initialize notifications
    await ref.watch(initializeNotificationsProvider.future);

    // Check permissions
    final hasPermission = await ref.watch(notificationPermissionProvider.future);

    // Get device token
    final deviceToken = ref.watch(deviceTokenProvider);

    // Update state
    ref.read(notificationStateProvider.notifier).state =
        ref.read(notificationStateProvider).copyWith(
          isInitialized: true,
          hasPermission: hasPermission,
          deviceToken: deviceToken,
        );

    print('Notification system initialized');
  } catch (e) {
    print('Error initializing notification system: $e');
    rethrow;
  }
});
</file>

<file path="frontend/lib/state/presence_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/providers.dart';

/// User presence status
enum PresenceStatus {
  online,
  away,
  offline,
}

/// User presence information
class UserPresence {
  final String userId;
  final String conversationId;
  final PresenceStatus status;
  final DateTime lastSeen;

  UserPresence({
    required this.userId,
    required this.conversationId,
    required this.status,
    required this.lastSeen,
  });
}

/// Manages user presence for a conversation
class PresenceManager {
  final Ref ref;
  final String conversationId;
  final String userId;
  
  PresenceManager({
    required this.ref,
    required this.conversationId,
    required this.userId,
  });

  /// Join presence channel (user is viewing conversation)
  Future<void> joinPresence() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    // Subscribe to presence channel
    final presence = supabase.channel('presence:$conversationId');

    // Subscribe to presence channel
    presence.subscribe(
      (status, [err]) {
        print('Presence subscription: $status - $err');
      },
    );

    // Track this user's presence
    await presence.track({
      'user_id': userId,
      'status': 'online',
      'last_seen': DateTime.now().toIso8601String(),
    });
  }

  /// Leave presence channel (user is no longer viewing)
  Future<void> leavePresence() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('presence:$conversationId');
    await presence.unsubscribe();
  }

  /// Update user status
  Future<void> updateStatus(PresenceStatus status) async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('presence:$conversationId');
    await presence.track({
      'user_id': userId,
      'status': status.name,
      'last_seen': DateTime.now().toIso8601String(),
    });
  }

  /// Get all users' presence in conversation
  Future<List<UserPresence>> getConversationPresence() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('presence:$conversationId');
    final state = presence.presenceState();
    
    final presences = <UserPresence>[];
    
    for (final entry in state.entries) {
      for (final presence in entry.value) {
        final presenceMap = presence as Map<String, dynamic>;
        presences.add(UserPresence(
          userId: presenceMap['user_id'] as String,
          conversationId: conversationId,
          status: PresenceStatus.values.firstWhere(
            (s) => s.name == (presenceMap['status'] as String),
            orElse: () => PresenceStatus.offline,
          ),
          lastSeen: DateTime.parse(presenceMap['last_seen'] as String),
        ));
      }
    }
    
    return presences;
  }

  /// Check if user is online
  Future<bool> isUserOnline(String otherUserId) async {
    final presences = await getConversationPresence();
    return presences.any((p) =>
        p.userId == otherUserId && p.status == PresenceStatus.online);
  }
}

/// Provider for presence manager
final presenceManagerProvider = Provider.family<PresenceManager, (String, String)>((ref, args) {
  final (conversationId, userId) = args;
  return PresenceManager(
    ref: ref,
    conversationId: conversationId,
    userId: userId,
  );
});

/// Stream of user presence in a conversation
final conversationPresenceProvider =
    StreamProvider.autoDispose.family<List<UserPresence>, String>((ref, conversationId) async* {
  // This would typically subscribe to realtime presence updates
  // For now, we'll yield an empty list
  yield [];
  
  // TODO: Set up realtime presence stream
});

/// Check if a specific user is online
final userOnlineProvider = FutureProvider.autoDispose
    .family<bool, (String, String)>((ref, args) async {
  final (conversationId, userId) = args;
  final manager = ref.watch(presenceManagerProvider((conversationId, userId)));
  return manager.isUserOnline(userId);
});
</file>

<file path="frontend/lib/state/providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart' as fpr;
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:dio/dio.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/gen/api/clients/messages_api.dart';
import 'package:messageai/gen/api/clients/receipts_api.dart';

/// Provides the Supabase client instance
final supabaseClientProvider = fpr.Provider<SupabaseClient>((ref) {
  return SupabaseClientProvider.client;
});

/// Provides the Supabase auth client
final authProvider = fpr.Provider((ref) {
  return ref.watch(supabaseClientProvider).auth;
});

/// Provides the current authenticated user
final currentUserProvider = fpr.StreamProvider((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  return supabase.auth.onAuthStateChange.map((data) => data.session?.user);
});

/// Provides a Dio HTTP client configured for the API
final dioProvider = fpr.Provider<Dio>((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  final dio = Dio(
    BaseOptions(
      baseUrl: supabase.restUrl,
      headers: {
        'Authorization': 'Bearer ${supabase.auth.currentSession?.accessToken}',
        'apikey': supabase.auth.currentSession?.user.id ?? '',
      },
    ),
  );
  return dio;
});

/// Provides the Messages API client
final messagesApiProvider = fpr.Provider<MessagesApi>((ref) {
  final dio = ref.watch(dioProvider);
  final supabase = ref.watch(supabaseClientProvider);
  return MessagesApi(
    dio: dio,
    baseUrl: supabase.restUrl,
  );
});

/// Provides the Receipts API client
final receiptsApiProvider = fpr.Provider<ReceiptsApi>((ref) {
  final dio = ref.watch(dioProvider);
  final supabase = ref.watch(supabaseClientProvider);
  return ReceiptsApi(
    dio: dio,
    baseUrl: supabase.restUrl,
  );
});

/// Indicates whether the user is currently authenticated
final isAuthenticatedProvider = fpr.StreamProvider<bool>((ref) async* {
  final authState = ref.watch(currentUserProvider);
  yield* authState.when(
    data: (user) async* {
      yield user != null;
    },
    loading: () async* {
      yield false;
    },
    error: (err, st) async* {
      yield false;
    },
  );
});
</file>

<file path="frontend/lib/state/realtime_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/state/database_provider.dart';
import 'package:messageai/state/providers.dart';

/// Manages realtime subscriptions to conversation messages
class RealtimeManager {
  final Ref ref;
  final Map<String, dynamic> _subscriptions = {};

  RealtimeManager({required this.ref});

  /// Subscribe to messages in a conversation
  void subscribeToConversationMessages(String conversationId) {
    final supabase = ref.watch(supabaseClientProvider);
    
    // Create a channel for this conversation's messages
    final subscription = supabase.channel('public:messages:$conversationId');
    
    // Subscribe to the channel
    subscription.subscribe((status, [error]) async {
      if (status == 'SUBSCRIBED') {
        // Successfully subscribed
        // Note: In Supabase v1.x, realtime postgres changes work differently
        // This is a placeholder - the actual message sync happens through
        // the existing realtime message service
      }
    });
    
    _subscriptions[conversationId] = subscription;
  }

  /// Unsubscribe from conversation messages
  Future<void> unsubscribeFromConversation(String conversationId) async {
    final subscription = _subscriptions.remove(conversationId);
    if (subscription != null) {
      await subscription.unsubscribe();
    }
  }

  /// Cleanup all subscriptions
  Future<void> cleanup() async {
    for (final subscription in _subscriptions.values) {
      await subscription.unsubscribe();
    }
    _subscriptions.clear();
  }
}

/// Provider for realtime manager
final realtimeManagerProvider = Provider.autoDispose<RealtimeManager>((ref) {
  return RealtimeManager(ref: ref);
});

/// Subscribe to messages in a conversation
final conversationMessagesRealtimeProvider = 
    FutureProvider.autoDispose.family<void, String>((ref, conversationId) async {
  final manager = ref.watch(realtimeManagerProvider);
  manager.subscribeToConversationMessages(conversationId);
  
  // Cleanup on dispose
  ref.onDispose(() {
    manager.unsubscribeFromConversation(conversationId);
  });
});

/// Watch for realtime message updates in a conversation
final realtimeConversationMessagesProvider = 
    StreamProvider.autoDispose.family<List<Message>, String>((ref, conversationId) async* {
  // Enable realtime subscription
  await ref.watch(conversationMessagesRealtimeProvider(conversationId).future);
  
  // Watch the local messages - use .stream instead
  yield* ref.watch(messagesStreamProvider(conversationId).stream);
});
</file>

<file path="frontend/lib/state/typing_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/providers.dart';

/// User typing information
class TypingUser {
  final String userId;
  final DateTime startedAt;
  final Duration timeout;

  TypingUser({
    required this.userId,
    required this.startedAt,
    this.timeout = const Duration(seconds: 3),
  });

  /// Check if typing indicator has expired
  bool get isExpired {
    return DateTime.now().difference(startedAt) > timeout;
  }
}

/// Manages typing indicators for a conversation
class TypingManager {
  final Ref ref;
  final String conversationId;
  final String userId;
  
  final Map<String, TypingUser> _typingUsers = {};
  static const Duration _debounceDelay = Duration(milliseconds: 300);
  DateTime? _lastTypingSent;

  TypingManager({
    required this.ref,
    required this.conversationId,
    required this.userId,
  });

  /// Broadcast that user is typing
  Future<void> sendTypingIndicator() async {
    final now = DateTime.now();
    
    // Debounce: only send every 300ms
    if (_lastTypingSent != null &&
        now.difference(_lastTypingSent!) < _debounceDelay) {
      return;
    }
    
    _lastTypingSent = now;
    
    final supabase = ref.watch(supabaseClientProvider);
    
    // Send typing indicator through presence
    final presence = supabase.channel('typing:$conversationId');
    
    try {
      // Subscribe to the channel (returns void, no await needed)
      presence.subscribe(
        (status, [err]) {
          print('Typing subscription: $status - $err');
        },
      );
      
      await presence.track({
        'user_id': userId,
        'typing': true,
        'timestamp': now.toIso8601String(),
      });
    } catch (e) {
      print('Error sending typing indicator: $e');
    }
  }

  /// Stop broadcasting typing
  Future<void> stopTypingIndicator() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('typing:$conversationId');
    
    try {
      await presence.track({
        'user_id': userId,
        'typing': false,
      });
      
      await presence.unsubscribe();
    } catch (e) {
      print('Error stopping typing indicator: $e');
    }
  }

  /// Add a typing user (received from server)
  void addTypingUser(String otherUserId) {
    _typingUsers[otherUserId] = TypingUser(userId: otherUserId, startedAt: DateTime.now());
  }

  /// Remove a typing user
  void removeTypingUser(String otherUserId) {
    _typingUsers.remove(otherUserId);
  }

  /// Get list of currently typing users (excluding expired ones)
  List<TypingUser> getTypingUsers() {
    // Remove expired entries
    _typingUsers.removeWhere((_, user) => user.isExpired);
    return _typingUsers.values.toList();
  }

  /// Get typing users display text
  String getTypingText() {
    final typingUsers = getTypingUsers();
    
    if (typingUsers.isEmpty) return '';
    if (typingUsers.length == 1) return '${typingUsers.first.userId} is typing...';
    if (typingUsers.length == 2) {
      return '${typingUsers[0].userId} and ${typingUsers[1].userId} are typing...';
    }
    
    return '${typingUsers.length} people are typing...';
  }

  /// Check if anyone is typing
  bool get anyoneTyping => getTypingUsers().isNotEmpty;
}

/// Provider for typing manager
final typingManagerProvider =
    Provider.family<TypingManager, (String, String)>((ref, args) {
  final (conversationId, userId) = args;
  return TypingManager(
    ref: ref,
    conversationId: conversationId,
    userId: userId,
  );
});

/// Stream of typing users in a conversation
final conversationTypingProvider = StreamProvider.autoDispose
    .family<List<TypingUser>, String>((ref, conversationId) async* {
  // This would typically subscribe to realtime typing updates
  // For now, we'll yield an empty list
  yield [];
  
  // TODO: Set up realtime typing stream
});

/// Get typing status text for display
final typingStatusTextProvider = StreamProvider.autoDispose
    .family<String, String>((ref, conversationId) async* {
  yield* ref.watch(conversationTypingProvider(conversationId)).when(
        data: (typingUsers) async* {
          if (typingUsers.isEmpty) {
            yield '';
          } else if (typingUsers.length == 1) {
            yield '${typingUsers.first.userId} is typing...';
          } else {
            yield '${typingUsers.length} people are typing...';
          }
        },
        loading: () async* {
          yield '';
        },
        error: (err, st) async* {
          yield '';
        },
      );
});
</file>

<file path="frontend/lib/widgets/sliding_panel.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';

/// A sliding panel widget that can be dragged up and down
/// Used for the message screen to slide over AI insights
class SlidingPanel extends StatefulWidget {
  /// Builder function to create the child with scroll controller
  final Widget Function(ScrollController)? builder;
  
  /// The content to display in the sliding panel (deprecated, use builder instead)
  final Widget? child;
  
  /// Called when the panel position changes (0.0 = collapsed, 1.0 = fully expanded)
  final ValueChanged<double>? onSlide;
  
  /// Minimum height as a fraction of screen (0.0 - 1.0)
  final double minHeight;
  
  /// Maximum height as a fraction of screen (0.0 - 1.0)
  final double maxHeight;
  
  /// Initial height as a fraction of screen (0.0 - 1.0)
  final double initialHeight;
  
  /// Snap positions for the panel (as fractions of screen height)
  final List<double> snapSizes;
  
  /// Background color of the panel
  final Color? backgroundColor;
  
  /// Border radius for the top corners
  final double borderRadius;
  
  /// Whether to show the drag handle
  final bool showDragHandle;

  const SlidingPanel({
    Key? key,
    this.builder,
    this.child,
    this.onSlide,
    this.minHeight = 0.2,
    this.maxHeight = 0.95,
    this.initialHeight = 0.8,
    this.snapSizes = const [0.2, 0.5, 0.8, 0.95],
    this.backgroundColor,
    this.borderRadius = 16.0,
    this.showDragHandle = true,
  }) : assert(builder != null || child != null, 'Either builder or child must be provided'),
       super(key: key);

  @override
  State<SlidingPanel> createState() => _SlidingPanelState();
}

class _SlidingPanelState extends State<SlidingPanel> {
  final DraggableScrollableController _controller = DraggableScrollableController();
  
  @override
  void initState() {
    super.initState();
    // Add listener to track position changes
    _controller.addListener(_onPositionChanged);
  }
  
  @override
  void dispose() {
    _controller.removeListener(_onPositionChanged);
    _controller.dispose();
    super.dispose();
  }
  
  void _onPositionChanged() {
    if (_controller.isAttached) {
      final size = _controller.size;
      // Normalize the size to 0.0 - 1.0 range
      final normalizedPosition = (size - widget.minHeight) / (widget.maxHeight - widget.minHeight);
      widget.onSlide?.call(normalizedPosition.clamp(0.0, 1.0));
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final bgColor = widget.backgroundColor ?? 
                    (isDark ? AppTheme.black : AppTheme.white);
    
    return NotificationListener<DraggableScrollableNotification>(
      onNotification: (notification) {
        // Update position for smoother tracking
        if (widget.onSlide != null) {
          final normalizedPosition = (notification.extent - widget.minHeight) / 
                                     (widget.maxHeight - widget.minHeight);
          widget.onSlide?.call(normalizedPosition.clamp(0.0, 1.0));
        }
        return false;
      },
      child: DraggableScrollableSheet(
        controller: _controller,
        initialChildSize: widget.initialHeight,
        minChildSize: widget.minHeight,
        maxChildSize: widget.maxHeight,
        snap: true,
        snapSizes: widget.snapSizes,
        expand: false,
        builder: (BuildContext context, ScrollController scrollController) {
          return Container(
            decoration: BoxDecoration(
              color: bgColor,
              borderRadius: BorderRadius.only(
                topLeft: Radius.circular(widget.borderRadius),
                topRight: Radius.circular(widget.borderRadius),
              ),
              boxShadow: isDark ? AppTheme.shadow2Dark : AppTheme.shadow3Light,
            ),
            child: Column(
              children: [
                // Drag handle - simple tap to cycle through positions
                if (widget.showDragHandle)
                  InkWell(
                    onTap: () => _snapToNextPosition(),
                    child: Container(
                      width: double.infinity,
                      padding: const EdgeInsets.symmetric(
                        vertical: AppTheme.spacingM,
                      ),
                      child: Center(
                        child: Container(
                          width: 40,
                          height: 5,
                          decoration: BoxDecoration(
                            color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                            borderRadius: BorderRadius.circular(AppTheme.radiusPill),
                          ),
                        ),
                      ),
                    ),
                  ),
                
                // Panel content with scroll controller for dragging
                Expanded(
                  child: widget.builder != null 
                    ? widget.builder!(scrollController) 
                    : (widget.child != null 
                        ? SingleChildScrollView(
                            controller: scrollController,
                            child: widget.child!,
                          )
                        : const SizedBox.shrink()),
                ),
              ],
            ),
          );
        },
      ),
    );
  }
  
  /// Snaps the panel to the next position in the snapSizes list
  void _snapToNextPosition() {
    if (!_controller.isAttached) return;
    
    final currentSize = _controller.size;
    final sortedSnaps = List<double>.from(widget.snapSizes)..sort();
    
    // Find the next snap position
    final nextSnap = sortedSnaps.firstWhere(
      (snap) => snap > currentSize + 0.05, // Add small buffer for floating point
      orElse: () => sortedSnaps.first, // Wrap around to first
    );
    
    _controller.animateTo(
      nextSnap,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
  }
}

/// Extension to provide convenience methods for sliding panel
extension SlidingPanelController on DraggableScrollableController {
  /// Animate to a specific size
  Future<void> animateToSize(
    double size, {
    Duration duration = const Duration(milliseconds: 300),
    Curve curve = Curves.easeInOut,
  }) {
    return animateTo(
      size,
      duration: duration,
      curve: curve,
    );
  }
  
  /// Jump to a specific size without animation
  void jumpToSize(double size) {
    jumpTo(size);
  }
  
  /// Get current size
  double get currentSize => isAttached ? size : 0.0;
}
</file>

<file path="frontend/test/offline_queue_test.dart">
import 'package:flutter_test/flutter_test.dart';

/// Placeholder test for offline queue functionality
/// Full implementation requires database mocking setup
void main() {
  group('Offline Message Queue', () {
    test('Offline queue service exists', () {
      // Basic test to ensure the test file compiles
      expect(true, isTrue);
    });

    test('Network connectivity service can be instantiated', () {
      // Placeholder test
      expect(1 + 1, equals(2));
    });

    test('Retry service handles exponential backoff', () {
      // Placeholder test
      expect(true, isTrue);
    });
  });

  group('Message Syncing', () {
    test('Messages can be queued', () {
      // Placeholder test
      expect(true, isTrue);
    });

    test('Messages can be synced when online', () {
      // Placeholder test
      expect(true, isTrue);
    });
  });
}
</file>

<file path="frontend/test/realtime_diagnostic_test.dart">
import 'package:flutter_test/flutter_test.dart';

/// Placeholder test for realtime diagnostic functionality
void main() {
  group('Realtime Diagnostics', () {
    test('Realtime diagnostic service exists', () {
      // Basic test to ensure the test file compiles
      expect(true, isTrue);
    });

    test('Channel diagnostics can be tracked', () {
      // Placeholder test
      expect(1 + 1, equals(2));
    });

    test('Health checks can be performed', () {
      // Placeholder test  
      expect(true, isTrue);
    });
  });

  group('Connection Testing', () {
    test('Connection test can be executed', () {
      // Placeholder test
      expect(true, isTrue);
    });

    test('Latency can be measured', () {
      // Placeholder test
      expect(true, isTrue);
    });
  });
}
</file>

<file path="frontend/test/widget_test.dart">
// Basic Flutter widget test for MessageAI app

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/app.dart';

void main() {
  testWidgets('MessageAI app loads', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(
      const ProviderScope(
        child: MessageAIApp(),
      ),
    );

    // Verify app loads without errors
    expect(find.byType(MaterialApp), findsOneWidget);
  });
}
</file>

<file path="README.md">
# MessageAI

A modern, cross-platform messaging application built with Flutter and Supabase, featuring real-time messaging, typing indicators, image sharing, offline support, and AI-powered message analysis.

## ‚ú® Features

### Core Messaging
- üîê **Secure Authentication** - Email/password authentication with Supabase
- üí¨ **Real-time Messaging** - Instant message delivery with Supabase Realtime
- ‚å®Ô∏è **Typing Indicators** - See when others are typing with animated indicators
- üì∑ **Image Sharing** - Upload and share images in conversations
- üë§ **Profile Pictures** - Custom avatar support with image upload
- üìß **Add by Email** - Add participants to conversations using email addresses
- üì± **Offline Support** - Queue messages when offline, auto-sync when back online
- üé® **Modern UI** - Dark/light mode support with thoughtful design
- üìñ **Message Previews** - See the last message in each conversation
- ‚úì **Read Receipts** - Track message delivery and read status

### ü§ñ AI Features

#### Smart Message Interpreter
- **Tone Analysis** - Automatically detect message tone, urgency level, and intent
- **RSD Trigger Detection** - Identify Rejection Sensitive Dysphoria triggers with reassurance
- **Boundary Detection** - Recognize boundary violations and suggest appropriate responses
- **Alternative Interpretations** - See multiple ways to interpret ambiguous messages
- **Anxiety Assessment** - Understand response anxiety levels and mitigation strategies
- **Evidence-Based Analysis** - See exactly what phrases support each analysis

#### Adaptive Response Assistant (Draft Analysis)
- **Message Feedback** - Get real-time feedback on your drafted messages
- **Confidence Scoring** - See how confident the AI is in its analysis
- **Social Scripts** - Get suggested templates and social scripts for various situations
- **Situation Detection** - Automatically detect message context (declining, boundary-setting, etc.)
- **Formatting Options** - Get suggestions for formatting and rephrasing

#### Smart Inbox Filters
- **Auto-Categorization** - Automatically categorize and prioritize messages
- **Smart Filtering** - Filter by urgency, message type, or context
- **Conversation Prioritization** - See the most important conversations first
- **Follow-up Tracking** - Track action items and pending questions

#### RAG Context Panel
- **Conversation History** - Rich context from past interactions
- **Relationship Memory** - Remember important details about relationships
- **Safe Topics** - Track which topics are positive and safe
- **Context-Aware Responses** - Help AI understand your preferences and patterns

## üìã Prerequisites

Before you begin, ensure you have the following installed:

### Required Software

1. **Flutter SDK** (3.10.0 or higher)
   - [Download Flutter](https://docs.flutter.dev/get-started/install)
   - Verify installation: `flutter doctor`

2. **Android Studio** (for Android development)
   - [Download Android Studio](https://developer.android.com/studio)
   - Install Android SDK and emulator

3. **Xcode** (for iOS development - macOS only)
   - Install from Mac App Store
   - Run: `sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer`

4. **Git**
   - [Download Git](https://git-scm.com/downloads)

5. **Node.js** (16.x or higher) - for backend
   - [Download Node.js](https://nodejs.org/)

6. **Supabase CLI** (optional, for local development)
   - Install: `npm install -g supabase`

7. **OpenAI API Key** (for AI features)
   - Get key from [OpenAI Platform](https://platform.openai.com/api-keys)
   - Set as `OPENAI_API_KEY` environment variable in Supabase

## üöÄ Getting Started

### Step 1: Clone the Repository

```bash
git clone https://github.com/yourusername/MessageAI.git
cd MessageAI
```

### Step 2: Set Up the Backend

#### Option A: Use Supabase Cloud (Recommended for Quick Start)

Create .env in backend folder and add 
   - Project URL (e.g., `https://abcdefghijk.supabase.co`)
   - `anon/public` API key
   - `OPENAI_API_KEY` - Your OpenAI API key for AI features


### Step 3: Configure the Frontend

1. Navigate to the frontend directory:
   ```bash
   cd frontend
   ```

2. Create a configuration file:
   ```bash
   # Create .env.dev.json in the frontend directory
   cat > .env.dev.json << EOF
   {
     "SUPABASE_URL": "https://your-project-id.supabase.co",
     "SUPABASE_ANON_KEY": "your-anon-key-here"
   }
   EOF
   ```

3. Replace the placeholder values with your actual Supabase credentials

4. Install Flutter dependencies:
   ```bash
   flutter pub get
   ```

## üì± Running the App

### Android Emulator Setup

1. **Open Android Studio**
2. Go to **Tools** ‚Üí **Device Manager**
3. Click **Create Device**
4. Select a device (e.g., Pixel 7) and click **Next**
5. Select a system image (e.g., Android 13) and click **Next**
6. Click **Finish** to create the emulator
7. Click the **Play** button to start the emulator

### iOS Simulator Setup (macOS only)

1. **Open Xcode**
2. Go to **Xcode** ‚Üí **Open Developer Tool** ‚Üí **Simulator**
3. The simulator will launch with a default device

### Run the App

1. **Check available devices:**
   ```bash
   flutter devices
   ```

2. **Run the app:**

   **Option A: Without configuration file** (if you hardcoded credentials)
   ```bash
   flutter run
   ```

   **Option B: With configuration file** (recommended)
   ```bash
   flutter run --dart-define-from-file=.env.dev.json
   ```

   **Option C: On a specific device**
   ```bash
   flutter run -d <device-id> --dart-define-from-file=.env.dev.json
   ```

3. **Hot Reload during development:**
   - Press `r` in the terminal to hot reload
   - Press `R` to hot restart
   - Press `q` to quit

### Load Showcase Data

```bash
cd backend
supabase db reset
```

This loads demonstration conversations and messages showcasing all AI features.

### Build for Production

**Android APK:**
```bash
flutter build apk --release --dart-define-from-file=.env.dev.json
# Output: build/app/outputs/flutter-apk/app-release.apk
```

**Android App Bundle:**
```bash
flutter build appbundle --release --dart-define-from-file=.env.dev.json
# Output: build/app/outputs/bundle/release/app-release.aab
```

**iOS (macOS only):**
```bash
cd ios
pod install
cd ..
flutter build ios --release --dart-define-from-file=.env.dev.json
```

## üîß Troubleshooting

### Common Issues

#### 1. "SUPABASE_URL not configured" Error

**Solution:** Make sure you created `.env.dev.json` with your Supabase credentials and run with:
```bash
flutter run --dart-define-from-file=.env.dev.json
```

#### 2. "API key required" Error for AI Features

**Solution:** Ensure `OPENAI_API_KEY` is set in your Supabase Edge Functions environment:
```bash
supabase secrets set OPENAI_API_KEY=your-key-here
```

#### 3. Flutter Doctor Issues

**Run:**
```bash
flutter doctor
```

Follow the instructions to fix any issues (Android licenses, Xcode setup, etc.)

#### 4. Android License Not Accepted

**Run:**
```bash
flutter doctor --android-licenses
```

Accept all licenses when prompted.

#### 5. Gradle Build Errors

**Solution:**
```bash
cd android
./gradlew clean
cd ..
flutter clean
flutter pub get
```

#### 6. iOS Pod Installation Errors

**Solution:**
```bash
cd ios
pod deintegrate
pod install
cd ..
```

#### 7. Image Picker Not Working

Make sure you have the required permissions in:
- **Android:** `android/app/src/main/AndroidManifest.xml`
- **iOS:** `ios/Runner/Info.plist`

#### 8. Emulator Not Detected

**Android:**
```bash
# List Android Virtual Devices
emulator -list-avds

# Start a specific AVD
emulator -avd <avd-name>
```

**iOS:**
```bash
# List simulators
xcrun simctl list devices

# Boot a simulator
xcrun simctl boot <device-id>
```

## üèóÔ∏è Project Structure

```
MessageAI/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ functions/         # Edge Functions (AI analysis, interpretation, etc.)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ migrations/        # Database migrations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ policies/          # RLS policies
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ seed_showcase_data.sql  # Demo data
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ core/              # Core configurations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ data/              # Data layer (Drift, repos)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ features/          # Feature modules
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/          # Business logic services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ state/             # State management
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/            # Data models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.dart           # Main app widget
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.dart          # Entry point
‚îÇ   ‚îú‚îÄ‚îÄ android/               # Android platform code
‚îÇ   ‚îú‚îÄ‚îÄ ios/                   # iOS platform code
‚îÇ   ‚îî‚îÄ‚îÄ pubspec.yaml           # Flutter dependencies
‚îú‚îÄ‚îÄ .gitignore
‚îî‚îÄ‚îÄ README.md
```

## üõ†Ô∏è Tech Stack

### Frontend
- **Flutter** - Cross-platform UI framework
- **Riverpod** - State management
- **Drift** - Local SQLite database
- **Supabase Flutter** - Backend client
- **Image Picker** - Image selection

### Backend
- **Supabase** - Backend as a Service
  - PostgreSQL database
  - Real-time subscriptions
  - Authentication
  - Storage
  - Edge Functions (Deno)
- **OpenAI GPT-4** - AI analysis and interpretation

## üìù Environment Variables

Create `.env.dev.json` in the `frontend` directory:

```json
{
  "SUPABASE_URL": "https://your-project-id.supabase.co",
  "SUPABASE_ANON_KEY": "your-anon-key-here"
}
```

For backend Edge Functions, set in Supabase:
```bash
supabase secrets set OPENAI_API_KEY=sk-...
```

For production, create `.env.prod.json` with production credentials.

## üß™ Testing

### Run Tests
```bash
cd frontend
flutter test
```

### Run Specific Test
```bash
flutter test test/offline_queue_test.dart
```

### Test Offline Message Queueing

See `frontend/OFFLINE_QUEUE_TEST.md` for detailed testing instructions.

## üìö Additional Documentation

- **Architecture**: See `docs/Architecture.puml`
- **ERD**: See `docs/ERD.puml`
- **Offline Queueing**: See `frontend/OFFLINE_QUEUE_TEST.md`
- **API Contracts**: See `contracts/openapi.yaml`
- **AI Features**: See `docs/AI_FEATURES.md`

## ü§ù Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## üìÑ License

This project is licensed under the MIT License - see the LICENSE file for details.

## üÜò Support

If you encounter any issues:

1. Check the [Troubleshooting](#-troubleshooting) section
2. Review closed issues on GitHub
3. Open a new issue with:
   - Your environment details (`flutter doctor -v`)
   - Steps to reproduce
   - Error messages/screenshots

## üé® Color Scheme & AI Feature Colors

**Core Theme:**
- **Primary**: Burnt orange with transparency (`#C77506` at 60% opacity)
- **Secondary**: Same burnt orange
- **Accent**: Slate grey (`#475569`)
- **Background**: Adaptive (light/dark mode)

**AI Feature Colors:**
- **Smart Message Interpreter**: Purple (`#7C3AED`)
- **Adaptive Response Assistant**: Blue (`#06B6D4`)
- **Smart Inbox Filters**: Indigo (`#6366F1`)
- **RAG Context Panel**: Green (`#22C55E`)

## üîÆ Roadmap

### AI Features (In Progress)
- [x] Smart Message Interpreter with tone analysis
- [x] RSD trigger detection
- [x] Boundary violation detection
- [x] Adaptive Response Assistant
- [x] Smart Inbox Filters
- [x] RAG Context Panel
- [ ] Voice message analysis
- [ ] Emotion detection from images
- [ ] Personalized suggestion learning

### Messaging
- [ ] Voice messages
- [ ] Voice/video calls
- [ ] Message reactions
- [ ] Message search
- [ ] File sharing (PDFs, documents)
- [ ] Location sharing

### Security & Privacy
- [ ] End-to-end encryption
- [ ] Message disappearing timers
- [ ] Device management
- [ ] Login activity

### Platform & Scale
- [ ] Desktop apps (Windows, macOS, Linux)
- [ ] Web app
- [ ] Message syncing across devices
- [ ] Performance optimization for large conversations

## üë• Authors

- Your Name - Initial work

## üôè Acknowledgments

- Flutter team for the amazing framework
- Supabase for the backend infrastructure
- OpenAI for AI capabilities
- Community contributors

---

Made with ‚ù§Ô∏è using Flutter, Supabase, and AI
</file>

<file path="backend/supabase/config.toml">
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "backend"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false
# Paths to self-signed certificate pair.
# cert_path = "../certs/my-cert.pem"
# key_path = "../certs/my-key.pem"

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 17

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# If disabled, migrations will be skipped during a db push or reset.
enabled = true
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[db.network_restrictions]
# Enable management of network restrictions.
enabled = false
# List of IPv4 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv4 connections. Set empty array to block all IPs.
allowed_cidrs = ["0.0.0.0/0"]
# List of IPv6 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv6 connections. Set empty array to block all IPs.
allowed_cidrs_v6 = ["::/0"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# Path to JWT signing key. DO NOT commit your signing keys file to git.
# signing_keys_path = "./signing_keys.json"
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30
# Number of Web3 logins that can be made in a 5 minute interval per IP address.
web3 = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a new user is created and allows developers to reject the request based on the incoming user object.
# [auth.hook.before_user_created]
# enabled = true
# uri = "pg-functions://postgres/auth/before-user-created-hook"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false
# If enabled, it will allow the user to successfully authenticate when the provider does not return an email address.
email_optional = false

# Allow Solana wallet holders to sign in to your project via the Sign in with Solana (SIWS, EIP-4361) standard.
# You can configure "web3" rate limit in the [auth.rate_limit] section and set up [auth.captcha] if self-hosting.
[auth.web3.solana]
enabled = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

# OAuth server configuration
[auth.oauth_server]
# Enable OAuth server functionality
enabled = false
# Path for OAuth consent flow UI
authorization_url_path = "/oauth/consent"
# Allow dynamic client registration
allow_dynamic_registration = false

[edge_runtime]
enabled = true
# Supported request policies: `oneshot`, `per_worker`.
# `per_worker` (default) ‚Äî enables hot reload during local development.
# `oneshot` ‚Äî fallback mode if hot reload causes issues (e.g. in large repos or with symlinks).
policy = "per_worker"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 2

[edge_runtime.secrets]
OPENAI_API_KEY = "env(OPENAI_API_KEY)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"
</file>

<file path="contracts/openapi.yaml">
openapi: 3.1.0
info: 
  title: MessageAI API
  version: 1.0.0
  description: Real-time messaging API with end-to-end encrypted conversations and media support
  contact:
    name: MessageAI Team
  license:
    name: Proprietary
servers:
  - url: http://localhost:54321/rest/v1
    description: Local Supabase development
  - url: https://api.messageai.app/rest/v1
    description: Production API

paths:
  /v1/messages.send:
    post:
      summary: Send a message to a conversation
      description: Creates a new message in a conversation with optional media attachment. Idempotent operation using message ID.
      tags:
        - Messages
      operationId: sendMessage
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MessagePayload'
      responses:
        '200':
          description: Message sent successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MessageResponse'
        '400':
          description: Invalid request
        '401':
          description: Unauthorized
        '409':
          description: Message already exists (idempotent)

  /v1/receipts.ack:
    post:
      summary: Acknowledge message receipts
      description: Batch update receipt status (delivered/read) for multiple messages
      tags:
        - Receipts
      operationId: acknowledgeReceipts
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ReceiptPayload'
      responses:
        '200':
          description: Receipts acknowledged successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                  count:
                    type: integer
                    description: Number of receipts updated
        '400':
          description: Invalid request
        '401':
          description: Unauthorized

  /v1/create_group:
    post:
      summary: Create a group conversation
      description: Create a group conversation with multiple members
      tags:
        - Groups
      operationId: createGroup
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateGroupPayload'
      responses:
        '200':
          description: Group created successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GroupResponse'
        '400':
          description: Invalid request
        '401':
          description: Unauthorized

  /v1/push_notify:
    post:
      summary: Send push notifications
      description: Send push notifications to inactive participants
      tags:
        - Notifications
      operationId: pushNotify
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PushNotifyPayload'
      responses:
        '200':
          description: Notifications sent
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PushNotifyResponse'
        '400':
          description: Invalid request
        '401':
          description: Unauthorized

components:
  schemas:
    # ========================================================================
    # Message Schemas
    # ========================================================================
    MessagePayload:
      type: object
      description: Request payload for sending a message
      properties:
        id:
          type: string
          format: uuid
          description: Unique message ID (client-generated for idempotency)
        conversation_id:
          type: string
          format: uuid
          description: ID of the target conversation
        body:
          type: string
          description: Message content (text)
          minLength: 1
        media_url:
          type: string
          format: uri
          nullable: true
          description: Optional URL to attached media (image, video, file)
      required:
        - id
        - conversation_id
        - body

    MessageResponse:
      type: object
      description: Server response after sending a message
      properties:
        id:
          type: string
          format: uuid
          description: Message ID
        conversation_id:
          type: string
          format: uuid
          description: Conversation ID
        sender_id:
          type: string
          format: uuid
          description: ID of message sender
        body:
          type: string
          description: Message content
        media_url:
          type: string
          format: uri
          nullable: true
          description: Media attachment URL if present
        created_at:
          type: string
          format: date-time
          description: Timestamp when message was created
        server_time:
          type: string
          format: date-time
          description: Server timestamp for synchronization
      required:
        - id
        - conversation_id
        - sender_id
        - body
        - created_at
        - server_time

    # ========================================================================
    # Receipt Schemas
    # ========================================================================
    ReceiptPayload:
      type: object
      description: Request payload for acknowledging message receipts
      properties:
        message_ids:
          type: array
          items:
            type: string
            format: uuid
          description: List of message IDs to acknowledge
          minItems: 1
        status:
          type: string
          enum:
            - delivered
            - read
          description: Status to mark messages as
      required:
        - message_ids
        - status

    MessageReceipt:
      type: object
      description: Message receipt status
      properties:
        id:
          type: string
          format: uuid
          description: Receipt ID
        message_id:
          type: string
          format: uuid
          description: Message ID
        user_id:
          type: string
          format: uuid
          description: User who received/read the message
        status:
          type: string
          enum:
            - delivered
            - read
          description: Receipt status
        at:
          type: string
          format: date-time
          description: Timestamp of the receipt
      required:
        - id
        - message_id
        - user_id
        - status
        - at

    # ========================================================================
    # Group Schemas
    # ========================================================================
    CreateGroupPayload:
      type: object
      description: Request payload for creating a group
      properties:
        title:
          type: string
          description: Group name (1-255 characters)
          minLength: 1
          maxLength: 255
        description:
          type: string
          nullable: true
          description: Group description
        member_ids:
          type: array
          items:
            type: string
            format: uuid
          description: User IDs to add (1-500)
          minItems: 1
      required:
        - title
        - member_ids

    GroupResponse:
      type: object
      description: Group creation response
      properties:
        id:
          type: string
          format: uuid
        title:
          type: string
        description:
          type: string
          nullable: true
        is_group:
          type: boolean
        created_by:
          type: string
          format: uuid
        created_at:
          type: string
          format: date-time
        member_count:
          type: integer
        members:
          type: array
          items:
            type: object
            properties:
              user_id:
                type: string
                format: uuid
              joined_at:
                type: string
                format: date-time
      required:
        - id
        - title
        - is_group
        - created_by
        - created_at
        - member_count

    # ========================================================================
    # Notification Schemas
    # ========================================================================
    PushNotifyPayload:
      type: object
      description: Request payload for push notifications
      properties:
        conversation_id:
          type: string
          format: uuid
          description: Target conversation
        message_id:
          type: string
          format: uuid
          description: Message being notified
        sender_id:
          type: string
          format: uuid
          description: Message sender
        sender_name:
          type: string
          description: Display name of sender
        title:
          type: string
          nullable: true
          description: Notification title
        body:
          type: string
          nullable: true
          description: Notification body
      required:
        - conversation_id
        - message_id
        - sender_id
        - sender_name

    PushNotifyResponse:
      type: object
      description: Push notification response
      properties:
        success:
          type: boolean
        message_id:
          type: string
          format: uuid
        notifications_sent:
          type: integer
        recipients:
          type: array
          items:
            type: object
            properties:
              user_id:
                type: string
                format: uuid
              device_count:
                type: integer
      required:
        - success
        - message_id
        - notifications_sent

    # ========================================================================
    # Conversation Schemas
    # ========================================================================
    Conversation:
      type: object
      description: Messaging conversation (1:1 or group)
      properties:
        id:
          type: string
          format: uuid
          description: Conversation ID
        title:
          type: string
          nullable: true
          description: Conversation title (for groups)
        description:
          type: string
          nullable: true
          description: Conversation description
        is_group:
          type: boolean
          description: Whether this is a group conversation
        created_by:
          type: string
          format: uuid
          description: User ID who created the conversation
        created_at:
          type: string
          format: date-time
          description: Creation timestamp
        updated_at:
          type: string
          format: date-time
          description: Last update timestamp
      required:
        - id
        - is_group
        - created_by
        - created_at
        - updated_at

    ConversationParticipant:
      type: object
      description: User participation in a conversation
      properties:
        id:
          type: string
          format: uuid
        conversation_id:
          type: string
          format: uuid
        user_id:
          type: string
          format: uuid
        joined_at:
          type: string
          format: date-time
        last_read_at:
          type: string
          format: date-time
          nullable: true
      required:
        - id
        - conversation_id
        - user_id
        - joined_at

    # ========================================================================
    # Profile Schemas
    # ========================================================================
    Profile:
      type: object
      description: User profile
      properties:
        id:
          type: string
          format: uuid
        user_id:
          type: string
          format: uuid
        username:
          type: string
          description: Unique username
        display_name:
          type: string
          nullable: true
          description: Display name
        avatar_url:
          type: string
          format: uri
          nullable: true
          description: Avatar image URL
        bio:
          type: string
          nullable: true
          description: User bio
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time
      required:
        - id
        - user_id
        - username
        - created_at
        - updated_at

    Device:
      type: object
      description: User device for push notifications
      properties:
        id:
          type: string
          format: uuid
        user_id:
          type: string
          format: uuid
        fcm_token:
          type: string
          description: Firebase Cloud Messaging token
        platform:
          type: string
          enum:
            - ios
            - android
            - web
          description: Device platform
        last_seen:
          type: string
          format: date-time
          description: Last activity timestamp
        created_at:
          type: string
          format: date-time
      required:
        - id
        - user_id
        - fcm_token
        - platform
        - created_at
</file>

<file path="frontend/lib/data/drift/app_db.dart">
import 'package:drift/drift.dart';
import 'package:drift_flutter/drift_flutter.dart';
import 'package:messageai/data/drift/daos/conversation_dao.dart';
import 'package:messageai/data/drift/daos/message_dao.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/drift/daos/participant_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';
// AI Analysis DAO commented out (using remote-only approach)
// Uncomment and restore from backup files when scaling to local cache
// import 'package:messageai/data/drift/daos/ai_analysis_dao.dart';

part 'app_db.g.dart';

// Table definitions
class Conversations extends Table {
  TextColumn get id => text()();
  TextColumn get title => text()();
  TextColumn get description => text().nullable()();
  IntColumn get createdAt => integer()(); // Unix timestamp
  IntColumn get updatedAt => integer()();
  BoolColumn get isGroup => boolean().withDefault(const Constant(false))();
  IntColumn get lastMessageAt => integer().nullable()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};
}

class Messages extends Table {
  TextColumn get id => text()();
  TextColumn get conversationId => text()();
  TextColumn get senderId => text()();
  TextColumn get body => text()();
  TextColumn get mediaUrl => text().nullable()();
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    {conversationId, id}
  ];
}

class Participants extends Table {
  TextColumn get id => text()();
  TextColumn get conversationId => text()();
  TextColumn get userId => text()();
  IntColumn get joinedAt => integer()();
  BoolColumn get isAdmin => boolean().withDefault(const Constant(false))();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    {conversationId, userId}
  ];
}

class Receipts extends Table {
  TextColumn get id => text()();
  TextColumn get messageId => text()();
  TextColumn get userId => text()();
  TextColumn get status => text()(); // 'delivered', 'read'
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    {messageId, userId}
  ];
}

class PendingOutbox extends Table {
  TextColumn get id => text()();
  TextColumn get operation => text()(); // 'send_message', 'ack_receipt'
  TextColumn get payload => text()(); // JSON serialized
  TextColumn get conversationId => text().nullable()();
  IntColumn get createdAt => integer()();
  IntColumn get retryCount => integer().withDefault(const Constant(0))();
  TextColumn get lastError => text().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

// AI Analysis table commented out for now (using remote-only approach)
// Uncomment and restore from backup files when scaling to local cache
/*
class AiAnalysis extends Table {
  TextColumn get id => text()();
  TextColumn get messageId => text()();
  TextColumn get tone => text()();
  TextColumn get urgencyLevel => text().nullable()();
  TextColumn get intent => text().nullable()();
  RealColumn get confidenceScore => real().nullable()();
  IntColumn get analysisTimestamp => integer()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();

  @override
  Set<Column> get primaryKey => {id};
}
*/

// Main database class
// Note: AiAnalysis table and AIAnalysisDao commented out (using remote-only approach)
@DriftDatabase(
  tables: [Conversations, Messages, Participants, Receipts, PendingOutbox],
  daos: [ConversationDao, MessageDao, ReceiptDao, ParticipantDao, PendingOutboxDao],
)
class AppDb extends _$AppDb {
  AppDb() : super(_openConnection());

  @override
  int get schemaVersion => 1; // Reverted to 1 (AI table removed)

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) async {
        await m.createAll();
      },
      onUpgrade: (Migrator m, int from, int to) async {
        // AI Analysis migration commented out (using remote-only approach)
        // if (from == 1 && to == 2) {
        //   await m.createTable(aiAnalysis);
        // }
      },
    );
  }

  /// Get the singleton instance of the database
  static AppDb? _instance;

  static AppDb get instance => _instance ??= AppDb();

  /// Close the database connection
  Future<void> close() async {
    await super.close();
    _instance = null;
  }
}

// Connection logic
QueryExecutor _openConnection() {
  return driftDatabase(
    name: 'messageai_db',
  );
}
</file>

<file path="frontend/lib/data/drift/daos/message_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'message_dao.g.dart';

@DriftAccessor(tables: [Messages])
class MessageDao extends DatabaseAccessor<AppDb> with _$MessageDaoMixin {
  MessageDao(AppDb db) : super(db);

  /// Get all messages for a conversation ordered by creation time (oldest first)
  Future<List<Message>> getMessagesByConversation(String conversationId) async {
    final results = await (select(messages)
          ..where((m) => m.conversationId.equals(conversationId))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.asc)]))
        .get();
    
    // Debug: Print message order
    if (results.isNotEmpty) {
      print('üìä Messages loaded: ${results.length} total');
      final firstBody = results.first.body.length > 20 
          ? '${results.first.body.substring(0, 20)}...' 
          : results.first.body;
      final lastBody = results.last.body.length > 20 
          ? '${results.last.body.substring(0, 20)}...' 
          : results.last.body;
      print('   First message: "$firstBody" at timestamp ${results.first.createdAt}');
      print('   Last message: "$lastBody" at timestamp ${results.last.createdAt}');
    }
    
    return results;
  }

  /// Get recent messages for a conversation
  Future<List<Message>> getRecentMessages(String conversationId, {int limit = 50}) async {
    return (select(messages)
          ..where((m) => m.conversationId.equals(conversationId))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.desc)])
          ..limit(limit))
        .get();
  }

  /// Insert a new message
  Future<void> insertMessage(Message message) async {
    await into(messages).insert(message);
  }

  /// Update message sync status
  Future<void> markMessageAsSynced(String messageId) async {
    await (update(messages)..where((m) => m.id.equals(messageId)))
        .write(const MessagesCompanion(isSynced: Value(true)));
  }

  /// Get unsynced messages
  Future<List<Message>> getUnsyncedMessages() async {
    return (select(messages)..where((m) => m.isSynced.equals(false)))
        .get();
  }

  /// Delete message by ID
  Future<int> deleteMessage(String id) async {
    return (delete(messages)..where((m) => m.id.equals(id))).go();
  }

  /// Get message by ID
  Future<Message?> getMessageById(String id) async {
    return (select(messages)..where((m) => m.id.equals(id)))
        .getSingleOrNull();
  }

  /// Get the most recent message for a conversation
  Future<Message?> getLatestMessageForConversation(String conversationId) async {
    return (select(messages)
          ..where((m) => m.conversationId.equals(conversationId))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.desc)])
          ..limit(1))
        .getSingleOrNull();
  }

  /// Get unsynced message count
  Future<int> getUnsyncedMessageCount() async {
    final result = await (select(messages)..where((m) => m.isSynced.equals(false))).get();
    return result.length;
  }

  /// Search messages in a conversation
  Future<List<Message>> searchMessages(String conversationId, String query) async {
    return (select(messages)
          ..where((m) => m.conversationId.equals(conversationId) & m.body.contains(query))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.desc)]))
        .get();
  }

  /// Insert multiple messages
  Future<void> insertMessages(List<Message> messageList) async {
    await batch((batch) {
      batch.insertAll(messages, messageList);
    });
  }

  /// Upsert a message (insert or update)
  Future<void> upsertMessage(Message message) async {
    await into(messages).insertOnConflictUpdate(message);
  }
}
</file>

<file path="frontend/lib/data/drift/daos/participant_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'participant_dao.g.dart';

@DriftAccessor(tables: [Participants])
class ParticipantDao extends DatabaseAccessor<AppDb> with _$ParticipantDaoMixin {
  ParticipantDao(AppDb db) : super(db);

  /// Get all participants in a conversation
  Future<List<Participant>> getParticipantsByConversation(String conversationId) async {
    return (select(participants)
          ..where((p) => p.conversationId.equals(conversationId)))
        .get();
  }

  /// Get participant by ID
  Future<Participant?> getParticipantById(String id) async {
    return (select(participants)..where((p) => p.id.equals(id)))
        .getSingleOrNull();
  }

  /// Get participant by conversation ID and user ID
  Future<Participant?> getParticipant(String conversationId, String userId) async {
    return (select(participants)
          ..where((p) =>
              p.conversationId.equals(conversationId) & p.userId.equals(userId)))
        .getSingleOrNull();
  }

  /// Add participant to conversation (upsert to avoid duplicates)
  Future<void> addParticipant(Participant participant) async {
    await into(participants).insertOnConflictUpdate(participant);
  }

  /// Batch add participants
  Future<void> addParticipants(List<Participant> parts) async {
    await batch((batch) {
      batch.insertAll(participants, parts, mode: InsertMode.insertOrReplace);
    });
  }

  /// Remove participant from conversation
  Future<int> removeParticipant(String conversationId, String userId) async {
    return (delete(participants)
          ..where((p) =>
              p.conversationId.equals(conversationId) & p.userId.equals(userId)))
        .go();
  }

  /// Remove participant by ID
  Future<int> removeParticipantById(String id) async {
    return (delete(participants)..where((p) => p.id.equals(id))).go();
  }

  /// Remove all participants from conversation
  Future<int> removeConversationParticipants(String conversationId) async {
    return (delete(participants)..where((p) => p.conversationId.equals(conversationId)))
        .go();
  }

  /// Promote participant to admin
  Future<void> promoteToAdmin(String id) async {
    await (update(participants)..where((p) => p.id.equals(id)))
        .write(const ParticipantsCompanion(isAdmin: Value(true)));
  }

  /// Demote participant from admin
  Future<void> demoteFromAdmin(String id) async {
    await (update(participants)..where((p) => p.id.equals(id)))
        .write(const ParticipantsCompanion(isAdmin: Value(false)));
  }

  /// Get admin count for conversation
  Future<int> getAdminCount(String conversationId) async {
    final result = await (select(participants)
          ..where((p) =>
              p.conversationId.equals(conversationId) & p.isAdmin.equals(true)))
        .get();
    return result.length;
  }

  /// Get participant count for a conversation
  Future<int> getParticipantCount(String conversationId) async {
    final result = await (select(participants)
          ..where((p) => p.conversationId.equals(conversationId)))
        .get();
    return result.length;
  }

  /// Check if user is participant in conversation
  Future<bool> isParticipant(String conversationId, String userId) async {
    final participant = await getParticipant(conversationId, userId);
    return participant != null;
  }

  /// Check if user is admin in conversation
  Future<bool> isAdmin(String conversationId, String userId) async {
    final participant = await getParticipant(conversationId, userId);
    return participant?.isAdmin ?? false;
  }

  /// Mark participants as synced
  Future<void> markParticipantsAsSynced(List<String> ids) async {
    await batch((batch) {
      for (final id in ids) {
        batch.update(participants, const ParticipantsCompanion(isSynced: Value(true)),
            where: (p) => p.id.equals(id));
      }
    });
  }
}
</file>

<file path="frontend/lib/data/drift/daos/pending_outbox_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'pending_outbox_dao.g.dart';

@DriftAccessor(tables: [PendingOutbox])
class PendingOutboxDao extends DatabaseAccessor<AppDb> with _$PendingOutboxDaoMixin {
  PendingOutboxDao(AppDb db) : super(db);

  /// Get all pending operations
  Future<List<PendingOutboxData>> getAllPendingOperations() async {
    return (select(pendingOutbox)
          ..orderBy([(p) => OrderingTerm(expression: p.createdAt)]))
        .get();
  }

  /// Get pending operations for a specific conversation
  Future<List<PendingOutboxData>> getPendingOperationsByConversation(String conversationId) async {
    return (select(pendingOutbox)
          ..where((p) => p.conversationId.equals(conversationId))
          ..orderBy([(p) => OrderingTerm(expression: p.createdAt)]))
        .get();
  }

  /// Add operation to pending outbox
  Future<void> addPendingOperation({
    required String id,
    required String operation,
    required String payload,
    required String? conversationId,
  }) async {
    await into(pendingOutbox).insert(PendingOutboxCompanion(
      id: Value(id),
      operation: Value(operation),
      payload: Value(payload),
      conversationId: Value(conversationId),
      createdAt: Value(DateTime.now().millisecondsSinceEpoch ~/ 1000),
      retryCount: const Value(0),
    ));
  }

  /// Remove operation from pending outbox (after successful sync)
  Future<int> removePendingOperation(String id) async {
    return (delete(pendingOutbox)..where((p) => p.id.equals(id))).go();
  }

  /// Batch remove multiple operations
  Future<int> removePendingOperations(List<String> ids) async {
    return (delete(pendingOutbox)..where((p) => p.id.isIn(ids))).go();
  }

  /// Update retry count and last error
  Future<void> updateRetryInfo(String id, int retryCount, String? lastError) async {
    await (update(pendingOutbox)..where((p) => p.id.equals(id)))
        .write(PendingOutboxCompanion(
          retryCount: Value(retryCount),
          lastError: Value(lastError),
        ));
  }

  /// Get retryable operations (with retry count < max retries)
  Future<List<PendingOutboxData>> getRetryableOperations({int maxRetries = 3}) async {
    return (select(pendingOutbox)
          ..where((p) => p.retryCount.isSmallerThanValue(maxRetries)))
        .get();
  }

  /// Get oldest pending operation
  Future<PendingOutboxData?> getOldestPendingOperation() async {
    return (select(pendingOutbox)
          ..orderBy([(p) => OrderingTerm(expression: p.createdAt)])
          ..limit(1))
        .getSingleOrNull();
  }

  /// Get pending operations by type
  Future<List<PendingOutboxData>> getPendingOperationsByType(String operationType) async {
    return (select(pendingOutbox)
          ..where((p) => p.operation.equals(operationType)))
        .get();
  }

  /// Clean up old pending operations (older than cutoffTime)
  Future<int> cleanupOldOperations(int cutoffTime) async {
    return (delete(pendingOutbox)..where((p) => p.createdAt.isSmallerThanValue(cutoffTime))).go();
  }

  /// Get pending operations count
  Future<int> getPendingOperationCount() async {
    final result = await select(pendingOutbox).get();
    return result.length;
  }

  /// Check if there are any pending operations
  Future<bool> hasPendingOperations() async {
    final count = await getPendingOperationCount();
    return count > 0;
  }
}
</file>

<file path="frontend/lib/data/remote/supabase_client.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/core/env.dart';

/// Singleton Supabase client for the application.
/// 
/// Initialize with [initializeSupabase] before accessing the client.
class SupabaseClientProvider {
  static late final Supabase _instance;

  /// Get the initialized Supabase client instance
  static Supabase get instance => _instance;

  /// Get the Supabase client for convenience
  static SupabaseClient get client => _instance.client;

  /// Initialize the Supabase client with environment config
  static Future<void> initialize() async {
    Env.validate();
    
    _instance = await Supabase.initialize(
      url: Env.supabaseUrl,
      anonKey: Env.supabaseAnonKey,
      // Enable realtime
      // Note: The underlying realtime_client has heartbeat enabled by default (30s)
      realtimeClientOptions: const RealtimeClientOptions(
        eventsPerSecond: 10,
        logLevel: RealtimeLogLevel.info, // Enable logging for diagnostics
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/auth/screens/auth_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/auth_service.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_ui.dart';

/// Authentication screen for login/signup
class AuthScreen extends StatefulWidget {
  final VoidCallback onAuthSuccess;

  const AuthScreen({
    Key? key,
    required this.onAuthSuccess,
  }) : super(key: key);

  @override
  State<AuthScreen> createState() => _AuthScreenState();
}

class _AuthScreenState extends State<AuthScreen> with ErrorHandlerMixin {
  late TextEditingController _emailController;
  late TextEditingController _passwordController;
  bool _isLoading = false;
  bool _isSignUp = false;
  final _authService = AuthService();

  @override
  void initState() {
    super.initState();
    _emailController = TextEditingController();
    _passwordController = TextEditingController();
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _handleSignIn() async {
    if (_emailController.text.isEmpty || _passwordController.text.isEmpty) {
      ErrorUI.showErrorSnackbar(
        context,
        AppError(
          category: ErrorCategory.validation,
          severity: ErrorSeverity.warning,
          code: 'VAL001',
          message: 'Please enter email and password',
          userMessage: 'Please enter both email and password',
        ),
      );
      return;
    }

    setState(() => _isLoading = true);

    try {
      await _authService.signIn(
        email: _emailController.text.trim(),
        password: _passwordController.text,
      );

      if (mounted) {
        widget.onAuthSuccess();
      }
    } on AppError catch (error) {
      if (mounted) {
        showError(error, onRetry: _handleSignIn);
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  Future<void> _handleSignUp() async {
    // Validation
    if (_emailController.text.isEmpty || _passwordController.text.isEmpty) {
      ErrorUI.showErrorSnackbar(
        context,
        AppError(
          category: ErrorCategory.validation,
          severity: ErrorSeverity.warning,
          code: 'VAL001',
          message: 'Please enter email and password',
          userMessage: 'Please enter both email and password',
        ),
      );
      return;
    }

    if (!_isValidEmail(_emailController.text.trim())) {
      ErrorUI.showErrorSnackbar(
        context,
        AuthError.invalidEmail(),
      );
      return;
    }

    if (_passwordController.text.length < 6) {
      ErrorUI.showErrorSnackbar(
        context,
        AuthError.weakPassword(),
      );
      return;
    }

    setState(() => _isLoading = true);

    try {
      await _authService.signUp(
        email: _emailController.text.trim(),
        password: _passwordController.text,
      );

      if (mounted) {
        // Show success message
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 12),
                Text('Sign up successful! Signing you in...'),
              ],
            ),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
        
        // Auto sign in after signup
        await Future.delayed(const Duration(seconds: 1));
        if (mounted) {
          await _handleSignIn();
        }
      }
    } on AppError catch (error) {
      if (mounted) {
        showError(error, onRetry: _handleSignUp);
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  /// Validate email format
  bool _isValidEmail(String email) {
    final emailRegex = RegExp(
      r'^[a-zA-Z0-9.]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+',
    );
    return emailRegex.hasMatch(email);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('MessageAI'),
        centerTitle: true,
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.chat_bubble,
                size: 64,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(height: 24),
              Text(
                _isSignUp ? 'Create Account' : 'Welcome to MessageAI',
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32),
              TextField(
                controller: _emailController,
                enabled: !_isLoading,
                decoration: InputDecoration(
                  hintText: 'Email',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  prefixIcon: const Icon(Icons.email),
                ),
                keyboardType: TextInputType.emailAddress,
              ),
              const SizedBox(height: 16),
              TextField(
                controller: _passwordController,
                enabled: !_isLoading,
                decoration: InputDecoration(
                  hintText: 'Password',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  prefixIcon: const Icon(Icons.lock),
                ),
                obscureText: true,
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _isLoading
                      ? null
                      : (_isSignUp ? _handleSignUp : _handleSignIn),
                  child: _isLoading
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : Text(_isSignUp ? 'Sign Up' : 'Sign In'),
                ),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(_isSignUp
                      ? 'Already have an account? '
                      : "Don't have an account? "),
                  TextButton(
                    onPressed: _isLoading
                        ? null
                        : () {
                            setState(() {
                              _isSignUp = !_isSignUp;
                              // Clear any previous error messages when switching modes
                              ScaffoldMessenger.of(context).hideCurrentSnackBar();
                            });
                          },
                    child: Text(_isSignUp ? 'Sign In' : 'Sign Up'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/conversations/widgets/message_bubble.dart">
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/features/messages/widgets/tone_detail_sheet.dart';
import 'package:messageai/state/ai_providers.dart';
import 'package:messageai/core/theme/app_theme.dart';

/// Widget to display a single message with AI analysis
class MessageBubble extends ConsumerWidget {
  final Message message;
  final bool isSent;
  final bool isLoading;
  final VoidCallback? onRetry;

  const MessageBubble({
    Key? key,
    required this.message,
    required this.isSent,
    this.isLoading = false,
    this.onRetry,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    
    // Fetch AI analysis for this message
    final analysisAsync = ref.watch(messageAnalysisProvider(message.id));
    
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Row(
        mainAxisAlignment: isSent ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          if (!isSent)
            Padding(
              padding: const EdgeInsets.only(right: 8),
              child: CircleAvatar(
                radius: 16,
                backgroundColor: theme.colorScheme.primaryContainer,
                child: Text(
                  message.senderId.isNotEmpty 
                      ? message.senderId[0].toUpperCase() 
                      : 'U',
                  style: TextStyle(color: theme.colorScheme.onPrimaryContainer),
                ),
              ),
            ),
          Flexible(
            child: GestureDetector(
              onLongPress: () => _showContextMenu(context, ref),
              child: Container(
                decoration: BoxDecoration(
                  color: isSent
                      ? theme.colorScheme.primary
                      : theme.colorScheme.surfaceVariant,
                  borderRadius: BorderRadius.circular(12),
                ),
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    if (message.mediaUrl != null && message.mediaUrl!.isNotEmpty)
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: Container(
                          width: 200,
                          height: 200,
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(8),
                            color: Colors.grey[300],
                          ),
                          child: Icon(
                            Icons.image,
                            size: 80,
                            color: Colors.grey[600],
                          ),
                        ),
                      ),
                    Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        // Check mark for received messages (interpreter feature)
                        if (!isSent)
                          analysisAsync.when(
                            data: (analysis) {
                              // Auto-flag concerning messages or show on all received
                              final showCheckMark = analysis != null && 
                                (analysis.urgencyLevel == 'High' || 
                                 analysis.urgencyLevel == 'Critical' ||
                                 (analysis.contextFlags?['rsd_trigger'] == true));
                              
                              if (showCheckMark) {
                                return Padding(
                                  padding: const EdgeInsets.only(right: 8, top: 2),
                                  child: GestureDetector(
                                    onTap: () {
                                      // Show interpretation
                                      ToneDetailSheet.show(
                                        context,
                                        analysis,
                                        message.body,
                                        message.id,
                                      );
                                    },
                                    child: Container(
                                      padding: const EdgeInsets.all(4),
                                      decoration: BoxDecoration(
                                        color: const Color(0xFF7C3AED).withOpacity(0.15),
                                        shape: BoxShape.circle,
                                      ),
                                      child: const Icon(
                                        Icons.psychology_outlined,
                                        size: 16,
                                        color: Color(0xFF7C3AED), // Purple - interpreter feature
                                      ),
                                    ),
                                  ),
                                );
                              }
                              return const SizedBox.shrink();
                            },
                            loading: () => const SizedBox.shrink(),
                            error: (_, __) => const SizedBox.shrink(),
                          ),
                        Expanded(
                          child: Text(
                            message.body,
                            style: TextStyle(
                              color: isSent ? Colors.white : theme.textTheme.bodyMedium?.color,
                              fontSize: 14,
                            ),
                          ),
                        ),
                      ],
                    ),
                    Padding(
                      padding: const EdgeInsets.only(top: 4),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(
                            _formatTime(DateTime.fromMillisecondsSinceEpoch(
                              message.createdAt * 1000,
                            )),
                            style: TextStyle(
                              color: isSent 
                                  ? Colors.white70 
                                  : theme.textTheme.bodySmall?.color,
                              fontSize: 12,
                            ),
                          ),
                          if (isSent) ...[
                            const SizedBox(width: 4),
                            if (isLoading)
                              SizedBox(
                                width: 12,
                                height: 12,
                                child: CircularProgressIndicator(
                                  strokeWidth: 1.5,
                                  valueColor: AlwaysStoppedAnimation(
                                    Colors.white70,
                                  ),
                                ),
                              )
                            else if (message.isSynced)
                              Icon(
                                Icons.check_circle,
                                size: 12,
                                color: Colors.white70,
                              )
                            else
                              Icon(
                                Icons.schedule,
                                size: 12,
                                color: Colors.white70,
                              ),
                          ],
                        ],
                      ),
                    ),
                    // AI Analysis Badge (shows tone analysis if available)
                    analysisAsync.when(
                      data: (analysis) {
                        if (analysis == null) return const SizedBox.shrink();
                        return Padding(
                          padding: const EdgeInsets.only(top: 8),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              // Tone Badge
                              ToneBadge(
                                analysis: analysis,
                                onTap: () => ToneDetailSheet.show(
                                  context,
                                  analysis,
                                  message.body,
                                  message.id,
                                ),
                              ),
                              // ‚úÖ PHASE 1: RSD Warning Badge (immediate visibility)
                              if (analysis.rsdTriggers?.isNotEmpty ?? false) ...[
                                const SizedBox(height: 4),
                                Container(
                                  padding: const EdgeInsets.symmetric(
                                    horizontal: 8,
                                    vertical: 4,
                                  ),
                                  decoration: BoxDecoration(
                                    color: Colors.orange.withOpacity(0.2),
                                    borderRadius: BorderRadius.circular(8),
                                    border: Border.all(
                                      color: Colors.orange.withOpacity(0.5),
                                      width: 1,
                                    ),
                                  ),
                                  child: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      Icon(
                                        Icons.warning_amber_rounded,
                                        size: 14,
                                        color: Colors.orange[800],
                                      ),
                                      const SizedBox(width: 4),
                                      Text(
                                        'May trigger RSD',
                                        style: TextStyle(
                                          fontSize: 11,
                                          color: Colors.orange[800],
                                          fontWeight: FontWeight.w600,
                                        ),
                                      ),
                                      const SizedBox(width: 2),
                                      Text(
                                        '‚Ä¢ Tap for details',
                                        style: TextStyle(
                                          fontSize: 10,
                                          color: Colors.orange[700],
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            ],
                          ),
                        );
                      },
                      loading: () => const SizedBox.shrink(),
                      error: (_, __) => const SizedBox.shrink(),
                    ),
                  ],
                ),
              ),
            ),
          ),
          if (isSent)
            Padding(
              padding: const EdgeInsets.only(left: 8),
              child: CircleAvatar(
                radius: 16,
                backgroundColor: theme.colorScheme.primary,
                child: Icon(
                  Icons.person,
                  size: 12,
                  color: Colors.white,
                ),
              ),
            ),
        ],
      ),
    );
  }

  /// Show context menu with AI features and copy/paste options (iPhone-style)
  void _showContextMenu(BuildContext context, WidgetRef ref) {
    final analysisAsync = ref.read(messageAnalysisProvider(message.id));
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    // iPhone-style popup menu
    showDialog(
      context: context,
      barrierColor: Colors.transparent,
      builder: (context) => GestureDetector(
        onTap: () => Navigator.pop(context),
        child: Material(
          color: Colors.transparent,
          child: Stack(
            children: [
              // Blur background
              Positioned.fill(
                child: Container(
                  color: Colors.black.withOpacity(0.1),
                ),
              ),
              // Center popup
              Center(
                child: Container(
                  margin: const EdgeInsets.symmetric(horizontal: 40),
                  decoration: BoxDecoration(
                    color: isDark ? AppTheme.darkGray100.withOpacity(0.95) : AppTheme.white.withOpacity(0.95),
                    borderRadius: BorderRadius.circular(14),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.3),
                        blurRadius: 30,
                        spreadRadius: 5,
                      ),
                    ],
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // AI Features (for received messages)
                      if (!isSent) ...[
                        _buildPopupOption(
                          context,
                          icon: Icons.psychology_outlined,
                          label: 'Analyze Message',
                          color: const Color(0xFF7C3AED), // Purple - interpreter
                          isDark: isDark,
                          isFirst: true,
                          onTap: () {
                            Navigator.pop(context);
                            analysisAsync.whenData((analysis) {
                              if (analysis != null) {
                                ToneDetailSheet.show(context, analysis, message.body, message.id);
                              }
                            });
                          },
                        ),
                        Divider(height: 1, color: isDark ? AppTheme.darkGray300 : AppTheme.gray300),
                      ],
                      
                      // Copy
                      _buildPopupOption(
                        context,
                        icon: Icons.content_copy,
                        label: 'Copy',
                        color: isDark ? AppTheme.gray400 : AppTheme.gray700,
                        isDark: isDark,
                        isFirst: isSent,
                        onTap: () {
                          Clipboard.setData(ClipboardData(text: message.body));
                          Navigator.pop(context);
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: const Text('Copied to clipboard'),
                              behavior: SnackBarBehavior.floating,
                              duration: const Duration(seconds: 1),
                            ),
                          );
                        },
                      ),
                      
                      // Retry (if unsent)
                      if (isSent && !message.isSynced) ...[
                        Divider(height: 1, color: isDark ? AppTheme.darkGray300 : AppTheme.gray300),
                        _buildPopupOption(
                          context,
                          icon: Icons.refresh,
                          label: 'Retry',
                          color: AppTheme.accentOrange,
                          isDark: isDark,
                          isLast: true,
                          onTap: () {
                            Navigator.pop(context);
                            onRetry?.call();
                          },
                        ),
                      ],
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildPopupOption(
    BuildContext context, {
    required IconData icon,
    required String label,
    required Color color,
    required bool isDark,
    required VoidCallback onTap,
    bool isFirst = false,
    bool isLast = false,
  }) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.vertical(
        top: isFirst ? const Radius.circular(14) : Radius.zero,
        bottom: isLast ? const Radius.circular(14) : Radius.zero,
      ),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 22, color: color),
            const SizedBox(width: 12),
            Text(
              label,
              style: TextStyle(
                fontSize: 17,
                fontWeight: FontWeight.w500,
                color: color,
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// Format time for display
  String _formatTime(DateTime dateTime) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final yesterday = today.subtract(const Duration(days: 1));
    final messageDate = DateTime(dateTime.year, dateTime.month, dateTime.day);

    if (messageDate == today) {
      return '${dateTime.hour}:${dateTime.minute.toString().padLeft(2, '0')}';
    } else if (messageDate == yesterday) {
      return 'Yesterday';
    } else {
      return '${dateTime.month}/${dateTime.day}';
    }
  }
}
</file>

<file path="frontend/lib/services/media_service.dart">
import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path/path.dart' as p;
import 'package:uuid/uuid.dart';
import 'package:messageai/state/providers.dart';

/// Media upload progress
class MediaUploadProgress {
  final int bytesTransferred;
  final int totalBytes;
  
  MediaUploadProgress({
    required this.bytesTransferred,
    required this.totalBytes,
  });
  
  double get progress => totalBytes > 0 ? bytesTransferred / totalBytes : 0;
  double get percentage => progress * 100;
}

/// Media service for handling uploads
class MediaService {
  final Ref ref;
  
  static const String _mediaBucket = 'media';
  static const String _avatarBucket = 'avatars';
  
  MediaService({required this.ref});

  /// Pick image from gallery
  Future<XFile?> pickImageFromGallery() async {
    final picker = ImagePicker();
    return picker.pickImage(source: ImageSource.gallery);
  }

  /// Pick image from camera
  Future<XFile?> pickImageFromCamera() async {
    final picker = ImagePicker();
    return picker.pickImage(source: ImageSource.camera);
  }

  /// Upload image to Supabase Storage
  Future<String> uploadImage(XFile file, {String bucket = 'media'}) async {
    final supabase = ref.watch(supabaseClientProvider);
    final userId = supabase.auth.currentUser?.id;
    
    if (userId == null) {
      throw Exception('User not authenticated');
    }
    
    try {
      // Generate unique filename
      const uuid = Uuid();
      final fileName = '${uuid.v4()}_${p.basename(file.path)}';
      final path = '$userId/$fileName';
      
      // Read file bytes
      final fileBytes = await file.readAsBytes();
      
      // Upload to storage
      await supabase.storage
          .from(bucket)
          .uploadBinary(
            path,
            fileBytes,
          );
      
      // Get public URL
      final url = supabase.storage
          .from(bucket)
          .getPublicUrl(path);
      
      return url;
    } catch (e) {
      print('Error uploading image: $e');
      rethrow;
    }
  }
  
  /// Upload avatar image
  Future<String> uploadAvatar(XFile file) async {
    return uploadImage(file, bucket: _avatarBucket);
  }

  /// Upload image with progress tracking
  Future<String> uploadImageWithProgress(
    XFile file,
    Function(MediaUploadProgress) onProgress,
  ) async {
    final supabase = ref.watch(supabaseClientProvider);
    
    try {
      // Generate unique filename
      const uuid = Uuid();
      final fileName = '${uuid.v4()}_${p.basename(file.path)}';
      final path = 'conversations/$fileName';
      
      // Read file bytes
      final fileBytes = await file.readAsBytes();
      final totalBytes = fileBytes.length;
      
      // Simulate progress (Supabase doesn't provide built-in progress)
      // In production, use a dedicated upload library
      int bytesTransferred = 0;
      
      // Upload to storage
      await supabase.storage
          .from(_mediaBucket)
          .uploadBinary(
            path,
            fileBytes,
          );
      
      bytesTransferred = totalBytes;
      onProgress(MediaUploadProgress(
        bytesTransferred: bytesTransferred,
        totalBytes: totalBytes,
      ));
      
      // Get public URL
      final url = supabase.storage
          .from(_mediaBucket)
          .getPublicUrl(path);
      
      return url;
    } catch (e) {
      print('Error uploading image with progress: $e');
      rethrow;
    }
  }

  /// Delete image from storage
  Future<void> deleteImage(String url) async {
    final supabase = ref.watch(supabaseClientProvider);
    
    try {
      // Extract path from URL
      final uri = Uri.parse(url);
      final pathSegments = uri.pathSegments;
      final path = pathSegments.sublist(4).join('/'); // Skip storage, v1, object, public
      
      await supabase.storage.from(_mediaBucket).remove([path]);
    } catch (e) {
      print('Error deleting image: $e');
    }
  }

  /// Compress image before upload
  Future<File> compressImage(XFile file, {int quality = 85}) async {
    // TODO: Implement image compression using image package
    // For now, return original file
    return File(file.path);
  }
}

/// Provider for media service
final mediaServiceProvider = Provider<MediaService>((ref) {
  return MediaService(ref: ref);
});

/// State notifier for handling media uploads
class MediaUploadNotifier extends StateNotifier<AsyncValue<String>> {
  final Ref ref;

  MediaUploadNotifier({required this.ref}) : super(const AsyncValue.data(''));

  /// Upload image
  Future<String> uploadImage(XFile file) async {
    state = const AsyncValue.loading();
    
    try {
      final mediaService = ref.watch(mediaServiceProvider);
      final url = await mediaService.uploadImage(file);
      state = AsyncValue.data(url);
      return url;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }

  /// Upload image with progress
  Future<String> uploadImageWithProgress(
    XFile file,
    Function(MediaUploadProgress) onProgress,
  ) async {
    state = const AsyncValue.loading();
    
    try {
      final mediaService = ref.watch(mediaServiceProvider);
      final url = await mediaService.uploadImageWithProgress(file, onProgress);
      state = AsyncValue.data(url);
      return url;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }
}

/// State notifier provider for media uploads
final mediaUploadNotifierProvider =
    StateNotifierProvider<MediaUploadNotifier, AsyncValue<String>>((ref) {
  return MediaUploadNotifier(ref: ref);
});
</file>

<file path="frontend/lib/services/message_service.dart">
import 'package:uuid/uuid.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/core/errors/error_handler.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/services/ai_analysis_service.dart';

class MessageService {
  static final MessageService _instance = MessageService._internal();

  factory MessageService() {
    return _instance;
  }

  MessageService._internal();

  final _db = AppDb.instance;
  final _supabase = SupabaseClientProvider.client;
  final _errorHandler = ErrorHandler();
  final _aiAnalysis = AIAnalysisService();
  
  // Callback for when message is successfully sent (for triggering push notifications)
  void Function(String conversationId, String messageId)? onMessageSent;

  /// Send a new message
  Future<Message> sendMessage({
    required String conversationId,
    required String body,
    String? mediaUrl,
  }) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final messageId = const Uuid().v4();
      
      final message = Message(
        id: messageId,
        conversationId: conversationId,
        senderId: currentUser.id,
        body: body,
        mediaUrl: mediaUrl,
        createdAt: now,
        updatedAt: now,
        isSynced: false,
      );

      // Save to local database first (optimistic UI)
      try {
        await _db.messageDao.upsertMessage(message);
        await _db.conversationDao.updateLastMessageTime(conversationId);
      } catch (error, stackTrace) {
        // Critical: Can't even save locally
        throw _errorHandler.handleError(
          error, 
          stackTrace: stackTrace, 
          context: 'Save Message Locally',
        );
      }

      // Sync to backend
      try {
        final payload = {
          'id': messageId,
          'conversation_id': conversationId,
          'sender_id': currentUser.id,
          'body': body,
          'media_url': mediaUrl,
          'created_at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
          'updated_at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
        };
        
        await _supabase.from('messages').insert(payload);
        await _db.messageDao.markMessageAsSynced(messageId);
        
        // Trigger push notifications (don't wait for it)
        _sendPushNotification(conversationId, messageId, body).catchError((e) {
          print('‚ö†Ô∏è Push notification failed: $e');
        });
        
        // Trigger AI analysis for sent messages (don't wait for it)
        _triggerAIAnalysis(messageId, body).catchError((e) {
          print('‚ö†Ô∏è AI analysis failed: $e');
        });
      } catch (error, stackTrace) {
        // Convert to AppError
        final appError = _errorHandler.handleError(
          error, 
          stackTrace: stackTrace, 
          context: 'Send Message',
        );
        
        // If it's a network error, message is saved locally for retry
        if (_errorHandler.isNetworkError(appError)) {
          // Don't throw - message will sync later
        } else if (!appError.isRetryable) {
          // For non-retryable errors (like unauthorized), delete the local message
          await _db.messageDao.deleteMessage(messageId);
          throw appError;
        } else {
          // For other errors, throw so UI can handle
          throw appError;
        }
      }

      return message;
    } catch (error, stackTrace) {
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error, 
        stackTrace: stackTrace, 
        context: 'Send Message',
      );
    }
  }

  /// Sync messages from backend for a conversation
  Future<void> syncMessages(String conversationId) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      // Fetch messages from backend ordered by created_at
      final response = await _supabase
          .from('messages')
          .select('*')
          .eq('conversation_id', conversationId)
          .order('created_at', ascending: true);

      // Save to local database with proper timestamps
      for (final msgData in response as List) {
        final createdAt = DateTime.parse(msgData['created_at'] as String);
        final updatedAt = DateTime.parse(msgData['updated_at'] as String);
        
        final message = Message(
          id: msgData['id'] as String,
          conversationId: msgData['conversation_id'] as String,
          senderId: msgData['sender_id'] as String,
          body: msgData['body'] as String,
          mediaUrl: msgData['media_url'] as String?,
          createdAt: createdAt.millisecondsSinceEpoch ~/ 1000,
          updatedAt: updatedAt.millisecondsSinceEpoch ~/ 1000,
          isSynced: true,
        );

        // Use upsert to avoid duplicates
        await _db.messageDao.upsertMessage(message);
      }
    } catch (error, stackTrace) {
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error, 
        stackTrace: stackTrace, 
        context: 'Sync Messages',
      );
    }
  }

  /// Get messages for a conversation (with optional sync)
  Future<List<Message>> getMessagesByConversation(
    String conversationId, {
    bool syncFirst = false,
  }) async {
    if (syncFirst) {
      await syncMessages(conversationId);
    }
    return _db.messageDao.getMessagesByConversation(conversationId);
  }

  /// Get recent messages for a conversation
  Future<List<Message>> getRecentMessages(String conversationId, {int limit = 50}) async {
    return _db.messageDao.getRecentMessages(conversationId, limit: limit);
  }

  /// Get message by ID
  Future<Message?> getMessageById(String id) async {
    return _db.messageDao.getMessageById(id);
  }

  /// Delete message
  Future<void> deleteMessage(String id) async {
    await _db.messageDao.deleteMessage(id);
  }

  /// Get current user ID
  String? getCurrentUserId() {
    return _supabase.auth.currentUser?.id;
  }

  /// Send push notification for new message
  Future<void> _sendPushNotification(
    String conversationId,
    String messageId,
    String messageBody,
  ) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) return;

      // Get sender profile for notification (use maybeSingle to handle missing profile)
      final profile = await _supabase
          .from('profiles')
          .select('username, email')
          .eq('user_id', currentUser.id)
          .maybeSingle();

      final senderName = profile?['username'] as String? ?? 
                         profile?['email'] as String? ?? 
                         currentUser.email ?? 
                         'Someone';

      // Call push notification edge function with auth header
      final accessToken = _supabase.auth.currentSession?.accessToken;
      if (accessToken == null) return;
      
      print('üîî Sending push notification for message: ${messageId.substring(0, 8)}');
      final response = await _supabase.functions.invoke(
        'push_notify',
        body: {
          'message_id': messageId,
          'conversation_id': conversationId,
          'sender_id': currentUser.id,
          'sender_name': senderName,
          'title': senderName,
          'body': messageBody,
        },
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      );
      print('‚úÖ Push notification sent: ${response.data}');
    } catch (e) {
      print('‚ùå Failed to send push notification: $e');
    }
  }
  
  /// Trigger AI analysis for a message (non-blocking)
  Future<void> _triggerAIAnalysis(String messageId, String messageBody) async {
    try {
      final analysis = await _aiAnalysis.requestAnalysis(messageId, messageBody);
      if (analysis != null) {
        print('‚ú® AI analysis completed for ${messageId.substring(0, 8)}: ${analysis.tone}');
      }
    } catch (e) {
      print('‚ö†Ô∏è AI analysis failed for ${messageId.substring(0, 8)}: $e');
    }
  }
}
</file>

<file path="frontend/lib/services/notification_service.dart">
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/foundation.dart' show kIsWeb;

/// Notification payload model
class NotificationPayload {
  final String? title;
  final String? body;
  final Map<String, dynamic> data;
  final String? messageId;

  NotificationPayload({
    this.title,
    this.body,
    required this.data,
    this.messageId,
  });

  /// Extract conversation ID from payload
  String? get conversationId => data['conversation_id'] as String?;

  /// Extract sender ID from payload
  String? get senderId => data['sender_id'] as String?;

  /// Extract message ID from payload
  String? get messageIdFromPayload => data['message_id'] as String?;

  /// Extract message body from payload
  String? get messageBody => data['message_body'] as String?;
}

/// Firebase Cloud Messaging service
class NotificationService {
  final FirebaseMessaging _messaging = FirebaseMessaging.instance;
  
  static const String _channelId = 'messages';
  static const String _channelName = 'Message Notifications';

  /// Initialize Firebase Messaging
  Future<void> initialize({
    required Function(NotificationPayload) onMessageReceived,
    required Function(String) onTokenRefresh,
  }) async {
    print('üîî ========================================');
    print('üîî INITIALIZING FIREBASE MESSAGING');
    print('üîî ========================================');
    
    // Skip Firebase Messaging on web due to compatibility issues
    if (kIsWeb) {
      print('‚ö†Ô∏è  Firebase Messaging not supported on web platform');
      return;
    }
    
    print('üì± Platform: Mobile (FCM supported)');
    
    try {
      print('üìù Requesting notification permissions...');
      // Request notification permissions
      final settings = await _messaging.requestPermission(
        alert: true,
        announcement: false,
        badge: true,
        criticalAlert: false,
        provisional: false,
        sound: true,
      );

      print('‚úÖ Permission status: ${settings.authorizationStatus}');

      // Get initial token
      print('üì± Getting FCM device token...');
      final token = await getDeviceToken();
      if (token != null) {
        print('‚úÖ FCM Token obtained: ${token.substring(0, 50)}...');
        print('   Full token: $token');
      } else {
        print('‚ö†Ô∏è  No FCM token obtained');
      }

      // Listen for token refresh
      FirebaseMessaging.instance.onTokenRefresh.listen((newToken) {
        print('FCM Token refreshed: $newToken');
        onTokenRefresh(newToken);
      });

      // Listen for foreground messages
      FirebaseMessaging.onMessage.listen((RemoteMessage message) {
        print('Got a message whilst in the foreground!');
        print('Message data: ${message.data}');

        final payload = NotificationPayload(
          title: message.notification?.title,
          body: message.notification?.body,
          data: message.data,
          messageId: message.messageId,
        );

        onMessageReceived(payload);
      });

      // Handle background message (top-level function)
      // This should be registered before the app starts
    } catch (e, stackTrace) {
      print('‚ùå ========================================');
      print('‚ùå ERROR INITIALIZING FIREBASE MESSAGING');
      print('‚ùå ========================================');
      print('Error: $e');
      print('Stack trace: $stackTrace');
      print('‚ùå ========================================');
    }
  }

  /// Get device token for sending notifications
  Future<String?> getDeviceToken() async {
    if (kIsWeb) return null;
    
    try {
      final token = await _messaging.getToken();
      return token;
    } catch (e) {
      print('Error getting device token: $e');
      return null;
    }
  }

  /// Subscribe to a topic
  Future<void> subscribeToTopic(String topic) async {
    if (kIsWeb) return;
    
    try {
      await _messaging.subscribeToTopic(topic);
      print('Subscribed to topic: $topic');
    } catch (e) {
      print('Error subscribing to topic: $e');
    }
  }

  /// Unsubscribe from a topic
  Future<void> unsubscribeFromTopic(String topic) async {
    if (kIsWeb) return;
    
    try {
      await _messaging.unsubscribeFromTopic(topic);
      print('Unsubscribed from topic: $topic');
    } catch (e) {
      print('Error unsubscribing from topic: $e');
    }
  }

  /// Check if notifications are enabled
  Future<bool> areNotificationsEnabled() async {
    if (kIsWeb) return false;
    
    try {
      final settings = await _messaging.getNotificationSettings();
      return settings.authorizationStatus == AuthorizationStatus.authorized;
    } catch (e) {
      print('Error checking notification settings: $e');
      return false;
    }
  }

  /// Handle notification tap
  Future<void> setupNotificationTapHandler({
    required Function(String) onNotificationTapped,
  }) async {
    if (kIsWeb) return;
    
    try {
      // When the app is in foreground and user taps notification
      FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
        print('Notification tapped: ${message.data}');
        final conversationId = message.data['conversation_id'] as String?;
        if (conversationId != null) {
          onNotificationTapped(conversationId);
        }
      });

      // Check if app was opened from a notification when app was terminated
      final initialMessage = await _messaging.getInitialMessage();
      if (initialMessage != null) {
        print('App opened from notification: ${initialMessage.data}');
        final conversationId = initialMessage.data['conversation_id'] as String?;
        if (conversationId != null) {
          onNotificationTapped(conversationId);
        }
      }
    } catch (e) {
      print('Error setting up notification tap handler: $e');
    }
  }
}

/// Provider for notification service
final notificationServiceProvider = Provider<NotificationService>((ref) {
  return NotificationService();
});

/// Store device token
final deviceTokenProvider = StateProvider<String?>((ref) {
  return null;
});

/// Handle notification reception
final notificationHandlerProvider = FutureProvider<void>((ref) async {
  final service = ref.watch(notificationServiceProvider);
  
  // This would be called after the service is initialized
  // Placeholder for notification setup
});
</file>

<file path="frontend/lib/services/presence_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Service for tracking user presence and online status
class PresenceService {
  static final PresenceService _instance = PresenceService._internal();

  factory PresenceService() {
    return _instance;
  }

  PresenceService._internal();

  final _supabase = SupabaseClientProvider.client;
  final Map<String, RealtimeChannel> _channels = {};
  final Map<String, Set<String>> _onlineUsers = {};

  /// Subscribe to presence updates for a conversation
  Future<void> subscribeToPresence(String conversationId) async {
    if (_channels.containsKey(conversationId)) {
      return; // Already subscribed
    }

    final channel = _supabase.realtime.channel('presence:$conversationId');

    // Listen for presence events using the 'on' method
    channel.on(RealtimeListenTypes.presence, ChannelFilter(event: 'sync'), (payload, [ref]) {
      print('üë• Presence sync for $conversationId');
      _updateOnlineUsers(conversationId, channel);
    });

    channel.on(RealtimeListenTypes.presence, ChannelFilter(event: 'join'), (payload, [ref]) {
      print('üëã User joined: ${payload['user_id'] ?? 'unknown'}');
      _updateOnlineUsers(conversationId, channel);
    });

    channel.on(RealtimeListenTypes.presence, ChannelFilter(event: 'leave'), (payload, [ref]) {
      print('üëã User left: ${payload['user_id'] ?? 'unknown'}');
      _updateOnlineUsers(conversationId, channel);
    });

    // Subscribe with extended timeout for slower connections
    channel.subscribe(
      (status, [err]) {
        print('Presence subscription status: $status');
        if (status == 'SUBSCRIBED') {
          _updateOnlineUsers(conversationId, channel);
          // Periodically update to catch any missed events
          Future.delayed(const Duration(seconds: 1), () {
            _updateOnlineUsers(conversationId, channel);
          });
        }
        if (err != null) {
          print('Error subscribing to presence: $err');
        }
      },
      const Duration(seconds: 30), // Increased timeout for mobile networks
    );

    _channels[conversationId] = channel;
  }

  /// Unsubscribe from presence updates
  Future<void> unsubscribeFromPresence(String conversationId) async {
    final channel = _channels.remove(conversationId);
    if (channel != null) {
      await channel.unsubscribe();
    }
    _onlineUsers.remove(conversationId);
  }

  /// Broadcast user presence
  Future<void> setPresenceStatus(String conversationId, bool isOnline) async {
    final channel = _channels[conversationId];
    if (channel == null) return;

    final currentUser = _supabase.auth.currentUser;
    if (currentUser == null) return;

    try {
      await channel.track({
        'user_id': currentUser.id,
        'online': isOnline,
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('Error setting presence: $e');
    }
  }

  /// Get online users for a conversation
  Set<String> getOnlineUsers(String conversationId) {
    return _onlineUsers[conversationId] ?? {};
  }

  /// Check if a user is online
  bool isUserOnline(String conversationId, String userId) {
    return _onlineUsers[conversationId]?.contains(userId) ?? false;
  }

  void _updateOnlineUsers(String conversationId, RealtimeChannel channel) {
    try {
      final presenceState = channel.presenceState();
      final onlineSet = <String>{};

      // Iterate through all presence states
      for (final entry in presenceState.entries) {
        for (final presence in entry.value) {
          // Access the payload property which contains the tracked data
          final payload = presence.payload;
          if (payload is Map<String, dynamic>) {
            if (payload['online'] == true) {
              final userId = payload['user_id'] as String?;
              if (userId != null) {
                onlineSet.add(userId);
              }
            }
          }
        }
      }

      _onlineUsers[conversationId] = onlineSet;
      print('üìä Online users updated: ${onlineSet.length} users online');
    } catch (e) {
      print('Error updating online users: $e');
    }
  }

  /// Clean up all subscriptions
  Future<void> dispose() async {
    for (final channel in _channels.values) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        print('Error unsubscribing: $e');
      }
    }
    _channels.clear();
    _onlineUsers.clear();
  }
}
</file>

<file path="frontend/lib/services/realtime_message_service.dart">
import 'dart:async';
import 'package:uuid/uuid.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/services/realtime_diagnostic_service.dart';
import 'package:messageai/services/ai_analysis_service.dart';

/// Service for real-time message synchronization
class RealTimeMessageService {
  static final RealTimeMessageService _instance =
      RealTimeMessageService._internal();

  factory RealTimeMessageService() {
    return _instance;
  }

  RealTimeMessageService._internal();

  final _supabase = SupabaseClientProvider.client;
  final _db = AppDb.instance;
  final _diagnostics = RealtimeDiagnosticService();
  final _aiAnalysis = AIAnalysisService();
  final Map<String, RealtimeChannel> _channels = {};
  final Map<String, RealtimeChannel> _receiptChannels = {};
  final Map<String, StreamController<List<Message>>> _messageControllers = {};
  final Map<String, StreamController<List<Receipt>>> _receiptControllers = {};

  /// Subscribe to real-time messages for a conversation
  Stream<List<Message>> subscribeToMessages(String conversationId) {
    if (_messageControllers.containsKey(conversationId)) {
      return _messageControllers[conversationId]!.stream;
    }

    final controller = StreamController<List<Message>>.broadcast();
    _messageControllers[conversationId] = controller;

    _setupRealtimeListener(conversationId, controller);

    return controller.stream;
  }

  void _setupRealtimeListener(
    String conversationId,
    StreamController<List<Message>> controller,
  ) {
    try {
      final channelName = 'messages:$conversationId';
      final channel = _supabase.realtime.channel(channelName);
      
      // Register channel for diagnostics
      _diagnostics.registerChannel(channelName, channel);
      
      // Listen for postgres changes using the correct API
      channel.on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          filter: 'conversation_id=eq.$conversationId',
        ),
        (payload, [ref]) async {
          _diagnostics.recordMessageReceived(channelName);
          print('üì® Realtime message received');
          
          try {
            final data = payload['new'] as Map<String, dynamic>;
            final timestamp = DateTime.parse(data['created_at'] as String)
                .millisecondsSinceEpoch ~/
                1000;
            
            final message = Message(
              id: data['id'] as String,
              conversationId: data['conversation_id'] as String,
              senderId: data['sender_id'] as String,
              body: data['body'] as String,
              mediaUrl: data['media_url'] as String?,
              createdAt: timestamp,
              updatedAt: DateTime.parse(data['updated_at'] as String)
                  .millisecondsSinceEpoch ~/
                  1000,
              isSynced: true,
            );
            
            await _db.messageDao.upsertMessage(message);
            
            // Refresh the stream
            final messages =
                await _db.messageDao.getMessagesByConversation(conversationId);
            controller.add(messages);
            print('‚úÖ UI updated with ${messages.length} messages');
            
            // Create delivery receipt for received message
            final currentUser = _supabase.auth.currentUser;
            if (currentUser != null && message.senderId != currentUser.id) {
              await _createReceipt(message.id, currentUser.id, 'delivered');
              
              // Trigger AI analysis for received messages (non-blocking)
              _triggerAIAnalysis(message);
            }
          } catch (e) {
            print('‚ùå Error processing message: $e');
          }
        },
      );

      // Subscribe with extended timeout for slower connections
      channel.subscribe(
        (status, [err]) {
          _diagnostics.updateChannelStatus(channelName, status);
          
          // Log all status changes for debugging
          print('üì° Realtime [$conversationId]: $status');
          
          if (status == 'CHANNEL_ERROR' || status == 'TIMED_OUT' || err != null) {
            print('‚ùå Realtime error for $conversationId: $status ${err ?? ""}');
            if (err != null) {
              _diagnostics.recordError(channelName, err.toString());
              controller.addError(err);
            }
          }
        },
        const Duration(seconds: 30), // Increased timeout for mobile networks
      );

      _channels[conversationId] = channel;
      
      // Load initial messages
      Future.delayed(Duration.zero, () async {
        try {
          final messages =
              await _db.messageDao.getMessagesByConversation(conversationId);
          controller.add(messages);
        } catch (e) {
          controller.addError(e);
        }
      });
    } catch (e) {
      print('Error setting up realtime listener: $e');
      controller.addError(e);
    }
  }

  /// Trigger AI analysis for a message (non-blocking)
  void _triggerAIAnalysis(Message message) {
    // Run in background, don't await
    _aiAnalysis.requestAnalysis(message.id, message.body).then((analysis) {
      if (analysis != null) {
        print('‚ú® AI analysis completed for ${message.id.substring(0, 8)}: ${analysis.tone}');
      }
    }).catchError((error) {
      print('‚ö†Ô∏è AI analysis failed for ${message.id.substring(0, 8)}: $error');
    });
  }

  Future<void> _createReceipt(String messageId, String userId, String status) async {
    try {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final receiptId = const Uuid().v4();
      
      await _db.receiptDao.addReceipt(Receipt(
        id: receiptId,
        messageId: messageId,
        userId: userId,
        status: status,
        createdAt: now,
        updatedAt: now,
        isSynced: false,
      ));
      
      // Note: message_receipts table uses 'at' column, not 'created_at'
      await _supabase.from('message_receipts').insert({
        'id': receiptId,
        'message_id': messageId,
        'user_id': userId,
        'status': status,
        'at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
      });
      
      await _db.receiptDao.markReceiptAsSynced(receiptId);
    } catch (e) {
      // Silently fail - receipts are not critical
    }
  }

  /// Subscribe to real-time receipts for a conversation
  Stream<List<Receipt>> subscribeToReceipts(String conversationId) {
    if (_receiptControllers.containsKey(conversationId)) {
      return _receiptControllers[conversationId]!.stream;
    }

    final controller = StreamController<List<Receipt>>.broadcast();
    _receiptControllers[conversationId] = controller;

    _setupReceiptListener(conversationId, controller);

    return controller.stream;
  }

  void _setupReceiptListener(
    String conversationId,
    StreamController<List<Receipt>> controller,
  ) {
    try {
      final channelName = 'receipts:$conversationId';
      final channel = _supabase.realtime.channel(channelName);
      
      // Listen for receipt changes
      channel.on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: '*',  // All events (INSERT, UPDATE)
          schema: 'public',
          table: 'message_receipts',
        ),
        (payload, [ref]) async {
          print('üì® Receipt change received');
          
          try {
            // Reload all receipts for this conversation
            final receipts = await _db.receiptDao.getReceiptsByConversation(conversationId);
            controller.add(receipts);
          } catch (e) {
            print('‚ùå Error processing receipt: $e');
          }
        },
      );

      channel.subscribe(
        (status, [err]) {
          print('üì° Receipts [$conversationId]: $status');
          if (err != null) {
            controller.addError(err);
          }
        },
        const Duration(seconds: 30),
      );

      _receiptChannels[conversationId] = channel;
      
      // Load initial receipts
      Future.delayed(Duration.zero, () async {
        try {
          final receipts = await _db.receiptDao.getReceiptsByConversation(conversationId);
          controller.add(receipts);
        } catch (e) {
          controller.addError(e);
        }
      });
    } catch (e) {
      print('Error setting up receipt listener: $e');
      controller.addError(e);
    }
  }

  /// Unsubscribe from real-time messages
  Future<void> unsubscribeFromMessages(String conversationId) async {
    final controller = _messageControllers.remove(conversationId);
    controller?.close();

    final channel = _channels.remove(conversationId);
    if (channel != null) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
  }

  /// Unsubscribe from real-time receipts
  Future<void> unsubscribeFromReceipts(String conversationId) async {
    final controller = _receiptControllers.remove(conversationId);
    controller?.close();

    final channel = _receiptChannels.remove(conversationId);
    if (channel != null) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
  }

  /// Clean up all subscriptions
  Future<void> dispose() async {
    for (final controller in _messageControllers.values) {
      controller.close();
    }
    _messageControllers.clear();

    for (final controller in _receiptControllers.values) {
      controller.close();
    }
    _receiptControllers.clear();

    for (final channel in _channels.values) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
    _channels.clear();

    for (final channel in _receiptChannels.values) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
    _receiptChannels.clear();
    
    _diagnostics.dispose();
  }

  /// Get diagnostic report
  String getDiagnosticsReport() {
    return _diagnostics.generateReport();
  }

  /// Start diagnostic monitoring
  void startDiagnostics() {
    _diagnostics.startMonitoring();
  }

  /// Stop diagnostic monitoring
  void stopDiagnostics() {
    _diagnostics.stopMonitoring();
  }

  /// Test Realtime connection
  Future<RealtimeTestResult> testConnection() {
    return _diagnostics.testConnection();
  }
}
</file>

<file path="frontend/lib/services/typing_indicator_service.dart">
import 'dart:async';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Service to handle typing indicators using Supabase Realtime
class TypingIndicatorService {
  static final TypingIndicatorService _instance = TypingIndicatorService._internal();
  factory TypingIndicatorService() => _instance;
  TypingIndicatorService._internal();

  final _supabase = SupabaseClientProvider.client;
  final Map<String, RealtimeChannel> _channels = {};
  final Map<String, Set<String>> _typingUsers = {}; // conversationId -> Set of userIds
  final Map<String, StreamController<Set<String>>> _typingControllers = {};
  final Map<String, Timer?> _typingTimeouts = {}; // userId -> Timer

  static const _typingTimeout = Duration(seconds: 3);

  /// Subscribe to typing events for a conversation
  Stream<Set<String>> subscribeToTyping(String conversationId) {
    // Return existing stream if already subscribed
    if (_typingControllers.containsKey(conversationId)) {
      return _typingControllers[conversationId]!.stream;
    }

    // Create new stream controller
    final controller = StreamController<Set<String>>.broadcast();
    _typingControllers[conversationId] = controller;
    _typingUsers[conversationId] = {};

    // Create channel for this conversation
    final channel = _supabase.channel('typing:$conversationId');
    _channels[conversationId] = channel;

    // Listen for typing events using on() method
    channel.on(
      RealtimeListenTypes.broadcast,
      ChannelFilter(event: 'typing'),
      (payload, [ref]) {
        final data = payload as Map<String, dynamic>;
        final userId = data['user_id'] as String?;
        final isTyping = data['is_typing'] as bool? ?? false;
        final currentUserId = _supabase.auth.currentUser?.id;

        // Ignore own typing events
        if (userId == null || userId == currentUserId) return;

        final typingSet = _typingUsers[conversationId] ?? {};

        if (isTyping) {
          typingSet.add(userId);
          
          // Clear existing timeout for this user
          _typingTimeouts['$conversationId:$userId']?.cancel();
          
          // Set timeout to remove user from typing after inactivity
          _typingTimeouts['$conversationId:$userId'] = Timer(_typingTimeout, () {
            typingSet.remove(userId);
            _typingUsers[conversationId] = typingSet;
            if (!controller.isClosed) {
              controller.add(Set.from(typingSet));
            }
          });
        } else {
          typingSet.remove(userId);
          _typingTimeouts['$conversationId:$userId']?.cancel();
        }

        _typingUsers[conversationId] = typingSet;
        if (!controller.isClosed) {
          controller.add(Set.from(typingSet));
        }
      },
    );

    // Subscribe to channel with extended timeout
    channel.subscribe(
      (status, [err]) {
        print('Typing indicator subscription status: $status');
        if (err != null) {
          print('Error subscribing to typing indicator: $err');
        }
      },
      const Duration(seconds: 30), // Increased timeout for mobile networks
    );

    return controller.stream;
  }

  /// Send typing indicator
  Future<void> sendTypingIndicator(String conversationId, bool isTyping) async {
    final channel = _channels[conversationId];
    if (channel == null) return;

    final currentUserId = _supabase.auth.currentUser?.id;
    if (currentUserId == null) return;

    try {
      channel.send(
        type: RealtimeListenTypes.broadcast,
        event: 'typing',
        payload: {
          'user_id': currentUserId,
          'is_typing': isTyping,
        },
      );
    } catch (e) {
      print('Error sending typing indicator: $e');
    }
  }

  /// Unsubscribe from typing events for a conversation
  Future<void> unsubscribeFromTyping(String conversationId) async {
    final channel = _channels[conversationId];
    if (channel != null) {
      await channel.unsubscribe();
      _channels.remove(conversationId);
    }

    final controller = _typingControllers[conversationId];
    if (controller != null && !controller.isClosed) {
      await controller.close();
    }
    _typingControllers.remove(conversationId);
    _typingUsers.remove(conversationId);

    // Clear all timeouts for this conversation
    final keysToRemove = _typingTimeouts.keys
        .where((key) => key.startsWith('$conversationId:'))
        .toList();
    for (final key in keysToRemove) {
      _typingTimeouts[key]?.cancel();
      _typingTimeouts.remove(key);
    }
  }

  /// Get current typing users for a conversation
  Set<String> getTypingUsers(String conversationId) {
    return Set.from(_typingUsers[conversationId] ?? {});
  }

  /// Clean up all subscriptions
  Future<void> dispose() async {
    for (final channel in _channels.values) {
      await channel.unsubscribe();
    }
    _channels.clear();

    for (final controller in _typingControllers.values) {
      if (!controller.isClosed) {
        await controller.close();
      }
    }
    _typingControllers.clear();
    _typingUsers.clear();

    for (final timer in _typingTimeouts.values) {
      timer?.cancel();
    }
    _typingTimeouts.clear();
  }
}
</file>

<file path="frontend/lib/features/settings/screens/settings_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/features/auth/screens/auth_screen.dart';
import 'package:messageai/services/avatar_service.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_ui.dart';
import 'package:messageai/models/ai_feature.dart';
import 'package:messageai/features/settings/widgets/ai_feature_tile.dart';

/// User settings and account management screen
class SettingsScreen extends StatefulWidget {
  const SettingsScreen({Key? key}) : super(key: key);

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> with ErrorHandlerMixin {
  final _supabase = SupabaseClientProvider.client;
  final _avatarService = AvatarService();
  bool _notificationsEnabled = true;
  bool _isLoading = false;
  bool _isUploadingAvatar = false;
  String? _avatarUrl;
  
  // üÜï PHASE 4: AI Features state
  late Map<AIFeatureType, AIFeature> _aiFeatures;
  
  @override
  void initState() {
    super.initState();
    _loadProfile();
    _initializeAIFeatures();
  }
  
  /// Initialize all AI features as enabled by default
  void _initializeAIFeatures() {
    _aiFeatures = {
      AIFeatureType.smartMessageInterpreter: AIFeature(
        type: AIFeatureType.smartMessageInterpreter,
        isEnabled: true,
      ),
      AIFeatureType.adaptiveResponseAssistant: AIFeature(
        type: AIFeatureType.adaptiveResponseAssistant,
        isEnabled: true,
      ),
      AIFeatureType.smartInboxFilters: AIFeature(
        type: AIFeatureType.smartInboxFilters,
        isEnabled: true,
      ),
      AIFeatureType.ragContextPanel: AIFeature(
        type: AIFeatureType.ragContextPanel,
        isEnabled: true,
      ),
    };
  }
  
  /// Handle AI feature toggle
  void _handleFeatureToggle(AIFeatureType type, bool enabled) {
    setState(() {
      _aiFeatures[type]!.isEnabled = enabled;
    });
    // TODO: Save preference to backend/local storage
    print('ü§ñ ${_aiFeatures[type]!.config.title}: $enabled');
  }

  Future<void> _loadProfile() async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      final response = await _supabase
          .from('profiles')
          .select('avatar_url')
          .eq('user_id', userId)
          .maybeSingle();

      if (response != null && mounted) {
        setState(() {
          _avatarUrl = response['avatar_url'] as String?;
        });
      }
    } catch (e) {
      print('Error loading profile: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    final user = _supabase.auth.currentUser;
    final email = user?.email ?? 'Not logged in';
    final userId = user?.id ?? '';

    return Scaffold(
      appBar: AppBar(
        title: const Text('Settings'),
        elevation: 1,
      ),
      body: ListView(
        children: [
          // Profile Section (always visible)
          Container(
            padding: const EdgeInsets.all(24),
            color: Theme.of(context).colorScheme.surfaceContainer,
            child: Column(
              children: [
                Stack(
                  children: [
                    _isUploadingAvatar
                        ? const CircleAvatar(
                            radius: 50,
                            child: CircularProgressIndicator(),
                          )
                        : CircleAvatar(
                            radius: 50,
                            backgroundColor: Theme.of(context).colorScheme.primary,
                            backgroundImage: _avatarUrl != null
                                ? NetworkImage(_avatarUrl!)
                                : null,
                            child: _avatarUrl == null
                                ? Text(
                                    email[0].toUpperCase(),
                                    style: const TextStyle(
                                      fontSize: 40,
                                      fontWeight: FontWeight.bold,
                                      color: Colors.white,
                                    ),
                                  )
                                : null,
                          ),
                    Positioned(
                      bottom: 0,
                      right: 0,
                      child: Container(
                        decoration: BoxDecoration(
                          color: Theme.of(context).colorScheme.primary,
                          shape: BoxShape.circle,
                        ),
                        child: IconButton(
                          icon: const Icon(Icons.camera_alt, color: Colors.white, size: 20),
                          onPressed: _isUploadingAvatar ? null : _showAvatarOptions,
                          padding: const EdgeInsets.all(8),
                          constraints: const BoxConstraints(),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                Text(
                  email,
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                const SizedBox(height: 4),
                Text(
                  'ID: ${userId.substring(0, 8)}...',
                  style: Theme.of(context).textTheme.bodySmall,
                ),
              ],
            ),
          ),

          const SizedBox(height: 16),

          // üÜï AI FEATURES SECTION - ALWAYS EXPANDED AT TOP
          _buildSectionTitle('AI Features'),
          const SizedBox(height: 8),
          ...AIFeatureType.values.map((type) {
            return AIFeatureTile(
              feature: _aiFeatures[type]!,
              onToggle: (enabled) => _handleFeatureToggle(type, enabled),
            );
          }).toList(),

          const Divider(height: 32),

          // üÜï COLLAPSIBLE SECTIONS - Progressive Disclosure
          _buildCollapsibleSection(
            key: 'account',
            title: 'Account Settings',
            icon: Icons.person,
            children: [
              _buildSettingsTile(
                icon: Icons.person,
                title: 'Display Name',
                subtitle: email.split('@')[0],
                onTap: () => _showEditDisplayNameDialog(),
              ),
              _buildSettingsTile(
                icon: Icons.email,
                title: 'Email',
                subtitle: email,
                onTap: () {},
              ),
              _buildSettingsTile(
                icon: Icons.lock,
                title: 'Change Password',
                onTap: () => _showComingSoonDialog('Change Password'),
              ),
            ],
          ),

          _buildCollapsibleSection(
            key: 'notifications',
            title: 'Notifications',
            icon: Icons.notifications,
            children: [
              SwitchListTile(
                secondary: const Icon(Icons.notifications),
                title: const Text('Push Notifications'),
                subtitle: const Text('Receive message notifications'),
                value: _notificationsEnabled,
                onChanged: (value) {
                  setState(() => _notificationsEnabled = value);
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text(
                        value ? 'Notifications enabled' : 'Notifications disabled',
                      ),
                    ),
                  );
                },
              ),
              _buildSettingsTile(
                icon: Icons.volume_up,
                title: 'Notification Sound',
                subtitle: 'Default',
                onTap: () => _showComingSoonDialog('Notification Sounds'),
              ),
            ],
          ),

          _buildCollapsibleSection(
            key: 'security',
            title: 'Privacy & Security',
            icon: Icons.shield,
            children: [
              _buildSettingsTile(
                icon: Icons.block,
                title: 'Blocked Users',
                onTap: () => _showComingSoonDialog('Blocked Users'),
              ),
              _buildSettingsTile(
                icon: Icons.visibility,
                title: 'Online Status',
                subtitle: 'Visible to everyone',
                onTap: () => _showComingSoonDialog('Online Status Settings'),
              ),
              _buildSettingsTile(
                icon: Icons.check_circle,
                title: 'Read Receipts',
                subtitle: 'Enabled',
                onTap: () => _showComingSoonDialog('Read Receipts Settings'),
              ),
            ],
          ),

          _buildCollapsibleSection(
            key: 'storage',
            title: 'Storage',
            icon: Icons.storage,
            children: [
              _buildSettingsTile(
                icon: Icons.storage,
                title: 'Storage Usage',
                subtitle: 'Calculate storage...',
                onTap: () => _showComingSoonDialog('Storage Management'),
              ),
              _buildSettingsTile(
                icon: Icons.delete_sweep,
                title: 'Clear Cache',
                onTap: () => _showClearCacheDialog(),
              ),
            ],
          ),

          _buildCollapsibleSection(
            key: 'about',
            title: 'About',
            icon: Icons.info,
            children: [
              _buildSettingsTile(
                icon: Icons.info,
                title: 'App Version',
                subtitle: '1.0.0 (MVP)',
                onTap: () {},
              ),
              _buildSettingsTile(
                icon: Icons.privacy_tip,
                title: 'Privacy Policy',
                onTap: () => _showComingSoonDialog('Privacy Policy'),
              ),
              _buildSettingsTile(
                icon: Icons.description,
                title: 'Terms of Service',
                onTap: () => _showComingSoonDialog('Terms of Service'),
              ),
            ],
          ),

          const SizedBox(height: 16),

          // Logout Button
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: ElevatedButton.icon(
              onPressed: _isLoading ? null : _handleLogout,
              icon: _isLoading
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Icon(Icons.logout),
              label: const Text('Log Out'),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.red,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(vertical: 16),
              ),
            ),
          ),

          const SizedBox(height: 32),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 24, 16, 8),
      child: Text(
        title.toUpperCase(),
        style: TextStyle(
          fontSize: 12,
          fontWeight: FontWeight.w600,
          color: Theme.of(context).colorScheme.primary,
        ),
      ),
    );
  }

  Widget _buildCollapsibleSection({
    required String key,
    required String title,
    required IconData icon,
    required List<Widget> children,
  }) {
    return ExpansionTile(
      key: Key(key),
      leading: Icon(icon),
      title: Text(title),
      children: children,
    );
  }

  Widget _buildSettingsTile({
    required IconData icon,
    required String title,
    String? subtitle,
    VoidCallback? onTap,
  }) {
    return ListTile(
      leading: Icon(icon),
      title: Text(title),
      subtitle: subtitle != null ? Text(subtitle) : null,
      trailing: const Icon(Icons.chevron_right),
      onTap: onTap,
    );
  }

  /// Show avatar options (Gallery, Camera, Delete)
  void _showAvatarOptions() {
    showModalBottomSheet(
      context: context,
      builder: (BuildContext context) {
        return SafeArea(
          child: Wrap(
            children: [
              ListTile(
                leading: const Icon(Icons.photo_library),
                title: const Text('Choose from Gallery'),
                onTap: () {
                  Navigator.pop(context);
                  _uploadAvatarFromGallery();
                },
              ),
              ListTile(
                leading: const Icon(Icons.camera_alt),
                title: const Text('Take Photo'),
                onTap: () {
                  Navigator.pop(context);
                  _uploadAvatarFromCamera();
                },
              ),
              if (_avatarUrl != null)
                ListTile(
                  leading: const Icon(Icons.delete, color: Colors.red),
                  title: const Text('Remove Photo', style: TextStyle(color: Colors.red)),
                  onTap: () {
                    Navigator.pop(context);
                    _deleteAvatar();
                  },
                ),
              ListTile(
                leading: const Icon(Icons.cancel),
                title: const Text('Cancel'),
                onTap: () => Navigator.pop(context),
              ),
            ],
          ),
        );
      },
    );
  }

  /// Upload avatar from gallery
  Future<void> _uploadAvatarFromGallery() async {
    try {
      final image = await _avatarService.pickImage();
      if (image == null) return;

      await _uploadAvatar(image);
    } on AppError catch (error) {
      if (mounted) {
        showError(error);
      }
    }
  }

  /// Upload avatar from camera
  Future<void> _uploadAvatarFromCamera() async {
    try {
      final image = await _avatarService.pickImageFromCamera();
      if (image == null) return;

      await _uploadAvatar(image);
    } on AppError catch (error) {
      if (mounted) {
        showError(error);
      }
    }
  }

  /// Upload avatar to server
  Future<void> _uploadAvatar(image) async {
    if (mounted) {
      setState(() => _isUploadingAvatar = true);
    }

    try {
      final url = await _avatarService.uploadAvatar(image);

      if (mounted) {
        setState(() {
          _avatarUrl = url;
          _isUploadingAvatar = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 12),
                Text('Profile picture updated successfully'),
              ],
            ),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
      }
    } on AppError catch (error) {
      if (mounted) {
        setState(() => _isUploadingAvatar = false);
        showError(error);
      }
    }
  }

  /// Delete avatar
  Future<void> _deleteAvatar() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Remove Photo'),
        content: const Text('Are you sure you want to remove your profile picture?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('Remove'),
          ),
        ],
      ),
    );

    if (confirm != true) return;

    setState(() => _isUploadingAvatar = true);

    try {
      await _avatarService.deleteAvatar();

      if (mounted) {
        setState(() {
          _avatarUrl = null;
          _isUploadingAvatar = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Profile picture removed')),
        );
      }
    } on AppError catch (error) {
      if (mounted) {
        setState(() => _isUploadingAvatar = false);
        showError(error);
      }
    }
  }

  void _showEditDisplayNameDialog() {
    final controller = TextEditingController();
    final user = _supabase.auth.currentUser;
    controller.text = user?.email?.split('@')[0] ?? '';

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Edit Display Name'),
        content: TextField(
          controller: controller,
          decoration: const InputDecoration(
            labelText: 'Display Name',
            border: OutlineInputBorder(),
          ),
          autofocus: true,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Display name updated')),
              );
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  void _showComingSoonDialog(String feature) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Coming Soon'),
        content: Text('$feature will be available in a future update.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  void _showClearCacheDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Clear Cache'),
        content: const Text(
          'This will clear all cached images and files. Your messages will not be affected.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Cache cleared')),
              );
            },
            child: const Text('Clear'),
          ),
        ],
      ),
    );
  }

  Future<void> _handleLogout() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Log Out'),
        content: const Text('Are you sure you want to log out?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('Log Out'),
          ),
        ],
      ),
    );

    if (confirm == true && mounted) {
      setState(() => _isLoading = true);
      
      try {
        await _supabase.auth.signOut();
        
        if (mounted) {
          Navigator.of(context).pushAndRemoveUntil(
            MaterialPageRoute(
              builder: (context) => AuthScreen(onAuthSuccess: () {}),
            ),
            (route) => false,
          );
        }
      } catch (e) {
        if (mounted) {
          setState(() => _isLoading = false);
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error logging out: $e')),
          );
        }
      }
    }
  }
}
</file>

<file path="frontend/lib/app.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/features/auth/screens/auth_screen.dart';
import 'package:messageai/features/conversations/screens/conversations_list_screen.dart';
import 'package:messageai/features/messages/screens/message_screen.dart';
import 'package:messageai/state/providers.dart';
import 'package:messageai/services/device_registration_service.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

/// Global navigator key for deep linking and navigation from notifications
final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

/// Main application widget with lifecycle monitoring
class MessageAIApp extends ConsumerStatefulWidget {
  const MessageAIApp({Key? key}) : super(key: key);

  @override
  ConsumerState<MessageAIApp> createState() => _MessageAIAppState();
}

class _MessageAIAppState extends ConsumerState<MessageAIApp> with WidgetsBindingObserver {
  final _deviceRegistration = DeviceRegistrationService();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    // Update last_seen on app launch
    _updateLastSeen();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      // App came to foreground - update last_seen
      _updateLastSeen();
    }
  }

  Future<void> _updateLastSeen() async {
    try {
      print('‚è∞ Updating device last_seen...');
      final token = await FirebaseMessaging.instance.getToken();
      if (token != null) {
        await _deviceRegistration.updateDeviceLastSeen(token);
        print('‚úÖ Device last_seen updated');
      } else {
        print('‚ö†Ô∏è No FCM token available');
      }
    } catch (e) {
      print('‚ùå Failed to update last_seen: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'MessageAI',
      navigatorKey: navigatorKey,
      theme: AppTheme.lightTheme,
      darkTheme: AppTheme.darkTheme,
      themeMode: ThemeMode.system,
      home: const AuthGate(),
      routes: {
        '/auth': (_) => AuthScreen(onAuthSuccess: () {}),
        '/conversations': (_) => const ConversationsListScreen(),
      },
      // ‚úÖ Handle dynamic routes for deep linking (e.g., /conversation/:id)
      onGenerateRoute: (settings) {
        // Handle conversation deep links
        if (settings.name?.startsWith('/conversation/') ?? false) {
          final conversationId = settings.name!.split('/').last;
          
          print('üîó Deep link: navigating to conversation $conversationId');
          
          return MaterialPageRoute(
            builder: (_) => MessageScreen(
              conversationId: conversationId,
              conversationTitle: 'Chat', // Will be loaded by screen
            ),
            settings: settings,
          );
        }
        
        // Return null for unknown routes (will show error page)
        return null;
      },
    );
  }
}

/// Widget that routes between auth and main screens based on session
class AuthGate extends ConsumerWidget {
  const AuthGate({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isAuthenticated = ref.watch(isAuthenticatedProvider);

    return isAuthenticated.when(
      data: (authenticated) {
        if (authenticated) {
          return const ConversationsListScreen();
        } else {
          return AuthScreen(
            onAuthSuccess: () {
              // Refresh auth state - this will trigger a rebuild
              // ignore: unused_result
              ref.refresh(isAuthenticatedProvider);
            },
          );
        }
      },
      loading: () {
        return Scaffold(
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.chat_bubble,
                  size: 64,
                  color: Theme.of(context).colorScheme.primary,
                ),
                const SizedBox(height: 24),
                Text(
                  'MessageAI',
                  style: Theme.of(context).textTheme.headlineSmall,
                ),
                const SizedBox(height: 32),
                const CircularProgressIndicator(),
              ],
            ),
          ),
        );
      },
      error: (error, stackTrace) {
        return Scaffold(
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.error_outline,
                  size: 64,
                  color: Theme.of(context).colorScheme.error,
                ),
                const SizedBox(height: 24),
                Text(
                  'Error',
                  style: Theme.of(context).textTheme.headlineSmall,
                ),
                const SizedBox(height: 16),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 24),
                  child: Text(
                    error.toString(),
                    textAlign: TextAlign.center,
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}
</file>

<file path="frontend/lib/features/messages/screens/message_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/message_service.dart';
import 'package:messageai/services/conversation_service.dart';
import 'package:messageai/services/presence_service.dart';
import 'package:messageai/services/realtime_message_service.dart';
import 'package:messageai/services/typing_indicator_service.dart';
import 'package:messageai/services/context_preloader_service.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/features/messages/widgets/message_list_panel.dart';
import 'package:messageai/features/messages/widgets/context_panel.dart';
import 'package:messageai/models/conversation_context.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:image_picker/image_picker.dart';
import 'package:uuid/uuid.dart';
import 'dart:async';

class MessageScreen extends StatefulWidget {
  final String conversationId;
  final String conversationTitle;

  const MessageScreen({
    Key? key,
    required this.conversationId,
    required this.conversationTitle,
  }) : super(key: key);

  @override
  State<MessageScreen> createState() => _MessageScreenState();
}

class _MessageScreenState extends State<MessageScreen> {
  final _messageService = MessageService();
  final _conversationService = ConversationService();
  final _presenceService = PresenceService();
  final _realtimeService = RealTimeMessageService();
  final _typingService = TypingIndicatorService();
  final _contextService = ContextPreloaderService();
  final _receiptDao = AppDb.instance.receiptDao;
  final _messageController = TextEditingController();
  final _imagePicker = ImagePicker();
  late Future<List<Message>> _messagesFuture;
  late Future<List<Participant>> _participantsFuture;
  bool _isSending = false;
  bool _isUploadingImage = false;
  String? _currentUserId;
  Map<String, List<Receipt>> _receiptsCache = {};
  Set<String> _typingUsers = {};
  Timer? _typingTimer;
  XFile? _selectedImage;
  Set<String> _onlineUsers = {};
  double _panelPosition = 0.8; // Track sliding panel position (0.0 = down, 1.0 = up)
  ConversationContext? _conversationContext;

  @override
  void initState() {
    super.initState();
    _currentUserId = _messageService.getCurrentUserId();
    
    // Sync messages from backend first, then load
    _messagesFuture = _messageService.getMessagesByConversation(
      widget.conversationId,
      syncFirst: true,
    );
    _participantsFuture = _conversationService.getParticipants(widget.conversationId);
    
    // Initialize real-time features
    _initializeRealtime();
    
    // Load receipts
    _loadReceipts();
    
    // Load conversation context
    _loadContext();
    
    // Mark messages as read when opening conversation
    _messagesFuture.then((_) => _markMessagesAsRead());
    
    // üóëÔ∏è REMOVED: Auto-analysis should NOT run automatically
    // Analysis is now ONLY triggered by user manually long-pressing a message
    // (See MessageBubble widget for manual trigger)
    
    // Listen for text changes to send typing indicators
    _messageController.addListener(_onTextChanged);
  }

  Future<void> _loadContext() async {
    try {
      final context = await _contextService.loadContext(widget.conversationId);
      if (mounted) {
        setState(() {
          _conversationContext = context;
        });
      }
    } catch (e) {
      print('Error loading context: $e');
    }
  }

  Future<void> _loadReceipts() async {
    try {
      final receipts = await _receiptDao.getReceiptsByConversation(widget.conversationId);
      setState(() {
        _receiptsCache.clear();
        for (final receipt in receipts) {
          if (!_receiptsCache.containsKey(receipt.messageId)) {
            _receiptsCache[receipt.messageId] = [];
          }
          _receiptsCache[receipt.messageId]!.add(receipt);
        }
      });
    } catch (e) {
      print('Error loading receipts: $e');
    }
  }

  Future<void> _markMessagesAsRead() async {
    try {
      if (_currentUserId == null) return;
      
      // Get all messages
      final messages = await _messagesFuture;
      
      // Find unread messages from others
      for (final message in messages) {
        // Skip own messages
        if (message.senderId == _currentUserId) continue;
        
        // Check if we already have a read receipt
        final existingReceipts = _receiptsCache[message.id] ?? [];
        final hasReadReceipt = existingReceipts.any((r) => 
          r.userId == _currentUserId && r.status == 'read'
        );
        
        if (!hasReadReceipt) {
          await _createReadReceipt(message.id);
        }
      }
    } catch (e) {
      print('Error marking messages as read: $e');
    }
  }

  Future<void> _createReadReceipt(String messageId) async {
    try {
      if (_currentUserId == null) return;
      
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      
      // Check if receipt already exists
      final existingReceipt = await _receiptDao.getReceipt(messageId, _currentUserId!);
      
      if (existingReceipt != null) {
        // Update existing receipt to "read"
        await _receiptDao.updateReceiptStatus(messageId, _currentUserId!, 'read');
        
        // Sync to backend
        final supabase = SupabaseClientProvider.client;
        await supabase.from('message_receipts')
          .update({
            'status': 'read',
            'at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
          })
          .eq('message_id', messageId)
          .eq('user_id', _currentUserId!);
      } else {
        // Create new receipt
        final receiptId = const Uuid().v4();
        final receipt = Receipt(
          id: receiptId,
          messageId: messageId,
          userId: _currentUserId!,
          status: 'read',
          createdAt: now,
          updatedAt: now,
          isSynced: false,
        );
        
        await _receiptDao.addReceipt(receipt);
        
        final supabase = SupabaseClientProvider.client;
        await supabase.from('message_receipts').insert({
          'id': receiptId,
          'message_id': messageId,
          'user_id': _currentUserId,
          'status': 'read',
          'at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
        });
        
        await _receiptDao.markReceiptAsSynced(receiptId);
      }
    } catch (e) {
      print('Error creating read receipt: $e');
    }
  }

  Timer? _pollTimer;
  Timer? _presenceCheckTimer;

  Future<void> _initializeRealtime() async {
    try {
      // Subscribe to presence updates
      await _presenceService.subscribeToPresence(widget.conversationId);
      // Set current user as online
      await _presenceService.setPresenceStatus(widget.conversationId, true);
      
      // Poll presence status every 2 seconds to update UI
      _presenceCheckTimer = Timer.periodic(const Duration(seconds: 2), (timer) {
        if (mounted) {
          setState(() {
            _onlineUsers = _presenceService.getOnlineUsers(widget.conversationId);
          });
        }
      });
      
      // Subscribe to real-time messages
      _realtimeService.subscribeToMessages(widget.conversationId).listen((messages) {
        setState(() {
          _messagesFuture = Future.value(messages);
        });
        _loadReceipts();
        _markMessagesAsRead(); // Mark new messages as read
      });
      
      // Subscribe to real-time receipts
      _realtimeService.subscribeToReceipts(widget.conversationId).listen((receipts) {
        print('üì¨ Receipt update: ${receipts.length} total receipts');
        setState(() {
          _receiptsCache.clear();
          for (final receipt in receipts) {
            if (!_receiptsCache.containsKey(receipt.messageId)) {
              _receiptsCache[receipt.messageId] = [];
            }
            _receiptsCache[receipt.messageId]!.add(receipt);
            print('   - Message ${receipt.messageId.substring(0, 8)}: ${receipt.status} by ${receipt.userId.substring(0, 8)}');
          }
        });
      });
      
      // Subscribe to typing indicators
      _typingService.subscribeToTyping(widget.conversationId).listen((typingUserIds) {
        setState(() {
          _typingUsers = typingUserIds;
        });
      });
    } catch (e) {
      print('‚ùå Realtime init failed: $e');
    }
  }

  @override
  void dispose() {
    _messageController.removeListener(_onTextChanged);
    _messageController.dispose();
    _typingTimer?.cancel();
    _pollTimer?.cancel();
    _presenceCheckTimer?.cancel();
    // Set user as offline before leaving
    _presenceService.setPresenceStatus(widget.conversationId, false);
    // Clean up realtime subscriptions
    _presenceService.unsubscribeFromPresence(widget.conversationId);
    _realtimeService.unsubscribeFromMessages(widget.conversationId);
    _realtimeService.unsubscribeFromReceipts(widget.conversationId);
    _typingService.unsubscribeFromTyping(widget.conversationId);
    super.dispose();
  }

  void _onTextChanged() {
    if (_messageController.text.isNotEmpty) {
      // User is typing
      _typingService.sendTypingIndicator(widget.conversationId, true);
      
      // Reset the timer
      _typingTimer?.cancel();
      _typingTimer = Timer(const Duration(seconds: 2), () {
        // Stop typing after 2 seconds of inactivity
        _typingService.sendTypingIndicator(widget.conversationId, false);
      });
    } else {
      // User cleared text, stop typing
      _typingTimer?.cancel();
      _typingService.sendTypingIndicator(widget.conversationId, false);
    }
  }

  Future<void> _pickImage() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 1920,
        maxHeight: 1920,
        imageQuality: 85,
      );
      
      if (image != null) {
        setState(() {
          _selectedImage = image;
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error picking image: $e')),
        );
      }
    }
  }

  Future<String?> _uploadImage(XFile image) async {
    setState(() => _isUploadingImage = true);
    
    try {
      final userId = SupabaseClientProvider.client.auth.currentUser?.id;
      if (userId == null) throw Exception('User not authenticated');
      
      final fileBytes = await image.readAsBytes();
      final fileName = '${DateTime.now().millisecondsSinceEpoch}_${image.name}';
      final path = '$userId/$fileName';
      
      await SupabaseClientProvider.client.storage
          .from('media')
          .uploadBinary(path, fileBytes);
      
      final url = SupabaseClientProvider.client.storage
          .from('media')
          .getPublicUrl(path);
      
      return url;
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error uploading image: $e')),
        );
      }
      return null;
    } finally {
      if (mounted) {
        setState(() => _isUploadingImage = false);
      }
    }
  }

  Future<void> _sendMessage() async {
    final messageText = _messageController.text.trim();
    final hasText = messageText.isNotEmpty;
    final hasImage = _selectedImage != null;
    
    if (!hasText && !hasImage) return;
    if (_isSending || _isUploadingImage) return;

    // Clear input immediately for better UX
    _messageController.clear();
    final imageToSend = _selectedImage;
    setState(() {
      _selectedImage = null;
    });
    
    // Stop typing indicator when message is sent
    _typingTimer?.cancel();
    _typingService.sendTypingIndicator(widget.conversationId, false);

    setState(() => _isSending = true);

    try {
      String? mediaUrl;
      
      // Upload image if present
      if (imageToSend != null) {
        mediaUrl = await _uploadImage(imageToSend);
        if (mediaUrl == null) {
          throw Exception('Failed to upload image');
        }
      }
      
      await _messageService.sendMessage(
        conversationId: widget.conversationId,
        body: hasText ? messageText : 'üì∑ Photo',
        mediaUrl: mediaUrl,
      );

      setState(() {
        _messagesFuture = _messageService.getMessagesByConversation(widget.conversationId);
      });
      
      // Reload receipts to update delivery status
      _loadReceipts();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
        _messageController.text = messageText;
        if (imageToSend != null) {
          setState(() {
            _selectedImage = imageToSend;
          });
        }
      }
    } finally {
      if (mounted) {
        setState(() => _isSending = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    return WillPopScope(
      // üîß Always allow back navigation, even during analysis
      onWillPop: () async {
        Navigator.of(context).pop();
        return false; // We handle the pop manually
      },
      child: Scaffold(
        backgroundColor: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
        appBar: AppBar(
          title: Row(
            children: [
              Stack(
                children: [
                  CircleAvatar(
                    radius: 18,
                    backgroundColor: Colors.grey[300],
                    child: Icon(
                      Icons.group,
                      size: 20,
                      color: Colors.grey[700],
                    ),
                  ),
                  if (_onlineUsers.isNotEmpty)
                    Positioned(
                      right: 0,
                      bottom: 0,
                      child: Container(
                        padding: const EdgeInsets.all(4),
                        decoration: BoxDecoration(
                          color: Colors.green,
                          shape: BoxShape.circle,
                          border: Border.all(color: Colors.white, width: 2),
                        ),
                        child: Text(
                          '${_onlineUsers.length}',
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 10,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                ],
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      widget.conversationTitle,
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    if (_onlineUsers.isNotEmpty)
                      Text(
                        '${_onlineUsers.length} online',
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.white.withOpacity(0.8),
                        ),
                      ),
                  ],
                ),
              ),
            ],
          ),
          elevation: 1,
          actions: [
            IconButton(
              icon: const Icon(Icons.person_add),
              onPressed: _showAddParticipantsDialog,
              tooltip: 'Add participants',
            ),
            IconButton(
              icon: const Icon(Icons.more_vert),
              onPressed: () => _showParticipantsInfo(context),
              tooltip: 'Options',
            ),
          ],
        ),
        body: FutureBuilder<List<Message>>(
          future: _messagesFuture,
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Center(child: CircularProgressIndicator());
            }

            if (snapshot.hasError) {
              return Center(
                child: Text(
                  'Error: ${snapshot.error}',
                  style: theme.textTheme.bodyMedium,
                ),
              );
            }

            final messages = snapshot.data ?? [];

            return Column(
              children: [
                // Context Panel at top - shows relationship context
                ContextPanel(
                  conversationId: widget.conversationId,
                  context: _conversationContext,
                ),
                
                // Main area: Message list with sliding overlay
                Expanded(
                  child: Stack(
                    children: [
                      // Background: Message list
                      Container(
                        color: Theme.of(context).brightness == Brightness.dark 
                          ? AppTheme.darkGray200 
                          : AppTheme.gray50,
                        child: CustomScrollView(
                          slivers: [
                            SliverFillRemaining(
                              child: Container(),
                            ),
                          ],
                        ),
                      ),
                      
                      // Foreground: Sliding message panel (bottom fixed, top slides)
                      Align(
                        alignment: Alignment.bottomCenter,
                        child: GestureDetector(
                          onVerticalDragUpdate: (details) {
                            setState(() {
                              // Convert drag to panel height (inverted - drag down = smaller)
                              final screenHeight = MediaQuery.of(context).size.height;
                              final delta = -details.delta.dy / screenHeight;
                              _panelPosition = (_panelPosition + delta).clamp(0.12, 1.0);
                            });
                          },
                          onVerticalDragEnd: (details) {
                            // Snap to nearest position
                            setState(() {
                              if (_panelPosition < 0.18) {
                                _panelPosition = 0.12; // Minimized - just input + handle
                              } else if (_panelPosition < 0.4) {
                                _panelPosition = 0.3; // Small peek
                              } else if (_panelPosition < 0.65) {
                                _panelPosition = 0.5; // Half
                              } else if (_panelPosition < 0.9) {
                                _panelPosition = 0.85; // Most
                              } else {
                                _panelPosition = 1.0; // Full
                              }
                            });
                          },
                          child: AnimatedContainer(
                            duration: const Duration(milliseconds: 200),
                            curve: Curves.easeOut,
                            height: MediaQuery.of(context).size.height * _panelPosition,
                            width: double.infinity,
                            decoration: BoxDecoration(
                              color: isDark ? AppTheme.black : AppTheme.white,
                              borderRadius: const BorderRadius.only(
                                topLeft: Radius.circular(16),
                                topRight: Radius.circular(16),
                              ),
                              boxShadow: [
                                BoxShadow(
                                  color: Colors.black.withOpacity(0.3),
                                  blurRadius: 20,
                                  spreadRadius: 5,
                                  offset: const Offset(0, -5),
                                ),
                              ],
                            ),
                            child: Column(
                              children: [
                                // Drag handle at TOP
                                InkWell(
                                  onTap: () {
                                    setState(() {
                                      // Cycle through positions
                                      if (_panelPosition >= 1.0) {
                                        _panelPosition = 0.85; // Most
                                      } else if (_panelPosition >= 0.85) {
                                        _panelPosition = 0.5; // Half
                                      } else if (_panelPosition >= 0.5) {
                                        _panelPosition = 0.3; // Peek
                                      } else if (_panelPosition >= 0.3) {
                                        _panelPosition = 0.12; // Minimized
                                      } else {
                                        _panelPosition = 1.0; // Full
                                      }
                                    });
                                  },
                                  child: Container(
                                    width: double.infinity,
                                    padding: const EdgeInsets.symmetric(vertical: AppTheme.spacingM),
                                    child: Center(
                                      child: Container(
                                        width: 40,
                                        height: 5,
                                        decoration: BoxDecoration(
                                          color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                                          borderRadius: BorderRadius.circular(AppTheme.radiusPill),
                                        ),
                                      ),
                                    ),
                                  ),
                                ),
                                
                                // Message list
                                Expanded(
                                  child: MessageListPanel(
                                    messages: messages,
                                    currentUserId: _currentUserId,
                                    receiptsCache: _receiptsCache,
                                    typingUsers: _typingUsers,
                                    onlineUsers: _onlineUsers,
                                    messageController: _messageController,
                                    isSending: _isSending,
                                    isUploadingImage: _isUploadingImage,
                                    selectedImage: _selectedImage,
                                    onSendMessage: _sendMessage,
                                    onPickImage: _pickImage,
                                    onClearImage: () {
                                      setState(() {
                                        _selectedImage = null;
                                      });
                                    },
                                    showComposeBar: true,
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            );
          },
        ),
      ),
    );
  }

  void _showAddParticipantsDialog() {
    final emailController = TextEditingController();
    bool isSearching = false;
    
    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: const Text('Add Participant'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                controller: emailController,
                decoration: InputDecoration(
                  hintText: 'Enter email address',
                  helperText: 'Example: user@example.com',
                  prefixIcon: const Icon(Icons.email),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
                keyboardType: TextInputType.emailAddress,
                autofocus: true,
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: isSearching ? null : () async {
                final email = emailController.text.trim();
                if (email.isEmpty) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Please enter an email')),
                  );
                  return;
                }

                setState(() => isSearching = true);

                try {
                  // Add participant by email using database function
                  final response = await SupabaseClientProvider.client
                      .rpc('add_participant_by_email', params: {
                    'p_conversation_id': widget.conversationId,
                    'p_email': email,
                  });

                  final result = response as Map<String, dynamic>;
                  
                  if (result['success'] == false) {
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text(result['error'] ?? 'Failed to add participant')),
                      );
                    }
                    setState(() => isSearching = false);
                    return;
                  }
                  
                  if (mounted) {
                    Navigator.pop(context);
                    // Force refresh participants from backend
                    this.setState(() {
                      _participantsFuture = _conversationService.getParticipants(
                        widget.conversationId, 
                        syncFirst: true,  // Force sync from backend
                      );
                    });
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Added $email to conversation')),
                    );
                  }
                } catch (e) {
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Error: $e')),
                    );
                  }
                  setState(() => isSearching = false);
                }
              },
              child: isSearching 
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Text('Add'),
            ),
          ],
        ),
      ),
    );
  }

  void _showParticipantsInfo(BuildContext context) {
    showModalBottomSheet(
      context: context,
      builder: (context) => FutureBuilder<List<Participant>>(
        future: _participantsFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(child: Text('Error: ${snapshot.error}'));
          }

          final participants = snapshot.data ?? [];

          return SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Participants (${participants.length})',
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                  const SizedBox(height: 16),
                  if (participants.isEmpty)
                    const Center(
                      child: Padding(
                        padding: EdgeInsets.all(16),
                        child: Text('No participants yet'),
                      ),
                    )
                  else
                    ListView.builder(
                      shrinkWrap: true,
                      physics: const NeverScrollableScrollPhysics(),
                      itemCount: participants.length,
                      itemBuilder: (context, index) {
                        final participant = participants[index];
                        final isOnline = _presenceService.isUserOnline(
                          widget.conversationId,
                          participant.userId,
                        );
                        
                        return FutureBuilder<Map<String, dynamic>?>(
                          future: _conversationService.getParticipantProfile(participant.userId),
                          builder: (context, profileSnapshot) {
                            final profile = profileSnapshot.data;
                            final displayName = profile?['email'] as String? ?? 
                                              profile?['username'] as String? ?? 
                                              profile?['display_name'] as String? ??
                                              participant.userId.substring(0, 8);
                            final avatarUrl = profile?['avatar_url'] as String?;
                            final initial = displayName.isNotEmpty 
                                ? displayName[0].toUpperCase() 
                                : 'U';
                            
                            return ListTile(
                              leading: Stack(
                                children: [
                                  CircleAvatar(
                                    backgroundImage: avatarUrl != null
                                        ? NetworkImage(avatarUrl)
                                        : null,
                                    child: avatarUrl == null
                                        ? Text(initial)
                                        : null,
                                  ),
                                  Positioned(
                                    right: 0,
                                    bottom: 0,
                                    child: Container(
                                      width: 12,
                                      height: 12,
                                      decoration: BoxDecoration(
                                        color: isOnline ? Colors.green : Colors.grey,
                                        shape: BoxShape.circle,
                                        border: Border.all(
                                          color: Colors.white,
                                          width: 2,
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                              title: Text(displayName),
                              subtitle: Text(
                                isOnline
                                    ? (participant.isAdmin ? 'Admin ‚Ä¢ Online' : 'Member ‚Ä¢ Online')
                                    : (participant.isAdmin ? 'Admin ‚Ä¢ Offline' : 'Member ‚Ä¢ Offline'),
                              ),
                              trailing: participant.userId != _currentUserId
                                  ? IconButton(
                                      icon: const Icon(Icons.remove_circle),
                                      onPressed: () {
                                        Navigator.pop(context);
                                        _removeParticipant(participant.userId);
                                      },
                                    )
                                  : null,
                            );
                          },
                        );
                      },
                    ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Future<void> _removeParticipant(String userId) async {
    try {
      await _conversationService.removeParticipant(
        widget.conversationId,
        userId,
      );
      setState(() {
        _participantsFuture = _conversationService.getParticipants(widget.conversationId);
      });
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Participant removed')),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    }
  }

}
</file>

<file path="frontend/lib/main.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:messageai/core/env.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/state/notification_providers.dart';
import 'package:messageai/services/network_connectivity_service.dart';
import 'package:messageai/services/offline_queue_service.dart';
import 'package:messageai/app.dart';
import 'firebase_options.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

/// Background message handler for Firebase Cloud Messaging
/// This MUST be a top-level function (not inside a class)
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // Initialize Firebase if not already done
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  
  print('üîî Background message received!');
  print('   Title: ${message.notification?.title}');
  print('   Body: ${message.notification?.body}');
  print('   Data: ${message.data}');
  
  // Handle the background message here if needed
  // For now, just log it - the system notification will still appear
}

void main() async {
  // Ensure Flutter bindings are initialized
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase (required before any Firebase services)
  try {
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    print('‚úÖ Firebase initialized successfully');
    
    // Register background message handler (must be done after Firebase init)
    FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
    print('‚úÖ Background message handler registered');
  } catch (e) {
    print('‚ùå Firebase initialization error: $e');
    print('Push notifications will not work. Run "flutterfire configure" to set up Firebase.');
  }

  // Validate environment configuration
  Env.validate();

  // Initialize Supabase client
  await SupabaseClientProvider.initialize();

  // Initialize Drift database
  final db = AppDb.instance;
  
  // Initialize network services
  final connectivityService = NetworkConnectivityService();
  connectivityService.startMonitoring();
  
  final offlineQueueService = OfflineQueueService();
  offlineQueueService.startMonitoring();
  
  print('‚úÖ Network services initialized');
  
  // Run the app with Riverpod provider scope
  runApp(
    ProviderScope(
      child: _AppWithNotifications(),
    ),
  );
}

/// Wrapper widget to initialize notifications after ProviderScope
class _AppWithNotifications extends ConsumerWidget {
  const _AppWithNotifications();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Initialize notifications on app start
    final notificationInit = ref.watch(notificationInitializerProvider);
    
    notificationInit.when(
      data: (_) {
        print('üîî Notifications fully initialized!');
      },
      loading: () {
        print('üîÑ Initializing notifications...');
      },
      error: (error, stack) {
        print('‚ùå Notification initialization error: $error');
        print('Stack trace: $stack');
      },
    );

    return const MessageAIApp();
  }
}
</file>

<file path="frontend/lib/features/conversations/screens/conversations_list_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/conversation_service.dart';
import 'package:messageai/services/conversation_filter_service.dart';
import 'package:messageai/models/conversation_filter.dart';
import 'package:messageai/models/conversation_with_metadata.dart';
import 'package:messageai/features/conversations/widgets/conversation_filter_chips.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/features/messages/screens/message_screen.dart';
import 'package:messageai/features/settings/screens/settings_screen.dart';
import 'package:messageai/widgets/network_status_banner.dart';
import 'package:messageai/widgets/user_avatar.dart';

/// Screen showing list of conversations
class ConversationsListScreen extends StatefulWidget {
  const ConversationsListScreen({Key? key}) : super(key: key);

  @override
  State<ConversationsListScreen> createState() =>
      _ConversationsListScreenState();
}

class _ConversationsListScreenState extends State<ConversationsListScreen> {
  final _conversationService = ConversationService();
  final _filterService = ConversationFilterService();
  late Future<List<Conversation>> _conversationsFuture;
  Set<ConversationFilter> _activeFilters = {};
  Map<ConversationFilter, int>? _filterCounts;

  @override
  void initState() {
    super.initState();
    _conversationsFuture = _conversationService.getAllConversations();
    _updateFilterCounts();
  }
  
  Future<void> _refreshConversations() async {
    setState(() {
      _conversationsFuture = _conversationService.getAllConversations(syncFirst: true);
    });
    await _updateFilterCounts();
  }
  
  /// Update filter badge counts
  Future<void> _updateFilterCounts() async {
    try {
      final conversations = await _conversationsFuture;
      final allMeta = await Future.wait(
        conversations.map((c) => _filterService.getConversationMetadata(c)),
      );
      
      final counts = await _filterService.getFilterCounts(allMeta);
      
      if (mounted) {
        setState(() {
          _filterCounts = counts;
        });
      }
    } catch (e) {
      print('‚ùå Error updating filter counts: $e');
    }
  }
  
  /// Handle filter toggle
  void _handleFilterToggle(ConversationFilter filter) {
    setState(() {
      if (filter == ConversationFilter.all) {
        _activeFilters.clear();
      } else {
        if (_activeFilters.contains(filter)) {
          _activeFilters.remove(filter);
        } else {
          _activeFilters.add(filter);
        }
      }
    });
  }
  
  /// Get filtered conversations
  Future<List<ConversationWithMetadata>> _getFilteredConversations() async {
    final conversations = await _conversationsFuture;
    return await _filterService.filterConversations(
      conversations,
      _activeFilters,
    );
  }

  void _showNewConversationDialog() {
    final titleController = TextEditingController();
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('New Conversation'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: titleController,
              decoration: InputDecoration(
                hintText: 'Conversation title',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
              autofocus: true,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () async {
              if (titleController.text.isEmpty) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Please enter a title')),
                );
                return;
              }

              try {
                await _conversationService.createConversation(
                  title: titleController.text,
                );
                if (mounted) {
                  Navigator.pop(context);
                  setState(() {
                    // Don't re-sync from backend (keeps deleted convos deleted)
                    _conversationsFuture =
                        _conversationService.getAllConversations(syncFirst: false);
                  });
                }
              } catch (e) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Error: $e')),
                  );
                }
              }
            },
            child: const Text('Create'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('MessageAI'),
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.settings),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const SettingsScreen(),
                ),
              );
            },
            tooltip: 'Settings',
          ),
        ],
      ),
      body: Column(
        children: [
          const NetworkStatusBanner(),
          
          // üÜï ADD: Filter chips
          ConversationFilterChips(
            activeFilters: _activeFilters,
            onFilterToggled: _handleFilterToggle,
            badgeCounts: _filterCounts,
          ),
          
          // Conversation list (filtered)
          Expanded(
            child: RefreshIndicator(
              onRefresh: _refreshConversations,
              child: FutureBuilder<List<ConversationWithMetadata>>(
          future: _getFilteredConversations(),
          builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.error_outline,
                    size: 64,
                    color: Theme.of(context).colorScheme.error,
                  ),
                  const SizedBox(height: 16),
                  Text('Error: ${snapshot.error}'),
                ],
              ),
            );
          }

          final conversationsWithMeta = snapshot.data ?? [];

          if (conversationsWithMeta.isEmpty) {
            return _buildEmptyState();
          }

          return ListView.separated(
            itemCount: conversationsWithMeta.length,
            separatorBuilder: (context, index) => Divider(
              height: 1,
              indent: 72,
              color: Colors.grey[300],
            ),
            itemBuilder: (context, index) {
              final convMeta = conversationsWithMeta[index];
              return _buildConversationTile(convMeta);
            },
          );
          },
              ),
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _showNewConversationDialog,
        child: const Icon(Icons.add),
      ),
    );
  }

  String _formatTime(int? timestamp) {
    if (timestamp == null) return '';
    final dateTime = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inMinutes < 1) {
      return 'now';
    } else if (difference.inHours < 1) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inDays < 1) {
      return '${difference.inHours}h ago';
    } else if (difference.inDays < 7) {
      return '${difference.inDays}d ago';
    } else {
      return '${dateTime.month}/${dateTime.day}';
    }
  }
  
  /// üÜï Build empty state (with filter awareness)
  Widget _buildEmptyState() {
    if (_activeFilters.isNotEmpty) {
      // Filtered empty state
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.filter_list_off,
              size: 64,
              color: Colors.grey[400],
            ),
            const SizedBox(height: 16),
            Text(
              'No conversations match these filters',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
            TextButton(
              onPressed: () {
                setState(() => _activeFilters.clear());
              },
              child: const Text('Clear filters'),
            ),
          ],
        ),
      );
    }
    
    // Default empty state
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.chat_outlined,
            size: 80,
            color: Theme.of(context).colorScheme.primary.withOpacity(0.3),
          ),
          const SizedBox(height: 16),
          Text(
            'No conversations yet',
            style: Theme.of(context).textTheme.titleLarge,
          ),
          const SizedBox(height: 8),
          Text(
            'Start a new conversation to begin messaging',
            style: Theme.of(context).textTheme.bodyMedium,
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 32),
          ElevatedButton.icon(
            onPressed: _showNewConversationDialog,
            icon: const Icon(Icons.add),
            label: const Text('New Conversation'),
          ),
        ],
      ),
    );
  }
  
  /// üÜï Build conversation tile with metadata badges
  Widget _buildConversationTile(ConversationWithMetadata convMeta) {
    final conv = convMeta.conversation;
    
    return Dismissible(
      key: Key(conv.id),
      direction: DismissDirection.endToStart,
      background: Container(
        alignment: Alignment.centerRight,
        padding: const EdgeInsets.only(right: 20),
        color: Colors.red,
        child: const Icon(
          Icons.delete,
          color: Colors.white,
        ),
      ),
      confirmDismiss: (direction) async {
        return await showDialog(
          context: context,
          builder: (BuildContext context) {
            return AlertDialog(
              title: const Text('Delete Conversation'),
              content: Text(
                'Are you sure you want to delete "${conv.title}"? This cannot be undone.',
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(false),
                  child: const Text('Cancel'),
                ),
                TextButton(
                  onPressed: () => Navigator.of(context).pop(true),
                  style: TextButton.styleFrom(
                    foregroundColor: Colors.red,
                  ),
                  child: const Text('Delete'),
                ),
              ],
            );
          },
        );
      },
      onDismissed: (direction) async {
        try {
          await _conversationService.deleteConversation(conv.id);
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Deleted "${conv.title}"')),
            );
            setState(() {
              _conversationsFuture = _conversationService.getAllConversations(
                syncFirst: false,
              );
            });
          }
        } catch (e) {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Error deleting conversation: $e'),
                backgroundColor: Colors.red,
              ),
            );
          }
        }
      },
      child: InkWell(
        onTap: () {
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => MessageScreen(
                conversationId: conv.id,
                conversationTitle: conv.title,
              ),
            ),
          );
        },
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          child: Row(
            children: [
              UserAvatar(
                fallbackText: conv.title,
                radius: 28,
                isGroup: conv.isGroup,
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            conv.title,
                            style: const TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.w600,
                            ),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        // üÜï ADD: Priority/status badges
                        if (convMeta.hasUrgentMessages)
                          _buildIconBadge(
                            Icons.priority_high,
                            Colors.red,
                            'Urgent',
                          ),
                        if (convMeta.hasRSDTriggers)
                          _buildIconBadge(
                            Icons.warning_amber,
                            Colors.orange,
                            'RSD Trigger',
                          ),
                        if (convMeta.hasBoundaryViolations)
                          _buildIconBadge(
                            Icons.shield_outlined,
                            Colors.purple,
                            'Boundary Issue',
                          ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    FutureBuilder<Message?>(
                      future: _conversationService.getLatestMessage(conv.id),
                      builder: (context, snapshot) {
                        String previewText = 'Tap to start messaging';
                        
                        if (snapshot.hasData && snapshot.data != null) {
                          final message = snapshot.data!;
                          if (message.mediaUrl != null && message.mediaUrl!.isNotEmpty) {
                            previewText = 'üì∑ ${message.body}';
                          } else {
                            previewText = message.body;
                          }
                        }
                        
                        return Text(
                          previewText,
                          style: TextStyle(
                            fontSize: 14,
                            color: Colors.grey[600],
                          ),
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        );
                      },
                    ),
                  ],
                ),
              ),
              const SizedBox(width: 8),
              Column(
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    _formatTime(conv.lastMessageAt),
                    style: TextStyle(
                      fontSize: 12,
                      color: Theme.of(context).colorScheme.primary,
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  /// üÜï ADD: Icon badge helper
  Widget _buildIconBadge(IconData icon, Color color, String tooltip) {
    return Padding(
      padding: const EdgeInsets.only(left: 4),
      child: Tooltip(
        message: tooltip,
        child: Container(
          padding: const EdgeInsets.all(4),
          decoration: BoxDecoration(
            color: color.withOpacity(0.2),
            borderRadius: BorderRadius.circular(4),
          ),
          child: Icon(icon, size: 14, color: color),
        ),
      ),
    );
  }
}
</file>

<file path="frontend/pubspec.yaml">
name: messageai
description: MessageAI - Cross-platform messaging app with Flutter
version: 0.1.0+1
publish_to: none

environment:
  sdk: ^3.0.0
  flutter: ">=3.10.0"

dependencies:
  flutter:
    sdk: flutter

  # Network & API
  supabase_flutter: ^1.10.0
  dio: ^5.3.0

  # State management
  riverpod: ^2.4.0
  flutter_riverpod: ^2.4.0

  # Local database
  drift: ^2.14.0
  drift_flutter: ^0.2.7
  sqlite3_flutter_libs: ^0.5.16

  # Firebase
  firebase_core: ^2.27.0
  firebase_messaging: ^14.6.0

  # Local notifications (Phase 06)
  flutter_local_notifications: ^19.0.0

  # UI
  cupertino_icons: ^1.0.2

  # Utilities
  uuid: ^4.0.0
  image_picker: ^1.0.4
  path: ^1.8.3
  http: ^1.2.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter

  flutter_lints: ^3.0.0

  # Code generation
  build_runner: ^2.4.0
  drift_dev: ^2.14.0

flutter:
  uses-material-design: true

dependency_overrides:
  # Completely exclude sign_in_with_apple (uses deprecated Flutter APIs incompatible with latest Android)
  sign_in_with_apple:
  sign_in_with_apple_platform_interface:
  sign_in_with_apple_web:
</file>

</files>
