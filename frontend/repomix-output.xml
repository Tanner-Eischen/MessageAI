This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
.metadata
analysis_options.yaml
android/.gitignore
android/app/build.gradle.kts
android/app/src/debug/AndroidManifest.xml
android/app/src/main/AndroidManifest.xml
android/app/src/main/kotlin/com/example/messageai/MainActivity.kt
android/app/src/main/res/drawable-v21/launch_background.xml
android/app/src/main/res/drawable/launch_background.xml
android/app/src/main/res/mipmap-hdpi/ic_launcher.png
android/app/src/main/res/mipmap-mdpi/ic_launcher.png
android/app/src/main/res/mipmap-xhdpi/ic_launcher.png
android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png
android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
android/app/src/main/res/values-night/styles.xml
android/app/src/main/res/values/styles.xml
android/build.gradle.kts
android/gradle.properties
android/settings.gradle.kts
devtools_options.yaml
firebase.json
integration_test/ai_flow_test.dart
lib/app.dart
lib/core/env.dart
lib/core/errors/app_error.dart
lib/core/errors/error_handler.dart
lib/core/errors/error_ui.dart
lib/core/theme/app_theme.dart
lib/data/drift/app_db.dart
lib/data/drift/daos/ai_analysis_dao_cached.dart.backup
lib/data/drift/daos/conversation_dao.dart
lib/data/drift/daos/message_dao.dart
lib/data/drift/daos/participant_dao.dart
lib/data/drift/daos/pending_outbox_dao.dart
lib/data/drift/daos/receipt_dao.dart
lib/data/drift/entities/ai_analysis_cached.drift.backup
lib/data/drift/entities/conversation.drift
lib/data/remote/supabase_client.dart
lib/data/repositories/group_repository.dart
lib/data/repositories/message_repository.dart
lib/data/repositories/receipt_repository.dart
lib/features/auth/screens/auth_screen.dart
lib/features/conversations/screens/conversations_list_screen.dart
lib/features/conversations/widgets/message_bubble.dart
lib/features/messages/screens/message_screen.dart
lib/features/messages/widgets/ai_insights_background.dart
lib/features/messages/widgets/ai_insights_panel.dart
lib/features/messages/widgets/message_list_panel.dart
lib/features/messages/widgets/tone_badge.dart
lib/features/messages/widgets/tone_detail_sheet.dart
lib/features/notifications/widgets/notification_widgets.dart
lib/features/settings/screens/settings_screen.dart
lib/firebase_options.dart
lib/gen/api/api.dart
lib/gen/api/clients/messages_api.dart
lib/gen/api/clients/receipts_api.dart
lib/gen/api/models/message_payload.dart
lib/gen/api/models/receipt_payload.dart
lib/main.dart
lib/models/ai_analysis.dart
lib/services/ai_analysis_service_cached.dart.backup
lib/services/ai_analysis_service.dart
lib/services/auth_service.dart
lib/services/avatar_service.dart
lib/services/conversation_service.dart
lib/services/deep_link_handler.dart
lib/services/device_registration_service.dart
lib/services/local_notification_service.dart
lib/services/media_service.dart
lib/services/message_service.dart
lib/services/network_connectivity_service.dart
lib/services/notification_service.dart
lib/services/offline_queue_service.dart
lib/services/presence_service.dart
lib/services/realtime_diagnostic_service.dart
lib/services/realtime_message_service.dart
lib/services/retry_service.dart
lib/services/typing_indicator_service.dart
lib/state/ai_providers_cached.dart.backup
lib/state/ai_providers.dart
lib/state/database_provider.dart
lib/state/notification_providers.dart
lib/state/presence_providers.dart
lib/state/providers.dart
lib/state/realtime_providers.dart
lib/state/repository_providers.dart
lib/state/send_queue.dart
lib/state/typing_providers.dart
lib/widgets/network_status_banner.dart
lib/widgets/sliding_panel.dart
lib/widgets/user_avatar.dart
Makefile
pubspec.yaml
test/models/ai_analysis_test.dart
test/offline_queue_test.dart
test/realtime_diagnostic_test.dart
test/services/ai_analysis_service_test.dart
test/widget_test.dart
test/widgets/tone_badge_test.dart
web/favicon.png
web/icons/Icon-192.png
web/icons/Icon-512.png
web/icons/Icon-maskable-192.png
web/icons/Icon-maskable-512.png
web/index.html
web/manifest.json
windows/.gitignore
windows/CMakeLists.txt
windows/flutter/CMakeLists.txt
windows/runner/CMakeLists.txt
windows/runner/flutter_window.cpp
windows/runner/flutter_window.h
windows/runner/main.cpp
windows/runner/resource.h
windows/runner/resources/app_icon.ico
windows/runner/runner.exe.manifest
windows/runner/Runner.rc
windows/runner/utils.cpp
windows/runner/utils.h
windows/runner/win32_window.cpp
windows/runner/win32_window.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.packages
.pub-cache/
.pub/
/build/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release

# iOS/macOS
**/ios/**/*.mode1v3
**/ios/**/*.mode2v3
**/ios/**/*.moved-aside
**/ios/**/*.pbxuser
**/ios/**/*.perspectivev3
**/ios/**/*sync/
**/ios/**/.sconsign.dblite
**/ios/**/.tags*
**/ios/**/.vscode/*
!**/ios/**/.vscode/extensions.json
**/ios/**/DerivedData/
**/ios/**/Flutter/Flutter.framework/*
**/ios/**/Flutter/Flutter.podspec
**/ios/**/Flutter/Generated.xcconfig
**/ios/**/Flutter/ephemeral/
**/ios/**/Flutter/app.flx
**/ios/**/Flutter/app.zip
**/ios/**/Flutter/flutter_assets/
**/ios/**/Flutter/flutter_export_environment.sh
**/ios/**/GoogleService-Info.plist
**/ios/**/ServiceAccount.json
**/ios/**/.symlinks/
**/ios/**/.vagrant
**/ios/**/Flutter/Flutter.framework
**/ios/**/Flutter/Flutter.podspec
**/ios/Podfile
**/ios/Podfile.lock

# Web
lib/generated_plugin_registrant.dart

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
**/android/app/debug
**/android/app/profile
**/android/app/release
**/android/app/outputs
**/android/.gradle
**/android/captures/
**/android/gradlew
**/android/gradlew.bat
**/android/gradle/wrapper/gradle-wrapper.jar
**/android/gradle/wrapper/gradle-wrapper.properties

# Firebase
google-services.json
GoogleService-Info.plist
**/android/app/google-services.json
**/ios/GoogleService-Info.plist

# Exceptions to above rules.
!/packages/flutter_tools/test/data/dart_dependencies_test/**/.packages

# Environment files
.env
.env.local
.env.*.local
.env.dev.json
.env.prod.json

# Generated code
*.g.dart
*.config.dart
*.freezed.dart
*.chopper.dart

# Drift related
.dart_tool/build
lib/data/drift/**/*.g.dart

# Coverage
coverage/
.coverage

# Exceptions to above rules.
!/packages/flutter_tools/test/data/dart_dependencies_test/**/.packages

# Xcode related
*.xcarchive
*.xcworkspace
xcuser.xcuserdatad

# Compiled output
*.app/
*.framework/
*.so
.symbols/

# Obfuscation
app.*.map.json

# macOS
.DS_Store
.AppleDouble
.LSOverride
*.mode1v3
*.mode2v3
*.moved-aside
*.pbxuser
*.perspectivev3
**/*.sconsign.dblite
.sconsign.dblite
dsa_cert.certSigningRequest
profile
DerivedData/
build/
Generated.xcconfig
GeneratedPluginRegistrant.swift

# iOS
**/ios/.symlinks/
**/ios/.vagrant
**/ios/**/Flutter/Flutter.framework
**/ios/**/Flutter/Flutter.podspec
**/ios/**/Flutter/Generated.xcconfig
**/ios/**/Flutter/generated_plugin_registrant.m
**/ios/**/Flutter/ephemeral/
**/ios/**/GoogleService-Info.plist
**/ios/**/ServiceAccount.json
**/ios/**/.sconsign.dblite
**/ios/**/.tags
**/ios/**/.vscode/*
!**/ios/**/.vscode/extensions.json
**/ios/**/Flutter/.last_build_id
**/ios/**/Flutter/app.flx
**/ios/**/Flutter/app.zip
**/ios/**/Flutter/flutter_assets/
**/ios/**/Flutter/flutter_export_environment.sh

# Android
**/android/app/debug
**/android/app/profile
**/android/app/release
**/android/app/outputs/
**/android/.gradle
**/android/captures/
**/android/gradle-app.setting
**/android/gradlew
**/android/gradlew.bat
**/android/gradle/wrapper/gradle-wrapper.jar
**/android/gradle/wrapper/gradle-wrapper.properties
**/android/local.properties

# Web
lib/generated_plugin_registrant.dart

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
**/android/**/gradle-wrapper.jar
**/android/gradle
**/android/gradlew
**/android/gradlew.bat
**/android/local.properties
**/android/**/GeneratedPluginRegistrant.java

# iOS/macOS
**/ios/**/*.mode1v3
**/ios/**/*.mode2v3
**/ios/**/.vscode/*
!**/ios/**/.vscode/extensions.json
**/ios/**/DerivedData/
**/ios/**/Flutter/Flutter.framework
**/ios/**/Flutter/Flutter.podspec
**/ios/**/Flutter/Generated.xcconfig
**/ios/**/Flutter/ephemeral/
**/ios/**/Flutter/app.flx
**/ios/**/Flutter/app.zip
**/ios/**/Flutter/flutter_assets/
**/ios/**/Flutter/flutter_export_environment.sh
**/ios/**/GoogleService-Info.plist
**/ios/**/ServiceAccount.json
**/ios/**/.symlinks/
**/ios/**/.vagrant
**/macos/Flutter/Flutter-Debug.xcconfig
**/macos/Flutter/Flutter-Release.xcconfig
**/macos/Flutter/GeneratedPluginRegistrant.swift

# Windows
windows/flutter/generated_plugin_registrant.cc
windows/flutter/generated_plugin_registrant.h
windows/flutter/generated_plugins.cmake

# Linux
linux/flutter/generated_plugin_registrant.cc
linux/flutter/generated_plugin_registrant.h
linux/flutter/generated_plugins.cmake

# Coverage
coverage/

# Symbols
app.*.symbols

# Local env files
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# VS Code settings
.vscode/*
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json

# misc
*.deb
*.dsc
*.buildinfo
*.changes
*.orig.*
/.dart_tool
/.flutter-plugins
/.flutter-plugins-dependencies
/.packages
/.pub-cache
/pubspec.lock
/build
/linux/flutter/generated_plugin_registrant.cc
/linux/flutter/generated_plugin_registrant.h
/linux/flutter/generated_plugins.cmake
/macos/Flutter/GeneratedPluginRegistrant.swift
/web/plugins.json
/windows/flutter/generated_plugin_registrant.cc
/windows/flutter/generated_plugin_registrant.h
/windows/flutter/generated_plugins.cmake

# Firebase & Google Services
**/GoogleService-Info.plist
**/google-services.json
**/ServiceAccount.json

# Temporary files
*.tmp
*.swp
*.swo
*~
.~*

# System
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
</file>

<file path=".metadata">
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "9f455d2486bcb28cad87b062475f42edc959f636"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: 9f455d2486bcb28cad87b062475f42edc959f636
      base_revision: 9f455d2486bcb28cad87b062475f42edc959f636
    - platform: windows
      create_revision: 9f455d2486bcb28cad87b062475f42edc959f636
      base_revision: 9f455d2486bcb28cad87b062475f42edc959f636

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'
</file>

<file path="analysis_options.yaml">
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options
</file>

<file path="android/.gitignore">
gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java
.cxx/

# Remember to never publicly share your keystore.
# See https://flutter.dev/to/reference-keystore
key.properties
**/*.keystore
**/*.jks
</file>

<file path="android/app/build.gradle.kts">
plugins {
    id("com.android.application")
    // START: FlutterFire Configuration
    id("com.google.gms.google-services")
    // END: FlutterFire Configuration
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.messageai"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
        isCoreLibraryDesugaringEnabled = true
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_11.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.example.messageai"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
        multiDexEnabled = true
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}

dependencies {
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.1.4")
    
    // Exclude sign_in_with_apple which uses deprecated Flutter APIs
    configurations.all {
        exclude(group = "com.aboutyou.dart_packages", module = "sign_in_with_apple")
    }
}
</file>

<file path="android/app/src/debug/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
</file>

<file path="android/app/src/main/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="messageai"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>
</file>

<file path="android/app/src/main/kotlin/com/example/messageai/MainActivity.kt">
package com.example.messageai

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()
</file>

<file path="android/app/src/main/res/drawable-v21/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
</file>

<file path="android/app/src/main/res/drawable/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
</file>

<file path="android/app/src/main/res/values-night/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="android/app/src/main/res/values/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="android/build.gradle.kts">
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}
</file>

<file path="android/gradle.properties">
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
android.enableJetifier=true
</file>

<file path="android/settings.gradle.kts">
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.9.1" apply false
    // START: FlutterFire Configuration
    id("com.google.gms.google-services") version("4.3.15") apply false
    // END: FlutterFire Configuration
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
}

include(":app")
</file>

<file path="devtools_options.yaml">
description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:
</file>

<file path="firebase.json">
{"flutter":{"platforms":{"android":{"default":{"projectId":"messageai-e2e9e","appId":"1:397483513751:android:bb838799a2cd3f7f1c56d2","fileOutput":"android/app/google-services.json"}},"dart":{"lib/firebase_options.dart":{"projectId":"messageai-e2e9e","configurations":{"android":"1:397483513751:android:bb838799a2cd3f7f1c56d2","web":"1:397483513751:web:3121cbb846ddd8381c56d2","windows":"1:397483513751:web:ba73c764d577f4f51c56d2"}}}}}}
</file>

<file path="integration_test/ai_flow_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/app.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('AI Analysis Integration Flow', () {
    testWidgets('app structure loads correctly', (tester) async {
      // Verify the app widget exists
      const app = MessageAIApp();
      
      // Basic structure test
      expect(app, isA<MessageAIApp>());
    });
    
    testWidgets('complete AI analysis flow - TODO', (tester) async {
      // This is a placeholder for a full integration test
      // To implement when backend is fully configured:
      // 
      // 1. Initialize Supabase with test credentials
      // 2. Login with test user
      // 3. Navigate to a test conversation
      // 4. Send a message: "Hello, how are you doing today?"
      // 5. Wait for AI analysis to complete (may take 3-5 seconds)
      // 6. Verify ToneBadge appears on the message bubble
      // 7. Tap the badge to open ToneDetailSheet
      // 8. Verify sheet shows: tone, urgency level, intent, confidence
      // 9. Close sheet and pull down the message panel
      // 10. Verify AIInsightsPanel shows conversation-level insights
      // 
      // Requirements:
      // - Supabase running with test database
      // - OpenAI API key configured in ai_analyze_tone Edge Function
      // - Test user account in auth.users table
      // - Test conversation and participants in database
      
      // TODO: Implement full flow when authentication is configured
      expect(true, isTrue); // Placeholder assertion
    });
  });
}
</file>

<file path="lib/app.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/features/auth/screens/auth_screen.dart';
import 'package:messageai/features/conversations/screens/conversations_list_screen.dart';
import 'package:messageai/features/messages/screens/message_screen.dart';
import 'package:messageai/state/providers.dart';
import 'package:messageai/services/device_registration_service.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

/// Global navigator key for deep linking and navigation from notifications
final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

/// Main application widget with lifecycle monitoring
class MessageAIApp extends ConsumerStatefulWidget {
  const MessageAIApp({Key? key}) : super(key: key);

  @override
  ConsumerState<MessageAIApp> createState() => _MessageAIAppState();
}

class _MessageAIAppState extends ConsumerState<MessageAIApp> with WidgetsBindingObserver {
  final _deviceRegistration = DeviceRegistrationService();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    // Update last_seen on app launch
    _updateLastSeen();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      // App came to foreground - update last_seen
      _updateLastSeen();
    }
  }

  Future<void> _updateLastSeen() async {
    try {
      print('⏰ Updating device last_seen...');
      final token = await FirebaseMessaging.instance.getToken();
      if (token != null) {
        await _deviceRegistration.updateDeviceLastSeen(token);
        print('✅ Device last_seen updated');
      } else {
        print('⚠️ No FCM token available');
      }
    } catch (e) {
      print('❌ Failed to update last_seen: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'MessageAI',
      navigatorKey: navigatorKey,
      theme: AppTheme.lightTheme,
      darkTheme: AppTheme.darkTheme,
      themeMode: ThemeMode.system,
      home: const AuthGate(),
      routes: {
        '/auth': (_) => AuthScreen(onAuthSuccess: () {}),
        '/conversations': (_) => const ConversationsListScreen(),
      },
      // ✅ Handle dynamic routes for deep linking (e.g., /conversation/:id)
      onGenerateRoute: (settings) {
        // Handle conversation deep links
        if (settings.name?.startsWith('/conversation/') ?? false) {
          final conversationId = settings.name!.split('/').last;
          
          print('🔗 Deep link: navigating to conversation $conversationId');
          
          return MaterialPageRoute(
            builder: (_) => MessageScreen(
              conversationId: conversationId,
              conversationTitle: 'Chat', // Will be loaded by screen
            ),
            settings: settings,
          );
        }
        
        // Return null for unknown routes (will show error page)
        return null;
      },
    );
  }
}

/// Widget that routes between auth and main screens based on session
class AuthGate extends ConsumerWidget {
  const AuthGate({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isAuthenticated = ref.watch(isAuthenticatedProvider);

    return isAuthenticated.when(
      data: (authenticated) {
        if (authenticated) {
          return const ConversationsListScreen();
        } else {
          return AuthScreen(
            onAuthSuccess: () {
              // Refresh auth state - this will trigger a rebuild
              ref.refresh(isAuthenticatedProvider);
            },
          );
        }
      },
      loading: () {
        return Scaffold(
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.chat_bubble,
                  size: 64,
                  color: Theme.of(context).colorScheme.primary,
                ),
                const SizedBox(height: 24),
                Text(
                  'MessageAI',
                  style: Theme.of(context).textTheme.headlineSmall,
                ),
                const SizedBox(height: 32),
                const CircularProgressIndicator(),
              ],
            ),
          ),
        );
      },
      error: (error, stackTrace) {
        return Scaffold(
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.error_outline,
                  size: 64,
                  color: Theme.of(context).colorScheme.error,
                ),
                const SizedBox(height: 24),
                Text(
                  'Error',
                  style: Theme.of(context).textTheme.headlineSmall,
                ),
                const SizedBox(height: 16),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 24),
                  child: Text(
                    error.toString(),
                    textAlign: TextAlign.center,
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}
</file>

<file path="lib/core/env.dart">
/// Environment configuration for Supabase connection.
/// 
/// Reads SUPABASE_URL and SUPABASE_ANON_KEY from:
/// 1. Dart defines (via --dart-define-from-file=.env.dev.json)
/// 2. Environment variables as fallback

class Env {
  static const String supabaseUrl = String.fromEnvironment(
    'SUPABASE_URL',
    defaultValue: 'https://your-project.supabase.co',
  );

  static const String supabaseAnonKey = String.fromEnvironment(
    'SUPABASE_ANON_KEY',
    defaultValue: 'your-anon-key',
  );

  // Validate that required config is present
  static void validate() {
    assert(
      supabaseUrl != 'https://your-project.supabase.co',
      'SUPABASE_URL not configured',
    );
    assert(
      supabaseAnonKey != 'your-anon-key',
      'SUPABASE_ANON_KEY not configured',
    );
  }
}
</file>

<file path="lib/core/errors/app_error.dart">
/// Application error types and models
/// Provides structured error handling across the app

/// Error categories for classification
enum ErrorCategory {
  auth,
  network,
  database,
  messaging,
  storage,
  permission,
  validation,
  unknown,
}

/// Error severity levels
enum ErrorSeverity {
  info,     // Informational, no action required
  warning,  // Warning, user should be aware
  error,    // Error, user action may help
  critical, // Critical, likely requires app restart or support
}

/// Structured application error
class AppError implements Exception {
  final ErrorCategory category;
  final ErrorSeverity severity;
  final String code;
  final String message;
  final String? userMessage;
  final dynamic originalError;
  final StackTrace? stackTrace;
  final Map<String, dynamic>? context;
  final bool isRetryable;

  const AppError({
    required this.category,
    required this.severity,
    required this.code,
    required this.message,
    this.userMessage,
    this.originalError,
    this.stackTrace,
    this.context,
    this.isRetryable = false,
  });

  /// Get user-friendly error message
  String get displayMessage => userMessage ?? message;

  /// Check if error requires user action
  bool get requiresUserAction => 
      severity == ErrorSeverity.error || 
      severity == ErrorSeverity.critical;

  @override
  String toString() {
    return 'AppError($category.$code): $message';
  }

  /// Copy with modifications
  AppError copyWith({
    ErrorCategory? category,
    ErrorSeverity? severity,
    String? code,
    String? message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    Map<String, dynamic>? context,
    bool? isRetryable,
  }) {
    return AppError(
      category: category ?? this.category,
      severity: severity ?? this.severity,
      code: code ?? this.code,
      message: message ?? this.message,
      userMessage: userMessage ?? this.userMessage,
      originalError: originalError ?? this.originalError,
      stackTrace: stackTrace ?? this.stackTrace,
      context: context ?? this.context,
      isRetryable: isRetryable ?? this.isRetryable,
    );
  }
}

/// Authentication errors
class AuthError extends AppError {
  AuthError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = false,
  }) : super(
          category: ErrorCategory.auth,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory AuthError.invalidCredentials() => AuthError(
        code: 'AUTH001',
        message: 'Invalid email or password',
        userMessage: 'The email or password you entered is incorrect. Please try again.',
      );

  factory AuthError.emailAlreadyExists() => AuthError(
        code: 'AUTH002',
        message: 'Email already registered',
        userMessage: 'An account with this email already exists. Try signing in instead.',
      );

  factory AuthError.weakPassword() => AuthError(
        code: 'AUTH003',
        message: 'Password too weak',
        userMessage: 'Please choose a stronger password (at least 6 characters).',
      );

  factory AuthError.invalidEmail() => AuthError(
        code: 'AUTH004',
        message: 'Invalid email format',
        userMessage: 'Please enter a valid email address.',
      );

  factory AuthError.sessionExpired() => AuthError(
        code: 'AUTH005',
        message: 'Session expired',
        userMessage: 'Your session has expired. Please sign in again.',
      );

  factory AuthError.networkError() => AuthError(
        code: 'AUTH006',
        message: 'Network error during authentication',
        userMessage: 'Unable to connect. Please check your internet connection and try again.',
        isRetryable: true,
      );

  factory AuthError.unknown(dynamic error) => AuthError(
        code: 'AUTH999',
        message: 'Unknown authentication error',
        userMessage: 'Something went wrong during authentication. Please try again.',
        originalError: error,
        isRetryable: true,
      );
}

/// Network errors
class NetworkError extends AppError {
  NetworkError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
  }) : super(
          category: ErrorCategory.network,
          severity: ErrorSeverity.warning,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: true,
        );

  factory NetworkError.noConnection() => NetworkError(
        code: 'NET001',
        message: 'No internet connection',
        userMessage: 'No internet connection. Please check your network settings.',
      );

  factory NetworkError.timeout() => NetworkError(
        code: 'NET002',
        message: 'Request timeout',
        userMessage: 'The request took too long. Please try again.',
      );

  factory NetworkError.serverError() => NetworkError(
        code: 'NET003',
        message: 'Server error',
        userMessage: 'Server is temporarily unavailable. Please try again later.',
      );
}

/// Message sending errors
class MessageError extends AppError {
  MessageError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = true,
  }) : super(
          category: ErrorCategory.messaging,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory MessageError.sendFailed() => MessageError(
        code: 'MSG001',
        message: 'Failed to send message',
        userMessage: 'Unable to send message. Please try again.',
      );

  factory MessageError.networkError() => MessageError(
        code: 'MSG002',
        message: 'Network error while sending message',
        userMessage: 'Message saved offline. It will send when you\'re back online.',
      );

  factory MessageError.unauthorized() => MessageError(
        code: 'MSG003',
        message: 'Not authorized to send message',
        userMessage: 'You don\'t have permission to send messages to this conversation.',
        isRetryable: false,
      );

  factory MessageError.conversationNotFound() => MessageError(
        code: 'MSG004',
        message: 'Conversation not found',
        userMessage: 'This conversation no longer exists.',
        isRetryable: false,
      );

  factory MessageError.mediaTooLarge() => MessageError(
        code: 'MSG005',
        message: 'Media file too large',
        userMessage: 'The image is too large. Please choose a smaller file.',
        isRetryable: false,
      );

  factory MessageError.mediaUploadFailed() => MessageError(
        code: 'MSG006',
        message: 'Failed to upload media',
        userMessage: 'Unable to upload image. Please try again.',
      );
}

/// Storage errors
class StorageError extends AppError {
  StorageError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = true,
  }) : super(
          category: ErrorCategory.storage,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory StorageError.uploadFailed() => StorageError(
        code: 'STR001',
        message: 'Upload failed',
        userMessage: 'Unable to upload file. Please try again.',
      );

  factory StorageError.fileTooLarge() => StorageError(
        code: 'STR002',
        message: 'File too large',
        userMessage: 'The file is too large. Maximum size is 10MB.',
        isRetryable: false,
      );

  factory StorageError.unsupportedFormat() => StorageError(
        code: 'STR003',
        message: 'Unsupported file format',
        userMessage: 'This file type is not supported. Please use JPG, PNG, or GIF.',
        isRetryable: false,
      );
}

/// Database errors
class DatabaseError extends AppError {
  DatabaseError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = true,
  }) : super(
          category: ErrorCategory.database,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory DatabaseError.queryFailed() => DatabaseError(
        code: 'DB001',
        message: 'Database query failed',
        userMessage: 'Unable to fetch data. Please try again.',
      );

  factory DatabaseError.syncFailed() => DatabaseError(
        code: 'DB002',
        message: 'Sync failed',
        userMessage: 'Unable to sync data. Your changes are saved locally.',
      );
}

/// Permission errors
class PermissionError extends AppError {
  PermissionError({
    required String code,
    required String message,
    String? userMessage,
    bool isRetryable = false,
  }) : super(
          category: ErrorCategory.permission,
          severity: ErrorSeverity.warning,
          code: code,
          message: message,
          userMessage: userMessage,
          isRetryable: isRetryable,
        );

  factory PermissionError.cameraNotGranted() => PermissionError(
        code: 'PERM001',
        message: 'Camera permission not granted',
        userMessage: 'Camera access is required. Please enable it in Settings.',
      );

  factory PermissionError.storageNotGranted() => PermissionError(
        code: 'PERM002',
        message: 'Storage permission not granted',
        userMessage: 'Storage access is required. Please enable it in Settings.',
      );

  factory PermissionError.notificationsNotGranted() => PermissionError(
        code: 'PERM003',
        message: 'Notification permission not granted',
        userMessage: 'Enable notifications to receive message alerts.',
      );
}
</file>

<file path="lib/core/errors/error_handler.dart">
import 'package:messageai/core/errors/app_error.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

/// Global error handler service
class ErrorHandler {
  static final ErrorHandler _instance = ErrorHandler._internal();

  factory ErrorHandler() {
    return _instance;
  }

  ErrorHandler._internal();

  /// Convert any error to AppError
  AppError handleError(dynamic error, {StackTrace? stackTrace, String? context}) {
    AppError appError;

    if (error is AppError) {
      appError = error;
    } else if (error is AuthException) {
      appError = _handleAuthException(error);
    } else if (error is PostgrestException) {
      appError = _handlePostgrestException(error);
    } else if (error is StorageException) {
      appError = _handleStorageException(error);
    } else if (error is String) {
      appError = _handleStringError(error);
    } else {
      appError = _handleUnknownError(error);
    }

    // Log error
    _logError(appError, stackTrace, context);

    return appError;
  }

  /// Handle Supabase Auth exceptions
  AppError _handleAuthException(AuthException error) {
    final message = error.message.toLowerCase();

    if (message.contains('invalid login credentials') ||
        message.contains('invalid email or password')) {
      return AuthError.invalidCredentials();
    } else if (message.contains('already registered') ||
               message.contains('already been registered')) {
      return AuthError.emailAlreadyExists();
    } else if (message.contains('password') && message.contains('weak')) {
      return AuthError.weakPassword();
    } else if (message.contains('invalid email')) {
      return AuthError.invalidEmail();
    } else if (message.contains('session') && 
               (message.contains('expired') || message.contains('invalid'))) {
      return AuthError.sessionExpired();
    } else if (message.contains('network') || 
               message.contains('connection') ||
               message.contains('timeout')) {
      return AuthError.networkError();
    } else {
      return AuthError.unknown(error);
    }
  }

  /// Handle Supabase Postgrest (database) exceptions
  AppError _handlePostgrestException(PostgrestException error) {
    final message = error.message.toLowerCase();
    final code = error.code ?? '';

    // RLS policy violations
    if (code.contains('42501') || message.contains('permission denied')) {
      return MessageError.unauthorized();
    }

    // Foreign key violations
    if (code.contains('23503') || message.contains('foreign key')) {
      return MessageError.conversationNotFound();
    }

    // Network errors
    if (message.contains('network') || 
        message.contains('timeout') ||
        message.contains('connection')) {
      return NetworkError.noConnection();
    }

    // Server errors
    if (code.startsWith('5')) {
      return NetworkError.serverError();
    }

    // Generic database error
    return DatabaseError.queryFailed();
  }

  /// Handle Supabase Storage exceptions
  AppError _handleStorageException(StorageException error) {
    final message = error.message.toLowerCase();

    if (message.contains('size') || message.contains('too large')) {
      return StorageError.fileTooLarge();
    } else if (message.contains('format') || 
               message.contains('type') ||
               message.contains('invalid file')) {
      return StorageError.unsupportedFormat();
    } else {
      return StorageError.uploadFailed();
    }
  }

  /// Handle string errors (thrown as strings)
  AppError _handleStringError(String error) {
    final message = error.toLowerCase();

    // Auth errors
    if (message.contains('sign in') || message.contains('sign up')) {
      if (message.contains('failed')) {
        return AuthError.unknown(error);
      }
    }

    // Message errors
    if (message.contains('message')) {
      if (message.contains('failed') || message.contains('error')) {
        return MessageError.sendFailed();
      }
    }

    // Network errors
    if (message.contains('network') || 
        message.contains('connection') ||
        message.contains('offline') ||
        message.contains('internet')) {
      return NetworkError.noConnection();
    }

    // Generic error
    return AppError(
      category: ErrorCategory.unknown,
      severity: ErrorSeverity.error,
      code: 'UNK001',
      message: error,
      userMessage: 'Something went wrong. Please try again.',
      isRetryable: true,
    );
  }

  /// Handle unknown errors
  AppError _handleUnknownError(dynamic error) {
    return AppError(
      category: ErrorCategory.unknown,
      severity: ErrorSeverity.error,
      code: 'UNK999',
      message: error.toString(),
      userMessage: 'An unexpected error occurred. Please try again.',
      originalError: error,
      isRetryable: true,
    );
  }

  /// Log error for debugging
  void _logError(AppError error, StackTrace? stackTrace, String? context) {
    // Only log critical errors and non-retryable errors
    if (error.severity == ErrorSeverity.critical || !error.isRetryable) {
      final emoji = _getEmojiForSeverity(error.severity);
      print('$emoji ${error.code}: ${error.userMessage ?? error.message}');
    }
  }

  /// Get emoji for severity level
  String _getEmojiForSeverity(ErrorSeverity severity) {
    switch (severity) {
      case ErrorSeverity.info:
        return 'ℹ️';
      case ErrorSeverity.warning:
        return '⚠️';
      case ErrorSeverity.error:
        return '❌';
      case ErrorSeverity.critical:
        return '🚨';
    }
  }

  /// Check if error is network-related
  bool isNetworkError(AppError error) {
    return error.category == ErrorCategory.network ||
           (error.category == ErrorCategory.auth && error.code == 'AUTH006') ||
           (error.category == ErrorCategory.messaging && error.code == 'MSG002');
  }

  /// Check if error should trigger offline mode
  bool shouldGoOffline(AppError error) {
    return error.category == ErrorCategory.network &&
           error.code == 'NET001';
  }

  /// Get retry delay based on attempt number (exponential backoff)
  Duration getRetryDelay(int attemptNumber) {
    // Exponential backoff: 1s, 2s, 4s, 8s, 16s
    final delaySeconds = (1 << (attemptNumber - 1)).clamp(1, 16);
    return Duration(seconds: delaySeconds);
  }

  /// Check if should retry based on attempt count
  bool shouldRetry(AppError error, int attemptNumber, {int maxAttempts = 3}) {
    return error.isRetryable && attemptNumber < maxAttempts;
  }
}

/// Extension to add error handling to Future
extension FutureErrorHandler<T> on Future<T> {
  /// Handle errors and convert to AppError
  Future<T> handleAppError({String? context}) async {
    try {
      return await this;
    } catch (error, stackTrace) {
      throw ErrorHandler().handleError(error, stackTrace: stackTrace, context: context);
    }
  }
}
</file>

<file path="lib/core/errors/error_ui.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/errors/app_error.dart';

/// UI utilities for displaying errors to users
class ErrorUI {
  /// Show error as snackbar (for non-critical errors)
  static void showErrorSnackbar(
    BuildContext context,
    AppError error, {
    VoidCallback? onRetry,
  }) {
    final snackBar = SnackBar(
      content: Row(
        children: [
          Icon(
            _getIconForError(error),
            color: Colors.white,
            size: 20,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              error.displayMessage,
              style: const TextStyle(fontSize: 14),
            ),
          ),
        ],
      ),
      backgroundColor: _getColorForSeverity(error.severity),
      behavior: SnackBarBehavior.floating,
      action: error.isRetryable && onRetry != null
          ? SnackBarAction(
              label: 'Retry',
              textColor: Colors.white,
              onPressed: onRetry,
            )
          : null,
      duration: Duration(
        seconds: error.severity == ErrorSeverity.critical ? 6 : 4,
      ),
    );

    ScaffoldMessenger.of(context)
      ..hideCurrentSnackBar()
      ..showSnackBar(snackBar);
  }

  /// Show error as dialog (for critical errors or when user action required)
  static Future<bool?> showErrorDialog(
    BuildContext context,
    AppError error, {
    VoidCallback? onRetry,
    String? actionLabel,
  }) {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        icon: Icon(
          _getIconForError(error),
          color: _getColorForSeverity(error.severity),
          size: 48,
        ),
        title: Text(_getTitleForError(error)),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(error.displayMessage),
            if (error.code.isNotEmpty) ...[
              const SizedBox(height: 16),
              Text(
                'Error Code: ${error.code}',
                style: TextStyle(
                  fontSize: 12,
                  color: Colors.grey[600],
                ),
              ),
            ],
          ],
        ),
        actions: [
          if (!error.requiresUserAction)
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Dismiss'),
            ),
          if (error.isRetryable && onRetry != null)
            FilledButton(
              onPressed: () {
                Navigator.of(context).pop(true);
                onRetry();
              },
              child: Text(actionLabel ?? 'Retry'),
            ),
          if (!error.isRetryable || onRetry == null)
            FilledButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('OK'),
            ),
        ],
      ),
    );
  }

  /// Show permission error with option to open settings
  static Future<void> showPermissionError(
    BuildContext context,
    PermissionError error,
  ) {
    return showDialog(
      context: context,
      builder: (context) => AlertDialog(
        icon: const Icon(
          Icons.security,
          color: Colors.orange,
          size: 48,
        ),
        title: const Text('Permission Required'),
        content: Text(error.displayMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              Navigator.of(context).pop();
              // TODO: Open app settings
              // OpenSettings.openAppSettings();
            },
            child: const Text('Open Settings'),
          ),
        ],
      ),
    );
  }

  /// Show loading indicator with cancellation
  static Future<T?> showLoadingDialog<T>(
    BuildContext context, {
    required Future<T> Function() action,
    String message = 'Loading...',
  }) async {
    // Show loading dialog
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        content: Row(
          children: [
            const CircularProgressIndicator(),
            const SizedBox(width: 24),
            Text(message),
          ],
        ),
      ),
    );

    try {
      final result = await action();
      if (context.mounted) {
        Navigator.of(context).pop();
      }
      return result;
    } catch (error) {
      if (context.mounted) {
        Navigator.of(context).pop();
        if (error is AppError) {
          showErrorDialog(context, error);
        }
      }
      return null;
    }
  }

  /// Get icon for error
  static IconData _getIconForError(AppError error) {
    switch (error.category) {
      case ErrorCategory.auth:
        return Icons.lock_outline;
      case ErrorCategory.network:
        return Icons.wifi_off;
      case ErrorCategory.database:
        return Icons.storage_outlined;
      case ErrorCategory.messaging:
        return Icons.message_outlined;
      case ErrorCategory.storage:
        return Icons.cloud_upload_outlined;
      case ErrorCategory.permission:
        return Icons.security;
      case ErrorCategory.validation:
        return Icons.error_outline;
      case ErrorCategory.unknown:
        return Icons.warning_amber;
    }
  }

  /// Get color for severity
  static Color _getColorForSeverity(ErrorSeverity severity) {
    switch (severity) {
      case ErrorSeverity.info:
        return Colors.blue;
      case ErrorSeverity.warning:
        return Colors.orange;
      case ErrorSeverity.error:
        return Colors.red;
      case ErrorSeverity.critical:
        return Colors.red.shade900;
    }
  }

  /// Get title for error dialog
  static String _getTitleForError(AppError error) {
    switch (error.category) {
      case ErrorCategory.auth:
        return 'Authentication Error';
      case ErrorCategory.network:
        return 'Connection Problem';
      case ErrorCategory.database:
        return 'Data Error';
      case ErrorCategory.messaging:
        return 'Message Error';
      case ErrorCategory.storage:
        return 'Upload Error';
      case ErrorCategory.permission:
        return 'Permission Required';
      case ErrorCategory.validation:
        return 'Invalid Input';
      case ErrorCategory.unknown:
        return 'Error';
    }
  }
}

/// Mixin for widgets that need error handling
mixin ErrorHandlerMixin<T extends StatefulWidget> on State<T> {
  /// Show error to user
  void showError(AppError error, {VoidCallback? onRetry}) {
    if (!mounted) return;

    if (error.severity == ErrorSeverity.critical || error.requiresUserAction) {
      ErrorUI.showErrorDialog(context, error, onRetry: onRetry);
    } else {
      ErrorUI.showErrorSnackbar(context, error, onRetry: onRetry);
    }
  }

  /// Handle error from async operation
  Future<T?> handleAsyncError<T>(
    Future<T> Function() operation, {
    String? context,
    VoidCallback? onRetry,
  }) async {
    try {
      return await operation();
    } on AppError catch (error) {
      showError(error, onRetry: onRetry);
      return null;
    } catch (error) {
      final appError = AppError(
        category: ErrorCategory.unknown,
        severity: ErrorSeverity.error,
        code: 'UNK001',
        message: error.toString(),
        userMessage: 'An unexpected error occurred.',
      );
      showError(appError, onRetry: onRetry);
      return null;
    }
  }
}
</file>

<file path="lib/core/theme/app_theme.dart">
import 'package:flutter/material.dart';

/// MessageAI Theme System
/// Monochrome black/white/gray palette for clean, accessible design
class AppTheme {
  // Prevent instantiation
  AppTheme._();

  // ============================================================================
  // COLORS - Grayscale System
  // ============================================================================
  
  /// Pure colors
  static const Color white = Color(0xFFFFFFFF);
  static const Color black = Color(0xFF000000);
  
  /// Gray scale (Light Mode)
  static const Color gray50 = Color(0xFFFAFAFA);   // Almost white
  static const Color gray100 = Color(0xFFF5F5F5);  // Off white
  static const Color gray200 = Color(0xFFEEEEEE);  // Very light gray
  static const Color gray300 = Color(0xFFE0E0E0);  // Light gray
  static const Color gray400 = Color(0xFFBDBDBD);  // Light-medium gray
  static const Color gray500 = Color(0xFF9E9E9E);  // Medium gray
  static const Color gray600 = Color(0xFF757575);  // Medium-dark gray
  static const Color gray700 = Color(0xFF616161);  // Dark gray
  static const Color gray800 = Color(0xFF424242);  // Very dark gray
  static const Color gray900 = Color(0xFF212121);  // Almost black
  
  /// Dark mode grays
  static const Color darkGray100 = Color(0xFF1A1A1A);  // Near black surface
  static const Color darkGray200 = Color(0xFF242424);  // Dark surface
  static const Color darkGray300 = Color(0xFF2E2E2E);  // Medium dark
  static const Color darkGray400 = Color(0xFF3A3A3A);  // Lighter dark
  
  /// Accent colors (minimal use only)
  static const Color accentBlue = Color(0xFF000000);     // Actions, links
  static const Color accentGreen = Color(0xFF4CAF50);    // Online, success
  static const Color accentRed = Color(0xFFF44336);      // Error, urgent
  static const Color accentOrange = Color(0xFFFF9800);   // Warning
  
  // ============================================================================
  // TYPOGRAPHY
  // ============================================================================
  
  /// Font sizes
  static const double fontSizeXXL = 32.0;  // Page titles
  static const double fontSizeXL = 24.0;   // Section headers
  static const double fontSizeL = 20.0;    // Card titles
  static const double fontSizeM = 16.0;    // Body text (BASE)
  static const double fontSizeS = 14.0;    // Captions
  static const double fontSizeXS = 12.0;   // Timestamps
  static const double fontSizeXXS = 10.0;  // Micro-copy
  
  /// Font weights
  static const FontWeight fontWeightLight = FontWeight.w300;
  static const FontWeight fontWeightRegular = FontWeight.w400;
  static const FontWeight fontWeightMedium = FontWeight.w500;
  static const FontWeight fontWeightSemibold = FontWeight.w600;
  static const FontWeight fontWeightBold = FontWeight.w700;
  
  /// Line heights
  static const double lineHeightTight = 1.2;
  static const double lineHeightNormal = 1.5;
  static const double lineHeightRelaxed = 1.75;
  
  // ============================================================================
  // SPACING
  // ============================================================================
  
  /// Base unit: 4px - all spacing uses multiples of this
  static const double spacingXXS = 4.0;
  static const double spacingXS = 8.0;
  static const double spacingS = 12.0;
  static const double spacingM = 16.0;   // Standard spacing (BASE)
  static const double spacingL = 24.0;
  static const double spacingXL = 32.0;
  static const double spacingXXL = 48.0;
  static const double spacingXXXL = 64.0;
  
  // ============================================================================
  // BORDER RADIUS
  // ============================================================================
  
  static const double radiusNone = 0.0;
  static const double radiusXS = 2.0;
  static const double radiusS = 4.0;
  static const double radiusM = 8.0;    // Standard radius (BASE)
  static const double radiusL = 12.0;
  static const double radiusXL = 16.0;
  static const double radiusXXL = 24.0;
  static const double radiusPill = 9999.0;
  
  // ============================================================================
  // SHADOWS
  // ============================================================================
  
  /// Light mode shadows
  static List<BoxShadow> get shadow1Light => [
    BoxShadow(
      color: black.withOpacity(0.12),
      blurRadius: 3,
      offset: const Offset(0, 1),
    ),
    BoxShadow(
      color: black.withOpacity(0.08),
      blurRadius: 2,
      offset: const Offset(0, 1),
    ),
  ];
  
  static List<BoxShadow> get shadow2Light => [
    BoxShadow(
      color: black.withOpacity(0.12),
      blurRadius: 6,
      offset: const Offset(0, 2),
    ),
    BoxShadow(
      color: black.withOpacity(0.08),
      blurRadius: 4,
      offset: const Offset(0, 2),
    ),
  ];
  
  static List<BoxShadow> get shadow3Light => [
    BoxShadow(
      color: black.withOpacity(0.15),
      blurRadius: 12,
      offset: const Offset(0, 4),
    ),
    BoxShadow(
      color: black.withOpacity(0.10),
      blurRadius: 6,
      offset: const Offset(0, 2),
    ),
  ];
  
  /// Dark mode shadows (more subtle)
  static List<BoxShadow> get shadow1Dark => [
    BoxShadow(
      color: black.withOpacity(0.30),
      blurRadius: 3,
      offset: const Offset(0, 1),
    ),
    BoxShadow(
      color: black.withOpacity(0.20),
      blurRadius: 2,
      offset: const Offset(0, 1),
    ),
  ];
  
  static List<BoxShadow> get shadow2Dark => [
    BoxShadow(
      color: black.withOpacity(0.35),
      blurRadius: 6,
      offset: const Offset(0, 2),
    ),
    BoxShadow(
      color: black.withOpacity(0.25),
      blurRadius: 4,
      offset: const Offset(0, 2),
    ),
  ];
  
  // ============================================================================
  // THEME DATA
  // ============================================================================
  
  /// Light theme configuration
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      
      // Color scheme
      colorScheme: const ColorScheme.light(
        primary: accentBlue,
        onPrimary: white,
        secondary: gray900,
        onSecondary: white,
        surface: white,
        onSurface: black,
        surfaceContainerHighest: gray100,
        error: accentRed,
        onError: white,
      ),
      
      // Scaffold
      scaffoldBackgroundColor: white,
      
      // App bar
      appBarTheme: const AppBarTheme(
        backgroundColor: white,
        foregroundColor: black,
        elevation: 0,
        centerTitle: false,
        titleTextStyle: TextStyle(
          color: black,
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
        ),
        iconTheme: IconThemeData(
          color: black,
          size: 24,
        ),
      ),
      
      // Cards
      cardTheme: CardThemeData(
        color: white,
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radiusM),
          side: const BorderSide(color: gray300, width: 1),
        ),
        margin: const EdgeInsets.all(spacingS),
      ),
      
      // Text theme
      textTheme: const TextTheme(
        displayLarge: TextStyle(
          fontSize: fontSizeXXL,
          fontWeight: fontWeightBold,
          color: black,
          height: lineHeightTight,
        ),
        displayMedium: TextStyle(
          fontSize: fontSizeXL,
          fontWeight: fontWeightBold,
          color: black,
          height: lineHeightTight,
        ),
        displaySmall: TextStyle(
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
          color: black,
          height: lineHeightTight,
        ),
        bodyLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightRegular,
          color: black,
          height: lineHeightNormal,
        ),
        bodyMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightRegular,
          color: gray800,
          height: lineHeightNormal,
        ),
        bodySmall: TextStyle(
          fontSize: fontSizeXS,
          fontWeight: fontWeightRegular,
          color: gray600,
          height: lineHeightNormal,
        ),
        labelLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightSemibold,
          color: black,
        ),
        labelMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightMedium,
          color: black,
        ),
      ),
      
      // Buttons
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: accentBlue,
          foregroundColor: white,
          elevation: 0,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingL,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: accentBlue,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingM,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      // FAB
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: black,
        foregroundColor: white,
        elevation: 4,
        shape: CircleBorder(),
      ),
      
      // Input decoration
      inputDecorationTheme: InputDecorationTheme(
        filled: false,
        fillColor: white,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: gray300, width: 1),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: gray300, width: 1),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentBlue, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentRed, width: 1),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: spacingM,
          vertical: spacingS,
        ),
        hintStyle: const TextStyle(color: gray500),
      ),
      
      // Divider
      dividerTheme: const DividerThemeData(
        color: gray300,
        thickness: 1,
        space: 1,
      ),
      
      // Icon theme
      iconTheme: const IconThemeData(
        color: black,
        size: 24,
      ),
    );
  }
  
  /// Dark theme configuration
  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      
      // Color scheme
      colorScheme: const ColorScheme.dark(
        primary: accentBlue,
        onPrimary: black,
        secondary: white,
        onSecondary: black,
        surface: black,
        onSurface: white,
        surfaceContainerHighest: darkGray100,
        error: accentRed,
        onError: black,
      ),
      
      // Scaffold
      scaffoldBackgroundColor: black,
      
      // App bar
      appBarTheme: const AppBarTheme(
        backgroundColor: black,
        foregroundColor: white,
        elevation: 0,
        centerTitle: false,
        titleTextStyle: TextStyle(
          color: white,
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
        ),
        iconTheme: IconThemeData(
          color: white,
          size: 24,
        ),
      ),
      
      // Cards
      cardTheme: CardThemeData(
        color: darkGray100,
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radiusM),
          side: const BorderSide(color: darkGray300, width: 1),
        ),
        margin: const EdgeInsets.all(spacingS),
      ),
      
      // Text theme
      textTheme: const TextTheme(
        displayLarge: TextStyle(
          fontSize: fontSizeXXL,
          fontWeight: fontWeightBold,
          color: white,
          height: lineHeightTight,
        ),
        displayMedium: TextStyle(
          fontSize: fontSizeXL,
          fontWeight: fontWeightBold,
          color: white,
          height: lineHeightTight,
        ),
        displaySmall: TextStyle(
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
          color: white,
          height: lineHeightTight,
        ),
        bodyLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightRegular,
          color: white,
          height: lineHeightNormal,
        ),
        bodyMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightRegular,
          color: gray400,
          height: lineHeightNormal,
        ),
        bodySmall: TextStyle(
          fontSize: fontSizeXS,
          fontWeight: fontWeightRegular,
          color: gray500,
          height: lineHeightNormal,
        ),
        labelLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightSemibold,
          color: white,
        ),
        labelMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightMedium,
          color: white,
        ),
      ),
      
      // Buttons
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: white,
          foregroundColor: black,
          elevation: 0,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingL,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: accentBlue,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingM,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      // FAB
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: white,
        foregroundColor: black,
        elevation: 4,
        shape: CircleBorder(),
      ),
      
      // Input decoration
      inputDecorationTheme: InputDecorationTheme(
        filled: false,
        fillColor: darkGray100,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: darkGray300, width: 1),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: darkGray300, width: 1),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentBlue, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentRed, width: 1),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: spacingM,
          vertical: spacingS,
        ),
        hintStyle: const TextStyle(color: gray600),
      ),
      
      // Divider
      dividerTheme: const DividerThemeData(
        color: darkGray300,
        thickness: 1,
        space: 1,
      ),
      
      // Icon theme
      iconTheme: const IconThemeData(
        color: white,
        size: 24,
      ),
    );
  }
}
</file>

<file path="lib/data/drift/app_db.dart">
import 'package:drift/drift.dart';
import 'package:drift_flutter/drift_flutter.dart';
import 'package:messageai/data/drift/daos/conversation_dao.dart';
import 'package:messageai/data/drift/daos/message_dao.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/drift/daos/participant_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';
// AI Analysis DAO commented out (using remote-only approach)
// Uncomment and restore from backup files when scaling to local cache
// import 'package:messageai/data/drift/daos/ai_analysis_dao.dart';

part 'app_db.g.dart';

// Table definitions
class Conversations extends Table {
  TextColumn get id => text()();
  TextColumn get title => text()();
  TextColumn get description => text().nullable()();
  IntColumn get createdAt => integer()(); // Unix timestamp
  IntColumn get updatedAt => integer()();
  BoolColumn get isGroup => boolean().withDefault(const Constant(false))();
  IntColumn get lastMessageAt => integer().nullable()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};
}

class Messages extends Table {
  TextColumn get id => text()();
  TextColumn get conversationId => text()();
  TextColumn get senderId => text()();
  TextColumn get body => text()();
  TextColumn get mediaUrl => text().nullable()();
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    {conversationId, id}
  ];
}

class Participants extends Table {
  TextColumn get id => text()();
  TextColumn get conversationId => text()();
  TextColumn get userId => text()();
  IntColumn get joinedAt => integer()();
  BoolColumn get isAdmin => boolean().withDefault(const Constant(false))();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    {conversationId, userId}
  ];
}

class Receipts extends Table {
  TextColumn get id => text()();
  TextColumn get messageId => text()();
  TextColumn get userId => text()();
  TextColumn get status => text()(); // 'delivered', 'read'
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    {messageId, userId}
  ];
}

class PendingOutbox extends Table {
  TextColumn get id => text()();
  TextColumn get operation => text()(); // 'send_message', 'ack_receipt'
  TextColumn get payload => text()(); // JSON serialized
  TextColumn get conversationId => text().nullable()();
  IntColumn get createdAt => integer()();
  IntColumn get retryCount => integer().withDefault(const Constant(0))();
  TextColumn get lastError => text().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

// AI Analysis table commented out for now (using remote-only approach)
// Uncomment and restore from backup files when scaling to local cache
/*
class AiAnalysis extends Table {
  TextColumn get id => text()();
  TextColumn get messageId => text()();
  TextColumn get tone => text()();
  TextColumn get urgencyLevel => text().nullable()();
  TextColumn get intent => text().nullable()();
  RealColumn get confidenceScore => real().nullable()();
  IntColumn get analysisTimestamp => integer()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();

  @override
  Set<Column> get primaryKey => {id};
}
*/

// Main database class
// Note: AiAnalysis table and AIAnalysisDao commented out (using remote-only approach)
@DriftDatabase(
  tables: [Conversations, Messages, Participants, Receipts, PendingOutbox],
  daos: [ConversationDao, MessageDao, ReceiptDao, ParticipantDao, PendingOutboxDao],
)
class AppDb extends _$AppDb {
  AppDb() : super(_openConnection());

  @override
  int get schemaVersion => 1; // Reverted to 1 (AI table removed)

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) async {
        await m.createAll();
      },
      onUpgrade: (Migrator m, int from, int to) async {
        // AI Analysis migration commented out (using remote-only approach)
        // if (from == 1 && to == 2) {
        //   await m.createTable(aiAnalysis);
        // }
      },
    );
  }

  /// Get the singleton instance of the database
  static AppDb? _instance;

  static AppDb get instance => _instance ??= AppDb();

  /// Close the database connection
  Future<void> close() async {
    await super.close();
    _instance = null;
  }
}

// Connection logic
QueryExecutor _openConnection() {
  return driftDatabase(
    name: 'messageai_db',
  );
}
</file>

<file path="lib/data/drift/daos/ai_analysis_dao_cached.dart.backup">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'ai_analysis_dao.g.dart';

/// Data Access Object for AI Analysis operations
@DriftAccessor(tables: [AiAnalysis])
class AIAnalysisDao extends DatabaseAccessor<AppDb> with _$AIAnalysisDaoMixin {
  AIAnalysisDao(AppDb db) : super(db);

  /// Get all AI analyses
  Future<List<AiAnalysi>> getAllAnalyses() {
    return select(aiAnalysis).get();
  }

  /// Get analysis by ID
  Future<AiAnalysi?> getAnalysisById(String id) {
    return (select(aiAnalysis)..where((a) => a.id.equals(id))).getSingleOrNull();
  }

  /// Get analysis for a specific message
  Future<AiAnalysi?> getAnalysisByMessageId(String messageId) {
    return (select(aiAnalysis)..where((a) => a.messageId.equals(messageId)))
        .getSingleOrNull();
  }

  /// Get all analyses for multiple messages
  Future<List<AiAnalysi>> getAnalysesByMessageIds(List<String> messageIds) {
    return (select(aiAnalysis)..where((a) => a.messageId.isIn(messageIds))).get();
  }

  /// Get analyses for a conversation (requires joining with messages)
  /// Note: This is a simple version. For better performance, you might want to
  /// pass in message IDs from the conversation
  Future<List<AiAnalysi>> getAnalysesForConversation(List<String> messageIds) {
    return (select(aiAnalysis)
          ..where((a) => a.messageId.isIn(messageIds))
          ..orderBy([(a) => OrderingTerm.desc(a.analysisTimestamp)]))
        .get();
  }

  /// Add a new analysis
  Future<int> addAnalysis(AiAnalysisCompanion analysis) {
    return into(aiAnalysis).insert(analysis);
  }

  /// Add or update analysis
  Future<void> upsertAnalysis(AiAnalysisCompanion analysis) {
    return into(aiAnalysis).insertOnConflictUpdate(analysis);
  }

  /// Update analysis
  Future<bool> updateAnalysis(AiAnalysi analysis) {
    return update(aiAnalysis).replace(analysis);
  }

  /// Delete analysis
  Future<int> deleteAnalysis(String id) {
    return (delete(aiAnalysis)..where((a) => a.id.equals(id))).go();
  }

  /// Delete analysis by message ID
  Future<int> deleteAnalysisByMessageId(String messageId) {
    return (delete(aiAnalysis)..where((a) => a.messageId.equals(messageId))).go();
  }

  /// Mark analysis as synced
  Future<void> markAsSynced(String id) {
    return (update(aiAnalysis)..where((a) => a.id.equals(id)))
        .write(const AiAnalysisCompanion(isSynced: Value(1)));
  }

  /// Get unsynced analyses
  Future<List<AiAnalysi>> getUnsyncedAnalyses() {
    return (select(aiAnalysis)..where((a) => a.isSynced.equals(0))).get();
  }

  /// Get analyses with specific tone
  Future<List<AiAnalysi>> getAnalysesByTone(String tone) {
    return (select(aiAnalysis)..where((a) => a.tone.equals(tone))).get();
  }

  /// Get analyses with specific urgency level
  Future<List<AiAnalysi>> getAnalysesByUrgencyLevel(String urgencyLevel) {
    return (select(aiAnalysis)
          ..where((a) => a.urgencyLevel.equals(urgencyLevel)))
        .get();
  }

  /// Get analyses with high confidence (> threshold)
  Future<List<AiAnalysi>> getHighConfidenceAnalyses({double threshold = 0.8}) {
    return (select(aiAnalysis)
          ..where((a) => a.confidenceScore.isBiggerOrEqualValue(threshold)))
        .get();
  }

  /// Get recent analyses (within last N seconds)
  Future<List<AiAnalysi>> getRecentAnalyses({int seconds = 3600}) {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final cutoff = now - seconds;
    return (select(aiAnalysis)
          ..where((a) => a.analysisTimestamp.isBiggerOrEqualValue(cutoff))
          ..orderBy([(a) => OrderingTerm.desc(a.analysisTimestamp)]))
        .get();
  }

  /// Delete old analyses (older than N days)
  Future<int> deleteOldAnalyses({int days = 30}) {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final cutoff = now - (days * 24 * 60 * 60);
    return (delete(aiAnalysis)
          ..where((a) => a.analysisTimestamp.isSmallerThanValue(cutoff)))
        .go();
  }

  /// Clear all analyses
  Future<int> clearAllAnalyses() {
    return delete(aiAnalysis).go();
  }

  /// Get analysis count
  Future<int> getAnalysisCount() async {
    final count = countAll();
    final query = selectOnly(aiAnalysis)..addColumns([count]);
    final result = await query.getSingle();
    return result.read(count) ?? 0;
  }

  /// Get analysis count by tone
  Future<Map<String, int>> getAnalysisCountByTone() async {
    final query = selectOnly(aiAnalysis)
      ..addColumns([aiAnalysis.tone, countAll()])
      ..groupBy([aiAnalysis.tone]);

    final results = await query.get();
    return Map.fromEntries(
      results.map((row) {
        final tone = row.read(aiAnalysis.tone) ?? 'Unknown';
        final count = row.read(countAll()) ?? 0;
        return MapEntry(tone, count);
      }),
    );
  }

  /// Stream of all analyses
  Stream<List<AiAnalysi>> watchAllAnalyses() {
    return select(aiAnalysis).watch();
  }

  /// Stream analysis for a specific message
  Stream<AiAnalysi?> watchAnalysisForMessage(String messageId) {
    return (select(aiAnalysis)..where((a) => a.messageId.equals(messageId)))
        .watchSingleOrNull();
  }
}
</file>

<file path="lib/data/drift/daos/conversation_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'conversation_dao.g.dart';

@DriftAccessor(tables: [Conversations])
class ConversationDao extends DatabaseAccessor<AppDb> with _$ConversationDaoMixin {
  ConversationDao(AppDb db) : super(db);

  /// Get all conversations ordered by last message
  Future<List<Conversation>> getAllConversations() async {
    final query = select(conversations)
      ..orderBy([(c) => OrderingTerm(expression: c.lastMessageAt, mode: OrderingMode.desc)]);
    return query.get();
  }

  /// Get conversation by ID
  Future<Conversation?> getConversationById(String id) async {
    return (select(conversations)..where((c) => c.id.equals(id)))
        .getSingleOrNull();
  }

  /// Insert or update conversation
  Future<void> upsertConversation(Conversation conversation) async {
    await into(conversations).insert(
      conversation,
      onConflict: DoUpdate((_) => conversation),
    );
  }

  /// Batch insert conversations
  Future<void> insertConversations(List<Conversation> convs) async {
    await batch((batch) {
      batch.insertAll(conversations, convs, mode: InsertMode.insertOrReplace);
    });
  }

  /// Delete conversation by ID
  Future<int> deleteConversation(String id) async {
    return (delete(conversations)..where((c) => c.id.equals(id))).go();
  }

  /// Update conversation sync status
  Future<void> markConversationAsSynced(String id) async {
    await (update(conversations)..where((c) => c.id.equals(id)))
        .write(const ConversationsCompanion(isSynced: Value(true)));
  }

  /// Get unsynced conversations
  Future<List<Conversation>> getUnsyncedConversations() async {
    return (select(conversations)..where((c) => c.isSynced.equals(false)))
        .get();
  }

  /// Update last message time
  Future<void> updateLastMessageTime(String conversationId) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    await (update(conversations)..where((c) => c.id.equals(conversationId)))
        .write(ConversationsCompanion(
          updatedAt: Value(now),
          lastMessageAt: Value(now),
        ));
  }

  /// Get recent conversations (for list)
  Future<List<Conversation>> getRecentConversations({int limit = 20}) async {
    return (select(conversations)
          ..orderBy([(c) => OrderingTerm(expression: c.lastMessageAt, mode: OrderingMode.desc)])
          ..limit(limit))
        .get();
  }

  /// Count total conversations
  Future<int> getConversationCount() async {
    final result = await select(conversations).get();
    return result.length;
  }
}
</file>

<file path="lib/data/drift/daos/message_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'message_dao.g.dart';

@DriftAccessor(tables: [Messages])
class MessageDao extends DatabaseAccessor<AppDb> with _$MessageDaoMixin {
  MessageDao(AppDb db) : super(db);

  /// Get all messages for a conversation ordered by creation time (oldest first)
  Future<List<Message>> getMessagesByConversation(String conversationId) async {
    final results = await (select(messages)
          ..where((m) => m.conversationId.equals(conversationId))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.asc)]))
        .get();
    
    // Debug: Print message order
    if (results.isNotEmpty) {
      print('📊 Messages loaded: ${results.length} total');
      final firstBody = results.first.body.length > 20 
          ? '${results.first.body.substring(0, 20)}...' 
          : results.first.body;
      final lastBody = results.last.body.length > 20 
          ? '${results.last.body.substring(0, 20)}...' 
          : results.last.body;
      print('   First message: "$firstBody" at timestamp ${results.first.createdAt}');
      print('   Last message: "$lastBody" at timestamp ${results.last.createdAt}');
    }
    
    return results;
  }

  /// Get recent messages for a conversation
  Future<List<Message>> getRecentMessages(String conversationId, {int limit = 50}) async {
    return (select(messages)
          ..where((m) => m.conversationId.equals(conversationId))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.desc)])
          ..limit(limit))
        .get();
  }

  /// Insert a new message
  Future<void> insertMessage(Message message) async {
    await into(messages).insert(message);
  }

  /// Update message sync status
  Future<void> markMessageAsSynced(String messageId) async {
    await (update(messages)..where((m) => m.id.equals(messageId)))
        .write(const MessagesCompanion(isSynced: Value(true)));
  }

  /// Get unsynced messages
  Future<List<Message>> getUnsyncedMessages() async {
    return (select(messages)..where((m) => m.isSynced.equals(false)))
        .get();
  }

  /// Delete message by ID
  Future<int> deleteMessage(String id) async {
    return (delete(messages)..where((m) => m.id.equals(id))).go();
  }

  /// Get message by ID
  Future<Message?> getMessageById(String id) async {
    return (select(messages)..where((m) => m.id.equals(id)))
        .getSingleOrNull();
  }

  /// Get the most recent message for a conversation
  Future<Message?> getLatestMessageForConversation(String conversationId) async {
    return (select(messages)
          ..where((m) => m.conversationId.equals(conversationId))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.desc)])
          ..limit(1))
        .getSingleOrNull();
  }

  /// Get unsynced message count
  Future<int> getUnsyncedMessageCount() async {
    final result = await (select(messages)..where((m) => m.isSynced.equals(false))).get();
    return result.length;
  }

  /// Search messages in a conversation
  Future<List<Message>> searchMessages(String conversationId, String query) async {
    return (select(messages)
          ..where((m) => m.conversationId.equals(conversationId) & m.body.contains(query))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.desc)]))
        .get();
  }

  /// Insert multiple messages
  Future<void> insertMessages(List<Message> messageList) async {
    await batch((batch) {
      batch.insertAll(messages, messageList);
    });
  }

  /// Upsert a message (insert or update)
  Future<void> upsertMessage(Message message) async {
    await into(messages).insertOnConflictUpdate(message);
  }
}
</file>

<file path="lib/data/drift/daos/participant_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'participant_dao.g.dart';

@DriftAccessor(tables: [Participants])
class ParticipantDao extends DatabaseAccessor<AppDb> with _$ParticipantDaoMixin {
  ParticipantDao(AppDb db) : super(db);

  /// Get all participants in a conversation
  Future<List<Participant>> getParticipantsByConversation(String conversationId) async {
    return (select(participants)
          ..where((p) => p.conversationId.equals(conversationId)))
        .get();
  }

  /// Get participant by ID
  Future<Participant?> getParticipantById(String id) async {
    return (select(participants)..where((p) => p.id.equals(id)))
        .getSingleOrNull();
  }

  /// Get participant by conversation ID and user ID
  Future<Participant?> getParticipant(String conversationId, String userId) async {
    return (select(participants)
          ..where((p) =>
              p.conversationId.equals(conversationId) & p.userId.equals(userId)))
        .getSingleOrNull();
  }

  /// Add participant to conversation (upsert to avoid duplicates)
  Future<void> addParticipant(Participant participant) async {
    await into(participants).insertOnConflictUpdate(participant);
  }

  /// Batch add participants
  Future<void> addParticipants(List<Participant> parts) async {
    await batch((batch) {
      batch.insertAll(participants, parts, mode: InsertMode.insertOrReplace);
    });
  }

  /// Remove participant from conversation
  Future<int> removeParticipant(String conversationId, String userId) async {
    return (delete(participants)
          ..where((p) =>
              p.conversationId.equals(conversationId) & p.userId.equals(userId)))
        .go();
  }

  /// Remove participant by ID
  Future<int> removeParticipantById(String id) async {
    return (delete(participants)..where((p) => p.id.equals(id))).go();
  }

  /// Remove all participants from conversation
  Future<int> removeConversationParticipants(String conversationId) async {
    return (delete(participants)..where((p) => p.conversationId.equals(conversationId)))
        .go();
  }

  /// Promote participant to admin
  Future<void> promoteToAdmin(String id) async {
    await (update(participants)..where((p) => p.id.equals(id)))
        .write(const ParticipantsCompanion(isAdmin: Value(true)));
  }

  /// Demote participant from admin
  Future<void> demoteFromAdmin(String id) async {
    await (update(participants)..where((p) => p.id.equals(id)))
        .write(const ParticipantsCompanion(isAdmin: Value(false)));
  }

  /// Get admin count for conversation
  Future<int> getAdminCount(String conversationId) async {
    final result = await (select(participants)
          ..where((p) =>
              p.conversationId.equals(conversationId) & p.isAdmin.equals(true)))
        .get();
    return result.length;
  }

  /// Get participant count for a conversation
  Future<int> getParticipantCount(String conversationId) async {
    final result = await (select(participants)
          ..where((p) => p.conversationId.equals(conversationId)))
        .get();
    return result.length;
  }

  /// Check if user is participant in conversation
  Future<bool> isParticipant(String conversationId, String userId) async {
    final participant = await getParticipant(conversationId, userId);
    return participant != null;
  }

  /// Check if user is admin in conversation
  Future<bool> isAdmin(String conversationId, String userId) async {
    final participant = await getParticipant(conversationId, userId);
    return participant?.isAdmin ?? false;
  }

  /// Mark participants as synced
  Future<void> markParticipantsAsSynced(List<String> ids) async {
    await batch((batch) {
      for (final id in ids) {
        batch.update(participants, const ParticipantsCompanion(isSynced: Value(true)),
            where: (p) => p.id.equals(id));
      }
    });
  }
}
</file>

<file path="lib/data/drift/daos/pending_outbox_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'pending_outbox_dao.g.dart';

@DriftAccessor(tables: [PendingOutbox])
class PendingOutboxDao extends DatabaseAccessor<AppDb> with _$PendingOutboxDaoMixin {
  PendingOutboxDao(AppDb db) : super(db);

  /// Get all pending operations
  Future<List<PendingOutboxData>> getAllPendingOperations() async {
    return (select(pendingOutbox)
          ..orderBy([(p) => OrderingTerm(expression: p.createdAt)]))
        .get();
  }

  /// Get pending operations for a specific conversation
  Future<List<PendingOutboxData>> getPendingOperationsByConversation(String conversationId) async {
    return (select(pendingOutbox)
          ..where((p) => p.conversationId.equals(conversationId))
          ..orderBy([(p) => OrderingTerm(expression: p.createdAt)]))
        .get();
  }

  /// Add operation to pending outbox
  Future<void> addPendingOperation({
    required String id,
    required String operation,
    required String payload,
    required String? conversationId,
  }) async {
    await into(pendingOutbox).insert(PendingOutboxCompanion(
      id: Value(id),
      operation: Value(operation),
      payload: Value(payload),
      conversationId: Value(conversationId),
      createdAt: Value(DateTime.now().millisecondsSinceEpoch ~/ 1000),
      retryCount: const Value(0),
    ));
  }

  /// Remove operation from pending outbox (after successful sync)
  Future<int> removePendingOperation(String id) async {
    return (delete(pendingOutbox)..where((p) => p.id.equals(id))).go();
  }

  /// Batch remove multiple operations
  Future<int> removePendingOperations(List<String> ids) async {
    return (delete(pendingOutbox)..where((p) => p.id.isIn(ids))).go();
  }

  /// Update retry count and last error
  Future<void> updateRetryInfo(String id, int retryCount, String? lastError) async {
    await (update(pendingOutbox)..where((p) => p.id.equals(id)))
        .write(PendingOutboxCompanion(
          retryCount: Value(retryCount),
          lastError: Value(lastError),
        ));
  }

  /// Get retryable operations (with retry count < max retries)
  Future<List<PendingOutboxData>> getRetryableOperations({int maxRetries = 3}) async {
    return (select(pendingOutbox)
          ..where((p) => p.retryCount.isSmallerThanValue(maxRetries)))
        .get();
  }

  /// Get oldest pending operation
  Future<PendingOutboxData?> getOldestPendingOperation() async {
    return (select(pendingOutbox)
          ..orderBy([(p) => OrderingTerm(expression: p.createdAt)])
          ..limit(1))
        .getSingleOrNull();
  }

  /// Get pending operations by type
  Future<List<PendingOutboxData>> getPendingOperationsByType(String operationType) async {
    return (select(pendingOutbox)
          ..where((p) => p.operation.equals(operationType)))
        .get();
  }

  /// Clean up old pending operations (older than cutoffTime)
  Future<int> cleanupOldOperations(int cutoffTime) async {
    return (delete(pendingOutbox)..where((p) => p.createdAt.isSmallerThanValue(cutoffTime))).go();
  }

  /// Get pending operations count
  Future<int> getPendingOperationCount() async {
    final result = await select(pendingOutbox).get();
    return result.length;
  }
}
</file>

<file path="lib/data/drift/daos/receipt_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'receipt_dao.g.dart';

@DriftAccessor(tables: [Receipts, Messages])
class ReceiptDao extends DatabaseAccessor<AppDb> with _$ReceiptDaoMixin {
  ReceiptDao(AppDb db) : super(db);

  /// Get all receipts for a message
  Future<List<Receipt>> getReceiptsByMessage(String messageId) async {
    return (select(receipts)
          ..where((r) => r.messageId.equals(messageId)))
        .get();
  }

  /// Get receipt by ID
  Future<Receipt?> getReceiptById(String id) async {
    return (select(receipts)..where((r) => r.id.equals(id)))
        .getSingleOrNull();
  }

  /// Get receipt by message ID and user ID
  Future<Receipt?> getReceipt(String messageId, String userId) async {
    return (select(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.userId.equals(userId)))
        .getSingleOrNull();
  }

  /// Add receipt
  Future<void> addReceipt(Receipt receipt) async {
    await into(receipts).insert(receipt);
  }

  /// Batch add receipts
  Future<void> addReceipts(List<Receipt> recs) async {
    await batch((batch) {
      batch.insertAll(receipts, recs, mode: InsertMode.insertOrReplace);
    });
  }

  /// Update receipt status
  Future<void> updateReceiptStatus(String messageId, String userId, String status) async {
    await (update(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.userId.equals(userId)))
        .write(ReceiptsCompanion(
          status: Value(status),
          updatedAt: Value(DateTime.now().millisecondsSinceEpoch ~/ 1000),
        ));
  }

  /// Mark receipt as synced
  Future<void> markReceiptAsSynced(String id) async {
    await (update(receipts)..where((r) => r.id.equals(id)))
        .write(const ReceiptsCompanion(isSynced: Value(true)));
  }

  /// Mark multiple receipts as synced
  Future<void> markReceiptsAsSynced(List<String> ids) async {
    await batch((batch) {
      for (final id in ids) {
        batch.update(receipts, const ReceiptsCompanion(isSynced: Value(true)),
            where: (r) => r.id.equals(id));
      }
    });
  }

  /// Delete receipt
  Future<int> deleteReceipt(String id) async {
    return (delete(receipts)..where((r) => r.id.equals(id))).go();
  }

  /// Get unsynced receipts
  Future<List<Receipt>> getUnsyncedReceipts() async {
    return (select(receipts)..where((r) => r.isSynced.equals(false)))
        .get();
  }

  /// Get read count for a message
  Future<int> getReadCount(String messageId) async {
    final countResult = await (select(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.status.equals('read')))
        .get();
    return countResult.length;
  }

  /// Get delivered count for a message
  Future<int> getDeliveredCount(String messageId) async {
    final countResult = await (select(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.status.equals('delivered')))
        .get();
    return countResult.length;
  }

  /// Get all receipts for messages in conversation
  Future<List<Receipt>> getReceiptsByConversation(String conversationId) async {
    return (select(receipts).join([
      innerJoin(messages, messages.id.equalsExp(receipts.messageId)),
    ])
      ..where(messages.conversationId.equals(conversationId)))
        .map((row) => row.readTable(receipts))
        .get();
  }

  /// Check if message is read by all participants
  Future<bool> isReadByAll(String messageId, int expectedCount) async {
    final readCount = await getReadCount(messageId);
    return readCount >= expectedCount;
  }

  /// Get unsynced receipt count
  Future<int> getUnsyncedReceiptCount() async {
    final countResult = await (select(receipts)
          ..where((r) => r.isSynced.equals(false)))
        .get();
    return countResult.length;
  }
}
</file>

<file path="lib/data/drift/entities/ai_analysis_cached.drift.backup">
-- AI Analysis table for local caching of tone and intent analysis
CREATE TABLE ai_analysis (
  id TEXT PRIMARY KEY NOT NULL,
  message_id TEXT NOT NULL,
  tone TEXT NOT NULL,
  urgency_level TEXT,
  intent TEXT,
  confidence_score REAL,
  analysis_timestamp INTEGER NOT NULL,
  is_synced INTEGER NOT NULL DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

-- Index for efficient lookups by message
CREATE INDEX IF NOT EXISTS idx_ai_analysis_message_id ON ai_analysis(message_id);

-- Index for timestamp queries
CREATE INDEX IF NOT EXISTS idx_ai_analysis_timestamp ON ai_analysis(analysis_timestamp DESC);
</file>

<file path="lib/data/drift/entities/conversation.drift">
CREATE TABLE conversations (
  id TEXT PRIMARY KEY NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  is_group BOOLEAN NOT NULL DEFAULT 0,
  last_message_at INTEGER,
  is_synced BOOLEAN NOT NULL DEFAULT 0
) AS Conversation;

CREATE TABLE messages (
  id TEXT PRIMARY KEY NOT NULL,
  conversation_id TEXT NOT NULL,
  sender_id TEXT NOT NULL,
  body TEXT NOT NULL,
  media_url TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  is_synced BOOLEAN NOT NULL DEFAULT 0,
  FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
) AS Message;

CREATE TABLE participants (
  id TEXT PRIMARY KEY NOT NULL,
  conversation_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  joined_at INTEGER NOT NULL,
  is_admin BOOLEAN NOT NULL DEFAULT 0,
  is_synced BOOLEAN NOT NULL DEFAULT 0,
  FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE,
  UNIQUE(conversation_id, user_id)
) AS Participant;

CREATE TABLE receipts (
  id TEXT PRIMARY KEY NOT NULL,
  message_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  status TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  is_synced BOOLEAN NOT NULL DEFAULT 0,
  FOREIGN KEY(message_id) REFERENCES messages(id) ON DELETE CASCADE,
  UNIQUE(message_id, user_id)
) AS Receipt;

CREATE TABLE pending_outbox (
  id TEXT PRIMARY KEY NOT NULL,
  operation TEXT NOT NULL,
  payload TEXT NOT NULL,
  conversation_id TEXT,
  created_at INTEGER NOT NULL,
  retry_count INTEGER NOT NULL DEFAULT 0,
  last_error TEXT,
  FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
) AS PendingOutboxItem;
</file>

<file path="lib/data/remote/supabase_client.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/core/env.dart';

/// Singleton Supabase client for the application.
/// 
/// Initialize with [initializeSupabase] before accessing the client.
class SupabaseClientProvider {
  static late final Supabase _instance;

  /// Get the initialized Supabase client instance
  static Supabase get instance => _instance;

  /// Get the Supabase client for convenience
  static SupabaseClient get client => _instance.client;

  /// Initialize the Supabase client with environment config
  static Future<void> initialize() async {
    Env.validate();
    
    _instance = await Supabase.initialize(
      url: Env.supabaseUrl,
      anonKey: Env.supabaseAnonKey,
      // Enable realtime
      // Note: The underlying realtime_client has heartbeat enabled by default (30s)
      realtimeClientOptions: const RealtimeClientOptions(
        eventsPerSecond: 10,
        logLevel: RealtimeLogLevel.info, // Enable logging for diagnostics
      ),
    );
  }
}
</file>

<file path="lib/data/repositories/group_repository.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/conversation_dao.dart';
import 'package:messageai/data/drift/daos/participant_dao.dart';
import 'package:uuid/uuid.dart';

/// Repository for group operations
class GroupRepository {
  final ConversationDao _conversationDao;
  final ParticipantDao _participantDao;

  GroupRepository({
    required ConversationDao conversationDao,
    required ParticipantDao participantDao,
  })  : _conversationDao = conversationDao,
        _participantDao = participantDao;

  /// Create a new group conversation
  Future<Conversation> createGroup({
    required String title,
    required String description,
    required String creatorId,
    required List<String> memberIds,
  }) async {
    const uuid = Uuid();
    final conversationId = uuid.v4();
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Create conversation
    final conversation = Conversation(
      id: conversationId,
      title: title,
      description: description,
      createdAt: now,
      updatedAt: now,
      isGroup: true,
      isSynced: false,
    );
    
    await _conversationDao.upsertConversation(conversation);
    
    // Add creator as admin
    final creatorParticipant = Participant(
      id: uuid.v4(),
      conversationId: conversationId,
      userId: creatorId,
      joinedAt: now,
      isAdmin: true,
      isSynced: false,
    );
    
    await _participantDao.addParticipant(creatorParticipant);
    
    // Add other members
    final participants = memberIds.map((userId) {
      return Participant(
        id: uuid.v4(),
        conversationId: conversationId,
        userId: userId,
        joinedAt: now,
        isAdmin: false,
        isSynced: false,
      );
    }).toList();
    
    await _participantDao.addParticipants(participants);
    
    return conversation;
  }

  /// Get group details with members
  Future<(Conversation, List<Participant>)> getGroupWithMembers(String groupId) async {
    final conversation = await _conversationDao.getConversationById(groupId);
    if (conversation == null) {
      throw Exception('Group not found: $groupId');
    }
    
    final participants = await _participantDao.getParticipantsByConversation(groupId);
    
    return (conversation, participants);
  }

  /// Update group info
  Future<void> updateGroupInfo({
    required String groupId,
    String? title,
    String? description,
  }) async {
    // This would require a Conversation update method in ConversationDao
    // For now, creating a placeholder
    // TODO: Implement in ConversationDao
  }

  /// Add member to group
  Future<void> addGroupMember({
    required String groupId,
    required String userId,
  }) async {
    const uuid = Uuid();
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Check if already a member
    final existing = await _participantDao.getParticipant(groupId, userId);
    if (existing != null) {
      throw Exception('User is already a member of this group');
    }
    
    final participant = Participant(
      id: uuid.v4(),
      conversationId: groupId,
      userId: userId,
      joinedAt: now,
      isAdmin: false,
      isSynced: false,
    );
    
    await _participantDao.addParticipant(participant);
  }

  /// Remove member from group
  Future<void> removeGroupMember({
    required String groupId,
    required String userId,
  }) async {
    await _participantDao.removeParticipant(groupId, userId);
  }

  /// Promote member to admin
  Future<void> promoteToAdmin({
    required String groupId,
    required String userId,
  }) async {
    final participant = await _participantDao.getParticipant(groupId, userId);
    if (participant == null) {
      throw Exception('Member not found in group');
    }
    
    await _participantDao.promoteToAdmin(participant.id);
  }

  /// Demote admin to member
  Future<void> demoteFromAdmin({
    required String groupId,
    required String userId,
  }) async {
    final participant = await _participantDao.getParticipant(groupId, userId);
    if (participant == null) {
      throw Exception('Member not found in group');
    }
    
    await _participantDao.demoteFromAdmin(participant.id);
  }

  /// Get user's groups
  Future<List<Conversation>> getUserGroups(String userId) async {
    final allConversations = await _conversationDao.getAllConversations();
    
    // Filter to only groups where user is a participant
    final userGroups = <Conversation>[];
    
    for (final conversation in allConversations) {
      if (conversation.isGroup) {
        final isParticipant = await _participantDao.isParticipant(
          conversation.id,
          userId,
        );
        if (isParticipant) {
          userGroups.add(conversation);
        }
      }
    }
    
    return userGroups;
  }

  /// Leave group
  Future<void> leaveGroup({
    required String groupId,
    required String userId,
  }) async {
    await _participantDao.removeParticipant(groupId, userId);
  }

  /// Delete group (admin only)
  Future<void> deleteGroup(String groupId) async {
    // Remove all participants
    await _participantDao.removeConversationParticipants(groupId);
    
    // Delete conversation
    await _conversationDao.deleteConversation(groupId);
  }

  /// Get group members count
  Future<int> getGroupMemberCount(String groupId) async {
    return _participantDao.getParticipantCount(groupId);
  }

  /// Check if user is group admin
  Future<bool> isUserGroupAdmin(String groupId, String userId) async {
    return _participantDao.isAdmin(groupId, userId);
  }
}
</file>

<file path="lib/data/repositories/message_repository.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/message_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';
import 'package:messageai/gen/api/clients/messages_api.dart';
import 'package:messageai/gen/api/models/message_payload.dart';

/// Repository for message operations combining API and local database
class MessageRepository {
  final MessagesApi _messagesApi;
  final MessageDao _messageDao;
  final PendingOutboxDao _outboxDao;

  MessageRepository({
    required MessagesApi messagesApi,
    required MessageDao messageDao,
    required PendingOutboxDao outboxDao,
  })  : _messagesApi = messagesApi,
        _messageDao = messageDao,
        _outboxDao = outboxDao;

  /// Send a message (optimistic - save locally first, sync later)
  Future<Message> sendMessage({
    required String id,
    required String conversationId,
    required String senderId,
    required String body,
    String? mediaUrl,
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Create message locally first (optimistic)
    final message = Message(
      id: id,
      conversationId: conversationId,
      senderId: senderId,
      body: body,
      mediaUrl: mediaUrl,
      createdAt: now,
      updatedAt: now,
      isSynced: false,
    );
    
    // Save to local DB
    await _messageDao.insertMessage(message);
    
    // Queue for sync
    await _outboxDao.addPendingOperation(
      id: '${id}_send',
      operation: 'send_message',
      payload: message.toJson().toString(),
      conversationId: conversationId,
    );
    
    return message;
  }

  /// Get messages for a conversation from local DB
  Future<List<Message>> getConversationMessages(String conversationId) async {
    return _messageDao.getMessagesByConversation(conversationId);
  }

  /// Get recent messages for a conversation (paginated)
  Future<List<Message>> getRecentMessages(String conversationId, {int limit = 50}) async {
    return _messageDao.getRecentMessages(conversationId, limit: limit);
  }

  /// Sync unsynced messages to server
  Future<void> syncUnsyncedMessages() async {
    final unsyncedMessages = await _messageDao.getUnsyncedMessages();
    
    for (final message in unsyncedMessages) {
      try {
        final payload = MessagePayload(
          id: message.id,
          conversationId: message.conversationId,
          body: message.body,
        );
        
        // Send to server
        await _messagesApi.send(payload);
        
        // Mark as synced locally
        await _messageDao.markMessageAsSynced(message.id);
        
        // Remove from outbox
        await _outboxDao.removePendingOperation('${message.id}_send');
      } catch (e) {
        // Log error and continue
        print('Error syncing message ${message.id}: $e');
      }
    }
  }

  /// Search messages in a conversation
  Future<List<Message>> searchMessages(String conversationId, String query) async {
    return _messageDao.searchMessages(conversationId, query);
  }

  /// Insert messages from server
  Future<void> insertServerMessages(List<Message> messages) async {
    await _messageDao.insertMessages(messages);
  }

  /// Update message from server
  Future<void> updateMessageFromServer(Message message) async {
    await _messageDao.upsertMessage(message);
  }

  /// Upsert message (helper)
  Future<void> upsertMessage(Message message) async {
    // This would be added to MessageDao
    await _messageDao.insertMessage(message);
  }

  /// Get pending message count (for UI)
  Future<int> getPendingMessageCount() async {
    return _messageDao.getUnsyncedMessageCount();
  }
}

extension on Message {
  Map<String, dynamic> toJson() => {
    'id': id,
    'conversation_id': conversationId,
    'sender_id': senderId,
    'body': body,
    'media_url': mediaUrl,
    'created_at': createdAt,
    'updated_at': updatedAt,
    'is_synced': isSynced,
  };
}
</file>

<file path="lib/data/repositories/receipt_repository.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';
import 'package:messageai/gen/api/clients/receipts_api.dart';
import 'package:messageai/gen/api/models/receipt_payload.dart';

/// Repository for receipt operations combining API and local database
class ReceiptRepository {
  final ReceiptsApi _receiptsApi;
  final ReceiptDao _receiptDao;
  final PendingOutboxDao _outboxDao;

  ReceiptRepository({
    required ReceiptsApi receiptsApi,
    required ReceiptDao receiptDao,
    required PendingOutboxDao outboxDao,
  })  : _receiptsApi = receiptsApi,
        _receiptDao = receiptDao,
        _outboxDao = outboxDao;

  /// Acknowledge message receipts (optimistic)
  Future<void> acknowledgeReceipts({
    required List<String> messageIds,
    required String status, // 'delivered' or 'read'
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Save receipts locally first
    final receipts = messageIds.map((msgId) {
      return Receipt(
        id: '${msgId}_${status}_$now',
        messageId: msgId,
        userId: '', // Would be current user ID
        status: status,
        createdAt: now,
        updatedAt: now,
        isSynced: false,
      );
    }).toList();
    
    await _receiptDao.addReceipts(receipts);
    
    // Queue for sync
    await _outboxDao.addPendingOperation(
      id: 'ack_${status}_$now',
      operation: 'ack_receipt',
      payload: ReceiptPayload(
        messageIds: messageIds,
        status: status == 'delivered' ? ReceiptStatus.delivered : ReceiptStatus.read,
      ).toJson().toString(),
      conversationId: null,
    );
  }

  /// Get receipts for a message
  Future<List<Receipt>> getMessageReceipts(String messageId) async {
    return _receiptDao.getReceiptsByMessage(messageId);
  }

  /// Get read count for a message
  Future<int> getReadCount(String messageId) async {
    return _receiptDao.getReadCount(messageId);
  }

  /// Get delivered count for a message
  Future<int> getDeliveredCount(String messageId) async {
    return _receiptDao.getDeliveredCount(messageId);
  }

  /// Check if message is read by all participants
  Future<bool> isReadByAll(String messageId, int participantCount) async {
    return _receiptDao.isReadByAll(messageId, participantCount);
  }

  /// Sync unsynced receipts to server
  Future<void> syncUnsyncedReceipts() async {
    final unsyncedReceipts = await _receiptDao.getUnsyncedReceipts();
    
    if (unsyncedReceipts.isEmpty) return;
    
    try {
      // Group by status
      final deliveredIds = unsyncedReceipts
          .where((r) => r.status == 'delivered')
          .map((r) => r.messageId)
          .toList();
      
      final readIds = unsyncedReceipts
          .where((r) => r.status == 'read')
          .map((r) => r.messageId)
          .toList();
      
      // Send to server
      if (deliveredIds.isNotEmpty) {
        final payload = ReceiptPayload(
          messageIds: deliveredIds,
          status: ReceiptStatus.delivered,
        );
        await _receiptsApi.ack(payload);
      }
      
      if (readIds.isNotEmpty) {
        final payload = ReceiptPayload(
          messageIds: readIds,
          status: ReceiptStatus.read,
        );
        await _receiptsApi.ack(payload);
      }
      
      // Mark as synced
      final allIds = unsyncedReceipts.map((r) => r.id).toList();
      await _receiptDao.markReceiptsAsSynced(allIds);
    } catch (e) {
      print('Error syncing receipts: $e');
    }
  }

  /// Insert receipts from server
  Future<void> insertServerReceipts(List<Receipt> receipts) async {
    await _receiptDao.addReceipts(receipts);
  }

  /// Get unsynced receipt count (for UI)
  Future<int> getUnsyncedReceiptCount() async {
    return _receiptDao.getUnsyncedReceiptCount();
  }
}

extension on ReceiptPayload {
  Map<String, dynamic> toJson() => {
    'message_ids': messageIds,
    'status': status.toValue(),
  };
}
</file>

<file path="lib/features/auth/screens/auth_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/auth_service.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_ui.dart';

/// Authentication screen for login/signup
class AuthScreen extends StatefulWidget {
  final VoidCallback onAuthSuccess;

  const AuthScreen({
    Key? key,
    required this.onAuthSuccess,
  }) : super(key: key);

  @override
  State<AuthScreen> createState() => _AuthScreenState();
}

class _AuthScreenState extends State<AuthScreen> with ErrorHandlerMixin {
  late TextEditingController _emailController;
  late TextEditingController _passwordController;
  bool _isLoading = false;
  bool _isSignUp = false;
  final _authService = AuthService();

  @override
  void initState() {
    super.initState();
    _emailController = TextEditingController();
    _passwordController = TextEditingController();
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _handleSignIn() async {
    if (_emailController.text.isEmpty || _passwordController.text.isEmpty) {
      ErrorUI.showErrorSnackbar(
        context,
        AppError(
          category: ErrorCategory.validation,
          severity: ErrorSeverity.warning,
          code: 'VAL001',
          message: 'Please enter email and password',
          userMessage: 'Please enter both email and password',
        ),
      );
      return;
    }

    setState(() => _isLoading = true);

    try {
      await _authService.signIn(
        email: _emailController.text.trim(),
        password: _passwordController.text,
      );

      if (mounted) {
        widget.onAuthSuccess();
      }
    } on AppError catch (error) {
      if (mounted) {
        showError(error, onRetry: _handleSignIn);
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  Future<void> _handleSignUp() async {
    // Validation
    if (_emailController.text.isEmpty || _passwordController.text.isEmpty) {
      ErrorUI.showErrorSnackbar(
        context,
        AppError(
          category: ErrorCategory.validation,
          severity: ErrorSeverity.warning,
          code: 'VAL001',
          message: 'Please enter email and password',
          userMessage: 'Please enter both email and password',
        ),
      );
      return;
    }

    if (!_isValidEmail(_emailController.text.trim())) {
      ErrorUI.showErrorSnackbar(
        context,
        AuthError.invalidEmail(),
      );
      return;
    }

    if (_passwordController.text.length < 6) {
      ErrorUI.showErrorSnackbar(
        context,
        AuthError.weakPassword(),
      );
      return;
    }

    setState(() => _isLoading = true);

    try {
      await _authService.signUp(
        email: _emailController.text.trim(),
        password: _passwordController.text,
      );

      if (mounted) {
        // Show success message
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 12),
                Text('Sign up successful! Signing you in...'),
              ],
            ),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
        
        // Auto sign in after signup
        await Future.delayed(const Duration(seconds: 1));
        if (mounted) {
          await _handleSignIn();
        }
      }
    } on AppError catch (error) {
      if (mounted) {
        showError(error, onRetry: _handleSignUp);
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  /// Validate email format
  bool _isValidEmail(String email) {
    final emailRegex = RegExp(
      r'^[a-zA-Z0-9.]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+',
    );
    return emailRegex.hasMatch(email);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('MessageAI'),
        centerTitle: true,
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.chat_bubble,
                size: 64,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(height: 24),
              Text(
                _isSignUp ? 'Create Account' : 'Welcome to MessageAI',
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32),
              TextField(
                controller: _emailController,
                enabled: !_isLoading,
                decoration: InputDecoration(
                  hintText: 'Email',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  prefixIcon: const Icon(Icons.email),
                ),
                keyboardType: TextInputType.emailAddress,
              ),
              const SizedBox(height: 16),
              TextField(
                controller: _passwordController,
                enabled: !_isLoading,
                decoration: InputDecoration(
                  hintText: 'Password',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  prefixIcon: const Icon(Icons.lock),
                ),
                obscureText: true,
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _isLoading
                      ? null
                      : (_isSignUp ? _handleSignUp : _handleSignIn),
                  child: _isLoading
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : Text(_isSignUp ? 'Sign Up' : 'Sign In'),
                ),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(_isSignUp
                      ? 'Already have an account? '
                      : "Don't have an account? "),
                  TextButton(
                    onPressed: _isLoading
                        ? null
                        : () {
                            setState(() {
                              _isSignUp = !_isSignUp;
                              // Clear any previous error messages when switching modes
                              ScaffoldMessenger.of(context).hideCurrentSnackBar();
                            });
                          },
                    child: Text(_isSignUp ? 'Sign In' : 'Sign Up'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/conversations/screens/conversations_list_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/conversation_service.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/features/messages/screens/message_screen.dart';
import 'package:messageai/features/settings/screens/settings_screen.dart';
import 'package:messageai/widgets/network_status_banner.dart';
import 'package:messageai/widgets/user_avatar.dart';

/// Screen showing list of conversations
class ConversationsListScreen extends StatefulWidget {
  const ConversationsListScreen({Key? key}) : super(key: key);

  @override
  State<ConversationsListScreen> createState() =>
      _ConversationsListScreenState();
}

class _ConversationsListScreenState extends State<ConversationsListScreen> {
  final _conversationService = ConversationService();
  late Future<List<Conversation>> _conversationsFuture;

  @override
  void initState() {
    super.initState();
    _conversationsFuture = _conversationService.getAllConversations();
  }
  
  // Add pull-to-refresh
  Future<void> _refreshConversations() async {
    setState(() {
      _conversationsFuture = _conversationService.getAllConversations(syncFirst: true);
    });
  }

  void _showNewConversationDialog() {
    final titleController = TextEditingController();
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('New Conversation'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: titleController,
              decoration: InputDecoration(
                hintText: 'Conversation title',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
              autofocus: true,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () async {
              if (titleController.text.isEmpty) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Please enter a title')),
                );
                return;
              }

              try {
                await _conversationService.createConversation(
                  title: titleController.text,
                );
                if (mounted) {
                  Navigator.pop(context);
                  setState(() {
                    // Don't re-sync from backend (keeps deleted convos deleted)
                    _conversationsFuture =
                        _conversationService.getAllConversations(syncFirst: false);
                  });
                }
              } catch (e) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Error: $e')),
                  );
                }
              }
            },
            child: const Text('Create'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('MessageAI'),
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.settings),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const SettingsScreen(),
                ),
              );
            },
            tooltip: 'Settings',
          ),
        ],
      ),
      body: Column(
        children: [
          const NetworkStatusBanner(),
          Expanded(
            child: RefreshIndicator(
              onRefresh: _refreshConversations,
              child: FutureBuilder<List<Conversation>>(
          future: _conversationsFuture,
          builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.error_outline,
                    size: 64,
                    color: Theme.of(context).colorScheme.error,
                  ),
                  const SizedBox(height: 16),
                  Text('Error: ${snapshot.error}'),
                ],
              ),
            );
          }

          final conversations = snapshot.data ?? [];

          if (conversations.isEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.chat_outlined,
                    size: 80,
                    color: Theme.of(context)
                        .colorScheme
                        .primary
                        .withOpacity(0.3),
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'No conversations yet',
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Start a new conversation to begin messaging',
                    style: Theme.of(context).textTheme.bodyMedium,
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 32),
                  ElevatedButton.icon(
                    onPressed: _showNewConversationDialog,
                    icon: const Icon(Icons.add),
                    label: const Text('New Conversation'),
                  ),
                ],
              ),
            );
          }

          return ListView.separated(
            itemCount: conversations.length,
            separatorBuilder: (context, index) => Divider(
              height: 1,
              indent: 72,
              color: Colors.grey[300],
            ),
            itemBuilder: (context, index) {
              final conv = conversations[index];
              return Dismissible(
                key: Key(conv.id),
                direction: DismissDirection.endToStart,
                background: Container(
                  alignment: Alignment.centerRight,
                  padding: const EdgeInsets.only(right: 20),
                  color: Colors.red,
                  child: const Icon(
                    Icons.delete,
                    color: Colors.white,
                  ),
                ),
                confirmDismiss: (direction) async {
                  return await showDialog(
                    context: context,
                    builder: (BuildContext context) {
                      return AlertDialog(
                        title: const Text('Delete Conversation'),
                        content: Text(
                          'Are you sure you want to delete "${conv.title}"? This cannot be undone.',
                        ),
                        actions: [
                          TextButton(
                            onPressed: () => Navigator.of(context).pop(false),
                            child: const Text('Cancel'),
                          ),
                          TextButton(
                            onPressed: () => Navigator.of(context).pop(true),
                            style: TextButton.styleFrom(
                              foregroundColor: Colors.red,
                            ),
                            child: const Text('Delete'),
                          ),
                        ],
                      );
                    },
                  );
                },
                onDismissed: (direction) async {
                  try {
                    await _conversationService.deleteConversation(conv.id);
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text('Deleted "${conv.title}"')),
                      );
                      setState(() {
                        // Refresh from local DB only (don't re-sync from backend)
                        _conversationsFuture = _conversationService.getAllConversations(syncFirst: false);
                      });
                    }
                  } catch (e) {
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text('Error deleting conversation: $e')),
                      );
                      setState(() {
                        // Re-sync to refresh the list
                        _conversationsFuture = _conversationService.getAllConversations(syncFirst: true);
                      });
                    }
                  }
                },
                child: InkWell(
                  onTap: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => MessageScreen(
                          conversationId: conv.id,
                          conversationTitle: conv.title,
                        ),
                      ),
                    );
                  },
                  child: Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                    child: Row(
                      children: [
                        UserAvatar(
                          fallbackText: conv.title,
                          radius: 28,
                          isGroup: conv.isGroup,
                          // Note: We don't have userId for conversation participant here
                          // In a full implementation, we'd fetch the other user's ID
                          // For now, fallback to initials
                        ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              conv.title,
                              style: const TextStyle(
                                fontSize: 16,
                                fontWeight: FontWeight.w600,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                            const SizedBox(height: 4),
                            FutureBuilder<Message?>(
                              future: _conversationService.getLatestMessage(conv.id),
                              builder: (context, snapshot) {
                                String previewText = 'Tap to start messaging';
                                
                                if (snapshot.hasData && snapshot.data != null) {
                                  final message = snapshot.data!;
                                  if (message.mediaUrl != null && message.mediaUrl!.isNotEmpty) {
                                    previewText = '📷 ${message.body}';
                                  } else {
                                    previewText = message.body;
                                  }
                                }
                                
                                return Text(
                                  previewText,
                                  style: TextStyle(
                                    fontSize: 14,
                                    color: Colors.grey[600],
                                  ),
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis,
                                );
                              },
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(width: 8),
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.end,
                        children: [
                          Text(
                            _formatTime(conv.lastMessageAt),
                            style: TextStyle(
                              fontSize: 12,
                              color: Theme.of(context).colorScheme.primary,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                ),
              );
            },
          );
          },
              ),
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _showNewConversationDialog,
        child: const Icon(Icons.add),
      ),
    );
  }

  String _formatTime(int? timestamp) {
    if (timestamp == null) return '';
    final dateTime = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inMinutes < 1) {
      return 'now';
    } else if (difference.inHours < 1) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inDays < 1) {
      return '${difference.inHours}h ago';
    } else if (difference.inDays < 7) {
      return '${difference.inDays}d ago';
    } else {
      return '${dateTime.month}/${dateTime.day}';
    }
  }
}
</file>

<file path="lib/features/conversations/widgets/message_bubble.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/features/messages/widgets/tone_detail_sheet.dart';
import 'package:messageai/state/ai_providers.dart';

/// Widget to display a single message with AI analysis
class MessageBubble extends ConsumerWidget {
  final Message message;
  final bool isSent;
  final bool isLoading;
  final VoidCallback? onRetry;

  const MessageBubble({
    Key? key,
    required this.message,
    required this.isSent,
    this.isLoading = false,
    this.onRetry,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    
    // Fetch AI analysis for this message
    final analysisAsync = ref.watch(messageAnalysisProvider(message.id));
    
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Row(
        mainAxisAlignment: isSent ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          if (!isSent)
            Padding(
              padding: const EdgeInsets.only(right: 8),
              child: CircleAvatar(
                radius: 16,
                backgroundColor: theme.colorScheme.primaryContainer,
                child: Text(
                  message.senderId.isNotEmpty 
                      ? message.senderId[0].toUpperCase() 
                      : 'U',
                  style: TextStyle(color: theme.colorScheme.onPrimaryContainer),
                ),
              ),
            ),
          Flexible(
            child: GestureDetector(
              onLongPress: isSent && !message.isSynced ? onRetry : null,
              child: Container(
                decoration: BoxDecoration(
                  color: isSent
                      ? theme.colorScheme.primary
                      : theme.colorScheme.surfaceVariant,
                  borderRadius: BorderRadius.circular(12),
                ),
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    if (message.mediaUrl != null && message.mediaUrl!.isNotEmpty)
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: Container(
                          width: 200,
                          height: 200,
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(8),
                            color: Colors.grey[300],
                          ),
                          child: Icon(
                            Icons.image,
                            size: 80,
                            color: Colors.grey[600],
                          ),
                        ),
                      ),
                    Text(
                      message.body,
                      style: TextStyle(
                        color: isSent ? Colors.white : theme.textTheme.bodyMedium?.color,
                        fontSize: 14,
                      ),
                    ),
                    Padding(
                      padding: const EdgeInsets.only(top: 4),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(
                            _formatTime(DateTime.fromMillisecondsSinceEpoch(
                              message.createdAt * 1000,
                            )),
                            style: TextStyle(
                              color: isSent 
                                  ? Colors.white70 
                                  : theme.textTheme.bodySmall?.color,
                              fontSize: 12,
                            ),
                          ),
                          if (isSent) ...[
                            const SizedBox(width: 4),
                            if (isLoading)
                              SizedBox(
                                width: 12,
                                height: 12,
                                child: CircularProgressIndicator(
                                  strokeWidth: 1.5,
                                  valueColor: AlwaysStoppedAnimation(
                                    Colors.white70,
                                  ),
                                ),
                              )
                            else if (message.isSynced)
                              Icon(
                                Icons.check_circle,
                                size: 12,
                                color: Colors.white70,
                              )
                            else
                              Icon(
                                Icons.schedule,
                                size: 12,
                                color: Colors.white70,
                              ),
                          ],
                        ],
                      ),
                    ),
                    // AI Analysis Badge (shows tone analysis if available)
                    analysisAsync.when(
                      data: (analysis) {
                        if (analysis == null) return const SizedBox.shrink();
                        return Padding(
                          padding: const EdgeInsets.only(top: 8),
                          child: ToneBadge(
                            analysis: analysis,
                            onTap: () => ToneDetailSheet.show(
                              context,
                              analysis,
                              message.body,
                            ),
                          ),
                        );
                      },
                      loading: () => const SizedBox.shrink(),
                      error: (_, __) => const SizedBox.shrink(),
                    ),
                  ],
                ),
              ),
            ),
          ),
          if (isSent)
            Padding(
              padding: const EdgeInsets.only(left: 8),
              child: CircleAvatar(
                radius: 16,
                backgroundColor: theme.colorScheme.primary,
                child: Icon(
                  Icons.person,
                  size: 12,
                  color: Colors.white,
                ),
              ),
            ),
        ],
      ),
    );
  }

  /// Format time for display
  String _formatTime(DateTime dateTime) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final yesterday = today.subtract(const Duration(days: 1));
    final messageDate = DateTime(dateTime.year, dateTime.month, dateTime.day);

    if (messageDate == today) {
      return '${dateTime.hour}:${dateTime.minute.toString().padLeft(2, '0')}';
    } else if (messageDate == yesterday) {
      return 'Yesterday';
    } else {
      return '${dateTime.month}/${dateTime.day}';
    }
  }
}
</file>

<file path="lib/features/messages/screens/message_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/message_service.dart';
import 'package:messageai/services/conversation_service.dart';
import 'package:messageai/services/presence_service.dart';
import 'package:messageai/services/realtime_message_service.dart';
import 'package:messageai/services/typing_indicator_service.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/widgets/user_avatar.dart';
import 'package:messageai/widgets/sliding_panel.dart';
import 'package:messageai/features/messages/widgets/message_list_panel.dart';
import 'package:messageai/features/messages/widgets/ai_insights_panel.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:image_picker/image_picker.dart';
import 'package:uuid/uuid.dart';
import 'dart:async';
import 'dart:io';

class MessageScreen extends StatefulWidget {
  final String conversationId;
  final String conversationTitle;

  const MessageScreen({
    Key? key,
    required this.conversationId,
    required this.conversationTitle,
  }) : super(key: key);

  @override
  State<MessageScreen> createState() => _MessageScreenState();
}

class _MessageScreenState extends State<MessageScreen> {
  final _messageService = MessageService();
  final _conversationService = ConversationService();
  final _presenceService = PresenceService();
  final _realtimeService = RealTimeMessageService();
  final _typingService = TypingIndicatorService();
  final _receiptDao = AppDb.instance.receiptDao;
  final _messageController = TextEditingController();
  final _imagePicker = ImagePicker();
  late Future<List<Message>> _messagesFuture;
  late Future<List<Participant>> _participantsFuture;
  bool _isSending = false;
  bool _isUploadingImage = false;
  String? _currentUserId;
  Map<String, List<Receipt>> _receiptsCache = {};
  Set<String> _typingUsers = {};
  Timer? _typingTimer;
  XFile? _selectedImage;
  Set<String> _onlineUsers = {};
  double _panelPosition = 0.8; // Track sliding panel position (0.0 = down, 1.0 = up)

  @override
  void initState() {
    super.initState();
    _currentUserId = _messageService.getCurrentUserId();
    
    // Sync messages from backend first, then load
    _messagesFuture = _messageService.getMessagesByConversation(
      widget.conversationId,
      syncFirst: true,
    );
    _participantsFuture = _conversationService.getParticipants(widget.conversationId);
    
    // Initialize real-time features
    _initializeRealtime();
    
    // Load receipts
    _loadReceipts();
    
    // Mark messages as read when opening conversation
    _messagesFuture.then((_) => _markMessagesAsRead());
    
    // Listen for text changes to send typing indicators
    _messageController.addListener(_onTextChanged);
  }

  Future<void> _loadReceipts() async {
    try {
      final receipts = await _receiptDao.getReceiptsByConversation(widget.conversationId);
      setState(() {
        _receiptsCache.clear();
        for (final receipt in receipts) {
          if (!_receiptsCache.containsKey(receipt.messageId)) {
            _receiptsCache[receipt.messageId] = [];
          }
          _receiptsCache[receipt.messageId]!.add(receipt);
        }
      });
    } catch (e) {
      print('Error loading receipts: $e');
    }
  }

  Future<void> _markMessagesAsRead() async {
    try {
      if (_currentUserId == null) return;
      
      // Get all messages
      final messages = await _messagesFuture;
      
      // Find unread messages from others
      for (final message in messages) {
        // Skip own messages
        if (message.senderId == _currentUserId) continue;
        
        // Check if we already have a read receipt
        final existingReceipts = _receiptsCache[message.id] ?? [];
        final hasReadReceipt = existingReceipts.any((r) => 
          r.userId == _currentUserId && r.status == 'read'
        );
        
        if (!hasReadReceipt) {
          await _createReadReceipt(message.id);
        }
      }
    } catch (e) {
      print('Error marking messages as read: $e');
    }
  }

  Future<void> _createReadReceipt(String messageId) async {
    try {
      if (_currentUserId == null) return;
      
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      
      // Check if receipt already exists
      final existingReceipt = await _receiptDao.getReceipt(messageId, _currentUserId!);
      
      if (existingReceipt != null) {
        // Update existing receipt to "read"
        await _receiptDao.updateReceiptStatus(messageId, _currentUserId!, 'read');
        
        // Sync to backend
        final supabase = SupabaseClientProvider.client;
        await supabase.from('message_receipts')
          .update({
            'status': 'read',
            'at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
          })
          .eq('message_id', messageId)
          .eq('user_id', _currentUserId!);
      } else {
        // Create new receipt
        final receiptId = const Uuid().v4();
        final receipt = Receipt(
          id: receiptId,
          messageId: messageId,
          userId: _currentUserId!,
          status: 'read',
          createdAt: now,
          updatedAt: now,
          isSynced: false,
        );
        
        await _receiptDao.addReceipt(receipt);
        
        final supabase = SupabaseClientProvider.client;
        await supabase.from('message_receipts').insert({
          'id': receiptId,
          'message_id': messageId,
          'user_id': _currentUserId,
          'status': 'read',
          'at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
        });
        
        await _receiptDao.markReceiptAsSynced(receiptId);
      }
    } catch (e) {
      print('Error creating read receipt: $e');
    }
  }

  Timer? _pollTimer;
  Timer? _presenceCheckTimer;

  Future<void> _initializeRealtime() async {
    try {
      // Subscribe to presence updates
      await _presenceService.subscribeToPresence(widget.conversationId);
      // Set current user as online
      await _presenceService.setPresenceStatus(widget.conversationId, true);
      
      // Poll presence status every 2 seconds to update UI
      _presenceCheckTimer = Timer.periodic(const Duration(seconds: 2), (timer) {
        if (mounted) {
          setState(() {
            _onlineUsers = _presenceService.getOnlineUsers(widget.conversationId);
          });
        }
      });
      
      // Subscribe to real-time messages
      _realtimeService.subscribeToMessages(widget.conversationId).listen((messages) {
        setState(() {
          _messagesFuture = Future.value(messages);
        });
        _loadReceipts();
        _markMessagesAsRead(); // Mark new messages as read
      });
      
      // Subscribe to real-time receipts
      _realtimeService.subscribeToReceipts(widget.conversationId).listen((receipts) {
        print('📬 Receipt update: ${receipts.length} total receipts');
        setState(() {
          _receiptsCache.clear();
          for (final receipt in receipts) {
            if (!_receiptsCache.containsKey(receipt.messageId)) {
              _receiptsCache[receipt.messageId] = [];
            }
            _receiptsCache[receipt.messageId]!.add(receipt);
            print('   - Message ${receipt.messageId.substring(0, 8)}: ${receipt.status} by ${receipt.userId.substring(0, 8)}');
          }
        });
      });
      
      // Subscribe to typing indicators
      _typingService.subscribeToTyping(widget.conversationId).listen((typingUserIds) {
        setState(() {
          _typingUsers = typingUserIds;
        });
      });
    } catch (e) {
      print('❌ Realtime init failed: $e');
    }
  }

  @override
  void dispose() {
    _messageController.removeListener(_onTextChanged);
    _messageController.dispose();
    _typingTimer?.cancel();
    _pollTimer?.cancel();
    _presenceCheckTimer?.cancel();
    // Set user as offline before leaving
    _presenceService.setPresenceStatus(widget.conversationId, false);
    // Clean up realtime subscriptions
    _presenceService.unsubscribeFromPresence(widget.conversationId);
    _realtimeService.unsubscribeFromMessages(widget.conversationId);
    _realtimeService.unsubscribeFromReceipts(widget.conversationId);
    _typingService.unsubscribeFromTyping(widget.conversationId);
    super.dispose();
  }

  void _onTextChanged() {
    if (_messageController.text.isNotEmpty) {
      // User is typing
      _typingService.sendTypingIndicator(widget.conversationId, true);
      
      // Reset the timer
      _typingTimer?.cancel();
      _typingTimer = Timer(const Duration(seconds: 2), () {
        // Stop typing after 2 seconds of inactivity
        _typingService.sendTypingIndicator(widget.conversationId, false);
      });
    } else {
      // User cleared text, stop typing
      _typingTimer?.cancel();
      _typingService.sendTypingIndicator(widget.conversationId, false);
    }
  }

  Future<void> _pickImage() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 1920,
        maxHeight: 1920,
        imageQuality: 85,
      );
      
      if (image != null) {
        setState(() {
          _selectedImage = image;
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error picking image: $e')),
        );
      }
    }
  }

  Future<String?> _uploadImage(XFile image) async {
    setState(() => _isUploadingImage = true);
    
    try {
      final userId = SupabaseClientProvider.client.auth.currentUser?.id;
      if (userId == null) throw Exception('User not authenticated');
      
      final fileBytes = await image.readAsBytes();
      final fileName = '${DateTime.now().millisecondsSinceEpoch}_${image.name}';
      final path = '$userId/$fileName';
      
      await SupabaseClientProvider.client.storage
          .from('media')
          .uploadBinary(path, fileBytes);
      
      final url = SupabaseClientProvider.client.storage
          .from('media')
          .getPublicUrl(path);
      
      return url;
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error uploading image: $e')),
        );
      }
      return null;
    } finally {
      if (mounted) {
        setState(() => _isUploadingImage = false);
      }
    }
  }

  Future<void> _sendMessage() async {
    final messageText = _messageController.text.trim();
    final hasText = messageText.isNotEmpty;
    final hasImage = _selectedImage != null;
    
    if (!hasText && !hasImage) return;
    if (_isSending || _isUploadingImage) return;

    // Clear input immediately for better UX
    _messageController.clear();
    final imageToSend = _selectedImage;
    setState(() {
      _selectedImage = null;
    });
    
    // Stop typing indicator when message is sent
    _typingTimer?.cancel();
    _typingService.sendTypingIndicator(widget.conversationId, false);

    setState(() => _isSending = true);

    try {
      String? mediaUrl;
      
      // Upload image if present
      if (imageToSend != null) {
        mediaUrl = await _uploadImage(imageToSend);
        if (mediaUrl == null) {
          throw Exception('Failed to upload image');
        }
      }
      
      await _messageService.sendMessage(
        conversationId: widget.conversationId,
        body: hasText ? messageText : '📷 Photo',
        mediaUrl: mediaUrl,
      );

      setState(() {
        _messagesFuture = _messageService.getMessagesByConversation(widget.conversationId);
      });
      
      // Reload receipts to update delivery status
      _loadReceipts();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
        _messageController.text = messageText;
        if (imageToSend != null) {
          setState(() {
            _selectedImage = imageToSend;
          });
        }
      }
    } finally {
      if (mounted) {
        setState(() => _isSending = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    return Scaffold(
      backgroundColor: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
      appBar: AppBar(
        title: Row(
          children: [
            Stack(
              children: [
                CircleAvatar(
                  radius: 18,
                  backgroundColor: Colors.grey[300],
                  child: Icon(
                    Icons.group,
                    size: 20,
                    color: Colors.grey[700],
                  ),
                ),
                if (_onlineUsers.isNotEmpty)
                  Positioned(
                    right: 0,
                    bottom: 0,
                    child: Container(
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(
                        color: Colors.green,
                        shape: BoxShape.circle,
                        border: Border.all(color: Colors.white, width: 2),
                      ),
                      child: Text(
                        '${_onlineUsers.length}',
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
              ],
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    widget.conversationTitle,
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  if (_onlineUsers.isNotEmpty)
                    Text(
                      '${_onlineUsers.length} online',
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.white.withOpacity(0.8),
                      ),
                    ),
                ],
              ),
            ),
          ],
        ),
        elevation: 1,
        actions: [
          IconButton(
            icon: const Icon(Icons.person_add),
            onPressed: _showAddParticipantsDialog,
            tooltip: 'Add participants',
          ),
          IconButton(
            icon: const Icon(Icons.more_vert),
            onPressed: () => _showParticipantsInfo(context),
            tooltip: 'Options',
          ),
        ],
      ),
      body: FutureBuilder<List<Message>>(
        future: _messagesFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(
              child: Text(
                'Error: ${snapshot.error}',
                style: theme.textTheme.bodyMedium,
              ),
            );
          }

          final messages = snapshot.data ?? [];

          return Stack(
            children: [
              // Background: AI Insights Panel
              AIInsightsPanel(
                conversationId: widget.conversationId,
                messages: messages,
                panelPosition: _panelPosition,
              ),
              
              // Foreground: Sliding Message Panel
              SlidingPanel(
                onSlide: (position) {
                  setState(() {
                    _panelPosition = position;
                  });
                },
                child: MessageListPanel(
                  messages: messages,
                  currentUserId: _currentUserId,
                  receiptsCache: _receiptsCache,
                  typingUsers: _typingUsers,
                  onlineUsers: _onlineUsers,
                  messageController: _messageController,
                  isSending: _isSending,
                  isUploadingImage: _isUploadingImage,
                  selectedImage: _selectedImage,
                  onSendMessage: _sendMessage,
                  onPickImage: _pickImage,
                  onClearImage: () {
                    setState(() {
                      _selectedImage = null;
                    });
                  },
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  void _showAddParticipantsDialog() {
    final emailController = TextEditingController();
    bool isSearching = false;
    
    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: const Text('Add Participant'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                controller: emailController,
                decoration: InputDecoration(
                  hintText: 'Enter email address',
                  helperText: 'Example: user@example.com',
                  prefixIcon: const Icon(Icons.email),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
                keyboardType: TextInputType.emailAddress,
                autofocus: true,
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: isSearching ? null : () async {
                final email = emailController.text.trim();
                if (email.isEmpty) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Please enter an email')),
                  );
                  return;
                }

                setState(() => isSearching = true);

                try {
                  // Add participant by email using database function
                  final response = await SupabaseClientProvider.client
                      .rpc('add_participant_by_email', params: {
                    'p_conversation_id': widget.conversationId,
                    'p_email': email,
                  });

                  final result = response as Map<String, dynamic>;
                  
                  if (result['success'] == false) {
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text(result['error'] ?? 'Failed to add participant')),
                      );
                    }
                    setState(() => isSearching = false);
                    return;
                  }
                  
                  if (mounted) {
                    Navigator.pop(context);
                    // Force refresh participants from backend
                    this.setState(() {
                      _participantsFuture = _conversationService.getParticipants(
                        widget.conversationId, 
                        syncFirst: true,  // Force sync from backend
                      );
                    });
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Added $email to conversation')),
                    );
                  }
                } catch (e) {
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Error: $e')),
                    );
                  }
                  setState(() => isSearching = false);
                }
              },
              child: isSearching 
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Text('Add'),
            ),
          ],
        ),
      ),
    );
  }

  void _showParticipantsInfo(BuildContext context) {
    showModalBottomSheet(
      context: context,
      builder: (context) => FutureBuilder<List<Participant>>(
        future: _participantsFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(child: Text('Error: ${snapshot.error}'));
          }

          final participants = snapshot.data ?? [];

          return SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Participants (${participants.length})',
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                  const SizedBox(height: 16),
                  if (participants.isEmpty)
                    const Center(
                      child: Padding(
                        padding: EdgeInsets.all(16),
                        child: Text('No participants yet'),
                      ),
                    )
                  else
                    ListView.builder(
                      shrinkWrap: true,
                      physics: const NeverScrollableScrollPhysics(),
                      itemCount: participants.length,
                      itemBuilder: (context, index) {
                        final participant = participants[index];
                        final isOnline = _presenceService.isUserOnline(
                          widget.conversationId,
                          participant.userId,
                        );
                        
                        return FutureBuilder<Map<String, dynamic>?>(
                          future: _conversationService.getParticipantProfile(participant.userId),
                          builder: (context, profileSnapshot) {
                            final profile = profileSnapshot.data;
                            final displayName = profile?['email'] as String? ?? 
                                              profile?['username'] as String? ?? 
                                              profile?['display_name'] as String? ??
                                              participant.userId.substring(0, 8);
                            final avatarUrl = profile?['avatar_url'] as String?;
                            final initial = displayName.isNotEmpty 
                                ? displayName[0].toUpperCase() 
                                : 'U';
                            
                            return ListTile(
                              leading: Stack(
                                children: [
                                  CircleAvatar(
                                    backgroundImage: avatarUrl != null
                                        ? NetworkImage(avatarUrl)
                                        : null,
                                    child: avatarUrl == null
                                        ? Text(initial)
                                        : null,
                                  ),
                                  Positioned(
                                    right: 0,
                                    bottom: 0,
                                    child: Container(
                                      width: 12,
                                      height: 12,
                                      decoration: BoxDecoration(
                                        color: isOnline ? Colors.green : Colors.grey,
                                        shape: BoxShape.circle,
                                        border: Border.all(
                                          color: Colors.white,
                                          width: 2,
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                              title: Text(displayName),
                              subtitle: Text(
                                isOnline
                                    ? (participant.isAdmin ? 'Admin • Online' : 'Member • Online')
                                    : (participant.isAdmin ? 'Admin • Offline' : 'Member • Offline'),
                              ),
                              trailing: participant.userId != _currentUserId
                                  ? IconButton(
                                      icon: const Icon(Icons.remove_circle),
                                      onPressed: () {
                                        Navigator.pop(context);
                                        _removeParticipant(participant.userId);
                                      },
                                    )
                                  : null,
                            );
                          },
                        );
                      },
                    ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Future<void> _removeParticipant(String userId) async {
    try {
      await _conversationService.removeParticipant(
        widget.conversationId,
        userId,
      );
      setState(() {
        _participantsFuture = _conversationService.getParticipants(widget.conversationId);
      });
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Participant removed')),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    }
  }

}
</file>

<file path="lib/features/messages/widgets/ai_insights_background.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';

/// Background panel for AI insights that appears behind the sliding message panel
/// Users can swipe down the message panel to reveal this content
class AIInsightsBackground extends StatelessWidget {
  final String conversationId;
  final double panelPosition;

  const AIInsightsBackground({
    Key? key,
    required this.conversationId,
    this.panelPosition = 0.0,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    // Calculate opacity based on panel position
    // When panel is fully up (position = 1.0), fade out insights
    // When panel is down (position = 0.0), show insights fully
    final opacity = 1.0 - panelPosition;
    
    return Container(
      color: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
      padding: const EdgeInsets.all(AppTheme.spacingL),
      child: SafeArea(
        child: Opacity(
          opacity: opacity.clamp(0.3, 1.0), // Keep minimum visibility
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  Icon(
                    Icons.auto_awesome,
                    size: 28,
                    color: isDark ? AppTheme.white : AppTheme.black,
                  ),
                  const SizedBox(width: AppTheme.spacingS),
                  Text(
                    'AI Insights',
                    style: theme.textTheme.displaySmall?.copyWith(
                      fontWeight: AppTheme.fontWeightBold,
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: AppTheme.spacingXL),
              
              // Placeholder content
              _buildPlaceholderCard(
                context,
                icon: Icons.insights,
                title: 'Tone Analysis',
                description: 'Pull down to see how messages are being interpreted',
                isDark: isDark,
              ),
              
              const SizedBox(height: AppTheme.spacingM),
              
              _buildPlaceholderCard(
                context,
                icon: Icons.lightbulb_outline,
                title: 'Smart Suggestions',
                description: 'AI-powered response recommendations coming soon',
                isDark: isDark,
              ),
              
              const SizedBox(height: AppTheme.spacingM),
              
              _buildPlaceholderCard(
                context,
                icon: Icons.analytics_outlined,
                title: 'Conversation Health',
                description: 'Monitor communication patterns and insights',
                isDark: isDark,
              ),
              
              const Spacer(),
              
              // Hint text
              Center(
                child: Column(
                  children: [
                    Icon(
                      Icons.keyboard_arrow_down,
                      size: 32,
                      color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                    ),
                    const SizedBox(height: AppTheme.spacingXS),
                    Text(
                      'Pull down messages to view insights',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: isDark ? AppTheme.gray600 : AppTheme.gray500,
                      ),
                    ),
                  ],
                ),
              ),
              
              const SizedBox(height: AppTheme.spacingXXL),
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildPlaceholderCard(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String description,
    required bool isDark,
  }) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingS),
            decoration: BoxDecoration(
              color: isDark 
                ? AppTheme.darkGray300 
                : AppTheme.gray100,
              borderRadius: BorderRadius.circular(AppTheme.radiusS),
            ),
            child: Icon(
              icon,
              size: 24,
              color: isDark ? AppTheme.white : AppTheme.black,
            ),
          ),
          const SizedBox(width: AppTheme.spacingM),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: theme.textTheme.labelLarge?.copyWith(
                    fontWeight: AppTheme.fontWeightSemibold,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  description,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/messages/widgets/ai_insights_panel.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/state/ai_providers.dart';

/// Enhanced AI insights panel that displays conversation-level analysis
/// Replaces the placeholder background when user pulls down the message panel
class AIInsightsPanel extends ConsumerWidget {
  final String conversationId;
  final List<Message> messages;
  final double panelPosition;

  const AIInsightsPanel({
    Key? key,
    required this.conversationId,
    required this.messages,
    this.panelPosition = 0.0,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    // Calculate opacity based on panel position
    final opacity = 1.0 - panelPosition;
    
    // Fetch analyses for the conversation
    final analysisAsync = ref.watch(
      conversationAnalysisProvider(conversationId),
    );

    return Container(
      color: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
      padding: const EdgeInsets.all(AppTheme.spacingL),
      child: SafeArea(
        child: Opacity(
          opacity: opacity.clamp(0.3, 1.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  Icon(
                    Icons.auto_awesome,
                    size: 28,
                    color: isDark ? AppTheme.white : AppTheme.black,
                  ),
                  const SizedBox(width: AppTheme.spacingS),
                  Text(
                    'AI Insights',
                    style: theme.textTheme.displaySmall?.copyWith(
                      fontWeight: AppTheme.fontWeightBold,
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: AppTheme.spacingXL),
              
              // Analysis content
              Expanded(
                child: analysisAsync.when(
                  data: (analyses) {
                    if (analyses.isEmpty) {
                      return _buildEmptyState(context, isDark);
                    }
                    return _buildAnalysisCards(context, analyses, isDark);
                  },
                  loading: () => _buildLoadingState(context, isDark),
                  error: (error, stack) => _buildErrorState(context, error, isDark),
                ),
              ),
              
              // Hint text
              if (panelPosition > 0.5)
                Center(
                  child: Column(
                    children: [
                      Icon(
                        Icons.keyboard_arrow_down,
                        size: 32,
                        color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                      ),
                      const SizedBox(height: AppTheme.spacingXS),
                      Text(
                        'Pull down to view insights',
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: isDark ? AppTheme.gray600 : AppTheme.gray500,
                        ),
                      ),
                    ],
                  ),
                ),
              
              const SizedBox(height: AppTheme.spacingL),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildAnalysisCards(
    BuildContext context,
    Map<String, AIAnalysis> analyses,
    bool isDark,
  ) {
    final theme = Theme.of(context);
    
    // Calculate summary statistics
    final toneDistribution = <String, int>{};
    int urgentCount = 0;
    double avgConfidence = 0.0;
    
    for (final analysis in analyses.values) {
      toneDistribution[analysis.tone] = (toneDistribution[analysis.tone] ?? 0) + 1;
      if (analysis.urgencyLevel == 'High' || analysis.urgencyLevel == 'Critical') {
        urgentCount++;
      }
      avgConfidence += analysis.confidenceScore ?? 0.0;
    }
    
    if (analyses.isNotEmpty) {
      avgConfidence /= analyses.length;
    }
    
    final mostCommonTone = toneDistribution.entries
        .reduce((a, b) => a.value > b.value ? a : b)
        .key;

    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Overall tone card
          _buildInsightCard(
            context,
            icon: Icons.psychology,
            title: 'Overall Tone',
            value: mostCommonTone,
            description: '${analyses.length} messages analyzed',
            color: AppTheme.accentBlue,
            isDark: isDark,
          ),
          
          const SizedBox(height: AppTheme.spacingM),
          
          // Urgency indicator card
          if (urgentCount > 0)
            _buildInsightCard(
              context,
              icon: Icons.warning_amber,
              title: 'Urgent Messages',
              value: urgentCount.toString(),
              description: 'Requires attention',
              color: AppTheme.accentOrange,
              isDark: isDark,
            ),
          
          if (urgentCount > 0) const SizedBox(height: AppTheme.spacingM),
          
          // Confidence indicator
          _buildInsightCard(
            context,
            icon: Icons.thumb_up_outlined,
            title: 'Analysis Quality',
            value: '${(avgConfidence * 100).round()}%',
            description: 'Average confidence',
            color: avgConfidence > 0.8
                ? AppTheme.accentGreen
                : avgConfidence > 0.6
                    ? AppTheme.accentBlue
                    : AppTheme.accentOrange,
            isDark: isDark,
          ),
          
          const SizedBox(height: AppTheme.spacingM),
          
          // Recent analysis
          if (analyses.isNotEmpty) ...[
            Text(
              'Recent Analysis',
              style: theme.textTheme.labelLarge?.copyWith(
                fontWeight: AppTheme.fontWeightBold,
              ),
            ),
            const SizedBox(height: AppTheme.spacingS),
            ...analyses.entries.take(3).map(
              (entry) => Padding(
                padding: const EdgeInsets.only(bottom: AppTheme.spacingS),
                child: _buildRecentAnalysisItem(
                  context,
                  entry.value,
                  isDark,
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildInsightCard(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String value,
    required String description,
    required Color color,
    required bool isDark,
  }) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingM),
            decoration: BoxDecoration(
              color: color.withOpacity(0.1),
              borderRadius: BorderRadius.circular(AppTheme.radiusS),
            ),
            child: Icon(
              icon,
              size: 24,
              color: color,
            ),
          ),
          const SizedBox(width: AppTheme.spacingM),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  value,
                  style: theme.textTheme.displaySmall?.copyWith(
                    fontWeight: AppTheme.fontWeightBold,
                    color: color,
                  ),
                ),
                Text(
                  description,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray600 : AppTheme.gray500,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildRecentAnalysisItem(
    BuildContext context,
    AIAnalysis analysis,
    bool isDark,
  ) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingS),
      decoration: BoxDecoration(
        color: (isDark ? AppTheme.darkGray100 : AppTheme.white).withOpacity(0.5),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(
          color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Text(
            _getToneEmoji(analysis.tone),
            style: const TextStyle(fontSize: 20),
          ),
          const SizedBox(width: AppTheme.spacingS),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  analysis.tone,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    fontWeight: AppTheme.fontWeightSemibold,
                  ),
                ),
                if (analysis.intent != null)
                  Text(
                    analysis.intent!,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: isDark ? AppTheme.gray600 : AppTheme.gray500,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyState(BuildContext context, bool isDark) {
    final theme = Theme.of(context);
    
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.auto_awesome_outlined,
            size: 64,
            color: isDark ? AppTheme.gray600 : AppTheme.gray400,
          ),
          const SizedBox(height: AppTheme.spacingM),
          Text(
            'No AI analysis yet',
            style: theme.textTheme.titleLarge?.copyWith(
              fontWeight: AppTheme.fontWeightSemibold,
            ),
          ),
          const SizedBox(height: AppTheme.spacingS),
          Text(
            'Send messages to see AI-powered insights',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: isDark ? AppTheme.gray500 : AppTheme.gray600,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildLoadingState(BuildContext context, bool isDark) {
    return const Center(
      child: CircularProgressIndicator(),
    );
  }

  Widget _buildErrorState(BuildContext context, Object error, bool isDark) {
    final theme = Theme.of(context);
    
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.error_outline,
            size: 64,
            color: AppTheme.accentRed,
          ),
          const SizedBox(height: AppTheme.spacingM),
          Text(
            'Error loading insights',
            style: theme.textTheme.titleLarge,
          ),
          const SizedBox(height: AppTheme.spacingS),
          Text(
            error.toString(),
            style: theme.textTheme.bodySmall,
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  String _getToneEmoji(String tone) {
    switch (tone.toLowerCase()) {
      case 'friendly':
        return '😊';
      case 'professional':
        return '💼';
      case 'urgent':
        return '⚡';
      case 'casual':
        return '😎';
      case 'formal':
        return '👔';
      case 'concerned':
        return '😟';
      case 'excited':
        return '🎉';
      case 'neutral':
      default:
        return '💬';
    }
  }
}
</file>

<file path="lib/features/messages/widgets/message_list_panel.dart">
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/features/messages/widgets/tone_detail_sheet.dart';
import 'package:messageai/state/ai_providers.dart';
import 'package:messageai/widgets/user_avatar.dart';

/// Panel containing the message list and compose bar
/// This widget slides up and down over the AI insights background
class MessageListPanel extends ConsumerWidget {
  final List<Message> messages;
  final String? currentUserId;
  final Map<String, List<Receipt>> receiptsCache;
  final Set<String> typingUsers;
  final Set<String> onlineUsers;
  final TextEditingController messageController;
  final bool isSending;
  final bool isUploadingImage;
  final XFile? selectedImage;
  final VoidCallback onSendMessage;
  final VoidCallback onPickImage;
  final VoidCallback onClearImage;

  const MessageListPanel({
    Key? key,
    required this.messages,
    required this.currentUserId,
    required this.receiptsCache,
    required this.typingUsers,
    required this.onlineUsers,
    required this.messageController,
    required this.isSending,
    required this.isUploadingImage,
    required this.selectedImage,
    required this.onSendMessage,
    required this.onPickImage,
    required this.onClearImage,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    return Column(
      children: [
        // Message list
        Expanded(
          child: messages.isEmpty
              ? Center(
                  child: Text(
                    'No messages yet. Start the conversation!',
                    style: theme.textTheme.bodyMedium,
                  ),
                )
              : ListView.builder(
                  reverse: true,
                  padding: const EdgeInsets.symmetric(
                    vertical: AppTheme.spacingS,
                    horizontal: AppTheme.spacingXS,
                  ),
                  itemCount: messages.length + (typingUsers.isNotEmpty ? 1 : 0),
                  itemBuilder: (context, index) {
                    // Show typing indicator as first item (at bottom)
                    if (index == 0 && typingUsers.isNotEmpty) {
                      return _buildTypingIndicator(context, isDark);
                    }
                    
                    // Adjust index if typing indicator is showing
                    final messageIndex = typingUsers.isNotEmpty ? index - 1 : index;
                    final message = messages[messages.length - 1 - messageIndex];
                    final isOwn = message.senderId == currentUserId;
                    final isOnline = onlineUsers.contains(message.senderId);

                    return _buildMessageBubble(
                      context,
                      ref,
                      message,
                      isOwn,
                      isOnline,
                      isDark,
                    );
                  },
                ),
        ),
        
        // Compose bar
        _buildComposeBar(context, isDark),
      ],
    );
  }
  
  Widget _buildMessageBubble(
    BuildContext context,
    WidgetRef ref,
    Message message,
    bool isOwn,
    bool isOnline,
    bool isDark,
  ) {
    // Fetch AI analysis for this message
    final analysisAsync = ref.watch(messageAnalysisProvider(message.id));
    return Align(
      alignment: isOwn ? Alignment.centerRight : Alignment.centerLeft,
      child: Row(
        mainAxisAlignment: isOwn ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          // Show avatar for other users' messages (left side)
          if (!isOwn) ...[
            Padding(
              padding: const EdgeInsets.only(
                left: AppTheme.spacingS,
                right: AppTheme.spacingXXS,
                bottom: AppTheme.spacingXXS,
              ),
              child: Stack(
                children: [
                  UserAvatar(
                    userId: message.senderId,
                    fallbackText: message.senderId.substring(0, 1).toUpperCase(),
                    radius: 16,
                  ),
                  Positioned(
                    right: 0,
                    bottom: 0,
                    child: Container(
                      width: 12,
                      height: 12,
                      decoration: BoxDecoration(
                        color: isOnline ? AppTheme.accentGreen : AppTheme.gray500,
                        shape: BoxShape.circle,
                        border: Border.all(
                          color: isDark ? AppTheme.black : AppTheme.white,
                          width: 2,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
          
          // Message bubble
          Container(
            constraints: BoxConstraints(
              maxWidth: MediaQuery.of(context).size.width * 0.65,
            ),
            margin: EdgeInsets.only(
              left: isOwn ? 64 : 0,
              right: isOwn ? AppTheme.spacingS : 64,
              top: AppTheme.spacingXXS,
              bottom: AppTheme.spacingXXS,
            ),
            padding: const EdgeInsets.symmetric(
              horizontal: AppTheme.spacingS,
              vertical: AppTheme.spacingS,
            ),
            decoration: BoxDecoration(
              color: isOwn
                  ? (isDark ? AppTheme.darkGray300 : AppTheme.gray200)
                  : (isDark ? AppTheme.darkGray100 : AppTheme.white),
              borderRadius: BorderRadius.only(
                topLeft: const Radius.circular(AppTheme.radiusXL),
                topRight: const Radius.circular(AppTheme.radiusXL),
                bottomLeft: Radius.circular(isOwn ? AppTheme.radiusXL : AppTheme.radiusXS),
                bottomRight: Radius.circular(isOwn ? AppTheme.radiusXS : AppTheme.radiusXL),
              ),
              border: !isOwn
                  ? Border.all(
                      color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                      width: 1,
                    )
                  : null,
            ),
            child: Column(
              crossAxisAlignment: isOwn ? CrossAxisAlignment.end : CrossAxisAlignment.start,
              children: [
                // Show image if present
                if (message.mediaUrl != null && message.mediaUrl!.isNotEmpty) ...[
                  ClipRRect(
                    borderRadius: BorderRadius.circular(AppTheme.radiusS),
                    child: Image.network(
                      message.mediaUrl!,
                      width: 250,
                      fit: BoxFit.cover,
                      loadingBuilder: (context, child, loadingProgress) {
                        if (loadingProgress == null) return child;
                        return Container(
                          width: 250,
                          height: 250,
                          color: isDark ? AppTheme.darkGray200 : AppTheme.gray200,
                          child: Center(
                            child: CircularProgressIndicator(
                              value: loadingProgress.expectedTotalBytes != null
                                  ? loadingProgress.cumulativeBytesLoaded /
                                      loadingProgress.expectedTotalBytes!
                                  : null,
                            ),
                          ),
                        );
                      },
                      errorBuilder: (context, error, stackTrace) {
                        return Container(
                          width: 250,
                          height: 250,
                          color: isDark ? AppTheme.darkGray200 : AppTheme.gray200,
                          child: const Icon(Icons.broken_image, size: 50),
                        );
                      },
                    ),
                  ),
                  const SizedBox(height: AppTheme.spacingXXS),
                ],
                
                // Message text
                Text(
                  message.body,
                  style: TextStyle(
                    color: isDark ? AppTheme.white : AppTheme.black,
                    fontSize: AppTheme.fontSizeM,
                    height: AppTheme.lineHeightNormal,
                  ),
                ),
                
                const SizedBox(height: AppTheme.spacingXXS),
                
                // Timestamp and delivery indicator
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      _formatTime(message.createdAt),
                      style: TextStyle(
                        fontSize: AppTheme.fontSizeXS,
                        color: isDark ? AppTheme.gray600 : AppTheme.gray600,
                      ),
                    ),
                    if (isOwn) ...[
                      const SizedBox(width: AppTheme.spacingXXS),
                      _buildDeliveryIndicator(message),
                    ],
                  ],
                ),
                
                // AI Analysis Badge (shows tone analysis if available)
                analysisAsync.when(
                  data: (analysis) {
                    if (analysis == null) return const SizedBox.shrink();
                    return Padding(
                      padding: const EdgeInsets.only(top: 8),
                      child: ToneBadge(
                        analysis: analysis,
                        onTap: () => ToneDetailSheet.show(
                          context,
                          analysis,
                          message.body,
                        ),
                      ),
                    );
                  },
                  loading: () => const SizedBox.shrink(),
                  error: (_, __) => const SizedBox.shrink(),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildTypingIndicator(BuildContext context, bool isDark) {
    final count = typingUsers.length;
    final text = count == 1 
        ? 'Someone is typing...' 
        : '$count people are typing...';
    
    return Padding(
      padding: const EdgeInsets.symmetric(
        horizontal: AppTheme.spacingM,
        vertical: AppTheme.spacingS,
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.symmetric(
              horizontal: AppTheme.spacingS,
              vertical: AppTheme.spacingS,
            ),
            decoration: BoxDecoration(
              color: isDark ? AppTheme.darkGray100 : AppTheme.white,
              borderRadius: BorderRadius.circular(AppTheme.radiusM),
              border: Border.all(
                color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                width: 1,
              ),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  text,
                  style: TextStyle(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                    fontSize: AppTheme.fontSizeS,
                    fontStyle: FontStyle.italic,
                  ),
                ),
                const SizedBox(width: AppTheme.spacingS),
                SizedBox(
                  width: 20,
                  height: 20,
                  child: _TypingAnimation(isDark: isDark),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildComposeBar(BuildContext context, bool isDark) {
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingS),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        border: Border(
          top: BorderSide(
            color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
            width: 1,
          ),
        ),
      ),
      child: SafeArea(
        top: false,
        child: Column(
          children: [
            // Show selected image preview
            if (selectedImage != null) ...[
              Container(
                padding: const EdgeInsets.all(AppTheme.spacingS),
                child: Stack(
                  children: [
                    ClipRRect(
                      borderRadius: BorderRadius.circular(AppTheme.radiusS),
                      child: Image.file(
                        File(selectedImage!.path),
                        height: 150,
                        width: 150,
                        fit: BoxFit.cover,
                      ),
                    ),
                    Positioned(
                      top: AppTheme.spacingXXS,
                      right: AppTheme.spacingXXS,
                      child: GestureDetector(
                        onTap: onClearImage,
                        child: Container(
                          decoration: BoxDecoration(
                            color: AppTheme.black.withOpacity(0.6),
                            shape: BoxShape.circle,
                          ),
                          padding: const EdgeInsets.all(AppTheme.spacingXXS),
                          child: const Icon(
                            Icons.close,
                            color: AppTheme.white,
                            size: 20,
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
            
            // Input row
            Row(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                // Image picker button
                IconButton(
                  onPressed: isUploadingImage || isSending ? null : onPickImage,
                  icon: Icon(
                    Icons.image,
                    color: isUploadingImage || isSending
                        ? (isDark ? AppTheme.gray600 : AppTheme.gray400)
                        : AppTheme.accentBlue,
                  ),
                  padding: const EdgeInsets.all(AppTheme.spacingS),
                ),
                
                const SizedBox(width: AppTheme.spacingXXS),
                
                // Text input
                Expanded(
                  child: Container(
                    decoration: BoxDecoration(
                      color: isDark ? AppTheme.darkGray200 : AppTheme.gray100,
                      borderRadius: BorderRadius.circular(AppTheme.radiusXL),
                      border: Border.all(
                        color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                        width: 1,
                      ),
                    ),
                    padding: const EdgeInsets.symmetric(
                      horizontal: AppTheme.spacingM,
                    ),
                    child: TextField(
                      controller: messageController,
                      enabled: !isSending && !isUploadingImage,
                      decoration: const InputDecoration(
                        hintText: 'Message',
                        border: InputBorder.none,
                        contentPadding: EdgeInsets.symmetric(
                          vertical: AppTheme.spacingS,
                        ),
                      ),
                      maxLines: 5,
                      minLines: 1,
                      textCapitalization: TextCapitalization.sentences,
                      style: TextStyle(
                        color: isDark ? AppTheme.white : AppTheme.black,
                      ),
                    ),
                  ),
                ),
                
                const SizedBox(width: AppTheme.spacingS),
                
                // Send button
                Container(
                  decoration: BoxDecoration(
                    color: isDark ? AppTheme.white : AppTheme.black,
                    shape: BoxShape.circle,
                  ),
                  child: IconButton(
                    onPressed: (isSending || isUploadingImage) ? null : onSendMessage,
                    icon: (isSending || isUploadingImage)
                        ? SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              color: isDark ? AppTheme.black : AppTheme.white,
                            ),
                          )
                        : Icon(
                            Icons.send,
                            size: 20,
                            color: isDark ? AppTheme.black : AppTheme.white,
                          ),
                    padding: const EdgeInsets.all(AppTheme.spacingS),
                    constraints: const BoxConstraints(),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildDeliveryIndicator(Message message) {
    final receipts = receiptsCache[message.id] ?? [];
    
    // Filter out own receipts (shouldn't exist for sent messages, but just in case)
    final otherReceipts = receipts.where((r) => r.userId != currentUserId).toList();
    
    final hasDelivered = otherReceipts.any((r) => r.status == 'delivered' || r.status == 'read');
    final hasRead = otherReceipts.any((r) => r.status == 'read');

    IconData icon;
    Color color;

    if (hasRead) {
      icon = Icons.done_all;
      color = AppTheme.accentBlue;
    } else if (hasDelivered) {
      icon = Icons.done_all;
      color = AppTheme.gray600;
    } else {
      icon = Icons.done;
      color = AppTheme.gray600;
    }

    return Icon(
      icon,
      size: 14,
      color: color,
    );
  }
  
  String _formatTime(int timestamp) {
    final dateTime = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);
    final hour = dateTime.hour.toString().padLeft(2, '0');
    final minute = dateTime.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }
}

/// Animated typing indicator dots
class _TypingAnimation extends StatefulWidget {
  final bool isDark;
  
  const _TypingAnimation({required this.isDark});

  @override
  State<_TypingAnimation> createState() => _TypingAnimationState();
}

class _TypingAnimationState extends State<_TypingAnimation>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1000),
    )..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return Row(
          mainAxisSize: MainAxisSize.min,
          children: List.generate(3, (index) {
            final delay = index * 0.2;
            final value = (_controller.value - delay) % 1.0;
            final opacity = value < 0.5 ? value * 2 : (1 - value) * 2;
            
            return Container(
              width: 4,
              height: 4,
              margin: const EdgeInsets.symmetric(horizontal: 1),
              decoration: BoxDecoration(
                color: (widget.isDark ? AppTheme.gray600 : AppTheme.gray600)
                    .withOpacity(opacity),
                shape: BoxShape.circle,
              ),
            );
          }),
        );
      },
    );
  }
}
</file>

<file path="lib/features/messages/widgets/tone_badge.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/ai_analysis.dart';

/// A small badge widget that displays tone analysis for a message
/// Appears at the bottom-right of message bubbles
class ToneBadge extends StatelessWidget {
  final AIAnalysis analysis;
  final VoidCallback? onTap;

  const ToneBadge({
    Key? key,
    required this.analysis,
    this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    final toneInfo = _getToneInfo(analysis.tone);
    final urgencyColor = _getUrgencyColor(analysis.urgencyLevel);

    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: AppTheme.spacingXS,
          vertical: AppTheme.spacingXXS,
        ),
        decoration: BoxDecoration(
          color: (isDark ? AppTheme.darkGray200 : AppTheme.gray100)
              .withOpacity(0.9),
          borderRadius: BorderRadius.circular(AppTheme.radiusS),
          border: Border.all(
            color: urgencyColor.withOpacity(0.3),
            width: 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              toneInfo.emoji,
              style: const TextStyle(fontSize: 12),
            ),
            const SizedBox(width: AppTheme.spacingXXS),
            Text(
              toneInfo.label,
              style: TextStyle(
                fontSize: AppTheme.fontSizeXXS,
                fontWeight: AppTheme.fontWeightMedium,
                color: isDark ? AppTheme.white : AppTheme.black,
              ),
            ),
            if (analysis.urgencyLevel != null && analysis.urgencyLevel != 'Low') ...[
              const SizedBox(width: AppTheme.spacingXXS),
              Container(
                width: 6,
                height: 6,
                decoration: BoxDecoration(
                  color: urgencyColor,
                  shape: BoxShape.circle,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  ToneInfo _getToneInfo(String tone) {
    switch (tone.toLowerCase()) {
      case 'friendly':
        return ToneInfo(emoji: '😊', label: 'Friendly');
      case 'professional':
        return ToneInfo(emoji: '💼', label: 'Professional');
      case 'urgent':
        return ToneInfo(emoji: '⚡', label: 'Urgent');
      case 'casual':
        return ToneInfo(emoji: '😎', label: 'Casual');
      case 'formal':
        return ToneInfo(emoji: '👔', label: 'Formal');
      case 'concerned':
        return ToneInfo(emoji: '😟', label: 'Concerned');
      case 'excited':
        return ToneInfo(emoji: '🎉', label: 'Excited');
      case 'neutral':
      default:
        return ToneInfo(emoji: '💬', label: 'Neutral');
    }
  }

  Color _getUrgencyColor(String? urgencyLevel) {
    if (urgencyLevel == null) return AppTheme.gray500;
    
    switch (urgencyLevel.toLowerCase()) {
      case 'critical':
        return AppTheme.accentRed;
      case 'high':
        return AppTheme.accentOrange;
      case 'medium':
        return AppTheme.accentBlue;
      case 'low':
      default:
        return AppTheme.accentGreen;
    }
  }
}

class ToneInfo {
  final String emoji;
  final String label;

  ToneInfo({required this.emoji, required this.label});
}
</file>

<file path="lib/features/messages/widgets/tone_detail_sheet.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Bottom sheet showing detailed tone analysis
class ToneDetailSheet extends StatelessWidget {
  final AIAnalysis analysis;
  final String messageBody;

  const ToneDetailSheet({
    Key? key,
    required this.analysis,
    required this.messageBody,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingL),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(AppTheme.radiusXL),
          topRight: Radius.circular(AppTheme.radiusXL),
        ),
      ),
      child: SafeArea(
        top: false,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Handle bar
            Center(
              child: Container(
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                  borderRadius: BorderRadius.circular(AppTheme.radiusPill),
                ),
              ),
            ),
            
            const SizedBox(height: AppTheme.spacingL),
            
            // Header
            Row(
              children: [
                Icon(
                  Icons.psychology,
                  size: 28,
                  color: isDark ? AppTheme.white : AppTheme.black,
                ),
                const SizedBox(width: AppTheme.spacingS),
                Text(
                  'AI Analysis',
                  style: theme.textTheme.displaySmall?.copyWith(
                    fontWeight: AppTheme.fontWeightBold,
                  ),
                ),
              ],
            ),
            
            const SizedBox(height: AppTheme.spacingL),
            
            // Message preview
            _buildSection(
              context,
              'Message',
              messageBody.length > 100
                  ? '${messageBody.substring(0, 100)}...'
                  : messageBody,
              Icons.chat_bubble_outline,
              isDark,
            ),
            
            const SizedBox(height: AppTheme.spacingM),
            
            // Tone
            _buildSection(
              context,
              'Tone',
              analysis.tone,
              Icons.sentiment_satisfied,
              isDark,
              highlight: true,
            ),
            
            const SizedBox(height: AppTheme.spacingM),
            
            // Urgency
            if (analysis.urgencyLevel != null)
              _buildSection(
                context,
                'Urgency Level',
                analysis.urgencyLevel!,
                Icons.priority_high,
                isDark,
                color: _getUrgencyColor(analysis.urgencyLevel),
              ),
            
            if (analysis.urgencyLevel != null)
              const SizedBox(height: AppTheme.spacingM),
            
            // Intent
            if (analysis.intent != null)
              _buildSection(
                context,
                'Intent',
                analysis.intent!,
                Icons.lightbulb_outline,
                isDark,
              ),
            
            if (analysis.intent != null)
              const SizedBox(height: AppTheme.spacingM),
            
            // Confidence
            if (analysis.confidenceScore != null) ...[
              _buildConfidenceBar(
                context,
                analysis.confidenceScore!,
                isDark,
              ),
              const SizedBox(height: AppTheme.spacingL),
            ],
            
            // Feedback section
            _buildFeedbackSection(context, isDark),
            
            const SizedBox(height: AppTheme.spacingM),
            
            // Close button
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () => Navigator.pop(context),
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(
                    vertical: AppTheme.spacingM,
                  ),
                ),
                child: const Text('Close'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSection(
    BuildContext context,
    String label,
    String value,
    IconData icon,
    bool isDark, {
    bool highlight = false,
    Color? color,
  }) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: highlight
            ? (isDark ? AppTheme.darkGray200 : AppTheme.gray100)
            : (isDark ? AppTheme.darkGray200.withOpacity(0.5) : AppTheme.gray50),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: color ?? (isDark ? AppTheme.darkGray300 : AppTheme.gray300),
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingS),
            decoration: BoxDecoration(
              color: (color ?? (isDark ? AppTheme.darkGray300 : AppTheme.gray200))
                  .withOpacity(0.3),
              borderRadius: BorderRadius.circular(AppTheme.radiusS),
            ),
            child: Icon(
              icon,
              size: 20,
              color: color ?? (isDark ? AppTheme.white : AppTheme.black),
            ),
          ),
          const SizedBox(width: AppTheme.spacingM),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  label,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                    fontWeight: AppTheme.fontWeightMedium,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  value,
                  style: theme.textTheme.bodyLarge?.copyWith(
                    fontWeight: AppTheme.fontWeightSemibold,
                    color: color,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildConfidenceBar(
    BuildContext context,
    double confidence,
    bool isDark,
  ) {
    final theme = Theme.of(context);
    final percentage = (confidence * 100).round();
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Confidence',
              style: theme.textTheme.bodySmall?.copyWith(
                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                fontWeight: AppTheme.fontWeightMedium,
              ),
            ),
            Text(
              '$percentage%',
              style: theme.textTheme.bodySmall?.copyWith(
                fontWeight: AppTheme.fontWeightBold,
              ),
            ),
          ],
        ),
        const SizedBox(height: AppTheme.spacingXS),
        ClipRRect(
          borderRadius: BorderRadius.circular(AppTheme.radiusPill),
          child: LinearProgressIndicator(
            value: confidence,
            minHeight: 8,
            backgroundColor: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
            valueColor: AlwaysStoppedAnimation<Color>(
              confidence > 0.8
                  ? AppTheme.accentGreen
                  : confidence > 0.6
                      ? AppTheme.accentBlue
                      : AppTheme.accentOrange,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildFeedbackSection(BuildContext context, bool isDark) {
    final theme = Theme.of(context);
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Was this analysis helpful?',
          style: theme.textTheme.bodySmall?.copyWith(
            color: isDark ? AppTheme.gray500 : AppTheme.gray600,
            fontWeight: AppTheme.fontWeightMedium,
          ),
        ),
        const SizedBox(height: AppTheme.spacingXS),
        Row(
          children: [
            OutlinedButton.icon(
              onPressed: () {
                // TODO: Implement feedback logic
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Thanks for your feedback!')),
                );
              },
              icon: const Icon(Icons.thumb_up_outlined, size: 18),
              label: const Text('Helpful'),
              style: OutlinedButton.styleFrom(
                side: BorderSide(
                  color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                ),
              ),
            ),
            const SizedBox(width: AppTheme.spacingS),
            OutlinedButton.icon(
              onPressed: () {
                // TODO: Implement feedback logic
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Thanks for your feedback!')),
                );
              },
              icon: const Icon(Icons.thumb_down_outlined, size: 18),
              label: const Text('Not helpful'),
              style: OutlinedButton.styleFrom(
                side: BorderSide(
                  color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                ),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Color _getUrgencyColor(String? urgencyLevel) {
    if (urgencyLevel == null) return AppTheme.gray500;
    
    switch (urgencyLevel.toLowerCase()) {
      case 'critical':
        return AppTheme.accentRed;
      case 'high':
        return AppTheme.accentOrange;
      case 'medium':
        return AppTheme.accentBlue;
      case 'low':
      default:
        return AppTheme.accentGreen;
    }
  }

  static void show(
    BuildContext context,
    AIAnalysis analysis,
    String messageBody,
  ) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => ToneDetailSheet(
        analysis: analysis,
        messageBody: messageBody,
      ),
    );
  }
}
</file>

<file path="lib/features/notifications/widgets/notification_widgets.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/notification_providers.dart';
import 'package:messageai/services/notification_service.dart';

/// Widget to request notification permissions
class NotificationPermissionRequest extends ConsumerWidget {
  final VoidCallback? onPermissionGranted;
  final VoidCallback? onPermissionDenied;

  const NotificationPermissionRequest({
    Key? key,
    this.onPermissionGranted,
    this.onPermissionDenied,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final hasPermission = ref.watch(notificationPermissionProvider);

    return hasPermission.when(
      data: (hasPermission) {
        if (hasPermission) {
          return const SizedBox.shrink();
        }
        return _PermissionBanner(
          onGranted: onPermissionGranted,
          onDenied: onPermissionDenied,
        );
      },
      loading: () => const SizedBox.shrink(),
      error: (error, st) => const SizedBox.shrink(),
    );
  }
}

/// Permission request banner
class _PermissionBanner extends ConsumerWidget {
  final VoidCallback? onGranted;
  final VoidCallback? onDenied;

  const _PermissionBanner({
    this.onGranted,
    this.onDenied,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Container(
      color: Colors.blue.shade50,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      child: Row(
        children: [
          Icon(
            Icons.notifications_none,
            color: Colors.blue.shade700,
            size: 24,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  'Enable Notifications',
                  style: Theme.of(context).textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                ),
                Text(
                  'Get notified when you receive messages',
                  style: Theme.of(context).textTheme.bodySmall,
                ),
              ],
            ),
          ),
          const SizedBox(width: 12),
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextButton(
                onPressed: () {
                  onDenied?.call();
                },
                child: const Text('Not Now'),
              ),
              const SizedBox(width: 8),
              ElevatedButton(
                onPressed: () async {
                  final service = ref.read(notificationServiceProvider);
                  final granted = await service.areNotificationsEnabled();
                  if (granted) {
                    onGranted?.call();
                  } else {
                    onDenied?.call();
                  }
                },
                child: const Text('Enable'),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

/// Notification status indicator
class NotificationStatusIndicator extends ConsumerWidget {
  const NotificationStatusIndicator({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);

    if (!notificationState.isInitialized) {
      return const SizedBox.shrink();
    }

    final hasPermission = notificationState.hasPermission;

    return Tooltip(
      message: hasPermission ? 'Notifications enabled' : 'Notifications disabled',
      child: Icon(
        hasPermission ? Icons.notifications_active : Icons.notifications_off,
        color: hasPermission ? Colors.green : Colors.grey,
        size: 24,
      ),
    );
  }
}

/// Notification settings tile
class NotificationSettingsTile extends ConsumerWidget {
  final VoidCallback? onPressed;

  const NotificationSettingsTile({
    Key? key,
    this.onPressed,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);
    final hasPermission = notificationState.hasPermission;

    return ListTile(
      leading: Icon(
        hasPermission ? Icons.notifications_active : Icons.notifications_off,
        color: hasPermission ? Colors.green : Colors.grey,
      ),
      title: const Text('Notifications'),
      subtitle: Text(
        hasPermission ? 'Enabled' : 'Disabled',
        style: TextStyle(
          color: hasPermission ? Colors.green : Colors.grey,
        ),
      ),
      trailing: Icon(
        Icons.chevron_right,
        color: Theme.of(context).dividerColor,
      ),
      onTap: onPressed,
    );
  }
}

/// Unread notification badge
class NotificationBadge extends ConsumerWidget {
  final Widget child;
  final Color? backgroundColor;
  final TextStyle? textStyle;

  const NotificationBadge({
    Key? key,
    required this.child,
    this.backgroundColor,
    this.textStyle,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);
    final unreadCount = notificationState.unreadCount;

    if (unreadCount == 0) {
      return child;
    }

    return Badge(
      label: Text(
        unreadCount > 99 ? '99+' : '$unreadCount',
        style: textStyle,
      ),
      backgroundColor: backgroundColor ?? Colors.red,
      child: child,
    );
  }
}

/// Notification bottom sheet
class NotificationSettingsBottomSheet extends ConsumerWidget {
  const NotificationSettingsBottomSheet({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);
    final hasPermission = notificationState.hasPermission;
    final deviceToken = notificationState.deviceToken;

    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Text(
            'Notification Settings',
            style: Theme.of(context).textTheme.headlineSmall,
          ),
          const SizedBox(height: 24),

          // Permission status
          ListTile(
            leading: Icon(
              hasPermission ? Icons.check_circle : Icons.error_circle,
              color: hasPermission ? Colors.green : Colors.red,
            ),
            title: const Text('Notifications'),
            subtitle: Text(
              hasPermission ? 'Enabled' : 'Disabled',
              style: TextStyle(
                color: hasPermission ? Colors.green : Colors.red,
              ),
            ),
          ),
          const Divider(),

          // Device token info
          if (deviceToken != null)
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 8.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Device Token',
                    style: Theme.of(context).textTheme.labelMedium,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    deviceToken.substring(0, 20) + '...',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          fontFamily: 'monospace',
                        ),
                  ),
                ],
              ),
            ),
          const SizedBox(height: 24),

          // Close button
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Close'),
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/settings/screens/settings_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/features/auth/screens/auth_screen.dart';
import 'package:messageai/services/avatar_service.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_ui.dart';

/// User settings and account management screen
class SettingsScreen extends StatefulWidget {
  const SettingsScreen({Key? key}) : super(key: key);

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> with ErrorHandlerMixin {
  final _supabase = SupabaseClientProvider.client;
  final _avatarService = AvatarService();
  bool _notificationsEnabled = true;
  bool _isLoading = false;
  bool _isUploadingAvatar = false;
  String? _avatarUrl;

  @override
  void initState() {
    super.initState();
    _loadProfile();
  }

  Future<void> _loadProfile() async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      final response = await _supabase
          .from('profiles')
          .select('avatar_url')
          .eq('user_id', userId)
          .maybeSingle();

      if (response != null && mounted) {
        setState(() {
          _avatarUrl = response['avatar_url'] as String?;
        });
      }
    } catch (e) {
      print('Error loading profile: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    final user = _supabase.auth.currentUser;
    final email = user?.email ?? 'Not logged in';
    final userId = user?.id ?? '';

    return Scaffold(
      appBar: AppBar(
        title: const Text('Settings'),
        elevation: 1,
      ),
      body: ListView(
        children: [
          // Profile Section
          Container(
            padding: const EdgeInsets.all(24),
            color: Theme.of(context).colorScheme.surfaceContainer,
            child: Column(
              children: [
                Stack(
                  children: [
                    _isUploadingAvatar
                        ? const CircleAvatar(
                            radius: 50,
                            child: CircularProgressIndicator(),
                          )
                        : CircleAvatar(
                            radius: 50,
                            backgroundColor: Theme.of(context).colorScheme.primary,
                            backgroundImage: _avatarUrl != null
                                ? NetworkImage(_avatarUrl!)
                                : null,
                            child: _avatarUrl == null
                                ? Text(
                                    email[0].toUpperCase(),
                                    style: const TextStyle(
                                      fontSize: 40,
                                      fontWeight: FontWeight.bold,
                                      color: Colors.white,
                                    ),
                                  )
                                : null,
                          ),
                    Positioned(
                      bottom: 0,
                      right: 0,
                      child: Container(
                        decoration: BoxDecoration(
                          color: Theme.of(context).colorScheme.primary,
                          shape: BoxShape.circle,
                        ),
                        child: IconButton(
                          icon: const Icon(Icons.camera_alt, color: Colors.white, size: 20),
                          onPressed: _isUploadingAvatar ? null : _showAvatarOptions,
                          padding: const EdgeInsets.all(8),
                          constraints: const BoxConstraints(),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                Text(
                  email,
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                const SizedBox(height: 4),
                Text(
                  'ID: ${userId.substring(0, 8)}...',
                  style: Theme.of(context).textTheme.bodySmall,
                ),
              ],
            ),
          ),

          const SizedBox(height: 8),

          // Account Settings
          _buildSectionTitle('Account'),
          _buildSettingsTile(
            icon: Icons.person,
            title: 'Display Name',
            subtitle: email.split('@')[0],
            onTap: () => _showEditDisplayNameDialog(),
          ),
          _buildSettingsTile(
            icon: Icons.email,
            title: 'Email',
            subtitle: email,
            onTap: () {},
          ),
          _buildSettingsTile(
            icon: Icons.lock,
            title: 'Change Password',
            onTap: () => _showComingSoonDialog('Change Password'),
          ),

          const Divider(height: 1),

          // Notifications
          _buildSectionTitle('Notifications'),
          SwitchListTile(
            secondary: const Icon(Icons.notifications),
            title: const Text('Push Notifications'),
            subtitle: const Text('Receive message notifications'),
            value: _notificationsEnabled,
            onChanged: (value) {
              setState(() => _notificationsEnabled = value);
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(
                    value ? 'Notifications enabled' : 'Notifications disabled',
                  ),
                ),
              );
            },
          ),
          _buildSettingsTile(
            icon: Icons.volume_up,
            title: 'Notification Sound',
            subtitle: 'Default',
            onTap: () => _showComingSoonDialog('Notification Sounds'),
          ),

          const Divider(height: 1),

          // Privacy & Security
          _buildSectionTitle('Privacy & Security'),
          _buildSettingsTile(
            icon: Icons.shield,
            title: 'Blocked Users',
            onTap: () => _showComingSoonDialog('Blocked Users'),
          ),
          _buildSettingsTile(
            icon: Icons.visibility,
            title: 'Online Status',
            subtitle: 'Visible to everyone',
            onTap: () => _showComingSoonDialog('Online Status Settings'),
          ),
          _buildSettingsTile(
            icon: Icons.check_circle,
            title: 'Read Receipts',
            subtitle: 'Enabled',
            onTap: () => _showComingSoonDialog('Read Receipts Settings'),
          ),

          const Divider(height: 1),

          // Storage
          _buildSectionTitle('Storage'),
          _buildSettingsTile(
            icon: Icons.storage,
            title: 'Storage Usage',
            subtitle: 'Calculate storage...',
            onTap: () => _showComingSoonDialog('Storage Management'),
          ),
          _buildSettingsTile(
            icon: Icons.delete_sweep,
            title: 'Clear Cache',
            onTap: () => _showClearCacheDialog(),
          ),

          const Divider(height: 1),

          // About
          _buildSectionTitle('About'),
          _buildSettingsTile(
            icon: Icons.info,
            title: 'App Version',
            subtitle: '1.0.0 (MVP)',
            onTap: () {},
          ),
          _buildSettingsTile(
            icon: Icons.privacy_tip,
            title: 'Privacy Policy',
            onTap: () => _showComingSoonDialog('Privacy Policy'),
          ),
          _buildSettingsTile(
            icon: Icons.description,
            title: 'Terms of Service',
            onTap: () => _showComingSoonDialog('Terms of Service'),
          ),

          const SizedBox(height: 16),

          // Logout Button
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: ElevatedButton.icon(
              onPressed: _isLoading ? null : _handleLogout,
              icon: _isLoading
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Icon(Icons.logout),
              label: const Text('Log Out'),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.red,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(vertical: 16),
              ),
            ),
          ),

          const SizedBox(height: 32),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 24, 16, 8),
      child: Text(
        title.toUpperCase(),
        style: TextStyle(
          fontSize: 12,
          fontWeight: FontWeight.w600,
          color: Theme.of(context).colorScheme.primary,
        ),
      ),
    );
  }

  Widget _buildSettingsTile({
    required IconData icon,
    required String title,
    String? subtitle,
    VoidCallback? onTap,
  }) {
    return ListTile(
      leading: Icon(icon),
      title: Text(title),
      subtitle: subtitle != null ? Text(subtitle) : null,
      trailing: const Icon(Icons.chevron_right),
      onTap: onTap,
    );
  }

  /// Show avatar options (Gallery, Camera, Delete)
  void _showAvatarOptions() {
    showModalBottomSheet(
      context: context,
      builder: (BuildContext context) {
        return SafeArea(
          child: Wrap(
            children: [
              ListTile(
                leading: const Icon(Icons.photo_library),
                title: const Text('Choose from Gallery'),
                onTap: () {
                  Navigator.pop(context);
                  _uploadAvatarFromGallery();
                },
              ),
              ListTile(
                leading: const Icon(Icons.camera_alt),
                title: const Text('Take Photo'),
                onTap: () {
                  Navigator.pop(context);
                  _uploadAvatarFromCamera();
                },
              ),
              if (_avatarUrl != null)
                ListTile(
                  leading: const Icon(Icons.delete, color: Colors.red),
                  title: const Text('Remove Photo', style: TextStyle(color: Colors.red)),
                  onTap: () {
                    Navigator.pop(context);
                    _deleteAvatar();
                  },
                ),
              ListTile(
                leading: const Icon(Icons.cancel),
                title: const Text('Cancel'),
                onTap: () => Navigator.pop(context),
              ),
            ],
          ),
        );
      },
    );
  }

  /// Upload avatar from gallery
  Future<void> _uploadAvatarFromGallery() async {
    try {
      final image = await _avatarService.pickImage();
      if (image == null) return;

      await _uploadAvatar(image);
    } on AppError catch (error) {
      if (mounted) {
        showError(error);
      }
    }
  }

  /// Upload avatar from camera
  Future<void> _uploadAvatarFromCamera() async {
    try {
      final image = await _avatarService.pickImageFromCamera();
      if (image == null) return;

      await _uploadAvatar(image);
    } on AppError catch (error) {
      if (mounted) {
        showError(error);
      }
    }
  }

  /// Upload avatar to server
  Future<void> _uploadAvatar(image) async {
    if (mounted) {
      setState(() => _isUploadingAvatar = true);
    }

    try {
      final url = await _avatarService.uploadAvatar(image);

      if (mounted) {
        setState(() {
          _avatarUrl = url;
          _isUploadingAvatar = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 12),
                Text('Profile picture updated successfully'),
              ],
            ),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
      }
    } on AppError catch (error) {
      if (mounted) {
        setState(() => _isUploadingAvatar = false);
        showError(error);
      }
    }
  }

  /// Delete avatar
  Future<void> _deleteAvatar() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Remove Photo'),
        content: const Text('Are you sure you want to remove your profile picture?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('Remove'),
          ),
        ],
      ),
    );

    if (confirm != true) return;

    setState(() => _isUploadingAvatar = true);

    try {
      await _avatarService.deleteAvatar();

      if (mounted) {
        setState(() {
          _avatarUrl = null;
          _isUploadingAvatar = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Profile picture removed')),
        );
      }
    } on AppError catch (error) {
      if (mounted) {
        setState(() => _isUploadingAvatar = false);
        showError(error);
      }
    }
  }

  void _showEditDisplayNameDialog() {
    final controller = TextEditingController();
    final user = _supabase.auth.currentUser;
    controller.text = user?.email?.split('@')[0] ?? '';

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Edit Display Name'),
        content: TextField(
          controller: controller,
          decoration: const InputDecoration(
            labelText: 'Display Name',
            border: OutlineInputBorder(),
          ),
          autofocus: true,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Display name updated')),
              );
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  void _showComingSoonDialog(String feature) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Coming Soon'),
        content: Text('$feature will be available in a future update.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  void _showClearCacheDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Clear Cache'),
        content: const Text(
          'This will clear all cached images and files. Your messages will not be affected.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Cache cleared')),
              );
            },
            child: const Text('Clear'),
          ),
        ],
      ),
    );
  }

  Future<void> _handleLogout() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Log Out'),
        content: const Text('Are you sure you want to log out?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('Log Out'),
          ),
        ],
      ),
    );

    if (confirm == true && mounted) {
      setState(() => _isLoading = true);
      
      try {
        await _supabase.auth.signOut();
        
        if (mounted) {
          Navigator.of(context).pushAndRemoveUntil(
            MaterialPageRoute(
              builder: (context) => AuthScreen(onAuthSuccess: () {}),
            ),
            (route) => false,
          );
        }
      } catch (e) {
        if (mounted) {
          setState(() => _isLoading = false);
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error logging out: $e')),
          );
        }
      }
    }
  }
}
</file>

<file path="lib/firebase_options.dart">
// File generated by FlutterFire CLI.
// This is a placeholder file. To use Firebase, you need to:
// 1. Install FlutterFire CLI: dart pub global activate flutterfire_cli
// 2. Run: flutterfire configure
// 3. Follow the prompts to select your Firebase project
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import firebase_options.dart;
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyABa-DcxTR4T4CHlfJuy-7DKG1F_hDRNcg',
    appId: '1:397483513751:web:3121cbb846ddd8381c56d2',
    messagingSenderId: '397483513751',
    projectId: 'messageai-e2e9e',
    authDomain: 'messageai-e2e9e.firebaseapp.com',
    storageBucket: 'messageai-e2e9e.firebasestorage.app',
    measurementId: 'G-VCVQDFPTLV',
  );

  // Placeholder values - replace with your actual Firebase configuration

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyBBc-17a_EvWPvCutNSTEV9QEB2w2DUM_4',
    appId: '1:397483513751:android:bb838799a2cd3f7f1c56d2',
    messagingSenderId: '397483513751',
    projectId: 'messageai-e2e9e',
    storageBucket: 'messageai-e2e9e.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIza...',  // Replace with your iOS API key
    appId: '1:...',     // Replace with your iOS app ID
    messagingSenderId: '...',  // Replace with your sender ID
    projectId: 'your-project-id',  // Replace with your project ID
    storageBucket: 'your-project-id.appspot.com',
    iosBundleId: 'com.example.messageai',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIza...',  // Replace with your macOS API key
    appId: '1:...',     // Replace with your macOS app ID
    messagingSenderId: '...',  // Replace with your sender ID
    projectId: 'your-project-id',  // Replace with your project ID
    storageBucket: 'your-project-id.appspot.com',
    iosBundleId: 'com.example.messageai',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyABa-DcxTR4T4CHlfJuy-7DKG1F_hDRNcg',
    appId: '1:397483513751:web:ba73c764d577f4f51c56d2',
    messagingSenderId: '397483513751',
    projectId: 'messageai-e2e9e',
    authDomain: 'messageai-e2e9e.firebaseapp.com',
    storageBucket: 'messageai-e2e9e.firebasestorage.app',
    measurementId: 'G-C6R3PHYG95',
  );

}
</file>

<file path="lib/gen/api/api.dart">
// Generated API models and clients
export 'models/message_payload.dart';
export 'models/receipt_payload.dart';
export 'clients/messages_api.dart';
export 'clients/receipts_api.dart';
</file>

<file path="lib/gen/api/clients/messages_api.dart">
import 'package:dio/dio.dart';
import '../models/message_payload.dart';

/// API client for message operations
class MessagesApi {
  final Dio dio;
  final String baseUrl;

  MessagesApi({
    required this.dio,
    required this.baseUrl,
  });

  /// Send a message to the backend
  /// 
  /// [message] - The message payload to send
  /// 
  /// Returns the response from the server
  Future<Response> send(MessagePayload message) async {
    try {
      final response = await dio.post(
        '$baseUrl/v1/messages.send',
        data: message.toJson(),
      );
      return response;
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Exception _handleDioError(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.receiveTimeout:
      case DioExceptionType.sendTimeout:
        return Exception('Connection timeout: ${e.message}');
      case DioExceptionType.badResponse:
        return Exception(
          'Server error: ${e.response?.statusCode} - ${e.response?.data}',
        );
      case DioExceptionType.cancel:
        return Exception('Request cancelled');
      default:
        return Exception('Network error: ${e.message}');
    }
  }
}
</file>

<file path="lib/gen/api/clients/receipts_api.dart">
import 'package:dio/dio.dart';
import '../models/receipt_payload.dart';

/// API client for receipt operations
class ReceiptsApi {
  final Dio dio;
  final String baseUrl;

  ReceiptsApi({
    required this.dio,
    required this.baseUrl,
  });

  /// Acknowledge message receipts to the backend
  /// 
  /// [receipt] - The receipt payload to send
  /// 
  /// Returns the response from the server
  Future<Response> ack(ReceiptPayload receipt) async {
    try {
      final response = await dio.post(
        '$baseUrl/v1/receipts.ack',
        data: receipt.toJson(),
      );
      return response;
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Exception _handleDioError(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.receiveTimeout:
      case DioExceptionType.sendTimeout:
        return Exception('Connection timeout: ${e.message}');
      case DioExceptionType.badResponse:
        return Exception(
          'Server error: ${e.response?.statusCode} - ${e.response?.data}',
        );
      case DioExceptionType.cancel:
        return Exception('Request cancelled');
      default:
        return Exception('Network error: ${e.message}');
    }
  }
}
</file>

<file path="lib/gen/api/models/message_payload.dart">
class MessagePayload {
  final String id;
  final String conversationId;
  final String? body;

  MessagePayload({
    required this.id,
    required this.conversationId,
    this.body,
  });

  factory MessagePayload.fromJson(Map<String, dynamic> json) {
    return MessagePayload(
      id: json['id'] as String,
      conversationId: json['conversation_id'] as String,
      body: json['body'] as String?,
    );
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'conversation_id': conversationId,
        if (body != null) 'body': body,
      };

  @override
  String toString() =>
      'MessagePayload(id: $id, conversationId: $conversationId, body: $body)';
}
</file>

<file path="lib/gen/api/models/receipt_payload.dart">
enum ReceiptStatus {
  delivered,
  read;

  static ReceiptStatus fromString(String value) {
    return ReceiptStatus.values.firstWhere(
      (e) => e.name == value,
      orElse: () => throw ArgumentError('Unknown status: $value'),
    );
  }

  String toValue() => name;
}

class ReceiptPayload {
  final List<String> messageIds;
  final ReceiptStatus status;

  ReceiptPayload({
    required this.messageIds,
    required this.status,
  });

  factory ReceiptPayload.fromJson(Map<String, dynamic> json) {
    return ReceiptPayload(
      messageIds: List<String>.from(json['message_ids'] as List),
      status: ReceiptStatus.fromString(json['status'] as String),
    );
  }

  Map<String, dynamic> toJson() => {
        'message_ids': messageIds,
        'status': status.toValue(),
      };

  @override
  String toString() =>
      'ReceiptPayload(messageIds: $messageIds, status: ${status.name})';
}
</file>

<file path="lib/main.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:messageai/core/env.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/state/notification_providers.dart';
import 'package:messageai/services/network_connectivity_service.dart';
import 'package:messageai/services/offline_queue_service.dart';
import 'package:messageai/app.dart';
import 'firebase_options.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

/// Background message handler for Firebase Cloud Messaging
/// This MUST be a top-level function (not inside a class)
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // Initialize Firebase if not already done
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  
  print('🔔 Background message received!');
  print('   Title: ${message.notification?.title}');
  print('   Body: ${message.notification?.body}');
  print('   Data: ${message.data}');
  
  // Handle the background message here if needed
  // For now, just log it - the system notification will still appear
}

void main() async {
  // Ensure Flutter bindings are initialized
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase (required before any Firebase services)
  try {
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    print('✅ Firebase initialized successfully');
    
    // Register background message handler (must be done after Firebase init)
    FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
    print('✅ Background message handler registered');
  } catch (e) {
    print('❌ Firebase initialization error: $e');
    print('Push notifications will not work. Run "flutterfire configure" to set up Firebase.');
  }

  // Validate environment configuration
  Env.validate();

  // Initialize Supabase client
  await SupabaseClientProvider.initialize();

  // Initialize Drift database
  final db = AppDb.instance;
  
  // Initialize network services
  final connectivityService = NetworkConnectivityService();
  connectivityService.startMonitoring();
  
  final offlineQueueService = OfflineQueueService();
  offlineQueueService.startMonitoring();
  
  print('✅ Network services initialized');
  
  // Run the app with Riverpod provider scope
  runApp(
    ProviderScope(
      child: _AppWithNotifications(),
    ),
  );
}

/// Wrapper widget to initialize notifications after ProviderScope
class _AppWithNotifications extends ConsumerWidget {
  const _AppWithNotifications();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Initialize notifications on app start
    final notificationInit = ref.watch(notificationInitializerProvider);
    
    notificationInit.when(
      data: (_) {
        print('🔔 Notifications fully initialized!');
      },
      loading: () {
        print('🔄 Initializing notifications...');
      },
      error: (error, stack) {
        print('❌ Notification initialization error: $error');
        print('Stack trace: $stack');
      },
    );

    return const MessageAIApp();
  }
}
</file>

<file path="lib/models/ai_analysis.dart">
/// Simple AI Analysis model - no Drift dependency
/// Fetched directly from Supabase with in-memory session caching
class AIAnalysis {
  final String id;
  final String messageId;
  final String tone;
  final String? urgencyLevel;
  final String? intent;
  final double? confidenceScore;
  final int analysisTimestamp;
  
  const AIAnalysis({
    required this.id,
    required this.messageId,
    required this.tone,
    this.urgencyLevel,
    this.intent,
    this.confidenceScore,
    required this.analysisTimestamp,
  });
  
  /// Create from Supabase JSON response
  factory AIAnalysis.fromJson(Map<String, dynamic> json) {
    try {
      // Handle both direct table columns and RPC function results
      final id = json['id'] as String? ?? json['analysis_id'] as String?;
      final messageId = json['message_id'] as String?;
      final tone = json['tone'] as String?;
      
      if (id == null || messageId == null || tone == null) {
        throw FormatException(
          'Missing required fields in AI analysis JSON: '
          'id=$id, message_id=$messageId, tone=$tone. '
          'Full JSON: $json'
        );
      }
      
      return AIAnalysis(
        id: id,
        messageId: messageId,
        tone: tone,
        urgencyLevel: json['urgency_level'] as String?,
        intent: json['intent'] as String?,
        confidenceScore: (json['confidence_score'] as num?)?.toDouble(),
        analysisTimestamp: (json['analysis_timestamp'] as num?)?.toInt() ?? 
                           DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );
    } catch (e) {
      throw FormatException('Failed to parse AIAnalysis from JSON: $e\nJSON: $json');
    }
  }
  
  /// Convert to JSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'message_id': messageId,
      'tone': tone,
      'urgency_level': urgencyLevel,
      'intent': intent,
      'confidence_score': confidenceScore,
      'analysis_timestamp': analysisTimestamp,
    };
  }
  
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AIAnalysis &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          messageId == other.messageId;
  
  @override
  int get hashCode => id.hashCode ^ messageId.hashCode;
  
  @override
  String toString() {
    return 'AIAnalysis(id: $id, messageId: $messageId, tone: $tone, '
           'urgency: $urgencyLevel, intent: $intent, confidence: $confidenceScore)';
  }
}
</file>

<file path="lib/services/ai_analysis_service_cached.dart.backup">
import 'dart:async';
import 'dart:convert';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/ai_analysis_dao.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:uuid/uuid.dart';

/// Service for managing AI message analysis (tone, intent, urgency)
class AIAnalysisService {
  final _analysisDao = AppDb.instance.aiAnalysisDao;
  final _supabase = SupabaseClientProvider.client;
  final _uuid = const Uuid();

  // Debouncing: Track pending analysis requests to avoid duplicates
  final Map<String, Timer> _pendingRequests = {};
  final Duration _debounceDelay = const Duration(milliseconds: 500);

  /// Request AI analysis for a message
  /// Debounces requests to avoid spamming the API
  Future<AiAnalysi?> requestAnalysis(
    String messageId,
    String messageBody, {
    List<String>? conversationContext,
    bool forceRefresh = false,
  }) async {
    // Cancel any pending request for this message
    _pendingRequests[messageId]?.cancel();

    // Check if we already have cached analysis
    if (!forceRefresh) {
      final cached = await _analysisDao.getAnalysisByMessageId(messageId);
      if (cached != null) {
        print('📊 Using cached analysis for message ${messageId.substring(0, 8)}');
        return cached;
      }
    }

    // Create a debounced request
    final completer = Completer<AiAnalysi?>();
    
    _pendingRequests[messageId] = Timer(_debounceDelay, () async {
      try {
        print('🤖 Requesting AI analysis for message ${messageId.substring(0, 8)}...');
        
        final analysis = await _callAnalysisAPI(
          messageId,
          messageBody,
          conversationContext,
        );
        
        if (!completer.isCompleted) {
          completer.complete(analysis);
        }
      } catch (e) {
        print('❌ Analysis request failed: $e');
        if (!completer.isCompleted) {
          completer.completeError(e);
        }
      } finally {
        _pendingRequests.remove(messageId);
      }
    });

    return completer.future;
  }

  /// Call the AI analysis Edge Function
  Future<AiAnalysi> _callAnalysisAPI(
    String messageId,
    String messageBody,
    List<String>? conversationContext,
  ) async {
    try {
      final response = await _supabase.functions.invoke(
        'ai_analyze_tone',
        body: {
          'message_id': messageId,
          'message_body': messageBody,
          if (conversationContext != null)
            'conversation_context': conversationContext,
        },
      );

      if (response.status != 200) {
        throw Exception('API returned status ${response.status}');
      }

      final data = response.data;
      if (data == null || !data['success']) {
        throw Exception(data?['error'] ?? 'Unknown error');
      }

      final analysisData = data['analysis'];
      
      // Store in local database
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final analysis = AiAnalysisCompanion.insert(
        id: analysisData['id'] as String,
        messageId: messageId,
        tone: analysisData['tone'] as String,
        urgencyLevel: Value(analysisData['urgency_level'] as String?),
        intent: Value(analysisData['intent'] as String?),
        confidenceScore: Value(
          (analysisData['confidence_score'] as num?)?.toDouble(),
        ),
        analysisTimestamp: analysisData['analysis_timestamp'] as int? ?? now,
        isSynced: const Value(true),
        createdAt: now,
        updatedAt: now,
      );

      await _analysisDao.upsertAnalysis(analysis);
      
      print('✅ Analysis complete: ${analysisData['tone']} (${analysisData['urgency_level']})');
      
      // Return the stored analysis
      return (await _analysisDao.getAnalysisByMessageId(messageId))!;
    } catch (e) {
      print('❌ Failed to call analysis API: $e');
      rethrow;
    }
  }

  /// Get analysis for a specific message
  Future<AiAnalysi?> getAnalysis(String messageId) async {
    return _analysisDao.getAnalysisByMessageId(messageId);
  }

  /// Get analyses for multiple messages
  Future<Map<String, AiAnalysi>> getAnalysesForMessages(
    List<String> messageIds,
  ) async {
    final analyses = await _analysisDao.getAnalysesByMessageIds(messageIds);
    return Map.fromEntries(
      analyses.map((a) => MapEntry(a.messageId, a)),
    );
  }

  /// Get analyses for a conversation
  Future<Map<String, AiAnalysi>> getConversationAnalysis(
    String conversationId,
    List<String> messageIds,
  ) async {
    final analyses = await _analysisDao.getAnalysesForConversation(messageIds);
    return Map.fromEntries(
      analyses.map((a) => MapEntry(a.messageId, a)),
    );
  }

  /// Sync analysis from backend for a message
  Future<AiAnalysi?> syncAnalysisFromBackend(String messageId) async {
    try {
      print('🔄 Syncing analysis for message ${messageId.substring(0, 8)} from backend...');
      
      final response = await _supabase.rpc(
        'get_message_ai_analysis',
        params: {'p_message_id': messageId},
      );

      if (response == null || (response as List).isEmpty) {
        print('ℹ️ No analysis found on backend');
        return null;
      }

      final data = (response as List).first;
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      
      final analysis = AiAnalysisCompanion.insert(
        id: data['id'] as String,
        messageId: messageId,
        tone: data['tone'] as String,
        urgencyLevel: Value(data['urgency_level'] as String?),
        intent: Value(data['intent'] as String?),
        confidenceScore: Value((data['confidence_score'] as num?)?.toDouble()),
        analysisTimestamp: data['analysis_timestamp'] as int? ?? now,
        isSynced: const Value(true),
        createdAt: now,
        updatedAt: now,
      );

      await _analysisDao.upsertAnalysis(analysis);
      
      return _analysisDao.getAnalysisByMessageId(messageId);
    } catch (e) {
      print('❌ Failed to sync analysis from backend: $e');
      return null;
    }
  }

  /// Sync analyses for a conversation from backend
  Future<void> syncConversationAnalysesFromBackend(
    String conversationId,
  ) async {
    try {
      print('🔄 Syncing analyses for conversation ${conversationId.substring(0, 8)}...');
      
      final response = await _supabase.rpc(
        'get_conversation_ai_analysis',
        params: {'p_conversation_id': conversationId},
      );

      if (response == null || (response as List).isEmpty) {
        print('ℹ️ No analyses found on backend');
        return;
      }

      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final analyses = (response as List).cast<Map<String, dynamic>>();
      
      for (final data in analyses) {
        final analysis = AiAnalysisCompanion.insert(
          id: _uuid.v4(),
          messageId: data['message_id'] as String,
          tone: data['tone'] as String,
          urgencyLevel: Value(data['urgency_level'] as String?),
          intent: Value(data['intent'] as String?),
          confidenceScore: Value((data['confidence_score'] as num?)?.toDouble()),
          analysisTimestamp: data['analysis_timestamp'] as int? ?? now,
          isSynced: const Value(true),
          createdAt: now,
          updatedAt: now,
        );

        await _analysisDao.upsertAnalysis(analysis);
      }
      
      print('✅ Synced ${analyses.length} analyses from backend');
    } catch (e) {
      print('❌ Failed to sync conversation analyses: $e');
    }
  }

  /// Delete analysis for a message
  Future<void> deleteAnalysis(String messageId) async {
    await _analysisDao.deleteAnalysisByMessageId(messageId);
  }

  /// Clear old analyses (older than N days)
  Future<void> cleanupOldAnalyses({int days = 30}) async {
    final deleted = await _analysisDao.deleteOldAnalyses(days: days);
    print('🧹 Cleaned up $deleted old analyses');
  }

  /// Get analysis statistics
  Future<Map<String, dynamic>> getAnalysisStats() async {
    final count = await _analysisDao.getAnalysisCount();
    final byTone = await _analysisDao.getAnalysisCountByTone();
    
    return {
      'total_count': count,
      'by_tone': byTone,
    };
  }

  /// Stream analysis for a message
  Stream<AiAnalysi?> watchAnalysis(String messageId) {
    return _analysisDao.watchAnalysisForMessage(messageId);
  }

  /// Cancel pending analysis request
  void cancelPendingRequest(String messageId) {
    _pendingRequests[messageId]?.cancel();
    _pendingRequests.remove(messageId);
  }

  /// Cancel all pending requests
  void cancelAllPendingRequests() {
    for (final timer in _pendingRequests.values) {
      timer.cancel();
    }
    _pendingRequests.clear();
  }

  /// Dispose resources
  void dispose() {
    cancelAllPendingRequests();
  }
}
</file>

<file path="lib/services/ai_analysis_service.dart">
import 'dart:async';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Simple AI Analysis Service - Supabase only, no local persistence
/// Uses in-memory cache for current session to reduce API calls
class AIAnalysisService {
  final _supabase = SupabaseClientProvider.client;
  
  /// In-memory cache (cleared on app restart)
  final Map<String, AIAnalysis> _sessionCache = {};
  
  /// Pending requests to avoid duplicate API calls
  final Map<String, Future<AIAnalysis?>> _pendingRequests = {};
  
  /// Request AI analysis for a message
  /// Returns cached result if available, otherwise calls Edge Function
  Future<AIAnalysis?> requestAnalysis(
    String messageId,
    String messageBody, {
    List<String>? conversationContext,
  }) async {
    // Check session cache first
    if (_sessionCache.containsKey(messageId)) {
      print('📊 Using cached analysis for $messageId');
      return _sessionCache[messageId];
    }
    
    // Check if request is already in progress
    if (_pendingRequests.containsKey(messageId)) {
      print('⏳ Analysis already in progress for $messageId');
      return _pendingRequests[messageId];
    }
    
    // Make new request
    print('🤖 Requesting new analysis for $messageId');
    final future = _callAnalysisAPI(messageId, messageBody, conversationContext);
    _pendingRequests[messageId] = future;
    
    try {
      final result = await future;
      if (result != null) {
        _sessionCache[messageId] = result;
      }
      return result;
    } finally {
      _pendingRequests.remove(messageId);
    }
  }
  
  /// Call the Edge Function to analyze a message
  Future<AIAnalysis?> _callAnalysisAPI(
    String messageId,
    String messageBody,
    List<String>? conversationContext,
  ) async {
    try {
      final response = await _supabase.functions.invoke(
        'ai_analyze_tone',
        body: {
          'message_id': messageId,
          'message_body': messageBody,
          if (conversationContext != null)
            'conversation_context': conversationContext,
        },
      );
      
      if (response.status != 200) {
        throw Exception('API returned status ${response.status}');
      }
      
      final data = response.data;
      if (data == null || !data['success']) {
        throw Exception(data?['error'] ?? 'Unknown error');
      }
      
      return AIAnalysis.fromJson(data['analysis']);
    } catch (e) {
      print('❌ Analysis request failed: $e');
      return null;
    }
  }
  
  /// Fetch existing analysis from Supabase
  Future<AIAnalysis?> getAnalysis(String messageId) async {
    // Check cache
    if (_sessionCache.containsKey(messageId)) {
      return _sessionCache[messageId];
    }
    
    try {
      final response = await _supabase.rpc(
        'get_message_ai_analysis',
        params: {'p_message_id': messageId},
      );
      
      if (response == null || (response as List).isEmpty) {
        return null;
      }
      
      final analysis = AIAnalysis.fromJson(response[0]);
      _sessionCache[messageId] = analysis;
      return analysis;
    } catch (e) {
      print('❌ Failed to fetch analysis: $e');
      return null;
    }
  }
  
  /// Fetch all analyses for a conversation
  Future<Map<String, AIAnalysis>> getConversationAnalyses(
    String conversationId,
  ) async {
    try {
      final response = await _supabase.rpc(
        'get_conversation_ai_analysis',
        params: {'p_conversation_id': conversationId},
      );
      
      if (response == null || (response as List).isEmpty) {
        return {};
      }
      
      final Map<String, AIAnalysis> analyses = {};
      for (final item in response) {
        final analysis = AIAnalysis.fromJson(item);
        analyses[analysis.messageId] = analysis;
        _sessionCache[analysis.messageId] = analysis; // Cache it
      }
      
      return analyses;
    } catch (e) {
      print('❌ Failed to fetch conversation analyses: $e');
      return {};
    }
  }
  
  /// Clear the session cache
  void clearCache() {
    _sessionCache.clear();
    print('🧹 Analysis cache cleared');
  }
  
  /// Get cache statistics
  Map<String, dynamic> getCacheStats() {
    return {
      'cached_count': _sessionCache.length,
      'pending_count': _pendingRequests.length,
    };
  }
}
</file>

<file path="lib/services/auth_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/services/device_registration_service.dart';
import 'package:messageai/services/notification_service.dart';
import 'package:messageai/core/errors/error_handler.dart';

class AuthService {
  static final AuthService _instance = AuthService._internal();

  factory AuthService() {
    return _instance;
  }

  AuthService._internal();

  final _supabase = SupabaseClientProvider.client;
  final _deviceRegistrationService = DeviceRegistrationService();
  final _notificationService = NotificationService();
  final _errorHandler = ErrorHandler();

  /// Sign up with email and password
  Future<AuthResponse> signUp({
    required String email,
    required String password,
  }) async {
    try {
      print('📝 Attempting sign up for: $email');
      
      final response = await _supabase.auth.signUp(
        email: email,
        password: password,
      );
      
      print('✅ Sign up successful: ${response.user?.id}');
      return response;
    } catch (error, stackTrace) {
      print('❌ Sign up failed: $error');
      throw _errorHandler.handleError(error, stackTrace: stackTrace, context: 'Sign Up');
    }
  }

  /// Sign in with email and password
  Future<AuthResponse> signIn({
    required String email,
    required String password,
  }) async {
    try {
      print('🔐 Attempting sign in for: $email');
      
      final response = await _supabase.auth.signInWithPassword(
        email: email,
        password: password,
      );
      
      print('✅ Sign in successful: ${response.user?.id}');
      return response;
    } catch (error, stackTrace) {
      print('❌ Sign in failed: $error');
      throw _errorHandler.handleError(error, stackTrace: stackTrace, context: 'Sign In');
    }
  }

  /// Sign out
  Future<void> signOut() async {
    try {
      print('👋 Attempting sign out');
      
      // Unregister device token before signing out
      final token = await _notificationService.getDeviceToken();
      if (token != null) {
        try {
          await _deviceRegistrationService.unregisterDeviceToken(token);
          print('✅ Device token unregistered on sign out');
        } catch (e) {
          print('⚠️  Failed to unregister device token: $e');
          // Continue with sign out even if unregistration fails
        }
      }
      
      await _supabase.auth.signOut();
      print('✅ Sign out successful');
    } catch (error, stackTrace) {
      print('❌ Sign out failed: $error');
      throw _errorHandler.handleError(error, stackTrace: stackTrace, context: 'Sign Out');
    }
  }

  /// Get current user
  User? getCurrentUser() {
    return _supabase.auth.currentUser;
  }

  /// Check if user is authenticated
  bool isAuthenticated() {
    return _supabase.auth.currentUser != null;
  }

  /// Get current session
  Session? getCurrentSession() {
    return _supabase.auth.currentSession;
  }
}
</file>

<file path="lib/services/avatar_service.dart">
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:image_picker/image_picker.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_handler.dart';

/// Service for handling avatar uploads and management
class AvatarService {
  static final AvatarService _instance = AvatarService._internal();

  factory AvatarService() {
    return _instance;
  }

  AvatarService._internal();

  final _supabase = SupabaseClientProvider.client;
  final _errorHandler = ErrorHandler();
  final _imagePicker = ImagePicker();

  /// Pick an image from gallery
  Future<XFile?> pickImage() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 512,
        maxHeight: 512,
        imageQuality: 85,
      );
      return image;
    } catch (error, stackTrace) {
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Pick Image',
      );
    }
  }

  /// Pick an image from camera
  Future<XFile?> pickImageFromCamera() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.camera,
        maxWidth: 512,
        maxHeight: 512,
        imageQuality: 85,
      );
      return image;
    } catch (error, stackTrace) {
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Take Photo',
      );
    }
  }

  /// Upload avatar to Supabase Storage and update profile
  Future<String> uploadAvatar(XFile imageFile) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      print('📤 Uploading avatar for user: ${currentUser.id}');

      // Generate unique filename
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final extension = imageFile.path.split('.').last;
      final fileName = '${currentUser.id}/avatar_$timestamp.$extension';

      // Read file bytes
      final Uint8List fileBytes;
      if (kIsWeb) {
        fileBytes = await imageFile.readAsBytes();
      } else {
        fileBytes = await File(imageFile.path).readAsBytes();
      }

      print('📁 File size: ${fileBytes.length} bytes');
      print('📁 File name: $fileName');

      // Delete old avatar if exists
      await _deleteOldAvatar(currentUser.id);

      // Upload to Supabase Storage
      final uploadPath = await _supabase.storage
          .from('avatars')
          .uploadBinary(fileName, fileBytes);

      print('✅ Avatar uploaded: $uploadPath');

      // Get public URL
      final publicUrl = _supabase.storage
          .from('avatars')
          .getPublicUrl(fileName);

      print('🔗 Public URL: $publicUrl');

      // Update profile with new avatar URL
      await _updateProfileAvatar(currentUser.id, publicUrl);

      return publicUrl;
    } catch (error, stackTrace) {
      print('❌ Error uploading avatar: $error');
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Upload Avatar',
      );
    }
  }

  /// Delete old avatar files for a user
  Future<void> _deleteOldAvatar(String userId) async {
    try {
      // List all files in user's folder
      final files = await _supabase.storage
          .from('avatars')
          .list(path: userId);

      // Delete each file
      for (final file in files) {
        final filePath = '$userId/${file.name}';
        await _supabase.storage
            .from('avatars')
            .remove([filePath]);
        print('🗑️  Deleted old avatar: $filePath');
      }
    } catch (e) {
      print('⚠️  Error deleting old avatar (non-critical): $e');
      // Don't throw - old avatar deletion is non-critical
    }
  }

  /// Update profile table with new avatar URL
  Future<void> _updateProfileAvatar(String userId, String avatarUrl) async {
    try {
      await _supabase
          .from('profiles')
          .update({'avatar_url': avatarUrl, 'updated_at': DateTime.now().toIso8601String()})
          .eq('user_id', userId);

      print('✅ Profile updated with new avatar URL');
    } catch (error, stackTrace) {
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Update Profile Avatar',
      );
    }
  }

  /// Get avatar URL for a user
  Future<String?> getAvatarUrl(String userId) async {
    try {
      final response = await _supabase
          .from('profiles')
          .select('avatar_url')
          .eq('user_id', userId)
          .maybeSingle();

      if (response != null && response['avatar_url'] != null) {
        return response['avatar_url'] as String;
      }
      return null;
    } catch (error, stackTrace) {
      print('⚠️  Error fetching avatar URL: $error');
      // Return null instead of throwing - missing avatar is not critical
      return null;
    }
  }

  /// Delete avatar for current user
  Future<void> deleteAvatar() async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      print('🗑️  Deleting avatar for user: ${currentUser.id}');

      // Delete from storage
      await _deleteOldAvatar(currentUser.id);

      // Update profile to remove avatar URL
      await _supabase
          .from('profiles')
          .update({'avatar_url': null, 'updated_at': DateTime.now().toIso8601String()})
          .eq('user_id', currentUser.id);

      print('✅ Avatar deleted successfully');
    } catch (error, stackTrace) {
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Delete Avatar',
      );
    }
  }

  /// Get current user's avatar URL
  Future<String?> getCurrentUserAvatar() async {
    final currentUser = _supabase.auth.currentUser;
    if (currentUser == null) {
      return null;
    }
    return getAvatarUrl(currentUser.id);
  }
}
</file>

<file path="lib/services/conversation_service.dart">
import 'package:uuid/uuid.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';

class ConversationService {
  static final ConversationService _instance =
      ConversationService._internal();

  factory ConversationService() {
    return _instance;
  }

  ConversationService._internal();

  final _db = AppDb.instance;
  final _supabase = SupabaseClientProvider.client;

  /// Create a new conversation
  Future<Conversation> createConversation({
    required String title,
    String? description,
    bool isGroup = false,
  }) async {
    final currentUser = _supabase.auth.currentUser;
    if (currentUser == null) {
      throw 'User not authenticated';
    }

    final now = DateTime.now();
    final timestamp = now.millisecondsSinceEpoch ~/ 1000;
    final conversationId = const Uuid().v4();
    
    final conversation = Conversation(
      id: conversationId,
      title: title,
      description: description,
      createdAt: timestamp,
      updatedAt: timestamp,
      isGroup: isGroup,
      lastMessageAt: timestamp,
      isSynced: false,
    );

    // Save to local database first (optimistic UI)
    await _db.conversationDao.upsertConversation(conversation);

    // Sync to backend
    try {
      // Create conversation in backend
      await _supabase.from('conversations').insert({
        'id': conversationId,
        'title': title,
        'description': description,
        'is_group': isGroup,
        'created_by': currentUser.id,
        'created_at': DateTime.fromMillisecondsSinceEpoch(timestamp * 1000).toIso8601String(),
        'updated_at': DateTime.fromMillisecondsSinceEpoch(timestamp * 1000).toIso8601String(),
      });

      // Add current user as participant
      final participantId = const Uuid().v4();
      await _supabase.from('conversation_participants').insert({
        'id': participantId,
        'conversation_id': conversationId,
        'user_id': currentUser.id,
        'joined_at': DateTime.fromMillisecondsSinceEpoch(timestamp * 1000).toIso8601String(),
      });

      // Save participant locally
      await _db.participantDao.addParticipant(Participant(
        id: participantId,
        conversationId: conversationId,
        userId: currentUser.id,
        joinedAt: timestamp,
        isAdmin: true,
        isSynced: true,
      ));

      // Mark conversation as synced
      await _db.conversationDao.markConversationAsSynced(conversationId);
      
      print('Conversation synced to backend: $conversationId');
    } catch (e) {
      print('Error syncing conversation to backend: $e');
      // Conversation stays in local DB with isSynced=false for retry later
    }

    return conversation;
  }

  /// Sync conversations from backend
  Future<void> syncConversations() async {
    try {
      print('🔄 Syncing conversations from backend...');
      
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        print('❌ User not authenticated, skipping sync');
        return;
      }

      // Fetch conversations where user is a participant
      final response = await _supabase
          .from('conversation_participants')
          .select('conversation_id')
          .eq('user_id', currentUser.id);

      final conversationIds = (response as List)
          .map((p) => p['conversation_id'] as String)
          .toList();

      if (conversationIds.isEmpty) {
        print('ℹ️  No conversations found for user');
        return;
      }

      // Fetch full conversation details
      final conversationsResponse = await _supabase
          .from('conversations')
          .select('*')
          .in_('id', conversationIds);

      print('📥 Fetched ${(conversationsResponse as List).length} conversations from backend');

      // Save to local database
      for (final convData in conversationsResponse) {
        final conversation = Conversation(
          id: convData['id'] as String,
          title: convData['title'] as String,
          description: convData['description'] as String?,
          createdAt: DateTime.parse(convData['created_at'] as String)
              .millisecondsSinceEpoch ~/
              1000,
          updatedAt: DateTime.parse(convData['updated_at'] as String)
              .millisecondsSinceEpoch ~/
              1000,
          isGroup: convData['is_group'] as bool? ?? false,
          lastMessageAt: convData['last_message_at'] != null
              ? DateTime.parse(convData['last_message_at'] as String)
                  .millisecondsSinceEpoch ~/
                  1000
              : DateTime.parse(convData['created_at'] as String)
                  .millisecondsSinceEpoch ~/
                  1000,
          isSynced: true,
        );

        await _db.conversationDao.upsertConversation(conversation);
      }

      print('✅ Conversations synced successfully');
    } catch (e) {
      print('❌ Error syncing conversations: $e');
    }
  }

  /// Get all conversations (with optional sync)
  Future<List<Conversation>> getAllConversations({bool syncFirst = true}) async {
    if (syncFirst) {
      await syncConversations();
    }
    return _db.conversationDao.getAllConversations();
  }

  /// Get recent conversations
  Future<List<Conversation>> getRecentConversations({int limit = 20}) async {
    return _db.conversationDao.getRecentConversations(limit: limit);
  }

  /// Get conversation by ID
  Future<Conversation?> getConversationById(String id) async {
    return _db.conversationDao.getConversationById(id);
  }

  /// Delete conversation (local and remote)
  Future<void> deleteConversation(String id) async {
    final currentUser = _supabase.auth.currentUser;
    print('━' * 60);
    print('🗑️ DELETING CONVERSATION');
    print('━' * 60);
    print('Conversation ID: $id');
    print('User ID: ${currentUser?.id}');
    
    // Delete from local database first
    await _db.conversationDao.deleteConversation(id);
    print('✅ Deleted from local database');
    
    // Try to delete from Supabase
    try {
      print('Attempting to delete from Supabase...');
      
      // Delete from Supabase (CASCADE will delete participants and messages)
      await _supabase
          .from('conversations')
          .delete()
          .eq('id', id);
      
      print('✅ Conversation deleted from backend: $id');
      print('━' * 60);
    } catch (e) {
      print('━' * 60);
      print('❌ ERROR DELETING FROM BACKEND');
      print('━' * 60);
      print('Error: $e');
      print('Error Type: ${e.runtimeType}');
      
      if (e.toString().contains('row-level security')) {
        print('🔒 RLS POLICY BLOCKING DELETE!');
        print('Solution: Run the SQL in FIX_DELETE_CONVERSATION.md');
      }
      
      print('━' * 60);
      // Already deleted locally, so this is non-critical
      // But we should rethrow so the UI can show the error
      rethrow;
    }
  }

  /// Update conversation title
  Future<void> updateConversationTitle(String id, String title) async {
    final conv = await getConversationById(id);
    if (conv != null) {
      final updated = conv.copyWith(
        title: title,
        updatedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );
      await _db.conversationDao.upsertConversation(updated);
    }
  }

  /// Count conversations
  Future<int> getConversationCount() async {
    return _db.conversationDao.getConversationCount();
  }

  /// Sync participants from backend
  Future<void> syncParticipants(String conversationId) async {
    try {
      print('🔄 Syncing participants for conversation: $conversationId');
      
      // Fetch participants from backend
      final response = await _supabase
          .from('conversation_participants')
          .select('*')
          .eq('conversation_id', conversationId);

      print('📥 Fetched ${(response as List).length} participants from backend');

      // Save participants to local database
      for (final partData in response) {
        final participant = Participant(
          id: partData['id'] as String,
          conversationId: partData['conversation_id'] as String,
          userId: partData['user_id'] as String,
          joinedAt: DateTime.parse(partData['joined_at'] as String)
              .millisecondsSinceEpoch ~/
              1000,
          isAdmin: partData['is_admin'] as bool? ?? false,
          isSynced: true,
        );
        
        await _db.participantDao.addParticipant(participant);
      }

      print('✅ Participants synced successfully');
    } catch (e) {
      print('❌ Error syncing participants: $e');
    }
  }

  /// Get participants in a conversation
  Future<List<Participant>> getParticipants(String conversationId, {bool syncFirst = true}) async {
    if (syncFirst) {
      await syncParticipants(conversationId);
    }
    return _db.participantDao.getParticipantsByConversation(conversationId);
  }
  
  /// Get participant profile from Supabase by user ID
  Future<Map<String, dynamic>?> getParticipantProfile(String userId) async {
    try {
      final response = await _supabase
          .from('profiles')
          .select('user_id, username, email, avatar_url, display_name')
          .eq('user_id', userId)
          .single();
      
      return response as Map<String, dynamic>;
    } catch (e) {
      print('Error fetching profile for $userId: $e');
      return null;
    }
  }

  /// Add participant to conversation
  Future<void> addParticipant({
    required String conversationId,
    required String userId,
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final participantId = const Uuid().v4();
    
    final participant = Participant(
      id: participantId,
      conversationId: conversationId,
      userId: userId,
      joinedAt: now,
      isAdmin: false,
      isSynced: false,
    );
    
    // Save to local database first (optimistic UI)
    await _db.participantDao.addParticipant(participant);
    
    // Sync to backend
    try {
      await _supabase.from('conversation_participants').insert({
        'id': participantId,
        'conversation_id': conversationId,
        'user_id': userId,
        'joined_at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
      });
      
      print('Participant added to backend: $userId');
    } catch (e) {
      print('Error syncing participant to backend: $e');
    }
  }

  /// Remove participant from conversation
  Future<void> removeParticipant(String conversationId, String userId) async {
    await _db.participantDao.removeParticipant(conversationId, userId);
  }

  /// Add current user as participant to conversation
  Future<void> addCurrentUserAsParticipant(String conversationId) async {
    // This would typically be called after creating a conversation
    // For now, we'll add the creator automatically in createConversation
  }

  /// Get the latest message for a conversation
  Future<Message?> getLatestMessage(String conversationId) async {
    return _db.messageDao.getLatestMessageForConversation(conversationId);
  }
}
</file>

<file path="lib/services/deep_link_handler.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Handles deep linking and navigation from notifications
class DeepLinkHandler {
  final WidgetRef ref;
  final NavigatorState? navigatorState;

  DeepLinkHandler({
    required this.ref,
    this.navigatorState,
  });

  /// Handle notification tap - navigate to conversation
  Future<void> handleNotificationTap(String conversationId) async {
    try {
      // Navigate to conversation detail screen
      navigatorState?.pushNamed(
        '/conversation/$conversationId',
      );
      print('Navigated to conversation: $conversationId');
    } catch (e) {
      print('Error handling notification tap: $e');
    }
  }

  /// Handle initial message (app terminated)
  Future<void> handleInitialMessage(String conversationId) async {
    try {
      // Wait for app to fully initialize
      await Future.delayed(const Duration(milliseconds: 500));
      
      // Navigate to conversation
      navigatorState?.pushNamedAndRemoveUntil(
        '/conversation/$conversationId',
        ModalRoute.withName('/conversations'),
      );
      print('Navigated from initial message to: $conversationId');
    } catch (e) {
      print('Error handling initial message: $e');
    }
  }

  /// Handle background message (app in background)
  Future<void> handleBackgroundMessage(String conversationId) async {
    try {
      // Just navigate normally
      navigatorState?.pushNamed('/conversation/$conversationId');
      print('Navigated from background message to: $conversationId');
    } catch (e) {
      print('Error handling background message: $e');
    }
  }

  /// Parse notification payload to extract conversation ID
  String? extractConversationId(Map<String, dynamic> data) {
    return data['conversation_id'] as String?;
  }

  /// Parse notification payload to extract message metadata
  Map<String, dynamic> extractMessageMetadata(Map<String, dynamic> data) {
    return {
      'conversation_id': data['conversation_id'],
      'sender_id': data['sender_id'],
      'message_id': data['message_id'],
      'sender_name': data['sender_name'],
    };
  }
}

/// Notification route arguments
class NotificationRouteArgs {
  final String conversationId;
  final String? senderId;
  final String? messageId;
  final String? senderName;

  NotificationRouteArgs({
    required this.conversationId,
    this.senderId,
    this.messageId,
    this.senderName,
  });

  factory NotificationRouteArgs.fromPayload(Map<String, dynamic> payload) {
    return NotificationRouteArgs(
      conversationId: payload['conversation_id'] as String,
      senderId: payload['sender_id'] as String?,
      messageId: payload['message_id'] as String?,
      senderName: payload['sender_name'] as String?,
    );
  }
}

/// Generate named route for conversation
String conversationRoute(String conversationId) => '/conversation/$conversationId';

/// Parse conversation ID from route
String? parseConversationIdFromRoute(String route) {
  if (route.startsWith('/conversation/')) {
    return route.replaceFirst('/conversation/', '');
  }
  return null;
}
</file>

<file path="lib/services/device_registration_service.dart">
import 'dart:io' show Platform;
import 'package:messageai/data/remote/supabase_client.dart';

/// Service for registering and managing device tokens with the backend
class DeviceRegistrationService {
  /// Register or update device token in Supabase
  Future<void> registerDeviceToken(String token) async {
    try {
      final supabase = SupabaseClientProvider.client;
      final userId = supabase.auth.currentUser?.id;
      
      if (userId == null) {
        print('⚠️ Cannot register device: user not authenticated');
        throw Exception('User not authenticated');
      }
      
      // Determine platform
      String platform;
      if (Platform.isIOS) {
        platform = 'ios';
      } else if (Platform.isAndroid) {
        platform = 'android';
      } else {
        platform = 'web';
      }
      
      print('📱 Registering device token...');
      print('   User ID: $userId');
      print('   Platform: $platform');
      print('   Token: ${token.substring(0, 20)}...');
      
      // Upsert device (insert or update if token already exists)
      // This handles both new registrations and token refreshes
      await supabase.from('profile_devices').upsert({
        'user_id': userId,
        'fcm_token': token,
        'platform': platform,
        'last_seen': DateTime.now().toIso8601String(),
      }, onConflict: 'fcm_token');
      
      print('✅ Device token registered successfully!');
    } catch (e) {
      print('❌ Failed to register device token: $e');
      rethrow;
    }
  }
  
  /// Unregister device token (e.g., on logout)
  Future<void> unregisterDeviceToken(String token) async {
    try {
      final supabase = SupabaseClientProvider.client;
      
      print('🗑️ Unregistering device token...');
      
      await supabase
          .from('profile_devices')
          .delete()
          .eq('fcm_token', token);
      
      print('✅ Device token unregistered');
    } catch (e) {
      print('❌ Failed to unregister device token: $e');
      rethrow;
    }
  }
  
  /// Update last seen timestamp for device
  Future<void> updateDeviceLastSeen(String token) async {
    try {
      final supabase = SupabaseClientProvider.client;
      
      print('🔄 Updating last_seen for token: ${token.substring(0, 20)}...');
      
      final response = await supabase
          .from('profile_devices')
          .update({
            'last_seen': DateTime.now().toIso8601String(),
          })
          .eq('fcm_token', token)
          .select();
      
      if (response.isEmpty) {
        print('⚠️ No device found with that token - device may not be registered');
      } else {
        print('✅ Device last_seen updated successfully');
      }
    } catch (e) {
      print('❌ Failed to update device last_seen: $e');
      // Don't rethrow - this is not critical
    }
  }
}
</file>

<file path="lib/services/local_notification_service.dart">
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter/material.dart';

/// Local notification service for displaying notifications in foreground
class LocalNotificationService {
  static const String _channelId = 'messages';
  static const String _channelName = 'Message Notifications';
  
  final FlutterLocalNotificationsPlugin _plugin;

  LocalNotificationService({FlutterLocalNotificationsPlugin? plugin})
      : _plugin = plugin ?? FlutterLocalNotificationsPlugin();

  /// Initialize local notifications
  Future<void> initialize() async {
    try {
      // Android initialization
      const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');

      // iOS initialization
      const iosSettings = DarwinInitializationSettings(
        requestAlertPermission: true,
        requestBadgePermission: true,
        requestSoundPermission: true,
      );

      const settings = InitializationSettings(
        android: androidSettings,
        iOS: iosSettings,
      );

      await _plugin.initialize(settings);
      print('Local notifications initialized');
    } catch (e) {
      print('Error initializing local notifications: $e');
    }
  }

  /// Show a notification
  Future<void> showNotification({
    required int id,
    required String title,
    required String body,
    String? payload,
  }) async {
    try {
      // Android notification details
      const androidDetails = AndroidNotificationDetails(
        _channelId,
        _channelName,
        channelDescription: 'Notifications for incoming messages',
        importance: Importance.max,
        priority: Priority.high,
        showWhen: true,
        enableVibration: true,
        playSound: true,
        icon: '@mipmap/ic_launcher',
      );

      // iOS notification details
      const iosDetails = DarwinNotificationDetails(
        presentAlert: true,
        presentBadge: true,
        presentSound: true,
        badgeNumber: 1,
      );

      const details = NotificationDetails(
        android: androidDetails,
        iOS: iosDetails,
      );

      await _plugin.show(
        id,
        title,
        body,
        details,
        payload: payload,
      );

      print('Notification shown: $title - $body');
    } catch (e) {
      print('Error showing notification: $e');
    }
  }

  /// Show message notification
  Future<void> showMessageNotification({
    required String conversationId,
    required String senderName,
    required String messageBody,
  }) async {
    final id = conversationId.hashCode % 100000;
    await showNotification(
      id: id,
      title: senderName,
      body: messageBody,
      payload: conversationId,
    );
  }

  /// Cancel a notification
  Future<void> cancelNotification(int id) async {
    try {
      await _plugin.cancel(id);
    } catch (e) {
      print('Error canceling notification: $e');
    }
  }

  /// Cancel all notifications
  Future<void> cancelAllNotifications() async {
    try {
      await _plugin.cancelAll();
    } catch (e) {
      print('Error canceling all notifications: $e');
    }
  }

  /// Get pending notifications
  Future<List<PendingNotificationRequest>> getPendingNotifications() async {
    try {
      return await _plugin.pendingNotificationRequests();
    } catch (e) {
      print('Error getting pending notifications: $e');
      return [];
    }
  }

  /// Setup notification response handler
  void setupNotificationResponseHandler({
    required Function(String) onNotificationTapped,
  }) {
    _plugin.getNotificationAppLaunchDetails().then((details) {
      if (details?.didNotificationLaunchApp ?? false) {
        final payload = details?.notificationResponse?.payload;
        if (payload != null) {
          onNotificationTapped(payload);
        }
      }
    });

    // Listen for notification taps in foreground
  }

  /// Request notification permissions (Android 13+)
  Future<bool> requestPermissions() async {
    try {
      final result = await _plugin
          .resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin>()
          ?.requestNotificationsPermission();
      return result ?? false;
    } catch (e) {
      print('Error requesting permissions: $e');
      return false;
    }
  }
}
</file>

<file path="lib/services/media_service.dart">
import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path/path.dart' as p;
import 'package:uuid/uuid.dart';
import 'package:messageai/state/providers.dart';

/// Media upload progress
class MediaUploadProgress {
  final int bytesTransferred;
  final int totalBytes;
  
  MediaUploadProgress({
    required this.bytesTransferred,
    required this.totalBytes,
  });
  
  double get progress => totalBytes > 0 ? bytesTransferred / totalBytes : 0;
  double get percentage => progress * 100;
}

/// Media service for handling uploads
class MediaService {
  final Ref ref;
  
  static const String _mediaBucket = 'media';
  static const String _avatarBucket = 'avatars';
  
  MediaService({required this.ref});

  /// Pick image from gallery
  Future<XFile?> pickImageFromGallery() async {
    final picker = ImagePicker();
    return picker.pickImage(source: ImageSource.gallery);
  }

  /// Pick image from camera
  Future<XFile?> pickImageFromCamera() async {
    final picker = ImagePicker();
    return picker.pickImage(source: ImageSource.camera);
  }

  /// Upload image to Supabase Storage
  Future<String> uploadImage(XFile file, {String bucket = 'media'}) async {
    final supabase = ref.watch(supabaseClientProvider);
    final userId = supabase.auth.currentUser?.id;
    
    if (userId == null) {
      throw Exception('User not authenticated');
    }
    
    try {
      // Generate unique filename
      const uuid = Uuid();
      final fileName = '${uuid.v4()}_${p.basename(file.path)}';
      final path = '$userId/$fileName';
      
      // Read file bytes
      final fileBytes = await file.readAsBytes();
      
      // Upload to storage
      await supabase.storage
          .from(bucket)
          .uploadBinary(
            path,
            fileBytes,
            fileOptions: const FileOptions(cacheControl: '3600'),
          );
      
      // Get public URL
      final url = supabase.storage
          .from(bucket)
          .getPublicUrl(path);
      
      return url;
    } catch (e) {
      print('Error uploading image: $e');
      rethrow;
    }
  }
  
  /// Upload avatar image
  Future<String> uploadAvatar(XFile file) async {
    return uploadImage(file, bucket: _avatarBucket);
  }

  /// Upload image with progress tracking
  Future<String> uploadImageWithProgress(
    XFile file,
    Function(MediaUploadProgress) onProgress,
  ) async {
    final supabase = ref.watch(supabaseClientProvider);
    
    try {
      // Generate unique filename
      const uuid = Uuid();
      final fileName = '${uuid.v4()}_${p.basename(file.path)}';
      final path = 'conversations/$fileName';
      
      // Read file bytes
      final fileBytes = await file.readAsBytes();
      final totalBytes = fileBytes.length;
      
      // Simulate progress (Supabase doesn't provide built-in progress)
      // In production, use a dedicated upload library
      int bytesTransferred = 0;
      
      // Upload to storage
      await supabase.storage
          .from(_mediaBucket)
          .uploadBinary(
            path,
            fileBytes,
            fileOptions: const FileOptions(cacheControl: '3600'),
          );
      
      bytesTransferred = totalBytes;
      onProgress(MediaUploadProgress(
        bytesTransferred: bytesTransferred,
        totalBytes: totalBytes,
      ));
      
      // Get public URL
      final url = supabase.storage
          .from(_mediaBucket)
          .getPublicUrl(path);
      
      return url;
    } catch (e) {
      print('Error uploading image with progress: $e');
      rethrow;
    }
  }

  /// Delete image from storage
  Future<void> deleteImage(String url) async {
    final supabase = ref.watch(supabaseClientProvider);
    
    try {
      // Extract path from URL
      final uri = Uri.parse(url);
      final pathSegments = uri.pathSegments;
      final path = pathSegments.sublist(4).join('/'); // Skip storage, v1, object, public
      
      await supabase.storage.from(_mediaBucket).remove([path]);
    } catch (e) {
      print('Error deleting image: $e');
    }
  }

  /// Compress image before upload
  Future<File> compressImage(XFile file, {int quality = 85}) async {
    // TODO: Implement image compression using image package
    // For now, return original file
    return File(file.path);
  }
}

/// Provider for media service
final mediaServiceProvider = Provider<MediaService>((ref) {
  return MediaService(ref: ref);
});

/// State notifier for handling media uploads
class MediaUploadNotifier extends StateNotifier<AsyncValue<String>> {
  final Ref ref;

  MediaUploadNotifier({required this.ref}) : super(const AsyncValue.data(''));

  /// Upload image
  Future<String> uploadImage(XFile file) async {
    state = const AsyncValue.loading();
    
    try {
      final mediaService = ref.watch(mediaServiceProvider);
      final url = await mediaService.uploadImage(file);
      state = AsyncValue.data(url);
      return url;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }

  /// Upload image with progress
  Future<String> uploadImageWithProgress(
    XFile file,
    Function(MediaUploadProgress) onProgress,
  ) async {
    state = const AsyncValue.loading();
    
    try {
      final mediaService = ref.watch(mediaServiceProvider);
      final url = await mediaService.uploadImageWithProgress(file, onProgress);
      state = AsyncValue.data(url);
      return url;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }
}

/// State notifier provider for media uploads
final mediaUploadNotifierProvider =
    StateNotifierProvider<MediaUploadNotifier, AsyncValue<String>>((ref) {
  return MediaUploadNotifier(ref: ref);
});
</file>

<file path="lib/services/message_service.dart">
import 'package:uuid/uuid.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/core/errors/error_handler.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/services/ai_analysis_service.dart';

class MessageService {
  static final MessageService _instance = MessageService._internal();

  factory MessageService() {
    return _instance;
  }

  MessageService._internal();

  final _db = AppDb.instance;
  final _supabase = SupabaseClientProvider.client;
  final _errorHandler = ErrorHandler();
  final _aiAnalysis = AIAnalysisService();
  
  // Callback for when message is successfully sent (for triggering push notifications)
  void Function(String conversationId, String messageId)? onMessageSent;

  /// Send a new message
  Future<Message> sendMessage({
    required String conversationId,
    required String body,
    String? mediaUrl,
  }) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final messageId = const Uuid().v4();
      
      final message = Message(
        id: messageId,
        conversationId: conversationId,
        senderId: currentUser.id,
        body: body,
        mediaUrl: mediaUrl,
        createdAt: now,
        updatedAt: now,
        isSynced: false,
      );

      // Save to local database first (optimistic UI)
      try {
        await _db.messageDao.upsertMessage(message);
        await _db.conversationDao.updateLastMessageTime(conversationId);
      } catch (error, stackTrace) {
        // Critical: Can't even save locally
        throw _errorHandler.handleError(
          error, 
          stackTrace: stackTrace, 
          context: 'Save Message Locally',
        );
      }

      // Sync to backend
      try {
        final payload = {
          'id': messageId,
          'conversation_id': conversationId,
          'sender_id': currentUser.id,
          'body': body,
          'media_url': mediaUrl,
          'created_at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
          'updated_at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
        };
        
        await _supabase.from('messages').insert(payload);
        await _db.messageDao.markMessageAsSynced(messageId);
        
        // Trigger push notifications (don't wait for it)
        _sendPushNotification(conversationId, messageId, body).catchError((e) {
          print('⚠️ Push notification failed: $e');
        });
        
        // Trigger AI analysis for sent messages (don't wait for it)
        _triggerAIAnalysis(messageId, body).catchError((e) {
          print('⚠️ AI analysis failed: $e');
        });
      } catch (error, stackTrace) {
        // Convert to AppError
        final appError = _errorHandler.handleError(
          error, 
          stackTrace: stackTrace, 
          context: 'Send Message',
        );
        
        // If it's a network error, message is saved locally for retry
        if (_errorHandler.isNetworkError(appError)) {
          // Don't throw - message will sync later
        } else if (!appError.isRetryable) {
          // For non-retryable errors (like unauthorized), delete the local message
          await _db.messageDao.deleteMessage(messageId);
          throw appError;
        } else {
          // For other errors, throw so UI can handle
          throw appError;
        }
      }

      return message;
    } catch (error, stackTrace) {
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error, 
        stackTrace: stackTrace, 
        context: 'Send Message',
      );
    }
  }

  /// Sync messages from backend for a conversation
  Future<void> syncMessages(String conversationId) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      // Fetch messages from backend ordered by created_at
      final response = await _supabase
          .from('messages')
          .select('*')
          .eq('conversation_id', conversationId)
          .order('created_at', ascending: true);

      // Save to local database with proper timestamps
      for (final msgData in response as List) {
        final createdAt = DateTime.parse(msgData['created_at'] as String);
        final updatedAt = DateTime.parse(msgData['updated_at'] as String);
        
        final message = Message(
          id: msgData['id'] as String,
          conversationId: msgData['conversation_id'] as String,
          senderId: msgData['sender_id'] as String,
          body: msgData['body'] as String,
          mediaUrl: msgData['media_url'] as String?,
          createdAt: createdAt.millisecondsSinceEpoch ~/ 1000,
          updatedAt: updatedAt.millisecondsSinceEpoch ~/ 1000,
          isSynced: true,
        );

        // Use upsert to avoid duplicates
        await _db.messageDao.upsertMessage(message);
      }
    } catch (error, stackTrace) {
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error, 
        stackTrace: stackTrace, 
        context: 'Sync Messages',
      );
    }
  }

  /// Get messages for a conversation (with optional sync)
  Future<List<Message>> getMessagesByConversation(
    String conversationId, {
    bool syncFirst = false,
  }) async {
    if (syncFirst) {
      await syncMessages(conversationId);
    }
    return _db.messageDao.getMessagesByConversation(conversationId);
  }

  /// Get recent messages for a conversation
  Future<List<Message>> getRecentMessages(String conversationId, {int limit = 50}) async {
    return _db.messageDao.getRecentMessages(conversationId, limit: limit);
  }

  /// Get message by ID
  Future<Message?> getMessageById(String id) async {
    return _db.messageDao.getMessageById(id);
  }

  /// Delete message
  Future<void> deleteMessage(String id) async {
    await _db.messageDao.deleteMessage(id);
  }

  /// Get current user ID
  String? getCurrentUserId() {
    return _supabase.auth.currentUser?.id;
  }

  /// Send push notification for new message
  Future<void> _sendPushNotification(
    String conversationId,
    String messageId,
    String messageBody,
  ) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) return;

      // Get sender profile for notification (use maybeSingle to handle missing profile)
      final profile = await _supabase
          .from('profiles')
          .select('username, email')
          .eq('user_id', currentUser.id)
          .maybeSingle();

      final senderName = profile?['username'] as String? ?? 
                         profile?['email'] as String? ?? 
                         currentUser.email ?? 
                         'Someone';

      // Call push notification edge function with auth header
      final accessToken = _supabase.auth.currentSession?.accessToken;
      if (accessToken == null) return;
      
      print('🔔 Sending push notification for message: ${messageId.substring(0, 8)}');
      final response = await _supabase.functions.invoke(
        'push_notify',
        body: {
          'message_id': messageId,
          'conversation_id': conversationId,
          'sender_id': currentUser.id,
          'sender_name': senderName,
          'title': senderName,
          'body': messageBody,
        },
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      );
      print('✅ Push notification sent: ${response.data}');
    } catch (e) {
      print('❌ Failed to send push notification: $e');
    }
  }
  
  /// Trigger AI analysis for a message (non-blocking)
  Future<void> _triggerAIAnalysis(String messageId, String messageBody) async {
    try {
      final analysis = await _aiAnalysis.requestAnalysis(messageId, messageBody);
      if (analysis != null) {
        print('✨ AI analysis completed for ${messageId.substring(0, 8)}: ${analysis.tone}');
      }
    } catch (e) {
      print('⚠️ AI analysis failed for ${messageId.substring(0, 8)}: $e');
    }
  }
}
</file>

<file path="lib/services/network_connectivity_service.dart">
import 'dart:async';
import 'package:flutter/foundation.dart';

/// Network connectivity states
enum ConnectivityStatus {
  online,
  offline,
  unknown,
}

/// Service for monitoring network connectivity
/// Note: For production, consider using connectivity_plus package
class NetworkConnectivityService {
  static final NetworkConnectivityService _instance =
      NetworkConnectivityService._internal();

  factory NetworkConnectivityService() {
    return _instance;
  }

  NetworkConnectivityService._internal();

  final _statusController = StreamController<ConnectivityStatus>.broadcast();
  ConnectivityStatus _currentStatus = ConnectivityStatus.unknown;
  Timer? _pingTimer;
  bool _isMonitoring = false;

  /// Get current connectivity status
  ConnectivityStatus get currentStatus => _currentStatus;

  /// Stream of connectivity status changes
  Stream<ConnectivityStatus> get onStatusChange => _statusController.stream;

  /// Check if currently online
  bool get isOnline => _currentStatus == ConnectivityStatus.online;

  /// Check if currently offline
  bool get isOffline => _currentStatus == ConnectivityStatus.offline;

  /// Start monitoring connectivity
  void startMonitoring({Duration checkInterval = const Duration(seconds: 10)}) {
    if (_isMonitoring) {
      print('⚠️  Connectivity monitoring already started');
      return;
    }

    _isMonitoring = true;
    print('🌐 Starting connectivity monitoring (every ${checkInterval.inSeconds}s)');

    // Check immediately
    _checkConnectivity();

    // Then check periodically
    _pingTimer = Timer.periodic(checkInterval, (_) {
      _checkConnectivity();
    });
  }

  /// Stop monitoring connectivity
  void stopMonitoring() {
    _pingTimer?.cancel();
    _pingTimer = null;
    _isMonitoring = false;
    print('🌐 Stopped connectivity monitoring');
  }

  /// Check connectivity status
  Future<void> _checkConnectivity() async {
    try {
      // Simple connectivity check
      // In production, use connectivity_plus package for better detection
      final previousStatus = _currentStatus;
      final newStatus = await _performConnectivityCheck();

      if (newStatus != previousStatus) {
        _currentStatus = newStatus;
        _statusController.add(_currentStatus);
        _logStatusChange(previousStatus, newStatus);
      }
    } catch (e) {
      print('❌ Error checking connectivity: $e');
    }
  }

  /// Perform actual connectivity check
  /// Override this method to use connectivity_plus or other packages
  Future<ConnectivityStatus> _performConnectivityCheck() async {
    try {
      // For now, we assume online unless explicitly set offline
      // In production, use connectivity_plus to check actual network state
      
      // You can enhance this by:
      // 1. Using connectivity_plus package
      // 2. Pinging a known endpoint
      // 3. Checking platform-specific APIs
      
      return ConnectivityStatus.online;
    } catch (e) {
      return ConnectivityStatus.offline;
    }
  }

  /// Manually set connectivity status (useful for testing)
  void setStatus(ConnectivityStatus status) {
    if (_currentStatus != status) {
      final previousStatus = _currentStatus;
      _currentStatus = status;
      _statusController.add(_currentStatus);
      _logStatusChange(previousStatus, status);
    }
  }

  /// Force a connectivity check now
  Future<ConnectivityStatus> checkNow() async {
    final status = await _performConnectivityCheck();
    if (status != _currentStatus) {
      final previousStatus = _currentStatus;
      _currentStatus = status;
      _statusController.add(_currentStatus);
      _logStatusChange(previousStatus, status);
    }
    return _currentStatus;
  }

  /// Log status changes
  void _logStatusChange(
    ConnectivityStatus previous,
    ConnectivityStatus current,
  ) {
    final emoji = current == ConnectivityStatus.online ? '✅' : '📴';
    print('$emoji Connectivity: ${previous.name} → ${current.name}');
  }

  /// Dispose resources
  void dispose() {
    stopMonitoring();
    _statusController.close();
  }
}

/// Extension for convenience methods
extension ConnectivityStatusExtension on ConnectivityStatus {
  bool get isOnline => this == ConnectivityStatus.online;
  bool get isOffline => this == ConnectivityStatus.offline;
  bool get isUnknown => this == ConnectivityStatus.unknown;
}
</file>

<file path="lib/services/notification_service.dart">
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/foundation.dart' show kIsWeb;

/// Notification payload model
class NotificationPayload {
  final String? title;
  final String? body;
  final Map<String, dynamic> data;
  final String? messageId;

  NotificationPayload({
    this.title,
    this.body,
    required this.data,
    this.messageId,
  });

  /// Extract conversation ID from payload
  String? get conversationId => data['conversation_id'] as String?;

  /// Extract sender ID from payload
  String? get senderId => data['sender_id'] as String?;

  /// Extract message ID from payload
  String? get messageIdFromPayload => data['message_id'] as String?;

  /// Extract message body from payload
  String? get messageBody => data['message_body'] as String?;
}

/// Firebase Cloud Messaging service
class NotificationService {
  final FirebaseMessaging _messaging = FirebaseMessaging.instance;
  
  static const String _channelId = 'messages';
  static const String _channelName = 'Message Notifications';

  /// Initialize Firebase Messaging
  Future<void> initialize({
    required Function(NotificationPayload) onMessageReceived,
    required Function(String) onTokenRefresh,
  }) async {
    print('🔔 ========================================');
    print('🔔 INITIALIZING FIREBASE MESSAGING');
    print('🔔 ========================================');
    
    // Skip Firebase Messaging on web due to compatibility issues
    if (kIsWeb) {
      print('⚠️  Firebase Messaging not supported on web platform');
      return;
    }
    
    print('📱 Platform: Mobile (FCM supported)');
    
    try {
      print('📝 Requesting notification permissions...');
      // Request notification permissions
      final settings = await _messaging.requestPermission(
        alert: true,
        announcement: false,
        badge: true,
        criticalAlert: false,
        provisional: false,
        sound: true,
      );

      print('✅ Permission status: ${settings.authorizationStatus}');

      // Get initial token
      print('📱 Getting FCM device token...');
      final token = await getDeviceToken();
      if (token != null) {
        print('✅ FCM Token obtained: ${token.substring(0, 50)}...');
        print('   Full token: $token');
      } else {
        print('⚠️  No FCM token obtained');
      }

      // Listen for token refresh
      FirebaseMessaging.instance.onTokenRefresh.listen((newToken) {
        print('FCM Token refreshed: $newToken');
        onTokenRefresh(newToken);
      });

      // Listen for foreground messages
      FirebaseMessaging.onMessage.listen((RemoteMessage message) {
        print('Got a message whilst in the foreground!');
        print('Message data: ${message.data}');

        final payload = NotificationPayload(
          title: message.notification?.title,
          body: message.notification?.body,
          data: message.data,
          messageId: message.messageId,
        );

        onMessageReceived(payload);
      });

      // Handle background message (top-level function)
      // This should be registered before the app starts
    } catch (e, stackTrace) {
      print('❌ ========================================');
      print('❌ ERROR INITIALIZING FIREBASE MESSAGING');
      print('❌ ========================================');
      print('Error: $e');
      print('Stack trace: $stackTrace');
      print('❌ ========================================');
    }
  }

  /// Get device token for sending notifications
  Future<String?> getDeviceToken() async {
    if (kIsWeb) return null;
    
    try {
      final token = await _messaging.getToken();
      return token;
    } catch (e) {
      print('Error getting device token: $e');
      return null;
    }
  }

  /// Subscribe to a topic
  Future<void> subscribeToTopic(String topic) async {
    if (kIsWeb) return;
    
    try {
      await _messaging.subscribeToTopic(topic);
      print('Subscribed to topic: $topic');
    } catch (e) {
      print('Error subscribing to topic: $e');
    }
  }

  /// Unsubscribe from a topic
  Future<void> unsubscribeFromTopic(String topic) async {
    if (kIsWeb) return;
    
    try {
      await _messaging.unsubscribeFromTopic(topic);
      print('Unsubscribed from topic: $topic');
    } catch (e) {
      print('Error unsubscribing from topic: $e');
    }
  }

  /// Check if notifications are enabled
  Future<bool> areNotificationsEnabled() async {
    if (kIsWeb) return false;
    
    try {
      final settings = await _messaging.getNotificationSettings();
      return settings.authorizationStatus == AuthorizationStatus.authorized;
    } catch (e) {
      print('Error checking notification settings: $e');
      return false;
    }
  }

  /// Handle notification tap
  Future<void> setupNotificationTapHandler({
    required Function(String) onNotificationTapped,
  }) async {
    if (kIsWeb) return;
    
    try {
      // When the app is in foreground and user taps notification
      FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
        print('Notification tapped: ${message.data}');
        final conversationId = message.data['conversation_id'] as String?;
        if (conversationId != null) {
          onNotificationTapped(conversationId);
        }
      });

      // Check if app was opened from a notification when app was terminated
      final initialMessage = await _messaging.getInitialMessage();
      if (initialMessage != null) {
        print('App opened from notification: ${initialMessage.data}');
        final conversationId = initialMessage.data['conversation_id'] as String?;
        if (conversationId != null) {
          onNotificationTapped(conversationId);
        }
      }
    } catch (e) {
      print('Error setting up notification tap handler: $e');
    }
  }
}

/// Provider for notification service
final notificationServiceProvider = Provider<NotificationService>((ref) {
  return NotificationService();
});

/// Store device token
final deviceTokenProvider = StateProvider<String?>((ref) {
  return null;
});

/// Handle notification reception
final notificationHandlerProvider = FutureProvider<void>((ref) async {
  final service = ref.watch(notificationServiceProvider);
  
  // This would be called after the service is initialized
  // Placeholder for notification setup
});
</file>

<file path="lib/services/offline_queue_service.dart">
import 'dart:async';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/services/network_connectivity_service.dart';
import 'package:messageai/services/retry_service.dart';
import 'package:messageai/core/errors/app_error.dart';

/// Service for managing offline message queue and auto-sync
class OfflineQueueService {
  static final OfflineQueueService _instance =
      OfflineQueueService._internal();

  factory OfflineQueueService() {
    return _instance;
  }

  OfflineQueueService._internal();

  final _db = AppDb.instance;
  final _supabase = SupabaseClientProvider.client;
  final _connectivityService = NetworkConnectivityService();
  final _retryService = RetryService();

  StreamSubscription<ConnectivityStatus>? _connectivitySubscription;
  Timer? _syncTimer;
  bool _isSyncing = false;
  bool _isMonitoring = false;

  /// Start monitoring and auto-syncing
  void startMonitoring() {
    if (_isMonitoring) {
      return;
    }

    _isMonitoring = true;

    // Listen for connectivity changes - only sync when coming back online
    _connectivitySubscription = _connectivityService.onStatusChange.listen((status) {
      if (status == ConnectivityStatus.online) {
        syncPendingMessages();
      }
    });

    // No periodic polling - sync only happens:
    // 1. When connectivity is restored
    // 2. When explicitly requested (e.g., after sending a message)
  }

  /// Stop monitoring
  void stopMonitoring() {
    _connectivitySubscription?.cancel();
    _connectivitySubscription = null;
    _syncTimer?.cancel();
    _syncTimer = null;
    _isMonitoring = false;
    print('📦 Stopped offline queue monitoring');
  }

  /// Get count of pending messages
  Future<int> getPendingMessageCount() async {
    try {
      final messages = await _db.messageDao.getUnsyncedMessages();
      return messages.length;
    } catch (e) {
      print('❌ Error getting pending message count: $e');
      return 0;
    }
  }

  /// Sync all pending messages
  Future<SyncResult> syncPendingMessages() async {
    if (_isSyncing) {
      return SyncResult.alreadyRunning();
    }

    if (_connectivityService.isOffline) {
      return SyncResult.offline();
    }

    _isSyncing = true;
    int successCount = 0;
    int failureCount = 0;
    final List<String> failedMessageIds = [];

    try {
      final pendingMessages = await _db.messageDao.getUnsyncedMessages();

      if (pendingMessages.isEmpty) {
        return SyncResult.noMessages();
      }

      for (final message in pendingMessages) {
        final result = await _syncSingleMessage(message);
        if (result) {
          successCount++;
        } else {
          failureCount++;
          failedMessageIds.add(message.id);
        }
      }

      if (failureCount > 0) {
        print('⚠️ Sync: $successCount succeeded, $failureCount failed');
      }

      return SyncResult(
        totalMessages: pendingMessages.length,
        successCount: successCount,
        failureCount: failureCount,
        failedMessageIds: failedMessageIds,
      );
    } catch (e) {
      print('❌ Error syncing: $e');
      return SyncResult.error(e.toString());
    } finally {
      _isSyncing = false;
    }
  }

  /// Sync a single message with retry
  Future<bool> _syncSingleMessage(Message message) async {
    try {
      final result = await _retryService.execute(
        operation: () => _sendMessageToBackend(message),
        operationName: 'Sync Message ${message.id.substring(0, 8)}',
        config: RetryConfig.defaultConfig,
      );

      if (result.succeeded) {
        await _db.messageDao.markMessageAsSynced(message.id);
        return true;
      } else {
        final error = result.error;
        
        // If error is non-retryable, delete the message from queue
        if (error != null && !error.isRetryable) {
          print('🗑️ Removed invalid message: ${error.code}');
          await _db.messageDao.deleteMessage(message.id);
          return true;
        }
        
        return false;
      }
    } catch (e) {
      return false;
    }
  }

  /// Send message to backend
  Future<void> _sendMessageToBackend(Message message) async {
    final payload = {
      'id': message.id,
      'conversation_id': message.conversationId,
      'sender_id': message.senderId,
      'body': message.body,
      'media_url': message.mediaUrl,
      'created_at': DateTime.fromMillisecondsSinceEpoch(message.createdAt * 1000)
          .toIso8601String(),
      'updated_at': DateTime.fromMillisecondsSinceEpoch(message.updatedAt * 1000)
          .toIso8601String(),
    };

    await _supabase.from('messages').insert(payload);
    
    // Send push notification (don't wait for it)
    _sendPushNotification(message).catchError((e) {
      // Silently fail - push notifications are not critical
    });
  }

  /// Send push notification for message
  Future<void> _sendPushNotification(Message message) async {
    try {
      // Get sender profile (use maybeSingle to handle missing profile)
      final profile = await _supabase
          .from('profiles')
          .select('username, email')
          .eq('user_id', message.senderId)
          .maybeSingle();

      final senderName = profile?['username'] as String? ?? 
                         profile?['email'] as String? ?? 
                         'Someone';

      // Call push notification edge function with auth header
      final accessToken = _supabase.auth.currentSession?.accessToken;
      if (accessToken == null) return;
      
      await _supabase.functions.invoke(
        'push_notify',
        body: {
          'message_id': message.id,
          'conversation_id': message.conversationId,
          'sender_id': message.senderId,
          'sender_name': senderName,
          'title': senderName,
          'body': message.body,
        },
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      );
    } catch (e) {
      // Ignore errors
    }
  }

  /// Force sync now (called by user action)
  Future<SyncResult> forceSyncNow() async {
    print('🔄 Force sync requested');
    return await syncPendingMessages();
  }

  /// Check if any messages are pending
  Future<bool> hasPendingMessages() async {
    final count = await getPendingMessageCount();
    return count > 0;
  }

  /// Dispose resources
  void dispose() {
    stopMonitoring();
  }
}

/// Result of sync operation
class SyncResult {
  final int totalMessages;
  final int successCount;
  final int failureCount;
  final List<String> failedMessageIds;
  final String? errorMessage;
  final SyncStatus status;

  SyncResult({
    required this.totalMessages,
    required this.successCount,
    required this.failureCount,
    this.failedMessageIds = const [],
    this.errorMessage,
    this.status = SyncStatus.completed,
  });

  SyncResult.noMessages()
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          status: SyncStatus.noMessages,
        );

  SyncResult.offline()
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          status: SyncStatus.offline,
        );

  SyncResult.alreadyRunning()
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          status: SyncStatus.alreadyRunning,
        );

  SyncResult.error(String message)
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          errorMessage: message,
          status: SyncStatus.error,
        );

  bool get hasErrors => failureCount > 0 || errorMessage != null;
  bool get isSuccess => failureCount == 0 && errorMessage == null;
  bool get isPartialSuccess => successCount > 0 && failureCount > 0;
}

/// Status of sync operation
enum SyncStatus {
  completed,
  noMessages,
  offline,
  alreadyRunning,
  error,
}
</file>

<file path="lib/services/presence_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Service for tracking user presence and online status
class PresenceService {
  static final PresenceService _instance = PresenceService._internal();

  factory PresenceService() {
    return _instance;
  }

  PresenceService._internal();

  final _supabase = SupabaseClientProvider.client;
  final Map<String, RealtimeChannel> _channels = {};
  final Map<String, Set<String>> _onlineUsers = {};

  /// Subscribe to presence updates for a conversation
  Future<void> subscribeToPresence(String conversationId) async {
    if (_channels.containsKey(conversationId)) {
      return; // Already subscribed
    }

    final channel = _supabase.realtime.channel('presence:$conversationId');

    // Listen for presence events using the 'on' method
    channel.on(RealtimeListenTypes.presence, ChannelFilter(event: 'sync'), (payload, [ref]) {
      print('👥 Presence sync for $conversationId');
      _updateOnlineUsers(conversationId, channel);
    });

    channel.on(RealtimeListenTypes.presence, ChannelFilter(event: 'join'), (payload, [ref]) {
      print('👋 User joined: ${payload['user_id'] ?? 'unknown'}');
      _updateOnlineUsers(conversationId, channel);
    });

    channel.on(RealtimeListenTypes.presence, ChannelFilter(event: 'leave'), (payload, [ref]) {
      print('👋 User left: ${payload['user_id'] ?? 'unknown'}');
      _updateOnlineUsers(conversationId, channel);
    });

    // Subscribe with extended timeout for slower connections
    channel.subscribe(
      (status, [err]) {
        print('Presence subscription status: $status');
        if (status == 'SUBSCRIBED') {
          _updateOnlineUsers(conversationId, channel);
          // Periodically update to catch any missed events
          Future.delayed(const Duration(seconds: 1), () {
            _updateOnlineUsers(conversationId, channel);
          });
        }
        if (err != null) {
          print('Error subscribing to presence: $err');
        }
      },
      const Duration(seconds: 30), // Increased timeout for mobile networks
    );

    _channels[conversationId] = channel;
  }

  /// Unsubscribe from presence updates
  Future<void> unsubscribeFromPresence(String conversationId) async {
    final channel = _channels.remove(conversationId);
    if (channel != null) {
      await channel.unsubscribe();
    }
    _onlineUsers.remove(conversationId);
  }

  /// Broadcast user presence
  Future<void> setPresenceStatus(String conversationId, bool isOnline) async {
    final channel = _channels[conversationId];
    if (channel == null) return;

    final currentUser = _supabase.auth.currentUser;
    if (currentUser == null) return;

    try {
      await channel.track({
        'user_id': currentUser.id,
        'online': isOnline,
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('Error setting presence: $e');
    }
  }

  /// Get online users for a conversation
  Set<String> getOnlineUsers(String conversationId) {
    return _onlineUsers[conversationId] ?? {};
  }

  /// Check if a user is online
  bool isUserOnline(String conversationId, String userId) {
    return _onlineUsers[conversationId]?.contains(userId) ?? false;
  }

  void _updateOnlineUsers(String conversationId, RealtimeChannel channel) {
    try {
      final presenceState = channel.presenceState();
      final onlineSet = <String>{};

      // Iterate through all presence states
      for (final entry in presenceState.entries) {
        for (final presence in entry.value) {
          // Access the payload property which contains the tracked data
          final payload = presence.payload;
          if (payload is Map<String, dynamic>) {
            if (payload['online'] == true) {
              final userId = payload['user_id'] as String?;
              if (userId != null) {
                onlineSet.add(userId);
              }
            }
          }
        }
      }

      _onlineUsers[conversationId] = onlineSet;
      print('📊 Online users updated: ${onlineSet.length} users online');
    } catch (e) {
      print('Error updating online users: $e');
    }
  }

  /// Clean up all subscriptions
  Future<void> dispose() async {
    for (final channel in _channels.values) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        print('Error unsubscribing: $e');
      }
    }
    _channels.clear();
    _onlineUsers.clear();
  }
}
</file>

<file path="lib/services/realtime_diagnostic_service.dart">
import 'dart:async';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Diagnostic information about a Realtime channel
class RealtimeChannelDiagnostics {
  final String channelName;
  final String status;
  final DateTime subscribedAt;
  final DateTime? lastMessageAt;
  final int messagesReceived;
  final List<String> errors;
  final Duration? latency;

  RealtimeChannelDiagnostics({
    required this.channelName,
    required this.status,
    required this.subscribedAt,
    this.lastMessageAt,
    this.messagesReceived = 0,
    this.errors = const [],
    this.latency,
  });

  bool get isHealthy => status == 'SUBSCRIBED' && errors.isEmpty;
  
  Duration get timeSinceLastMessage => 
      lastMessageAt != null 
          ? DateTime.now().difference(lastMessageAt!)
          : Duration.zero;
}

/// Service for diagnosing and monitoring Realtime connections
class RealtimeDiagnosticService {
  static final RealtimeDiagnosticService _instance =
      RealtimeDiagnosticService._internal();

  factory RealtimeDiagnosticService() {
    return _instance;
  }

  RealtimeDiagnosticService._internal();

  final _supabase = SupabaseClientProvider.client;
  final Map<String, RealtimeChannelDiagnostics> _channelDiagnostics = {};
  final Map<String, DateTime> _messageTimestamps = {};
  Timer? _healthCheckTimer;
  bool _isMonitoring = false;

  /// Start monitoring Realtime health
  void startMonitoring({Duration checkInterval = const Duration(seconds: 5)}) {
    if (_isMonitoring) {
      return;
    }

    _isMonitoring = true;
    _healthCheckTimer = Timer.periodic(checkInterval, (_) {
      _performHealthCheck();
    });
  }

  /// Stop monitoring
  void stopMonitoring() {
    _healthCheckTimer?.cancel();
    _healthCheckTimer = null;
    _isMonitoring = false;
  }

  /// Register a channel for monitoring
  void registerChannel(String channelName, RealtimeChannel channel) {
    _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
      channelName: channelName,
      status: 'SUBSCRIBING',
      subscribedAt: DateTime.now(),
    );
  }

  /// Update channel status
  void updateChannelStatus(String channelName, String status) {
    final current = _channelDiagnostics[channelName];
    if (current != null) {
      _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
        channelName: channelName,
        status: status,
        subscribedAt: current.subscribedAt,
        lastMessageAt: current.lastMessageAt,
        messagesReceived: current.messagesReceived,
        errors: current.errors,
        latency: current.latency,
      );
    }
  }

  /// Record message received
  void recordMessageReceived(String channelName) {
    final current = _channelDiagnostics[channelName];
    if (current != null) {
      final now = DateTime.now();
      
      // Calculate latency if we have a timestamp
      Duration? latency;
      if (_messageTimestamps.containsKey(channelName)) {
        latency = now.difference(_messageTimestamps[channelName]!);
      }

      _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
        channelName: channelName,
        status: current.status,
        subscribedAt: current.subscribedAt,
        lastMessageAt: now,
        messagesReceived: current.messagesReceived + 1,
        errors: current.errors,
        latency: latency,
      );
    }
  }

  /// Record error
  void recordError(String channelName, String error) {
    final current = _channelDiagnostics[channelName];
    if (current != null) {
      final newErrors = List<String>.from(current.errors)..add(error);
      
      _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
        channelName: channelName,
        status: current.status,
        subscribedAt: current.subscribedAt,
        lastMessageAt: current.lastMessageAt,
        messagesReceived: current.messagesReceived,
        errors: newErrors,
        latency: current.latency,
      );

      print('❌ Error on $channelName: $error');
    }
  }

  /// Mark message send timestamp (for latency calculation)
  void markMessageSent(String channelName) {
    _messageTimestamps[channelName] = DateTime.now();
  }

  /// Perform health check on all channels
  void _performHealthCheck() {
    print('🏥 Realtime Health Check');
    print('━' * 60);

    if (_channelDiagnostics.isEmpty) {
      print('   No active channels');
      return;
    }

    for (final entry in _channelDiagnostics.entries) {
      final channel = entry.key;
      final diag = entry.value;

      final healthEmoji = diag.isHealthy ? '✅' : '⚠️';
      final statusEmoji = _getStatusEmoji(diag.status);

      print('$healthEmoji $channel');
      print('   $statusEmoji Status: ${diag.status}');
      print('   📊 Messages: ${diag.messagesReceived}');
      
      if (diag.lastMessageAt != null) {
        final timeSince = DateTime.now().difference(diag.lastMessageAt!);
        print('   ⏱️  Last message: ${timeSince.inSeconds}s ago');
      }

      if (diag.latency != null) {
        print('   🚀 Latency: ${diag.latency!.inMilliseconds}ms');
      }

      if (diag.errors.isNotEmpty) {
        print('   ❌ Errors: ${diag.errors.length}');
        for (final error in diag.errors.take(3)) {
          print('      - $error');
        }
      }

      final uptime = DateTime.now().difference(diag.subscribedAt);
      print('   ⏰ Uptime: ${_formatDuration(uptime)}');
      print('');
    }

    print('━' * 60);
  }

  /// Get emoji for status
  String _getStatusEmoji(String status) {
    switch (status) {
      case 'SUBSCRIBED':
        return '✅';
      case 'SUBSCRIBING':
        return '🔄';
      case 'CLOSED':
        return '⏸️';
      case 'CHANNEL_ERROR':
        return '❌';
      case 'TIMED_OUT':
        return '⏰';
      default:
        return '❓';
    }
  }

  /// Format duration nicely
  String _formatDuration(Duration duration) {
    if (duration.inSeconds < 60) {
      return '${duration.inSeconds}s';
    } else if (duration.inMinutes < 60) {
      return '${duration.inMinutes}m ${duration.inSeconds % 60}s';
    } else {
      return '${duration.inHours}h ${duration.inMinutes % 60}m';
    }
  }

  /// Get diagnostics for a channel
  RealtimeChannelDiagnostics? getDiagnostics(String channelName) {
    return _channelDiagnostics[channelName];
  }

  /// Get all diagnostics
  Map<String, RealtimeChannelDiagnostics> getAllDiagnostics() {
    return Map.from(_channelDiagnostics);
  }

  /// Test Realtime connection
  Future<RealtimeTestResult> testConnection() async {
    print('🧪 Testing Realtime connection...');
    
    final startTime = DateTime.now();
    final testChannel = _supabase.realtime.channel('test_${startTime.millisecondsSinceEpoch}');
    
    try {
      final completer = Completer<RealtimeTestResult>();
      var subscribeStatus = 'UNKNOWN';

      testChannel.subscribe(
        (status, [error]) {
          subscribeStatus = status;
          
          if (status == 'SUBSCRIBED') {
            final latency = DateTime.now().difference(startTime);
            completer.complete(RealtimeTestResult(
              success: true,
              latency: latency,
              status: status,
            ));
          } else if (status == 'CHANNEL_ERROR' || status == 'TIMED_OUT') {
            completer.complete(RealtimeTestResult(
            success: false,
            status: status,
            error: error?.toString(),
          ));
        }
      },
      const Duration(seconds: 30), // Test with 30s timeout
      );

      // Timeout after 10 seconds
      final result = await completer.future.timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          return RealtimeTestResult(
            success: false,
            status: 'TIMEOUT',
            error: 'Connection test timed out after 10 seconds',
          );
        },
      );

      // Clean up
      await testChannel.unsubscribe();

      return result;
    } catch (e) {
      return RealtimeTestResult(
        success: false,
        status: 'ERROR',
        error: e.toString(),
      );
    }
  }

  /// Generate diagnostic report
  String generateReport() {
    final buffer = StringBuffer();
    
    buffer.writeln('═' * 60);
    buffer.writeln('REALTIME DIAGNOSTICS REPORT');
    buffer.writeln('Generated: ${DateTime.now()}');
    buffer.writeln('═' * 60);
    buffer.writeln();

    if (_channelDiagnostics.isEmpty) {
      buffer.writeln('No active channels');
      return buffer.toString();
    }

    for (final entry in _channelDiagnostics.entries) {
      final diag = entry.value;
      
      buffer.writeln('Channel: ${diag.channelName}');
      buffer.writeln('  Status: ${diag.status} ${diag.isHealthy ? '✓' : '✗'}');
      buffer.writeln('  Messages Received: ${diag.messagesReceived}');
      buffer.writeln('  Subscribed At: ${diag.subscribedAt}');
      
      if (diag.lastMessageAt != null) {
        buffer.writeln('  Last Message: ${diag.lastMessageAt}');
        buffer.writeln('  Time Since Last: ${diag.timeSinceLastMessage.inSeconds}s');
      }
      
      if (diag.latency != null) {
        buffer.writeln('  Latency: ${diag.latency!.inMilliseconds}ms');
      }
      
      if (diag.errors.isNotEmpty) {
        buffer.writeln('  Errors: ${diag.errors.length}');
        for (final error in diag.errors) {
          buffer.writeln('    - $error');
        }
      }
      
      buffer.writeln();
    }

    buffer.writeln('═' * 60);
    return buffer.toString();
  }

  /// Dispose resources
  void dispose() {
    stopMonitoring();
    _channelDiagnostics.clear();
    _messageTimestamps.clear();
  }
}

/// Result of Realtime connection test
class RealtimeTestResult {
  final bool success;
  final Duration? latency;
  final String status;
  final String? error;

  RealtimeTestResult({
    required this.success,
    this.latency,
    required this.status,
    this.error,
  });

  @override
  String toString() {
    if (success) {
      return 'SUCCESS: Connected in ${latency?.inMilliseconds}ms (Status: $status)';
    } else {
      return 'FAILED: $status${error != null ? ' - $error' : ''}';
    }
  }
}
</file>

<file path="lib/services/realtime_message_service.dart">
import 'dart:async';
import 'package:uuid/uuid.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/services/realtime_diagnostic_service.dart';
import 'package:messageai/services/ai_analysis_service.dart';

/// Service for real-time message synchronization
class RealTimeMessageService {
  static final RealTimeMessageService _instance =
      RealTimeMessageService._internal();

  factory RealTimeMessageService() {
    return _instance;
  }

  RealTimeMessageService._internal();

  final _supabase = SupabaseClientProvider.client;
  final _db = AppDb.instance;
  final _diagnostics = RealtimeDiagnosticService();
  final _aiAnalysis = AIAnalysisService();
  final Map<String, RealtimeChannel> _channels = {};
  final Map<String, RealtimeChannel> _receiptChannels = {};
  final Map<String, StreamController<List<Message>>> _messageControllers = {};
  final Map<String, StreamController<List<Receipt>>> _receiptControllers = {};

  /// Subscribe to real-time messages for a conversation
  Stream<List<Message>> subscribeToMessages(String conversationId) {
    if (_messageControllers.containsKey(conversationId)) {
      return _messageControllers[conversationId]!.stream;
    }

    final controller = StreamController<List<Message>>.broadcast();
    _messageControllers[conversationId] = controller;

    _setupRealtimeListener(conversationId, controller);

    return controller.stream;
  }

  void _setupRealtimeListener(
    String conversationId,
    StreamController<List<Message>> controller,
  ) {
    try {
      final channelName = 'messages:$conversationId';
      final channel = _supabase.realtime.channel(channelName);
      
      // Register channel for diagnostics
      _diagnostics.registerChannel(channelName, channel);
      
      // Listen for postgres changes using the correct API
      channel.on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          filter: 'conversation_id=eq.$conversationId',
        ),
        (payload, [ref]) async {
          _diagnostics.recordMessageReceived(channelName);
          print('📨 Realtime message received');
          
          try {
            final data = payload['new'] as Map<String, dynamic>;
            final timestamp = DateTime.parse(data['created_at'] as String)
                .millisecondsSinceEpoch ~/
                1000;
            
            final message = Message(
              id: data['id'] as String,
              conversationId: data['conversation_id'] as String,
              senderId: data['sender_id'] as String,
              body: data['body'] as String,
              mediaUrl: data['media_url'] as String?,
              createdAt: timestamp,
              updatedAt: DateTime.parse(data['updated_at'] as String)
                  .millisecondsSinceEpoch ~/
                  1000,
              isSynced: true,
            );
            
            await _db.messageDao.upsertMessage(message);
            
            // Refresh the stream
            final messages =
                await _db.messageDao.getMessagesByConversation(conversationId);
            controller.add(messages);
            print('✅ UI updated with ${messages.length} messages');
            
            // Create delivery receipt for received message
            final currentUser = _supabase.auth.currentUser;
            if (currentUser != null && message.senderId != currentUser.id) {
              await _createReceipt(message.id, currentUser.id, 'delivered');
              
              // Trigger AI analysis for received messages (non-blocking)
              _triggerAIAnalysis(message);
            }
          } catch (e) {
            print('❌ Error processing message: $e');
          }
        },
      );

      // Subscribe with extended timeout for slower connections
      channel.subscribe(
        (status, [err]) {
          _diagnostics.updateChannelStatus(channelName, status);
          
          // Log all status changes for debugging
          print('📡 Realtime [$conversationId]: $status');
          
          if (status == 'CHANNEL_ERROR' || status == 'TIMED_OUT' || err != null) {
            print('❌ Realtime error for $conversationId: $status ${err ?? ""}');
            if (err != null) {
              _diagnostics.recordError(channelName, err.toString());
              controller.addError(err);
            }
          }
        },
        const Duration(seconds: 30), // Increased timeout for mobile networks
      );

      _channels[conversationId] = channel;
      
      // Load initial messages
      Future.delayed(Duration.zero, () async {
        try {
          final messages =
              await _db.messageDao.getMessagesByConversation(conversationId);
          controller.add(messages);
        } catch (e) {
          controller.addError(e);
        }
      });
    } catch (e) {
      print('Error setting up realtime listener: $e');
      controller.addError(e);
    }
  }

  /// Trigger AI analysis for a message (non-blocking)
  void _triggerAIAnalysis(Message message) {
    // Run in background, don't await
    _aiAnalysis.requestAnalysis(message.id, message.body).then((analysis) {
      if (analysis != null) {
        print('✨ AI analysis completed for ${message.id.substring(0, 8)}: ${analysis.tone}');
      }
    }).catchError((error) {
      print('⚠️ AI analysis failed for ${message.id.substring(0, 8)}: $error');
    });
  }

  Future<void> _createReceipt(String messageId, String userId, String status) async {
    try {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final receiptId = const Uuid().v4();
      
      await _db.receiptDao.addReceipt(Receipt(
        id: receiptId,
        messageId: messageId,
        userId: userId,
        status: status,
        createdAt: now,
        updatedAt: now,
        isSynced: false,
      ));
      
      // Note: message_receipts table uses 'at' column, not 'created_at'
      await _supabase.from('message_receipts').insert({
        'id': receiptId,
        'message_id': messageId,
        'user_id': userId,
        'status': status,
        'at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
      });
      
      await _db.receiptDao.markReceiptAsSynced(receiptId);
    } catch (e) {
      // Silently fail - receipts are not critical
    }
  }

  /// Subscribe to real-time receipts for a conversation
  Stream<List<Receipt>> subscribeToReceipts(String conversationId) {
    if (_receiptControllers.containsKey(conversationId)) {
      return _receiptControllers[conversationId]!.stream;
    }

    final controller = StreamController<List<Receipt>>.broadcast();
    _receiptControllers[conversationId] = controller;

    _setupReceiptListener(conversationId, controller);

    return controller.stream;
  }

  void _setupReceiptListener(
    String conversationId,
    StreamController<List<Receipt>> controller,
  ) {
    try {
      final channelName = 'receipts:$conversationId';
      final channel = _supabase.realtime.channel(channelName);
      
      // Listen for receipt changes
      channel.on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: '*',  // All events (INSERT, UPDATE)
          schema: 'public',
          table: 'message_receipts',
        ),
        (payload, [ref]) async {
          print('📨 Receipt change received');
          
          try {
            // Reload all receipts for this conversation
            final receipts = await _db.receiptDao.getReceiptsByConversation(conversationId);
            controller.add(receipts);
          } catch (e) {
            print('❌ Error processing receipt: $e');
          }
        },
      );

      channel.subscribe(
        (status, [err]) {
          print('📡 Receipts [$conversationId]: $status');
          if (err != null) {
            controller.addError(err);
          }
        },
        const Duration(seconds: 30),
      );

      _receiptChannels[conversationId] = channel;
      
      // Load initial receipts
      Future.delayed(Duration.zero, () async {
        try {
          final receipts = await _db.receiptDao.getReceiptsByConversation(conversationId);
          controller.add(receipts);
        } catch (e) {
          controller.addError(e);
        }
      });
    } catch (e) {
      print('Error setting up receipt listener: $e');
      controller.addError(e);
    }
  }

  /// Unsubscribe from real-time messages
  Future<void> unsubscribeFromMessages(String conversationId) async {
    final controller = _messageControllers.remove(conversationId);
    controller?.close();

    final channel = _channels.remove(conversationId);
    if (channel != null) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
  }

  /// Unsubscribe from real-time receipts
  Future<void> unsubscribeFromReceipts(String conversationId) async {
    final controller = _receiptControllers.remove(conversationId);
    controller?.close();

    final channel = _receiptChannels.remove(conversationId);
    if (channel != null) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
  }

  /// Clean up all subscriptions
  Future<void> dispose() async {
    for (final controller in _messageControllers.values) {
      controller.close();
    }
    _messageControllers.clear();

    for (final controller in _receiptControllers.values) {
      controller.close();
    }
    _receiptControllers.clear();

    for (final channel in _channels.values) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
    _channels.clear();

    for (final channel in _receiptChannels.values) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
    _receiptChannels.clear();
    
    _diagnostics.dispose();
  }

  /// Get diagnostic report
  String getDiagnosticsReport() {
    return _diagnostics.generateReport();
  }

  /// Start diagnostic monitoring
  void startDiagnostics() {
    _diagnostics.startMonitoring();
  }

  /// Stop diagnostic monitoring
  void stopDiagnostics() {
    _diagnostics.stopMonitoring();
  }

  /// Test Realtime connection
  Future<RealtimeTestResult> testConnection() {
    return _diagnostics.testConnection();
  }
}
</file>

<file path="lib/services/retry_service.dart">
import 'dart:async';
import 'dart:math';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_handler.dart';

/// Configuration for retry behavior
class RetryConfig {
  final int maxAttempts;
  final Duration initialDelay;
  final Duration maxDelay;
  final double backoffMultiplier;
  final bool useJitter;

  const RetryConfig({
    this.maxAttempts = 3,
    this.initialDelay = const Duration(seconds: 1),
    this.maxDelay = const Duration(seconds: 30),
    this.backoffMultiplier = 2.0,
    this.useJitter = true,
  });

  /// Aggressive retry (more attempts, faster)
  static const aggressive = RetryConfig(
    maxAttempts: 5,
    initialDelay: Duration(milliseconds: 500),
    maxDelay: Duration(seconds: 15),
  );

  /// Conservative retry (fewer attempts, slower)
  static const conservative = RetryConfig(
    maxAttempts: 2,
    initialDelay: Duration(seconds: 2),
    maxDelay: Duration(seconds: 60),
  );

  /// Default retry configuration
  static const defaultConfig = RetryConfig();
}

/// Result of a retry operation
class RetryResult<T> {
  final T? data;
  final AppError? error;
  final int attempts;
  final bool succeeded;

  RetryResult({
    this.data,
    this.error,
    required this.attempts,
    required this.succeeded,
  });

  RetryResult.success(T data, int attempts)
      : this(
          data: data,
          succeeded: true,
          attempts: attempts,
        );

  RetryResult.failure(AppError error, int attempts)
      : this(
          error: error,
          succeeded: false,
          attempts: attempts,
        );
}

/// Service for handling retries with exponential backoff
class RetryService {
  static final RetryService _instance = RetryService._internal();

  factory RetryService() {
    return _instance;
  }

  RetryService._internal();

  final _errorHandler = ErrorHandler();
  final _random = Random();

  /// Execute operation with retry logic
  Future<RetryResult<T>> execute<T>({
    required Future<T> Function() operation,
    required String operationName,
    RetryConfig config = RetryConfig.defaultConfig,
    bool Function(AppError)? shouldRetry,
  }) async {
    int attemptNumber = 0;
    AppError? lastError;

    while (attemptNumber < config.maxAttempts) {
      attemptNumber++;

      try {
        final result = await operation();
        return RetryResult.success(result, attemptNumber);
      } catch (error, stackTrace) {
        // Convert to AppError
        final appError = error is AppError
            ? error
            : _errorHandler.handleError(
                error,
                stackTrace: stackTrace,
                context: operationName,
              );

        lastError = appError;

        // Check if we should retry
        final shouldRetryThis = shouldRetry?.call(appError) ??
            _errorHandler.shouldRetry(appError, attemptNumber, maxAttempts: config.maxAttempts);

        if (!shouldRetryThis) {
          return RetryResult.failure(appError, attemptNumber);
        }

        // Calculate delay before next attempt
        if (attemptNumber < config.maxAttempts) {
          final delay = _calculateDelay(
            attemptNumber,
            config: config,
          );
          await Future.delayed(delay);
        }
      }
    }

    return RetryResult.failure(
      lastError ?? AppError(
        category: ErrorCategory.unknown,
        severity: ErrorSeverity.error,
        code: 'RETRY001',
        message: 'Max retry attempts exceeded',
        userMessage: 'Operation failed after multiple attempts',
      ),
      attemptNumber,
    );
  }

  /// Calculate delay for next retry attempt (exponential backoff with jitter)
  Duration _calculateDelay(int attemptNumber, {required RetryConfig config}) {
    // Calculate base delay: initialDelay * (backoffMultiplier ^ attemptNumber)
    final exponentialDelay = config.initialDelay.inMilliseconds *
        pow(config.backoffMultiplier, attemptNumber - 1);

    // Cap at max delay
    final cappedDelay = min(exponentialDelay, config.maxDelay.inMilliseconds.toDouble());

    // Add jitter to avoid thundering herd
    final delayWithJitter = config.useJitter
        ? _addJitter(cappedDelay.toDouble())
        : cappedDelay.toDouble();

    return Duration(milliseconds: delayWithJitter.round());
  }

  /// Add random jitter to delay (±25%)
  double _addJitter(double delay) {
    final jitterRange = delay * 0.25; // ±25%
    final jitter = (_random.nextDouble() * 2 - 1) * jitterRange;
    return delay + jitter;
  }

  /// Execute with simple retry (no configuration)
  Future<T> executeSimple<T>({
    required Future<T> Function() operation,
    int maxAttempts = 3,
  }) async {
    final result = await execute(
      operation: operation,
      operationName: 'Operation',
      config: RetryConfig(maxAttempts: maxAttempts),
    );

    if (result.succeeded) {
      return result.data as T;
    } else {
      throw result.error!;
    }
  }

  /// Execute with timeout and retry
  Future<RetryResult<T>> executeWithTimeout<T>({
    required Future<T> Function() operation,
    required String operationName,
    Duration timeout = const Duration(seconds: 30),
    RetryConfig config = RetryConfig.defaultConfig,
  }) async {
    return execute<T>(
      operation: () async {
        return await operation().timeout(
          timeout,
          onTimeout: () {
            throw AppError(
              category: ErrorCategory.network,
              severity: ErrorSeverity.warning,
              code: 'NET002',
              message: 'Operation timeout',
              userMessage: 'The operation took too long. Please try again.',
              isRetryable: true,
            );
          },
        );
      },
      operationName: operationName,
      config: config,
    );
  }
}

/// Extension to add retry capability to Future
extension RetryExtension<T> on Future<T> {
  /// Retry this future with exponential backoff
  Future<T> withRetry({
    String operationName = 'Operation',
    int maxAttempts = 3,
  }) async {
    final retryService = RetryService();
    return retryService.executeSimple(
      operation: () => this,
      maxAttempts: maxAttempts,
    );
  }

  /// Retry with full configuration
  Future<RetryResult<T>> withRetryConfig({
    required String operationName,
    RetryConfig config = RetryConfig.defaultConfig,
  }) async {
    final retryService = RetryService();
    return retryService.execute(
      operation: () => this,
      operationName: operationName,
      config: config,
    );
  }
}
</file>

<file path="lib/services/typing_indicator_service.dart">
import 'dart:async';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Service to handle typing indicators using Supabase Realtime
class TypingIndicatorService {
  static final TypingIndicatorService _instance = TypingIndicatorService._internal();
  factory TypingIndicatorService() => _instance;
  TypingIndicatorService._internal();

  final _supabase = SupabaseClientProvider.client;
  final Map<String, RealtimeChannel> _channels = {};
  final Map<String, Set<String>> _typingUsers = {}; // conversationId -> Set of userIds
  final Map<String, StreamController<Set<String>>> _typingControllers = {};
  final Map<String, Timer?> _typingTimeouts = {}; // userId -> Timer

  static const _typingTimeout = Duration(seconds: 3);

  /// Subscribe to typing events for a conversation
  Stream<Set<String>> subscribeToTyping(String conversationId) {
    // Return existing stream if already subscribed
    if (_typingControllers.containsKey(conversationId)) {
      return _typingControllers[conversationId]!.stream;
    }

    // Create new stream controller
    final controller = StreamController<Set<String>>.broadcast();
    _typingControllers[conversationId] = controller;
    _typingUsers[conversationId] = {};

    // Create channel for this conversation
    final channel = _supabase.channel('typing:$conversationId');
    _channels[conversationId] = channel;

    // Listen for typing events using on() method
    channel.on(
      RealtimeListenTypes.broadcast,
      ChannelFilter(event: 'typing'),
      (payload, [ref]) {
        final data = payload as Map<String, dynamic>;
        final userId = data['user_id'] as String?;
        final isTyping = data['is_typing'] as bool? ?? false;
        final currentUserId = _supabase.auth.currentUser?.id;

        // Ignore own typing events
        if (userId == null || userId == currentUserId) return;

        final typingSet = _typingUsers[conversationId] ?? {};

        if (isTyping) {
          typingSet.add(userId);
          
          // Clear existing timeout for this user
          _typingTimeouts['$conversationId:$userId']?.cancel();
          
          // Set timeout to remove user from typing after inactivity
          _typingTimeouts['$conversationId:$userId'] = Timer(_typingTimeout, () {
            typingSet.remove(userId);
            _typingUsers[conversationId] = typingSet;
            if (!controller.isClosed) {
              controller.add(Set.from(typingSet));
            }
          });
        } else {
          typingSet.remove(userId);
          _typingTimeouts['$conversationId:$userId']?.cancel();
        }

        _typingUsers[conversationId] = typingSet;
        if (!controller.isClosed) {
          controller.add(Set.from(typingSet));
        }
      },
    );

    // Subscribe to channel with extended timeout
    channel.subscribe(
      (status, [err]) {
        print('Typing indicator subscription status: $status');
        if (err != null) {
          print('Error subscribing to typing indicator: $err');
        }
      },
      const Duration(seconds: 30), // Increased timeout for mobile networks
    );

    return controller.stream;
  }

  /// Send typing indicator
  Future<void> sendTypingIndicator(String conversationId, bool isTyping) async {
    final channel = _channels[conversationId];
    if (channel == null) return;

    final currentUserId = _supabase.auth.currentUser?.id;
    if (currentUserId == null) return;

    try {
      channel.send(
        type: RealtimeListenTypes.broadcast,
        event: 'typing',
        payload: {
          'user_id': currentUserId,
          'is_typing': isTyping,
        },
      );
    } catch (e) {
      print('Error sending typing indicator: $e');
    }
  }

  /// Unsubscribe from typing events for a conversation
  Future<void> unsubscribeFromTyping(String conversationId) async {
    final channel = _channels[conversationId];
    if (channel != null) {
      await channel.unsubscribe();
      _channels.remove(conversationId);
    }

    final controller = _typingControllers[conversationId];
    if (controller != null && !controller.isClosed) {
      await controller.close();
    }
    _typingControllers.remove(conversationId);
    _typingUsers.remove(conversationId);

    // Clear all timeouts for this conversation
    final keysToRemove = _typingTimeouts.keys
        .where((key) => key.startsWith('$conversationId:'))
        .toList();
    for (final key in keysToRemove) {
      _typingTimeouts[key]?.cancel();
      _typingTimeouts.remove(key);
    }
  }

  /// Get current typing users for a conversation
  Set<String> getTypingUsers(String conversationId) {
    return Set.from(_typingUsers[conversationId] ?? {});
  }

  /// Clean up all subscriptions
  Future<void> dispose() async {
    for (final channel in _channels.values) {
      await channel.unsubscribe();
    }
    _channels.clear();

    for (final controller in _typingControllers.values) {
      if (!controller.isClosed) {
        await controller.close();
      }
    }
    _typingControllers.clear();
    _typingUsers.clear();

    for (final timer in _typingTimeouts.values) {
      timer?.cancel();
    }
    _typingTimeouts.clear();
  }
}
</file>

<file path="lib/state/ai_providers_cached.dart.backup">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/services/ai_analysis_service.dart';

/// Provider for the AI Analysis Service singleton
final aiAnalysisServiceProvider = Provider<AIAnalysisService>((ref) {
  return AIAnalysisService();
});

/// Provider for getting analysis for a specific message
final messageAnalysisProvider = FutureProvider.family<AiAnalysi?, String>(
  (ref, messageId) async {
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getAnalysis(messageId);
  },
);

/// Stream provider for watching analysis changes for a message
final messageAnalysisStreamProvider = StreamProvider.family<AiAnalysi?, String>(
  (ref, messageId) {
    final service = ref.watch(aiAnalysisServiceProvider);
    return service.watchAnalysis(messageId);
  },
);

/// Provider for getting analyses for a conversation
final conversationAnalysisProvider = FutureProvider.family<Map<String, AiAnalysi>, ConversationAnalysisParams>(
  (ref, params) async {
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getConversationAnalysis(
      params.conversationId,
      params.messageIds,
    );
  },
);

/// Provider for analysis statistics
final analysisStatsProvider = FutureProvider<Map<String, dynamic>>(
  (ref) async {
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getAnalysisStats();
  },
);

/// Provider for requesting analysis (returns the service method)
/// Use this to trigger analysis requests from UI
final requestAnalysisProvider = Provider<Future<AiAnalysi?> Function(String, String)>((ref) {
  final service = ref.watch(aiAnalysisServiceProvider);
  return (messageId, messageBody) => service.requestAnalysis(messageId, messageBody);
});

/// Parameters for conversation analysis provider
class ConversationAnalysisParams {
  final String conversationId;
  final List<String> messageIds;

  ConversationAnalysisParams({
    required this.conversationId,
    required this.messageIds,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConversationAnalysisParams &&
          runtimeType == other.runtimeType &&
          conversationId == other.conversationId &&
          _listEquals(messageIds, other.messageIds);

  @override
  int get hashCode => conversationId.hashCode ^ messageIds.hashCode;

  bool _listEquals(List<String> a, List<String> b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }
}
</file>

<file path="lib/state/ai_providers.dart">
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/services/ai_analysis_service.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Provider for AI Analysis Service singleton
final aiAnalysisServiceProvider = Provider<AIAnalysisService>((ref) {
  return AIAnalysisService();
});

/// StateNotifier to track when to refresh analysis
class AnalysisRefreshNotifier extends StateNotifier<int> {
  AnalysisRefreshNotifier() : super(0);
  
  void refresh() {
    state++;
  }
}

final analysisRefreshProvider = StateNotifierProvider<AnalysisRefreshNotifier, int>((ref) {
  final notifier = AnalysisRefreshNotifier();
  
  // Listen to realtime updates on message_ai_analysis table
  final supabase = SupabaseClientProvider.client;
  final channel = supabase.realtime.channel('ai_analysis_updates');
  
  channel.on(
    RealtimeListenTypes.postgresChanges,
    ChannelFilter(
      event: 'INSERT',
      schema: 'public',
      table: 'message_ai_analysis',
    ),
    (payload, [ref]) {
      print('🔄 AI analysis updated, refreshing providers...');
      notifier.refresh();
    },
  );
  
  channel.subscribe(
    (status, [error]) {
      if (status == 'SUBSCRIBED') {
        print('✅ AI analysis realtime listener subscribed');
      } else if (error != null) {
        print('❌ AI analysis realtime error: $error');
      }
    },
    timeout: const Duration(seconds: 30),
  );
  
  ref.onDispose(() {
    channel.unsubscribe();
  });
  
  return notifier;
});

/// Fetch analysis for a single message (auto-refreshes on realtime updates)
final messageAnalysisProvider = FutureProvider.family<AIAnalysis?, String>(
  (ref, messageId) async {
    // Watch the refresh notifier to trigger rebuilds
    ref.watch(analysisRefreshProvider);
    
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getAnalysis(messageId);
  },
);

/// Fetch all analyses for a conversation (auto-refreshes on realtime updates)
final conversationAnalysisProvider = FutureProvider.family<Map<String, AIAnalysis>, String>(
  (ref, conversationId) async {
    // Watch the refresh notifier to trigger rebuilds
    ref.watch(analysisRefreshProvider);
    
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getConversationAnalyses(conversationId);
  },
);

/// Provider for triggering analysis requests
final requestAnalysisProvider = Provider((ref) {
  final service = ref.watch(aiAnalysisServiceProvider);
  return (String messageId, String messageBody) => 
      service.requestAnalysis(messageId, messageBody);
});
</file>

<file path="lib/state/database_provider.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/conversation_dao.dart';
import 'package:messageai/data/drift/daos/message_dao.dart';
import 'package:messageai/data/drift/daos/participant_dao.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';

/// Provides the main database instance
final appDbProvider = Provider<AppDb>((ref) {
  return AppDb.instance;
});

/// Provides the ConversationDao
final conversationDaoProvider = Provider<ConversationDao>((ref) {
  final db = ref.watch(appDbProvider);
  return ConversationDao(db);
});

/// Provides the MessageDao
final messageDaoProvider = Provider<MessageDao>((ref) {
  final db = ref.watch(appDbProvider);
  return MessageDao(db);
});

/// Provides the ParticipantDao
final participantDaoProvider = Provider<ParticipantDao>((ref) {
  final db = ref.watch(appDbProvider);
  return ParticipantDao(db);
});

/// Provides the ReceiptDao
final receiptDaoProvider = Provider<ReceiptDao>((ref) {
  final db = ref.watch(appDbProvider);
  return ReceiptDao(db);
});

/// Provides the PendingOutboxDao
final pendingOutboxDaoProvider = Provider<PendingOutboxDao>((ref) {
  final db = ref.watch(appDbProvider);
  return PendingOutboxDao(db);
});

/// Stream of all conversations (watching for changes)
final conversationsStreamProvider = StreamProvider<List<Conversation>>((ref) async* {
  final dao = ref.watch(conversationDaoProvider);
  
  // Initial load
  yield await dao.getAllConversations();
  
  // TODO: Set up watch stream for real-time updates
  // For now, update every time this is accessed
});

/// Stream of messages for a specific conversation
final messagesStreamProvider = StreamProvider.family<List<Message>, String>((ref, conversationId) async* {
  final dao = ref.watch(messageDaoProvider);
  
  // Initial load
  yield await dao.getMessagesByConversation(conversationId);
  
  // TODO: Set up watch stream for real-time updates
});

/// Stream of pending operations count (for UI indicators)
final pendingOperationsCountProvider = StreamProvider<int>((ref) async* {
  final dao = ref.watch(pendingOutboxDaoProvider);
  
  // Initial load
  yield await dao.getPendingOperationCount();
  
  // TODO: Set up periodic check or subscription
});

/// Check if there are any pending operations
final hasPendingOperationsProvider = FutureProvider<bool>((ref) async {
  final dao = ref.watch(pendingOutboxDaoProvider);
  return dao.hasPendingOperations();
});
</file>

<file path="lib/state/notification_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/services/notification_service.dart';
import 'package:messageai/services/local_notification_service.dart';
import 'package:messageai/services/deep_link_handler.dart';
import 'package:messageai/services/device_registration_service.dart';
import 'package:messageai/app.dart' show navigatorKey;

/// Device token state
final deviceTokenProvider = StateProvider<String?>((ref) {
  return null;
});

/// Notification service provider
final notificationServiceProvider = Provider<NotificationService>((ref) {
  return NotificationService();
});

/// Local notification service provider
final localNotificationServiceProvider = Provider<LocalNotificationService>((ref) {
  return LocalNotificationService();
});

/// Device registration service provider
final deviceRegistrationServiceProvider = Provider<DeviceRegistrationService>((ref) {
  return DeviceRegistrationService();
});

/// Initialize notifications (Firebase + Local)
final initializeNotificationsProvider = FutureProvider<void>((ref) async {
  print('📢 ========================================');
  print('📢 STARTING NOTIFICATION INITIALIZATION');
  print('📢 ========================================');
  
  final fcmService = ref.watch(notificationServiceProvider);
  final localService = ref.watch(localNotificationServiceProvider);
  final deviceRegistrationService = ref.watch(deviceRegistrationServiceProvider);

  print('📱 Initializing local notifications...');
  // Initialize local notifications first
  await localService.initialize();
  print('✅ Local notifications initialized');

  print('🔥 Initializing Firebase Messaging...');
  // Initialize Firebase Messaging
  await fcmService.initialize(
    onMessageReceived: (payload) {
      // Handle foreground message
      _handleForegroundMessage(ref, payload, localService);
    },
    onTokenRefresh: (token) async {
      // Update device token state
      ref.read(deviceTokenProvider.notifier).state = token;
      print('🔄 Device token refreshed: ${token.substring(0, 20)}...');
      
      // Register refreshed token with backend
      try {
        await deviceRegistrationService.registerDeviceToken(token);
        print('✅ Refreshed token registered with backend');
      } catch (e) {
        print('❌ Failed to register refreshed token: $e');
      }
    },
  );

  // Setup notification tap handler
  await fcmService.setupNotificationTapHandler(
    onNotificationTapped: (conversationId) {
      _handleNotificationTap(ref, conversationId);
    },
  );

  // Get initial device token
  final token = await fcmService.getDeviceToken();
  if (token != null) {
    ref.read(deviceTokenProvider.notifier).state = token;
    
    // Register token with backend
    try {
      await deviceRegistrationService.registerDeviceToken(token);
      print('✅ Initial token registered with backend');
    } catch (e) {
      print('❌ Failed to register initial token: $e');
      // Don't fail initialization if registration fails
    }
  }

  print('Notifications initialized successfully');
});

/// Handle foreground notification message
void _handleForegroundMessage(
  Ref ref,
  NotificationPayload payload,
  LocalNotificationService localService,
) async {
  try {
    final conversationId = payload.conversationId;
    final senderName = payload.data['sender_name'] as String? ?? 'New Message';
    final messageBody = payload.messageBody ?? payload.body ?? '';

    if (conversationId != null && messageBody.isNotEmpty) {
      await localService.showMessageNotification(
        conversationId: conversationId,
        senderName: senderName,
        messageBody: messageBody,
      );
    }
  } catch (e) {
    print('Error handling foreground message: $e');
  }
}

/// Handle notification tap
void _handleNotificationTap(Ref ref, String conversationId) {
  print('📱 Notification tapped: $conversationId');
  
  try {
    // Use the global navigator key to navigate
    final navigator = navigatorKey.currentState;
    
    if (navigator == null) {
      print('❌ Navigator not available');
      return;
    }
    
    // Navigate to conversation detail screen
    navigator.pushNamed(
      '/conversation/$conversationId',
      arguments: {'title': 'Conversation'},
    );
    
    print('✅ Navigated to conversation: $conversationId');
  } catch (e) {
    print('❌ Error navigating to conversation: $e');
  }
}

/// Notification permission state
final notificationPermissionProvider = FutureProvider<bool>((ref) async {
  final fcmService = ref.watch(notificationServiceProvider);
  return fcmService.areNotificationsEnabled();
});

/// Subscribe to conversation topic for group notifications
final subscribeToConversationTopicProvider = FutureProvider.autoDispose
    .family<void, String>((ref, conversationId) async {
  final fcmService = ref.watch(notificationServiceProvider);
  await fcmService.subscribeToTopic('conversation_$conversationId');
});

/// Unsubscribe from conversation topic
final unsubscribeFromConversationTopicProvider = FutureProvider.autoDispose
    .family<void, String>((ref, conversationId) async {
  final fcmService = ref.watch(notificationServiceProvider);
  await fcmService.unsubscribeFromTopic('conversation_$conversationId');
});

/// Subscribe to user topic for direct messages
final subscribeToUserTopicProvider = FutureProvider<void>((ref) async {
  final fcmService = ref.watch(notificationServiceProvider);
  // Subscribe to user's personal notification topic
  // (would use current user ID in real app)
  await fcmService.subscribeToTopic('user_direct_messages');
});

/// Notification state for UI
final notificationStateProvider = StateProvider<NotificationState>((ref) {
  return const NotificationState();
});

/// Notification state model
class NotificationState {
  final bool isInitialized;
  final bool hasPermission;
  final String? deviceToken;
  final int unreadCount;
  final List<String> subscribedTopics;

  const NotificationState({
    this.isInitialized = false,
    this.hasPermission = false,
    this.deviceToken,
    this.unreadCount = 0,
    this.subscribedTopics = const [],
  });

  NotificationState copyWith({
    bool? isInitialized,
    bool? hasPermission,
    String? deviceToken,
    int? unreadCount,
    List<String>? subscribedTopics,
  }) {
    return NotificationState(
      isInitialized: isInitialized ?? this.isInitialized,
      hasPermission: hasPermission ?? this.hasPermission,
      deviceToken: deviceToken ?? this.deviceToken,
      unreadCount: unreadCount ?? this.unreadCount,
      subscribedTopics: subscribedTopics ?? this.subscribedTopics,
    );
  }
}

/// Initialize notification system
final notificationInitializerProvider = FutureProvider<void>((ref) async {
  try {
    // Initialize notifications
    await ref.watch(initializeNotificationsProvider.future);

    // Check permissions
    final hasPermission = await ref.watch(notificationPermissionProvider.future);

    // Get device token
    final deviceToken = ref.watch(deviceTokenProvider);

    // Update state
    ref.read(notificationStateProvider.notifier).state =
        ref.read(notificationStateProvider).copyWith(
          isInitialized: true,
          hasPermission: hasPermission,
          deviceToken: deviceToken,
        );

    print('Notification system initialized');
  } catch (e) {
    print('Error initializing notification system: $e');
    rethrow;
  }
});
</file>

<file path="lib/state/presence_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/providers.dart';

/// User presence status
enum PresenceStatus {
  online,
  away,
  offline,
}

/// User presence information
class UserPresence {
  final String userId;
  final String conversationId;
  final PresenceStatus status;
  final DateTime lastSeen;

  UserPresence({
    required this.userId,
    required this.conversationId,
    required this.status,
    required this.lastSeen,
  });
}

/// Manages user presence for a conversation
class PresenceManager {
  final Ref ref;
  final String conversationId;
  final String userId;
  
  PresenceManager({
    required this.ref,
    required this.conversationId,
    required this.userId,
  });

  /// Join presence channel (user is viewing conversation)
  Future<void> joinPresence() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    // Subscribe to presence channel
    final presence = supabase.channel('presence:$conversationId').onPresenceSync(
      (_) {
        print('Presence synced for $conversationId');
      },
    ).onPresenceChange(
      PresenceAction.sync,
      (_) {
        print('Presence state changed for $conversationId');
      },
    );

    // Subscribe to presence channel
    await presence.subscribe(
      (status, [err]) {
        print('Presence subscription: $status - $err');
      },
      const Duration(seconds: 30), // Increased timeout for mobile networks
    );

    // Track this user's presence
    await presence.track({
      'user_id': userId,
      'status': 'online',
      'last_seen': DateTime.now().toIso8601String(),
    });
  }

  /// Leave presence channel (user is no longer viewing)
  Future<void> leavePresence() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('presence:$conversationId');
    await presence.unsubscribe();
  }

  /// Update user status
  Future<void> updateStatus(PresenceStatus status) async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('presence:$conversationId');
    await presence.track({
      'user_id': userId,
      'status': status.name,
      'last_seen': DateTime.now().toIso8601String(),
    });
  }

  /// Get all users' presence in conversation
  Future<List<UserPresence>> getConversationPresence() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('presence:$conversationId');
    final state = presence.presenceState();
    
    final presences = <UserPresence>[];
    
    for (final entry in state.entries) {
      for (final presence in entry.value) {
        final presenceMap = presence as Map<String, dynamic>;
        presences.add(UserPresence(
          userId: presenceMap['user_id'] as String,
          conversationId: conversationId,
          status: PresenceStatus.values.firstWhere(
            (s) => s.name == (presenceMap['status'] as String),
            orElse: () => PresenceStatus.offline,
          ),
          lastSeen: DateTime.parse(presenceMap['last_seen'] as String),
        ));
      }
    }
    
    return presences;
  }

  /// Check if user is online
  Future<bool> isUserOnline(String otherUserId) async {
    final presences = await getConversationPresence();
    return presences.any((p) =>
        p.userId == otherUserId && p.status == PresenceStatus.online);
  }
}

/// Provider for presence manager
final presenceManagerProvider = Provider.family<PresenceManager, (String, String)>((ref, args) {
  final (conversationId, userId) = args;
  return PresenceManager(
    ref: ref,
    conversationId: conversationId,
    userId: userId,
  );
});

/// Stream of user presence in a conversation
final conversationPresenceProvider =
    StreamProvider.autoDispose.family<List<UserPresence>, String>((ref, conversationId) async* {
  // This would typically subscribe to realtime presence updates
  // For now, we'll yield an empty list
  yield [];
  
  // TODO: Set up realtime presence stream
});

/// Check if a specific user is online
final userOnlineProvider = FutureProvider.autoDispose
    .family<bool, (String, String)>((ref, args) async {
  final (conversationId, userId) = args;
  final manager = ref.watch(presenceManagerProvider((conversationId, userId)));
  return manager.isUserOnline(userId);
});
</file>

<file path="lib/state/providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart' as fpr;
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:dio/dio.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/gen/api/clients/messages_api.dart';
import 'package:messageai/gen/api/clients/receipts_api.dart';

/// Provides the Supabase client instance
final supabaseClientProvider = fpr.Provider<SupabaseClient>((ref) {
  return SupabaseClientProvider.client;
});

/// Provides the Supabase auth client
final authProvider = fpr.Provider((ref) {
  return ref.watch(supabaseClientProvider).auth;
});

/// Provides the current authenticated user
final currentUserProvider = fpr.StreamProvider((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  return supabase.auth.onAuthStateChange.map((data) => data.session?.user);
});

/// Provides a Dio HTTP client configured for the API
final dioProvider = fpr.Provider<Dio>((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  final dio = Dio(
    BaseOptions(
      baseUrl: supabase.restUrl,
      headers: {
        'Authorization': 'Bearer ${supabase.auth.currentSession?.accessToken}',
        'apikey': supabase.auth.currentSession?.user.id ?? '',
      },
    ),
  );
  return dio;
});

/// Provides the Messages API client
final messagesApiProvider = fpr.Provider<MessagesApi>((ref) {
  final dio = ref.watch(dioProvider);
  final supabase = ref.watch(supabaseClientProvider);
  return MessagesApi(
    dio: dio,
    baseUrl: supabase.restUrl,
  );
});

/// Provides the Receipts API client
final receiptsApiProvider = fpr.Provider<ReceiptsApi>((ref) {
  final dio = ref.watch(dioProvider);
  final supabase = ref.watch(supabaseClientProvider);
  return ReceiptsApi(
    dio: dio,
    baseUrl: supabase.restUrl,
  );
});

/// Indicates whether the user is currently authenticated
final isAuthenticatedProvider = fpr.StreamProvider<bool>((ref) async* {
  final authState = ref.watch(currentUserProvider);
  yield* authState.when(
    data: (user) async* {
      yield user != null;
    },
    loading: () async* {
      yield false;
    },
    error: (err, st) async* {
      yield false;
    },
  );
});
</file>

<file path="lib/state/realtime_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/state/database_provider.dart';
import 'package:messageai/state/providers.dart';
import 'package:messageai/state/repository_providers.dart';

/// Manages realtime subscriptions to conversation messages
class RealtimeManager {
  final Ref ref;
  final Map<String, dynamic> _subscriptions = {};

  RealtimeManager({required this.ref});

  /// Subscribe to messages in a conversation
  void subscribeToConversationMessages(String conversationId) {
    final supabase = ref.watch(supabaseClientProvider);
    
    final subscription = supabase
        .channel('public:messages')
        .onPostgresChanges(
          event: PostgresChangeEvent.all,
          schema: 'public',
          table: 'messages',
          filter: PostgresChangeFilter(
            type: FilterType.eq,
            column: 'conversation_id',
            value: conversationId,
          ),
        )
        .subscribe((payload, [ref]) async {
          // Handle new/updated messages
          if (payload.eventType == 'INSERT' || payload.eventType == 'UPDATE') {
            final messageData = payload.newRecord as Map<String, dynamic>;
            final message = Message(
              id: messageData['id'] as String,
              conversationId: messageData['conversation_id'] as String,
              senderId: messageData['sender_id'] as String,
              body: messageData['body'] as String,
              mediaUrl: messageData['media_url'] as String?,
              createdAt: messageData['created_at'] as int,
              updatedAt: messageData['updated_at'] as int,
              isSynced: true,
            );
            
            // Update local DB
            final messageDao = ref.watch(messageDaoProvider);
            await messageDao.insertMessage(message);
          }
        });
    
    _subscriptions[conversationId] = subscription;
  }

  /// Unsubscribe from conversation messages
  Future<void> unsubscribeFromConversation(String conversationId) async {
    final subscription = _subscriptions.remove(conversationId);
    if (subscription != null) {
      await subscription.unsubscribe();
    }
  }

  /// Cleanup all subscriptions
  Future<void> cleanup() async {
    for (final subscription in _subscriptions.values) {
      await subscription.unsubscribe();
    }
    _subscriptions.clear();
  }
}

/// Provider for realtime manager
final realtimeManagerProvider = Provider.autoDispose<RealtimeManager>((ref) {
  return RealtimeManager(ref: ref);
});

/// Subscribe to messages in a conversation
final conversationMessagesRealtimeProvider = 
    FutureProvider.autoDispose.family<void, String>((ref, conversationId) async {
  final manager = ref.watch(realtimeManagerProvider);
  manager.subscribeToConversationMessages(conversationId);
  
  // Cleanup on dispose
  ref.onDispose(() {
    manager.unsubscribeFromConversation(conversationId);
  });
});

/// Watch for realtime message updates in a conversation
final realtimeConversationMessagesProvider = 
    StreamProvider.autoDispose.family<List<Message>, String>((ref, conversationId) async* {
  // Enable realtime subscription
  await ref.watch(conversationMessagesRealtimeProvider(conversationId).future);
  
  // Watch the local messages
  yield* ref.watch(messagesStreamProvider(conversationId));
});
</file>

<file path="lib/state/repository_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/repositories/message_repository.dart';
import 'package:messageai/data/repositories/receipt_repository.dart';
import 'package:messageai/data/repositories/group_repository.dart';
import 'package:messageai/state/database_provider.dart';
import 'package:messageai/state/providers.dart';

/// Provides the MessageRepository
final messageRepositoryProvider = Provider<MessageRepository>((ref) {
  final messagesApi = ref.watch(messagesApiProvider);
  final messageDao = ref.watch(messageDaoProvider);
  final outboxDao = ref.watch(pendingOutboxDaoProvider);
  
  return MessageRepository(
    messagesApi: messagesApi,
    messageDao: messageDao,
    outboxDao: outboxDao,
  );
});

/// Provides the ReceiptRepository
final receiptRepositoryProvider = Provider<ReceiptRepository>((ref) {
  final receiptsApi = ref.watch(receiptsApiProvider);
  final receiptDao = ref.watch(receiptDaoProvider);
  final outboxDao = ref.watch(pendingOutboxDaoProvider);
  
  return ReceiptRepository(
    receiptsApi: receiptsApi,
    receiptDao: receiptDao,
    outboxDao: outboxDao,
  );
});

/// Provides the GroupRepository
final groupRepositoryProvider = Provider<GroupRepository>((ref) {
  final conversationDao = ref.watch(conversationDaoProvider);
  final participantDao = ref.watch(participantDaoProvider);
  
  return GroupRepository(
    conversationDao: conversationDao,
    participantDao: participantDao,
  );
});

// Add receiptDaoProvider to database_provider.dart if not already there
// final receiptDaoProvider = Provider<ReceiptDao>((ref) {
//   final db = ref.watch(appDbProvider);
//   return ReceiptDao(db);
// });
</file>

<file path="lib/state/send_queue.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/state/repository_providers.dart';

/// Message to send
class SendableMessage {
  final String id;
  final String conversationId;
  final String senderId;
  final String body;
  final String? mediaUrl;

  SendableMessage({
    required this.id,
    required this.conversationId,
    required this.senderId,
    required this.body,
    this.mediaUrl,
  });
}

/// Manages sending messages with optimistic updates
class SendQueue {
  final Ref ref;
  
  SendQueue({required this.ref});

  /// Send a message
  Future<Message> sendMessage({
    required String conversationId,
    required String senderId,
    required String body,
    String? mediaUrl,
  }) async {
    // Generate unique ID
    const uuid = Uuid();
    final messageId = uuid.v4();
    
    // Get repository
    final messageRepo = ref.watch(messageRepositoryProvider);
    
    // Send optimistically (local first)
    final message = await messageRepo.sendMessage(
      id: messageId,
      conversationId: conversationId,
      senderId: senderId,
      body: body,
      mediaUrl: mediaUrl,
    );
    
    // Queue background sync
    _scheduleSyncIfNeeded();
    
    return message;
  }

  /// Drain the send queue (sync pending messages)
  Future<void> drainQueue() async {
    final messageRepo = ref.watch(messageRepositoryProvider);
    final receiptRepo = ref.watch(receiptRepositoryProvider);
    
    try {
      // Sync messages
      await messageRepo.syncUnsyncedMessages();
      
      // Sync receipts
      await receiptRepo.syncUnsyncedReceipts();
    } catch (e) {
      print('Error draining send queue: $e');
      rethrow;
    }
  }

  /// Schedule sync if there are pending operations
  void _scheduleSyncIfNeeded() {
    // In a real app, this would use a periodic timer or background service
    // For now, we'll just sync immediately for demo purposes
    _syncInBackground();
  }

  /// Sync in background
  void _syncInBackground() {
    // Run sync without awaiting (fire and forget)
    drainQueue().catchError((e) {
      print('Background sync error: $e');
    });
  }

  /// Get pending message count
  Future<int> getPendingCount() async {
    final messageRepo = ref.watch(messageRepositoryProvider);
    return messageRepo.getPendingMessageCount();
  }
}

/// Provider for send queue
final sendQueueProvider = Provider<SendQueue>((ref) {
  return SendQueue(ref: ref);
});

/// State notifier for managing message sends
class SendMessageNotifier extends StateNotifier<AsyncValue<void>> {
  final Ref ref;

  SendMessageNotifier({required this.ref}) : super(const AsyncValue.data(null));

  /// Send a message
  Future<Message> sendMessage({
    required String conversationId,
    required String senderId,
    required String body,
    String? mediaUrl,
  }) async {
    state = const AsyncValue.loading();
    
    try {
      final sendQueue = ref.watch(sendQueueProvider);
      final message = await sendQueue.sendMessage(
        conversationId: conversationId,
        senderId: senderId,
        body: body,
        mediaUrl: mediaUrl,
      );
      
      state = const AsyncValue.data(null);
      return message;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }

  /// Retry pending messages
  Future<void> retryPending() async {
    state = const AsyncValue.loading();
    
    try {
      final sendQueue = ref.watch(sendQueueProvider);
      await sendQueue.drainQueue();
      state = const AsyncValue.data(null);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }
}

/// State notifier provider for sending messages
final sendMessageNotifierProvider = 
    StateNotifierProvider<SendMessageNotifier, AsyncValue<void>>((ref) {
  return SendMessageNotifier(ref: ref);
});

/// Get pending message count
final pendingMessageCountProvider = FutureProvider<int>((ref) async {
  final sendQueue = ref.watch(sendQueueProvider);
  return sendQueue.getPendingCount();
});
</file>

<file path="lib/state/typing_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/providers.dart';

/// User typing information
class TypingUser {
  final String userId;
  final DateTime startedAt;
  final Duration timeout;

  TypingUser({
    required this.userId,
    required this.startedAt,
    this.timeout = const Duration(seconds: 3),
  });

  /// Check if typing indicator has expired
  bool get isExpired {
    return DateTime.now().difference(startedAt) > timeout;
  }
}

/// Manages typing indicators for a conversation
class TypingManager {
  final Ref ref;
  final String conversationId;
  final String userId;
  
  final Map<String, TypingUser> _typingUsers = {};
  static const Duration _debounceDelay = Duration(milliseconds: 300);
  DateTime? _lastTypingSent;

  TypingManager({
    required this.ref,
    required this.conversationId,
    required this.userId,
  });

  /// Broadcast that user is typing
  Future<void> sendTypingIndicator() async {
    final now = DateTime.now();
    
    // Debounce: only send every 300ms
    if (_lastTypingSent != null &&
        now.difference(_lastTypingSent!) < _debounceDelay) {
      return;
    }
    
    _lastTypingSent = now;
    
    final supabase = ref.watch(supabaseClientProvider);
    
    // Send typing indicator through presence
    final presence = supabase.channel('typing:$conversationId');
    
    try {
      await presence.subscribe(
        (status, [err]) {
          print('Typing subscription: $status - $err');
        },
        const Duration(seconds: 30), // Increased timeout for mobile networks
      );
      
      await presence.track({
        'user_id': userId,
        'typing': true,
        'timestamp': now.toIso8601String(),
      });
    } catch (e) {
      print('Error sending typing indicator: $e');
    }
  }

  /// Stop broadcasting typing
  Future<void> stopTypingIndicator() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('typing:$conversationId');
    
    try {
      await presence.track({
        'user_id': userId,
        'typing': false,
      });
      
      await presence.unsubscribe();
    } catch (e) {
      print('Error stopping typing indicator: $e');
    }
  }

  /// Add a typing user (received from server)
  void addTypingUser(String otherUserId) {
    _typingUsers[otherUserId] = TypingUser(userId: otherUserId, startedAt: DateTime.now());
  }

  /// Remove a typing user
  void removeTypingUser(String otherUserId) {
    _typingUsers.remove(otherUserId);
  }

  /// Get list of currently typing users (excluding expired ones)
  List<TypingUser> getTypingUsers() {
    // Remove expired entries
    _typingUsers.removeWhere((_, user) => user.isExpired);
    return _typingUsers.values.toList();
  }

  /// Get typing users display text
  String getTypingText() {
    final typingUsers = getTypingUsers();
    
    if (typingUsers.isEmpty) return '';
    if (typingUsers.length == 1) return '${typingUsers.first.userId} is typing...';
    if (typingUsers.length == 2) {
      return '${typingUsers[0].userId} and ${typingUsers[1].userId} are typing...';
    }
    
    return '${typingUsers.length} people are typing...';
  }

  /// Check if anyone is typing
  bool get anyoneTyping => getTypingUsers().isNotEmpty;
}

/// Provider for typing manager
final typingManagerProvider =
    Provider.family<TypingManager, (String, String)>((ref, args) {
  final (conversationId, userId) = args;
  return TypingManager(
    ref: ref,
    conversationId: conversationId,
    userId: userId,
  );
});

/// Stream of typing users in a conversation
final conversationTypingProvider = StreamProvider.autoDispose
    .family<List<TypingUser>, String>((ref, conversationId) async* {
  // This would typically subscribe to realtime typing updates
  // For now, we'll yield an empty list
  yield [];
  
  // TODO: Set up realtime typing stream
});

/// Get typing status text for display
final typingStatusTextProvider = StreamProvider.autoDispose
    .family<String, String>((ref, conversationId) async* {
  yield* ref.watch(conversationTypingProvider(conversationId)).when(
        data: (typingUsers) async* {
          if (typingUsers.isEmpty) {
            yield '';
          } else if (typingUsers.length == 1) {
            yield '${typingUsers.first.userId} is typing...';
          } else {
            yield '${typingUsers.length} people are typing...';
          }
        },
        loading: () async* {
          yield '';
        },
        error: (err, st) async* {
          yield '';
        },
      );
});
</file>

<file path="lib/widgets/network_status_banner.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/network_connectivity_service.dart';
import 'package:messageai/services/offline_queue_service.dart';

/// Banner that shows network status and pending message count
class NetworkStatusBanner extends StatefulWidget {
  const NetworkStatusBanner({Key? key}) : super(key: key);

  @override
  State<NetworkStatusBanner> createState() => _NetworkStatusBannerState();
}

class _NetworkStatusBannerState extends State<NetworkStatusBanner> {
  final _connectivityService = NetworkConnectivityService();
  final _offlineQueueService = OfflineQueueService();
  
  ConnectivityStatus _status = ConnectivityStatus.unknown;
  int _pendingMessages = 0;

  @override
  void initState() {
    super.initState();
    _status = _connectivityService.currentStatus;
    _loadPendingCount();
    
    // Listen to connectivity changes
    _connectivityService.onStatusChange.listen((status) {
      if (mounted) {
        setState(() => _status = status);
        _loadPendingCount();
      }
    });
  }

  Future<void> _loadPendingCount() async {
    final count = await _offlineQueueService.getPendingMessageCount();
    if (mounted) {
      setState(() => _pendingMessages = count);
    }
  }

  Future<void> _handleSyncTap() async {
    // Show loading
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Row(
          children: [
            SizedBox(
              width: 16,
              height: 16,
              child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),
            ),
            SizedBox(width: 12),
            Text('Syncing pending messages...'),
          ],
        ),
        duration: Duration(seconds: 2),
      ),
    );

    final result = await _offlineQueueService.forceSyncNow();
    
    if (!mounted) return;

    ScaffoldMessenger.of(context).hideCurrentSnackBar();
    
    if (result.isSuccess) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.check_circle, color: Colors.white),
              const SizedBox(width: 12),
              Text('${result.successCount} messages synced'),
            ],
          ),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 2),
        ),
      );
      _loadPendingCount();
    } else if (result.status == SyncStatus.noMessages) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Row(
            children: [
              Icon(Icons.check_circle, color: Colors.white),
              SizedBox(width: 12),
              Text('All messages are synced'),
            ],
          ),
          backgroundColor: Colors.blue,
          duration: Duration(seconds: 2),
        ),
      );
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.error, color: Colors.white),
              const SizedBox(width: 12),
              Text('Failed to sync: ${result.errorMessage ?? "Unknown error"}'),
            ],
          ),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    // Only show banner when offline or has pending messages
    if (_status == ConnectivityStatus.online && _pendingMessages == 0) {
      return const SizedBox.shrink();
    }

    return Material(
      color: _getBannerColor(),
      child: InkWell(
        onTap: _status == ConnectivityStatus.online && _pendingMessages > 0
            ? _handleSyncTap
            : null,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: Row(
            children: [
              Icon(
                _getBannerIcon(),
                size: 20,
                color: Colors.white,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  _getBannerText(),
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 14,
                  ),
                ),
              ),
              if (_status == ConnectivityStatus.online && _pendingMessages > 0)
                const Icon(
                  Icons.sync,
                  size: 20,
                  color: Colors.white,
                ),
            ],
          ),
        ),
      ),
    );
  }

  Color _getBannerColor() {
    if (_status == ConnectivityStatus.offline) {
      return Colors.red.shade700;
    } else if (_pendingMessages > 0) {
      return Colors.orange.shade700;
    }
    return Colors.blue;
  }

  IconData _getBannerIcon() {
    if (_status == ConnectivityStatus.offline) {
      return Icons.cloud_off;
    } else if (_pendingMessages > 0) {
      return Icons.cloud_sync;
    }
    return Icons.cloud_done;
  }

  String _getBannerText() {
    if (_status == ConnectivityStatus.offline) {
      if (_pendingMessages > 0) {
        return 'Offline • $_pendingMessages message${_pendingMessages == 1 ? '' : 's'} pending';
      }
      return 'You are offline';
    } else if (_pendingMessages > 0) {
      return 'Syncing $_pendingMessages message${_pendingMessages == 1 ? '' : 's'} • Tap to sync now';
    }
    return 'All messages synced';
  }
}

/// Small inline network indicator
class NetworkStatusIndicator extends StatefulWidget {
  final bool showLabel;

  const NetworkStatusIndicator({
    Key? key,
    this.showLabel = true,
  }) : super(key: key);

  @override
  State<NetworkStatusIndicator> createState() => _NetworkStatusIndicatorState();
}

class _NetworkStatusIndicatorState extends State<NetworkStatusIndicator> {
  final _connectivityService = NetworkConnectivityService();
  ConnectivityStatus _status = ConnectivityStatus.unknown;

  @override
  void initState() {
    super.initState();
    _status = _connectivityService.currentStatus;
    
    _connectivityService.onStatusChange.listen((status) {
      if (mounted) {
        setState(() => _status = status);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          width: 8,
          height: 8,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: _getStatusColor(),
          ),
        ),
        if (widget.showLabel) ...[
          const SizedBox(width: 6),
          Text(
            _getStatusLabel(),
            style: TextStyle(
              fontSize: 12,
              color: Colors.grey[600],
            ),
          ),
        ],
      ],
    );
  }

  Color _getStatusColor() {
    switch (_status) {
      case ConnectivityStatus.online:
        return Colors.green;
      case ConnectivityStatus.offline:
        return Colors.red;
      case ConnectivityStatus.unknown:
        return Colors.grey;
    }
  }

  String _getStatusLabel() {
    switch (_status) {
      case ConnectivityStatus.online:
        return 'Online';
      case ConnectivityStatus.offline:
        return 'Offline';
      case ConnectivityStatus.unknown:
        return 'Unknown';
    }
  }
}
</file>

<file path="lib/widgets/sliding_panel.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';

/// A sliding panel widget that can be dragged up and down
/// Used for the message screen to slide over AI insights
class SlidingPanel extends StatefulWidget {
  /// The content to display in the sliding panel
  final Widget child;
  
  /// Called when the panel position changes (0.0 = collapsed, 1.0 = fully expanded)
  final ValueChanged<double>? onSlide;
  
  /// Minimum height as a fraction of screen (0.0 - 1.0)
  final double minHeight;
  
  /// Maximum height as a fraction of screen (0.0 - 1.0)
  final double maxHeight;
  
  /// Initial height as a fraction of screen (0.0 - 1.0)
  final double initialHeight;
  
  /// Snap positions for the panel (as fractions of screen height)
  final List<double> snapSizes;
  
  /// Background color of the panel
  final Color? backgroundColor;
  
  /// Border radius for the top corners
  final double borderRadius;
  
  /// Whether to show the drag handle
  final bool showDragHandle;

  const SlidingPanel({
    Key? key,
    required this.child,
    this.onSlide,
    this.minHeight = 0.2,
    this.maxHeight = 0.95,
    this.initialHeight = 0.8,
    this.snapSizes = const [0.2, 0.5, 0.8, 0.95],
    this.backgroundColor,
    this.borderRadius = 16.0,
    this.showDragHandle = true,
  }) : super(key: key);

  @override
  State<SlidingPanel> createState() => _SlidingPanelState();
}

class _SlidingPanelState extends State<SlidingPanel> {
  final DraggableScrollableController _controller = DraggableScrollableController();
  
  @override
  void initState() {
    super.initState();
    // Add listener to track position changes
    _controller.addListener(_onPositionChanged);
  }
  
  @override
  void dispose() {
    _controller.removeListener(_onPositionChanged);
    _controller.dispose();
    super.dispose();
  }
  
  void _onPositionChanged() {
    if (_controller.isAttached) {
      final size = _controller.size;
      // Normalize the size to 0.0 - 1.0 range
      final normalizedPosition = (size - widget.minHeight) / (widget.maxHeight - widget.minHeight);
      widget.onSlide?.call(normalizedPosition.clamp(0.0, 1.0));
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final bgColor = widget.backgroundColor ?? 
                    (isDark ? AppTheme.black : AppTheme.white);
    
    return DraggableScrollableSheet(
      controller: _controller,
      initialChildSize: widget.initialHeight,
      minChildSize: widget.minHeight,
      maxChildSize: widget.maxHeight,
      snap: true,
      snapSizes: widget.snapSizes,
      builder: (BuildContext context, ScrollController scrollController) {
        return Container(
          decoration: BoxDecoration(
            color: bgColor,
            borderRadius: BorderRadius.only(
              topLeft: Radius.circular(widget.borderRadius),
              topRight: Radius.circular(widget.borderRadius),
            ),
            boxShadow: isDark ? AppTheme.shadow2Dark : AppTheme.shadow3Light,
          ),
          child: Column(
            children: [
              // Drag handle area
              if (widget.showDragHandle)
                GestureDetector(
                  onTap: () => _snapToNextPosition(),
                  child: Container(
                    width: double.infinity,
                    padding: const EdgeInsets.symmetric(
                      vertical: AppTheme.spacingS,
                    ),
                    child: Center(
                      child: Container(
                        width: 40,
                        height: 4,
                        decoration: BoxDecoration(
                          color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                          borderRadius: BorderRadius.circular(AppTheme.radiusPill),
                        ),
                      ),
                    ),
                  ),
                ),
              
              // Panel content
              Expanded(
                child: widget.child,
              ),
            ],
          ),
        );
      },
    );
  }
  
  /// Snaps the panel to the next position in the snapSizes list
  void _snapToNextPosition() {
    if (!_controller.isAttached) return;
    
    final currentSize = _controller.size;
    final sortedSnaps = List<double>.from(widget.snapSizes)..sort();
    
    // Find the next snap position
    final nextSnap = sortedSnaps.firstWhere(
      (snap) => snap > currentSize + 0.05, // Add small buffer for floating point
      orElse: () => sortedSnaps.first, // Wrap around to first
    );
    
    _controller.animateTo(
      nextSnap,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
  }
}

/// Extension to provide convenience methods for sliding panel
extension SlidingPanelController on DraggableScrollableController {
  /// Animate to a specific size
  Future<void> animateToSize(
    double size, {
    Duration duration = const Duration(milliseconds: 300),
    Curve curve = Curves.easeInOut,
  }) {
    return animateTo(
      size,
      duration: duration,
      curve: curve,
    );
  }
  
  /// Jump to a specific size without animation
  void jumpToSize(double size) {
    jumpTo(size);
  }
  
  /// Get current size
  double get currentSize => isAttached ? size : 0.0;
}
</file>

<file path="lib/widgets/user_avatar.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/avatar_service.dart';

/// Reusable widget for displaying user avatars
/// Fetches avatar from backend or shows fallback initial
class UserAvatar extends StatefulWidget {
  final String? userId;
  final String? avatarUrl;
  final String fallbackText;
  final double radius;
  final bool isGroup;

  const UserAvatar({
    Key? key,
    this.userId,
    this.avatarUrl,
    required this.fallbackText,
    this.radius = 20,
    this.isGroup = false,
  }) : super(key: key);

  @override
  State<UserAvatar> createState() => _UserAvatarState();
}

class _UserAvatarState extends State<UserAvatar> {
  final _avatarService = AvatarService();
  String? _fetchedAvatarUrl;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _loadAvatar();
  }

  @override
  void didUpdateWidget(UserAvatar oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Reload if userId changed
    if (oldWidget.userId != widget.userId || oldWidget.avatarUrl != widget.avatarUrl) {
      _loadAvatar();
    }
  }

  Future<void> _loadAvatar() async {
    // If avatarUrl is directly provided, use it
    if (widget.avatarUrl != null) {
      setState(() {
        _fetchedAvatarUrl = widget.avatarUrl;
      });
      return;
    }

    // If userId provided, fetch avatar
    if (widget.userId != null) {
      setState(() => _isLoading = true);
      
      try {
        final url = await _avatarService.getAvatarUrl(widget.userId!);
        if (mounted) {
          setState(() {
            _fetchedAvatarUrl = url;
            _isLoading = false;
          });
        }
      } catch (e) {
        if (mounted) {
          setState(() => _isLoading = false);
        }
        // Silently fail - fallback will be shown
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    // Show loading indicator
    if (_isLoading) {
      return CircleAvatar(
        radius: widget.radius,
        backgroundColor: theme.colorScheme.primary.withOpacity(0.2),
        child: SizedBox(
          width: widget.radius,
          height: widget.radius,
          child: const CircularProgressIndicator(strokeWidth: 2),
        ),
      );
    }

    // Show avatar image if available
    if (_fetchedAvatarUrl != null && _fetchedAvatarUrl!.isNotEmpty) {
      return CircleAvatar(
        radius: widget.radius,
        backgroundColor: theme.colorScheme.primary,
        backgroundImage: NetworkImage(_fetchedAvatarUrl!),
        // Error handling: show fallback if image fails to load
        onBackgroundImageError: (exception, stackTrace) {
          print('Error loading avatar: $exception');
        },
        child: Container(), // Empty container as placeholder
      );
    }

    // Fallback: Show initial or group icon
    return CircleAvatar(
      radius: widget.radius,
      backgroundColor: theme.colorScheme.primary,
      child: widget.isGroup
          ? Icon(
              Icons.group,
              color: Colors.white,
              size: widget.radius * 1.2,
            )
          : Text(
              _getInitial(widget.fallbackText),
              style: TextStyle(
                fontSize: widget.radius * 0.9,
                fontWeight: FontWeight.bold,
                color: Colors.white,
              ),
            ),
    );
  }

  /// Get first letter of name for fallback
  String _getInitial(String text) {
    if (text.isEmpty) return '?';
    return text[0].toUpperCase();
  }
}
</file>

<file path="Makefile">
contracts/gen: ; npm --prefix ../contracts run gen:dart
fmt: ; dart format .
dev: ; flutter run --dart-define-from-file=.env.dev.json
test: ; flutter test
</file>

<file path="pubspec.yaml">
name: messageai
description: MessageAI - Cross-platform messaging app with Flutter
version: 0.1.0+1
publish_to: none

environment:
  sdk: ^3.0.0
  flutter: ">=3.10.0"

dependencies:
  flutter:
    sdk: flutter

  # Network & API
  supabase_flutter: ^1.10.0
  dio: ^5.3.0

  # State management
  riverpod: ^2.4.0
  flutter_riverpod: ^2.4.0

  # Local database
  drift: ^2.14.0
  drift_flutter: ^0.2.7
  sqlite3_flutter_libs: ^0.5.16

  # Firebase
  firebase_core: ^2.27.0
  firebase_messaging: ^14.6.0

  # Local notifications (Phase 06)
  flutter_local_notifications: ^19.0.0

  # UI
  cupertino_icons: ^1.0.2

  # Utilities
  uuid: ^4.0.0
  image_picker: ^1.0.4
  path: ^1.8.3

dev_dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter

  flutter_lints: ^3.0.0

  # Code generation
  build_runner: ^2.4.0
  drift_dev: ^2.14.0

flutter:
  uses-material-design: true

dependency_overrides:
  # Completely exclude sign_in_with_apple (uses deprecated Flutter APIs incompatible with latest Android)
  sign_in_with_apple:
  sign_in_with_apple_platform_interface:
  sign_in_with_apple_web:
</file>

<file path="test/models/ai_analysis_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('AIAnalysis Model', () {
    test('fromJson creates valid object with all fields', () {
      final json = {
        'id': 'test-id-123',
        'message_id': 'msg-456',
        'tone': 'Professional',
        'urgency_level': 'Medium',
        'intent': 'requesting information',
        'confidence_score': 0.85,
        'analysis_timestamp': 1234567890,
      };
      
      final analysis = AIAnalysis.fromJson(json);
      
      expect(analysis.id, equals('test-id-123'));
      expect(analysis.messageId, equals('msg-456'));
      expect(analysis.tone, equals('Professional'));
      expect(analysis.urgencyLevel, equals('Medium'));
      expect(analysis.intent, equals('requesting information'));
      expect(analysis.confidenceScore, equals(0.85));
      expect(analysis.analysisTimestamp, equals(1234567890));
    });
    
    test('fromJson handles null optional fields', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-id',
        'tone': 'Neutral',
        'analysis_timestamp': 1234567890,
      };
      
      final analysis = AIAnalysis.fromJson(json);
      
      expect(analysis.tone, equals('Neutral'));
      expect(analysis.urgencyLevel, isNull);
      expect(analysis.intent, isNull);
      expect(analysis.confidenceScore, isNull);
    });
    
    test('toJson creates correct map', () {
      final analysis = AIAnalysis(
        id: 'id-1',
        messageId: 'msg-1',
        tone: 'Friendly',
        urgencyLevel: 'Low',
        intent: 'greeting',
        confidenceScore: 0.9,
        analysisTimestamp: 9876543210,
      );
      
      final json = analysis.toJson();
      
      expect(json['id'], equals('id-1'));
      expect(json['message_id'], equals('msg-1'));
      expect(json['tone'], equals('Friendly'));
      expect(json['urgency_level'], equals('Low'));
      expect(json['intent'], equals('greeting'));
      expect(json['confidence_score'], equals(0.9));
      expect(json['analysis_timestamp'], equals(9876543210));
    });
    
    test('equality works correctly', () {
      final a1 = AIAnalysis(
        id: 'same-id',
        messageId: 'same-msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );
      
      final a2 = AIAnalysis(
        id: 'same-id',
        messageId: 'same-msg',
        tone: 'Professional', // Different tone
        analysisTimestamp: 456, // Different timestamp
      );
      
      final a3 = AIAnalysis(
        id: 'different-id',
        messageId: 'same-msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );
      
      expect(a1, equals(a2)); // Same ID and message ID
      expect(a1, isNot(equals(a3))); // Different ID
    });
    
    test('hashCode is consistent', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Casual',
        analysisTimestamp: 123,
      );
      
      final hash1 = analysis.hashCode;
      final hash2 = analysis.hashCode;
      
      expect(hash1, equals(hash2));
    });
    
    test('toString includes key information', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Urgent',
        urgencyLevel: 'High',
        intent: 'needs response',
        confidenceScore: 0.95,
        analysisTimestamp: 123456,
      );
      
      final str = analysis.toString();
      
      expect(str, contains('test-id'));
      expect(str, contains('msg-id'));
      expect(str, contains('Urgent'));
      expect(str, contains('High'));
    });
    
    test('handles double and int confidence scores', () {
      // Test with integer
      final json1 = {
        'id': 'id-1',
        'message_id': 'msg-1',
        'tone': 'Neutral',
        'confidence_score': 1,
        'analysis_timestamp': 123,
      };
      
      final analysis1 = AIAnalysis.fromJson(json1);
      expect(analysis1.confidenceScore, equals(1.0));
      
      // Test with double
      final json2 = {
        'id': 'id-2',
        'message_id': 'msg-2',
        'tone': 'Neutral',
        'confidence_score': 0.75,
        'analysis_timestamp': 123,
      };
      
      final analysis2 = AIAnalysis.fromJson(json2);
      expect(analysis2.confidenceScore, equals(0.75));
    });
    
    test('round-trip JSON serialization preserves data', () {
      final original = AIAnalysis(
        id: 'round-trip-id',
        messageId: 'round-trip-msg',
        tone: 'Excited',
        urgencyLevel: 'Medium',
        intent: 'celebration',
        confidenceScore: 0.88,
        analysisTimestamp: 1111111111,
      );
      
      final json = original.toJson();
      final reconstructed = AIAnalysis.fromJson(json);
      
      expect(reconstructed, equals(original));
      expect(reconstructed.id, equals(original.id));
      expect(reconstructed.messageId, equals(original.messageId));
      expect(reconstructed.tone, equals(original.tone));
      expect(reconstructed.urgencyLevel, equals(original.urgencyLevel));
      expect(reconstructed.intent, equals(original.intent));
      expect(reconstructed.confidenceScore, equals(original.confidenceScore));
      expect(reconstructed.analysisTimestamp, equals(original.analysisTimestamp));
    });
  });
}
</file>

<file path="test/offline_queue_test.dart">
import 'package:flutter_test/flutter_test.dart';

/// Placeholder test for offline queue functionality
/// Full implementation requires database mocking setup
void main() {
  group('Offline Message Queue', () {
    test('Offline queue service exists', () {
      // Basic test to ensure the test file compiles
      expect(true, isTrue);
    });

    test('Network connectivity service can be instantiated', () {
      // Placeholder test
      expect(1 + 1, equals(2));
    });

    test('Retry service handles exponential backoff', () {
      // Placeholder test
      expect(true, isTrue);
    });
  });

  group('Message Syncing', () {
    test('Messages can be queued', () {
      // Placeholder test
      expect(true, isTrue);
    });

    test('Messages can be synced when online', () {
      // Placeholder test
      expect(true, isTrue);
    });
  });
}
</file>

<file path="test/realtime_diagnostic_test.dart">
import 'package:flutter_test/flutter_test.dart';

/// Placeholder test for realtime diagnostic functionality
void main() {
  group('Realtime Diagnostics', () {
    test('Realtime diagnostic service exists', () {
      // Basic test to ensure the test file compiles
      expect(true, isTrue);
    });

    test('Channel diagnostics can be tracked', () {
      // Placeholder test
      expect(1 + 1, equals(2));
    });

    test('Health checks can be performed', () {
      // Placeholder test  
      expect(true, isTrue);
    });
  });

  group('Connection Testing', () {
    test('Connection test can be executed', () {
      // Placeholder test
      expect(true, isTrue);
    });

    test('Latency can be measured', () {
      // Placeholder test
      expect(true, isTrue);
    });
  });
}
</file>

<file path="test/services/ai_analysis_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  // Note: Service tests that require Supabase client are skipped in unit tests
  // These should be tested in integration tests with proper Supabase setup
  
  group('AIAnalysisService - Unit Tests', () {
    test('service requires Supabase initialization', () {
      // This test documents that the service requires Supabase
      // Full service tests should be done in integration tests
      expect(true, isTrue);
    });
  });
  
  group('AIAnalysis Model Integration', () {
    test('AIAnalysis can be stored and retrieved', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-123',
        tone: 'Friendly',
        urgencyLevel: 'Low',
        intent: 'greeting',
        confidenceScore: 0.9,
        analysisTimestamp: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );
      
      expect(analysis.id, equals('test-id'));
      expect(analysis.messageId, equals('msg-123'));
      expect(analysis.tone, equals('Friendly'));
    });
    
    test('Multiple AIAnalysis objects can coexist', () {
      final analysis1 = AIAnalysis(
        id: 'id-1',
        messageId: 'msg-1',
        tone: 'Professional',
        analysisTimestamp: 123,
      );
      
      final analysis2 = AIAnalysis(
        id: 'id-2',
        messageId: 'msg-2',
        tone: 'Casual',
        analysisTimestamp: 456,
      );
      
      expect(analysis1.id, isNot(equals(analysis2.id)));
      expect(analysis1.tone, isNot(equals(analysis2.tone)));
    });
  });
}
</file>

<file path="test/widget_test.dart">
// Basic Flutter widget test for MessageAI app

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/app.dart';

void main() {
  testWidgets('MessageAI app loads', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(
      const ProviderScope(
        child: MessageAIApp(),
      ),
    );

    // Verify app loads without errors
    expect(find.byType(MaterialApp), findsOneWidget);
  });
}
</file>

<file path="test/widgets/tone_badge_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('ToneBadge Widget', () {
    testWidgets('displays Friendly tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        urgencyLevel: 'Low',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('😊'), findsOneWidget);
      expect(find.text('Friendly'), findsOneWidget);
    });
    
    testWidgets('displays Professional tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Professional',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('💼'), findsOneWidget);
      expect(find.text('Professional'), findsOneWidget);
    });
    
    testWidgets('displays Urgent tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Urgent',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('⚡'), findsOneWidget);
      expect(find.text('Urgent'), findsOneWidget);
    });
    
    testWidgets('displays Casual tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Casual',
        urgencyLevel: 'Low',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('😎'), findsOneWidget);
      expect(find.text('Casual'), findsOneWidget);
    });
    
    testWidgets('displays Formal tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Formal',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('👔'), findsOneWidget);
      expect(find.text('Formal'), findsOneWidget);
    });
    
    testWidgets('displays Excited tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Excited',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('🎉'), findsOneWidget);
      expect(find.text('Excited'), findsOneWidget);
    });
    
    testWidgets('displays Concerned tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Concerned',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('😟'), findsOneWidget);
      expect(find.text('Concerned'), findsOneWidget);
    });
    
    testWidgets('displays Neutral tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Neutral',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('💬'), findsOneWidget);
      expect(find.text('Neutral'), findsOneWidget);
    });
    
    testWidgets('shows urgency indicator for High urgency', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Urgent',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      // Urgency dot should be present (multiple Containers exist)
      expect(find.byType(Container), findsWidgets);
      expect(find.text('Urgent'), findsOneWidget);
    });
    
    testWidgets('shows urgency indicator for Critical urgency', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Professional',
        urgencyLevel: 'Critical',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.byType(Container), findsWidgets);
      expect(find.text('Professional'), findsOneWidget);
    });
    
    testWidgets('does not show urgency indicator for Low urgency', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Casual',
        urgencyLevel: 'Low',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('Casual'), findsOneWidget);
    });
    
    testWidgets('calls onTap callback when tapped', (tester) async {
      bool wasTapped = false;
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Excited',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(
              analysis: analysis,
              onTap: () => wasTapped = true,
            ),
          ),
        ),
      );
      
      await tester.tap(find.byType(ToneBadge));
      await tester.pump();
      
      expect(wasTapped, isTrue);
    });
    
    testWidgets('can be tapped without onTap callback', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      // Should not throw when tapped without callback
      await tester.tap(find.byType(ToneBadge));
      await tester.pump();
      
      expect(find.byType(ToneBadge), findsOneWidget);
    });
    
    testWidgets('handles case-insensitive tone names', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'FRIENDLY', // Uppercase
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      // Should still show the emoji (case handling in _getToneInfo)
      expect(find.text('😊'), findsOneWidget);
    });
  });
}
</file>

<file path="web/index.html">
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="messageai">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>messageai</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>
</file>

<file path="web/manifest.json">
{
    "name": "messageai",
    "short_name": "messageai",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}
</file>

<file path="windows/.gitignore">
flutter/ephemeral/

# Visual Studio user-specific files.
*.suo
*.user
*.userosscache
*.sln.docstates

# Visual Studio build-related files.
x64/
x86/

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/
</file>

<file path="windows/CMakeLists.txt">
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(messageai LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "messageai")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)
</file>

<file path="windows/flutter/CMakeLists.txt">
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)
</file>

<file path="windows/runner/CMakeLists.txt">
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)
</file>

<file path="windows/runner/flutter_window.cpp">
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}
</file>

<file path="windows/runner/flutter_window.h">
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_
</file>

<file path="windows/runner/main.cpp">
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"messageai", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}
</file>

<file path="windows/runner/resource.h">
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
</file>

<file path="windows/runner/runner.exe.manifest">
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>
</file>

<file path="windows/runner/Runner.rc">
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "com.example" "\0"
            VALUE "FileDescription", "messageai" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "messageai" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2025 com.example. All rights reserved." "\0"
            VALUE "OriginalFilename", "messageai.exe" "\0"
            VALUE "ProductName", "messageai" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
</file>

<file path="windows/runner/utils.cpp">
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}
</file>

<file path="windows/runner/utils.h">
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_
</file>

<file path="windows/runner/win32_window.cpp">
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}
</file>

<file path="windows/runner/win32_window.h">
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_
</file>

</files>
