This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
.metadata
analysis_options.yaml
android/.gitignore
android/app/build.gradle.kts
android/app/src/debug/AndroidManifest.xml
android/app/src/main/AndroidManifest.xml
android/app/src/main/kotlin/com/example/messageai/MainActivity.kt
android/app/src/main/res/drawable-v21/launch_background.xml
android/app/src/main/res/drawable/launch_background.xml
android/app/src/main/res/mipmap-hdpi/ic_launcher.png
android/app/src/main/res/mipmap-mdpi/ic_launcher.png
android/app/src/main/res/mipmap-xhdpi/ic_launcher.png
android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png
android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
android/app/src/main/res/values-night/styles.xml
android/app/src/main/res/values/styles.xml
android/build.gradle.kts
android/gradle.properties
android/settings.gradle.kts
devtools_options.yaml
firebase.json
integration_test/ai_flow_test.dart
integration_test/all_phases_comprehensive_test.dart
integration_test/context_system_test.dart
integration_test/enhanced_tone_analysis_test.dart
integration_test/phase1_smart_interpreter_test.dart
integration_test/phase2_response_assistant_test.dart
integration_test/phase3_context_system_test.dart
integration_test/phase4_followup_system_test.dart
lib/app.dart
lib/core/env.dart
lib/core/errors/app_error.dart
lib/core/errors/error_handler.dart
lib/core/errors/error_ui.dart
lib/core/theme/app_theme.dart
lib/data/drift/app_db.dart
lib/data/drift/daos/conversation_dao.dart
lib/data/drift/daos/message_dao.dart
lib/data/drift/daos/participant_dao.dart
lib/data/drift/daos/pending_outbox_dao.dart
lib/data/drift/daos/receipt_dao.dart
lib/data/drift/entities/conversation.drift
lib/data/remote/supabase_client.dart
lib/data/repositories/group_repository.dart
lib/data/repositories/message_repository.dart
lib/data/repositories/receipt_repository.dart
lib/features/auth/screens/auth_screen.dart
lib/features/conversations/screens/conversations_list_screen.dart
lib/features/conversations/widgets/context_preview_card.dart
lib/features/conversations/widgets/message_bubble.dart
lib/features/conversations/widgets/relationship_summary_sheet.dart
lib/features/conversations/widgets/who_is_this_button.dart
lib/features/follow_ups/screens/follow_up_dashboard_screen.dart
lib/features/follow_ups/widgets/extract_follow_ups_button.dart
lib/features/follow_ups/widgets/follow_up_badge.dart
lib/features/messages/screens/message_screen.dart
lib/features/messages/widgets/ai_insights_background.dart
lib/features/messages/widgets/ai_insights_panel.dart
lib/features/messages/widgets/draft_feedback_panel.dart
lib/features/messages/widgets/evidence_viewer.dart
lib/features/messages/widgets/interpretation_options.dart
lib/features/messages/widgets/message_formatter_panel.dart
lib/features/messages/widgets/message_list_panel.dart
lib/features/messages/widgets/relationship_type_selector.dart
lib/features/messages/widgets/rsd_alert_card.dart
lib/features/messages/widgets/smart_inbox_panel.dart
lib/features/messages/widgets/template_picker.dart
lib/features/messages/widgets/tone_badge.dart
lib/features/messages/widgets/tone_detail_sheet_simplified.dart
lib/features/messages/widgets/tone_detail_sheet.dart
lib/features/notifications/widgets/notification_widgets.dart
lib/features/settings/screens/settings_screen.dart
lib/firebase_options.dart
lib/gen/api/api.dart
lib/gen/api/clients/messages_api.dart
lib/gen/api/clients/receipts_api.dart
lib/gen/api/models/message_payload.dart
lib/gen/api/models/receipt_payload.dart
lib/main.dart
lib/models/action_item.dart
lib/models/ai_analysis.dart
lib/models/context_trigger.dart
lib/models/conversation_context.dart
lib/models/draft_analysis.dart
lib/models/draft_confidence.dart
lib/models/follow_up_item.dart
lib/models/formatted_message.dart
lib/models/relationship_profile.dart
lib/models/response_template.dart
lib/models/safe_topic.dart
lib/models/situation_type.dart
lib/services/ai_analysis_service.dart
lib/services/auth_service.dart
lib/services/avatar_service.dart
lib/services/context_preloader_service.dart
lib/services/conversation_service.dart
lib/services/deep_link_handler.dart
lib/services/device_registration_service.dart
lib/services/draft_analysis_service.dart
lib/services/draft_confidence_service.dart
lib/services/follow_up_service.dart
lib/services/local_notification_service.dart
lib/services/media_service.dart
lib/services/message_formatter_service.dart
lib/services/message_interpreter_service.dart
lib/services/message_service.dart
lib/services/network_connectivity_service.dart
lib/services/notification_service.dart
lib/services/offline_queue_service.dart
lib/services/presence_service.dart
lib/services/realtime_diagnostic_service.dart
lib/services/realtime_message_service.dart
lib/services/relationship_service.dart
lib/services/relationship_summary_service.dart
lib/services/response_template_service.dart
lib/services/retry_service.dart
lib/services/typing_indicator_service.dart
lib/state/ai_providers.dart
lib/state/database_provider.dart
lib/state/notification_providers.dart
lib/state/presence_providers.dart
lib/state/providers.dart
lib/state/realtime_providers.dart
lib/state/repository_providers.dart
lib/state/send_queue.dart
lib/state/typing_providers.dart
lib/widgets/network_status_banner.dart
lib/widgets/sliding_panel.dart
lib/widgets/user_avatar.dart
Makefile
pubspec.yaml
test/models/action_item_test.dart
test/models/ai_analysis_enhanced_test.dart
test/models/ai_analysis_phase1_test.dart
test/models/ai_analysis_test.dart
test/models/conversation_context_test.dart
test/models/evidence_test.dart
test/models/follow_up_item_test.dart
test/models/message_interpretation_test.dart
test/models/relationship_profile_test.dart
test/models/rsd_trigger_test.dart
test/models/safe_topic_test.dart
test/offline_queue_test.dart
test/realtime_diagnostic_test.dart
test/services/ai_analysis_service_test.dart
test/services/context_preloader_service_test.dart
test/services/follow_up_service_test.dart
test/services/message_formatter_service_test.dart
test/services/relationship_service_test.dart
test/widget_test.dart
test/widgets/context_preview_card_test.dart
test/widgets/follow_up_card_test.dart
test/widgets/tone_badge_enhanced_test.dart
test/widgets/tone_badge_test.dart
test/widgets/who_is_this_button_test.dart
web/favicon.png
web/icons/Icon-192.png
web/icons/Icon-512.png
web/icons/Icon-maskable-192.png
web/icons/Icon-maskable-512.png
web/index.html
web/manifest.json
windows/.gitignore
windows/CMakeLists.txt
windows/flutter/CMakeLists.txt
windows/runner/CMakeLists.txt
windows/runner/flutter_window.cpp
windows/runner/flutter_window.h
windows/runner/main.cpp
windows/runner/resource.h
windows/runner/resources/app_icon.ico
windows/runner/runner.exe.manifest
windows/runner/Runner.rc
windows/runner/utils.cpp
windows/runner/utils.h
windows/runner/win32_window.cpp
windows/runner/win32_window.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.packages
.pub-cache/
.pub/
/build/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release

# iOS/macOS
**/ios/**/*.mode1v3
**/ios/**/*.mode2v3
**/ios/**/*.moved-aside
**/ios/**/*.pbxuser
**/ios/**/*.perspectivev3
**/ios/**/*sync/
**/ios/**/.sconsign.dblite
**/ios/**/.tags*
**/ios/**/.vscode/*
!**/ios/**/.vscode/extensions.json
**/ios/**/DerivedData/
**/ios/**/Flutter/Flutter.framework/*
**/ios/**/Flutter/Flutter.podspec
**/ios/**/Flutter/Generated.xcconfig
**/ios/**/Flutter/ephemeral/
**/ios/**/Flutter/app.flx
**/ios/**/Flutter/app.zip
**/ios/**/Flutter/flutter_assets/
**/ios/**/Flutter/flutter_export_environment.sh
**/ios/**/GoogleService-Info.plist
**/ios/**/ServiceAccount.json
**/ios/**/.symlinks/
**/ios/**/.vagrant
**/ios/**/Flutter/Flutter.framework
**/ios/**/Flutter/Flutter.podspec
**/ios/Podfile
**/ios/Podfile.lock

# Web
lib/generated_plugin_registrant.dart

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
**/android/app/debug
**/android/app/profile
**/android/app/release
**/android/app/outputs
**/android/.gradle
**/android/captures/
**/android/gradlew
**/android/gradlew.bat
**/android/gradle/wrapper/gradle-wrapper.jar
**/android/gradle/wrapper/gradle-wrapper.properties

# Firebase
google-services.json
GoogleService-Info.plist
**/android/app/google-services.json
**/ios/GoogleService-Info.plist

# Exceptions to above rules.
!/packages/flutter_tools/test/data/dart_dependencies_test/**/.packages

# Environment files
.env
.env.local
.env.*.local
.env.dev.json
.env.prod.json

# Generated code
*.g.dart
*.config.dart
*.freezed.dart
*.chopper.dart

# Drift related
.dart_tool/build
lib/data/drift/**/*.g.dart

# Coverage
coverage/
.coverage

# Exceptions to above rules.
!/packages/flutter_tools/test/data/dart_dependencies_test/**/.packages

# Xcode related
*.xcarchive
*.xcworkspace
xcuser.xcuserdatad

# Compiled output
*.app/
*.framework/
*.so
.symbols/

# Obfuscation
app.*.map.json

# macOS
.DS_Store
.AppleDouble
.LSOverride
*.mode1v3
*.mode2v3
*.moved-aside
*.pbxuser
*.perspectivev3
**/*.sconsign.dblite
.sconsign.dblite
dsa_cert.certSigningRequest
profile
DerivedData/
build/
Generated.xcconfig
GeneratedPluginRegistrant.swift

# iOS
**/ios/.symlinks/
**/ios/.vagrant
**/ios/**/Flutter/Flutter.framework
**/ios/**/Flutter/Flutter.podspec
**/ios/**/Flutter/Generated.xcconfig
**/ios/**/Flutter/generated_plugin_registrant.m
**/ios/**/Flutter/ephemeral/
**/ios/**/GoogleService-Info.plist
**/ios/**/ServiceAccount.json
**/ios/**/.sconsign.dblite
**/ios/**/.tags
**/ios/**/.vscode/*
!**/ios/**/.vscode/extensions.json
**/ios/**/Flutter/.last_build_id
**/ios/**/Flutter/app.flx
**/ios/**/Flutter/app.zip
**/ios/**/Flutter/flutter_assets/
**/ios/**/Flutter/flutter_export_environment.sh

# Android
**/android/app/debug
**/android/app/profile
**/android/app/release
**/android/app/outputs/
**/android/.gradle
**/android/captures/
**/android/gradle-app.setting
**/android/gradlew
**/android/gradlew.bat
**/android/gradle/wrapper/gradle-wrapper.jar
**/android/gradle/wrapper/gradle-wrapper.properties
**/android/local.properties

# Web
lib/generated_plugin_registrant.dart

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
**/android/**/gradle-wrapper.jar
**/android/gradle
**/android/gradlew
**/android/gradlew.bat
**/android/local.properties
**/android/**/GeneratedPluginRegistrant.java

# iOS/macOS
**/ios/**/*.mode1v3
**/ios/**/*.mode2v3
**/ios/**/.vscode/*
!**/ios/**/.vscode/extensions.json
**/ios/**/DerivedData/
**/ios/**/Flutter/Flutter.framework
**/ios/**/Flutter/Flutter.podspec
**/ios/**/Flutter/Generated.xcconfig
**/ios/**/Flutter/ephemeral/
**/ios/**/Flutter/app.flx
**/ios/**/Flutter/app.zip
**/ios/**/Flutter/flutter_assets/
**/ios/**/Flutter/flutter_export_environment.sh
**/ios/**/GoogleService-Info.plist
**/ios/**/ServiceAccount.json
**/ios/**/.symlinks/
**/ios/**/.vagrant
**/macos/Flutter/Flutter-Debug.xcconfig
**/macos/Flutter/Flutter-Release.xcconfig
**/macos/Flutter/GeneratedPluginRegistrant.swift

# Windows
windows/flutter/generated_plugin_registrant.cc
windows/flutter/generated_plugin_registrant.h
windows/flutter/generated_plugins.cmake

# Linux
linux/flutter/generated_plugin_registrant.cc
linux/flutter/generated_plugin_registrant.h
linux/flutter/generated_plugins.cmake

# Coverage
coverage/

# Symbols
app.*.symbols

# Local env files
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# VS Code settings
.vscode/*
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json

# misc
*.deb
*.dsc
*.buildinfo
*.changes
*.orig.*
/.dart_tool
/.flutter-plugins
/.flutter-plugins-dependencies
/.packages
/.pub-cache
/pubspec.lock
/build
/linux/flutter/generated_plugin_registrant.cc
/linux/flutter/generated_plugin_registrant.h
/linux/flutter/generated_plugins.cmake
/macos/Flutter/GeneratedPluginRegistrant.swift
/web/plugins.json
/windows/flutter/generated_plugin_registrant.cc
/windows/flutter/generated_plugin_registrant.h
/windows/flutter/generated_plugins.cmake

# Firebase & Google Services
**/GoogleService-Info.plist
**/google-services.json
**/ServiceAccount.json

# Temporary files
*.tmp
*.swp
*.swo
*~
.~*

# System
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
</file>

<file path=".metadata">
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "9f455d2486bcb28cad87b062475f42edc959f636"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: 9f455d2486bcb28cad87b062475f42edc959f636
      base_revision: 9f455d2486bcb28cad87b062475f42edc959f636
    - platform: windows
      create_revision: 9f455d2486bcb28cad87b062475f42edc959f636
      base_revision: 9f455d2486bcb28cad87b062475f42edc959f636

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'
</file>

<file path="analysis_options.yaml">
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options
</file>

<file path="android/.gitignore">
gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java
.cxx/

# Remember to never publicly share your keystore.
# See https://flutter.dev/to/reference-keystore
key.properties
**/*.keystore
**/*.jks
</file>

<file path="android/app/build.gradle.kts">
plugins {
    id("com.android.application")
    // START: FlutterFire Configuration
    id("com.google.gms.google-services")
    // END: FlutterFire Configuration
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.messageai"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
        isCoreLibraryDesugaringEnabled = true
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_11.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.example.messageai"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
        multiDexEnabled = true
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}

dependencies {
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.1.4")
    
    // Exclude sign_in_with_apple which uses deprecated Flutter APIs
    configurations.all {
        exclude(group = "com.aboutyou.dart_packages", module = "sign_in_with_apple")
    }
}
</file>

<file path="android/app/src/debug/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
</file>

<file path="android/app/src/main/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="messageai"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>
</file>

<file path="android/app/src/main/kotlin/com/example/messageai/MainActivity.kt">
package com.example.messageai

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()
</file>

<file path="android/app/src/main/res/drawable-v21/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
</file>

<file path="android/app/src/main/res/drawable/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
</file>

<file path="android/app/src/main/res/values-night/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="android/app/src/main/res/values/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="android/build.gradle.kts">
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}
</file>

<file path="android/gradle.properties">
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
android.enableJetifier=true
</file>

<file path="android/settings.gradle.kts">
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.9.1" apply false
    // START: FlutterFire Configuration
    id("com.google.gms.google-services") version("4.3.15") apply false
    // END: FlutterFire Configuration
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
}

include(":app")
</file>

<file path="devtools_options.yaml">
description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:
</file>

<file path="firebase.json">
{"flutter":{"platforms":{"android":{"default":{"projectId":"messageai-e2e9e","appId":"1:397483513751:android:bb838799a2cd3f7f1c56d2","fileOutput":"android/app/google-services.json"}},"dart":{"lib/firebase_options.dart":{"projectId":"messageai-e2e9e","configurations":{"android":"1:397483513751:android:bb838799a2cd3f7f1c56d2","web":"1:397483513751:web:3121cbb846ddd8381c56d2","windows":"1:397483513751:web:ba73c764d577f4f51c56d2"}}}}}}
</file>

<file path="integration_test/ai_flow_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/app.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('AI Analysis Integration Flow', () {
    testWidgets('app structure loads correctly', (tester) async {
      // Verify the app widget exists
      const app = MessageAIApp();
      
      // Basic structure test
      expect(app, isA<MessageAIApp>());
    });
    
    testWidgets('complete AI analysis flow - TODO', (tester) async {
      // This is a placeholder for a full integration test
      // To implement when backend is fully configured:
      // 
      // 1. Initialize Supabase with test credentials
      // 2. Login with test user
      // 3. Navigate to a test conversation
      // 4. Send a message: "Hello, how are you doing today?"
      // 5. Wait for AI analysis to complete (may take 3-5 seconds)
      // 6. Verify ToneBadge appears on the message bubble
      // 7. Tap the badge to open ToneDetailSheet
      // 8. Verify sheet shows: tone, urgency level, intent, confidence
      // 9. Close sheet and pull down the message panel
      // 10. Verify AIInsightsPanel shows conversation-level insights
      // 
      // Requirements:
      // - Supabase running with test database
      // - OpenAI API key configured in ai_analyze_tone Edge Function
      // - Test user account in auth.users table
      // - Test conversation and participants in database
      
      // TODO: Implement full flow when authentication is configured
      expect(true, isTrue); // Placeholder assertion
    });
  });
}
</file>

<file path="integration_test/all_phases_comprehensive_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';

import 'phase1_smart_interpreter_test.dart' as phase1;
import 'phase2_response_assistant_test.dart' as phase2;
import 'phase3_context_system_test.dart' as phase3;
import 'phase4_followup_system_test.dart' as phase4;

/// Comprehensive Integration Tests for All 4 Phases
/// Runs all phase tests in sequence
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('MessageAI - All Phases Comprehensive Tests', () {
    print('🚀 Starting Comprehensive Test Suite for All 4 Phases');
    print('================================================\n');

    group('Phase 1: Smart Message Interpreter', () {
      print('\n📝 Testing Phase 1: Smart Message Interpreter');
      print('  - Enhanced Tone Analysis (23 tones)');
      print('  - RSD Detection');
      print('  - Alternative Interpretations\n');
      
      phase1.main();
    });

    group('Phase 2: Adaptive Response Assistant', () {
      print('\n✍️  Testing Phase 2: Adaptive Response Assistant');
      print('  - Draft Confidence Checker');
      print('  - Social Scripts & Templates');
      print('  - Boundary Support\n');
      
      phase2.main();
    });

    group('Phase 3: Smart Inbox with Context', () {
      print('\n📚 Testing Phase 3: Smart Inbox with Context');
      print('  - Context Preloading');
      print('  - Relationship Memory');
      print('  - RAG System (Vector Search)\n');
      
      phase3.main();
    });

    group('Phase 4: Smart Follow-up System', () {
      print('\n✅ Testing Phase 4: Smart Follow-up System');
      print('  - Action Item Extraction');
      print('  - Question Detection');
      print('  - Follow-up Dashboard\n');
      
      phase4.main();
    });

    print('\n================================================');
    print('✅ All Phase Tests Complete!');
  });
}
</file>

<file path="integration_test/context_system_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/main.dart' as app;

/// Integration tests for Phase 3: Context System
///
/// These tests verify the complete flow of:
/// 1. Loading conversation context
/// 2. Displaying context preview card
/// 3. Opening relationship profiles
/// 4. Viewing safe topics and communication patterns
///
/// Prerequisites:
/// - Test Supabase instance with sample data
/// - Authenticated user session
/// - At least one conversation with messages
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Context System Integration Tests', () {
    testWidgets('Full context preview flow', (tester) async {
      // Start the app
      app.main();
      await tester.pumpAndSettle();

      // Wait for authentication/home screen
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to a conversation (adjust selector based on your UI)
      // This is a template - adjust based on your actual navigation
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Verify context preview card appears
        expect(find.text('Last Conversation'), findsOneWidget,
            reason: 'Context preview card should appear at top of messages');

        // Verify key points are displayed if available
        final recentTopicsFinder = find.text('Recent topics:');
        if (recentTopicsFinder.evaluate().isNotEmpty) {
          expect(recentTopicsFinder, findsOneWidget,
              reason: 'Recent topics section should be visible');
        }
      }
    });

    testWidgets('Relationship profile flow', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to a conversation
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Find and tap "Who is this?" button
        final whoIsThisButton = find.byTooltip('Who is this?');
        if (whoIsThisButton.evaluate().isNotEmpty) {
          await tester.tap(whoIsThisButton);
          await tester.pumpAndSettle();

          // Verify relationship sheet opens
          // Look for common elements that should be in the sheet
          await tester.pumpAndSettle(const Duration(seconds: 2));

          // Close the sheet
          final closeButton = find.byIcon(Icons.close);
          if (closeButton.evaluate().isNotEmpty) {
            await tester.tap(closeButton);
            await tester.pumpAndSettle();
          }
        }
      }
    });

    testWidgets('Context caching behavior', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Open a conversation
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Wait for context to load
        await tester.pumpAndSettle(const Duration(seconds: 2));

        // Go back
        final backButton = find.byTooltip('Back');
        if (backButton.evaluate().isNotEmpty) {
          await tester.tap(backButton);
          await tester.pumpAndSettle();

          // Open same conversation again
          await tester.tap(conversationFinder);
          await tester.pumpAndSettle();

          // Second load should be faster (cached)
          // Look for 'cached' indicator
          final cachedIndicator = find.text('cached');
          // Note: This may not always appear depending on timing
          await tester.pumpAndSettle();
        }
      }
    });

    testWidgets('Pending questions display', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to conversation with pending questions
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Look for pending questions badge
        final pendingQuestionsFinder = find.byIcon(Icons.help_outline);
        if (pendingQuestionsFinder.evaluate().isNotEmpty) {
          expect(pendingQuestionsFinder, findsOneWidget,
              reason: 'Pending questions indicator should be visible');

          // Verify text format
          final questionTextFinder = find.textContaining('unanswered question');
          expect(questionTextFinder, findsOneWidget,
              reason: 'Pending questions count should be displayed');
        }
      }
    });

    testWidgets('Safe topics display in relationship profile', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to conversation
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Open relationship profile
        final whoIsThisButton = find.byTooltip('Who is this?');
        if (whoIsThisButton.evaluate().isNotEmpty) {
          await tester.tap(whoIsThisButton);
          await tester.pumpAndSettle(const Duration(seconds: 2));

          // Look for safe topics section
          final safeTopicsFinder = find.text('Safe Topics');
          if (safeTopicsFinder.evaluate().isNotEmpty) {
            expect(safeTopicsFinder, findsOneWidget,
                reason: 'Safe topics section should be visible');
          }

          // Look for topics to avoid section
          final avoidTopicsFinder = find.text('Topics to Avoid');
          if (avoidTopicsFinder.evaluate().isNotEmpty) {
            expect(avoidTopicsFinder, findsOneWidget,
                reason: 'Topics to avoid section should be visible');
          }

          // Close the sheet
          final closeButton = find.byIcon(Icons.close);
          if (closeButton.evaluate().isNotEmpty) {
            await tester.tap(closeButton);
            await tester.pumpAndSettle();
          }
        }
      }
    });

    testWidgets('Context updates after sending message', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to conversation
      final conversationFinder = find.text('Test Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Note initial context
        await tester.pumpAndSettle(const Duration(seconds: 2));

        // Send a message
        final messageField = find.byType(TextField);
        if (messageField.evaluate().isNotEmpty) {
          await tester.enterText(messageField.first, 'Test message for context');
          await tester.testTextInput.receiveAction(TextInputAction.send);
          await tester.pumpAndSettle();

          // Context should eventually update
          // Note: In real scenario, this depends on backend processing
          await tester.pumpAndSettle(const Duration(seconds: 3));
        }
      }
    });
  });

  group('Error Handling Tests', () {
    testWidgets('Handles missing context gracefully', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Navigate to a new conversation with no context
      // Should not crash or show errors
      final conversationFinder = find.text('New Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Should show messages without context card
        expect(tester.takeException(), isNull,
            reason: 'Should handle missing context without crashing');
      }
    });

    testWidgets('Handles missing relationship profile', (tester) async {
      app.main();
      await tester.pumpAndSettle();
      await tester.pumpAndSettle(const Duration(seconds: 2));

      final conversationFinder = find.text('New Conversation').first;
      if (conversationFinder.evaluate().isNotEmpty) {
        await tester.tap(conversationFinder);
        await tester.pumpAndSettle();

        // Try to open relationship profile
        final whoIsThisButton = find.byTooltip('Who is this?');
        if (whoIsThisButton.evaluate().isNotEmpty) {
          await tester.tap(whoIsThisButton);
          await tester.pumpAndSettle(const Duration(seconds: 2));

          // Should show "No profile available" message
          final noProfileFinder = find.text('No profile available');
          if (noProfileFinder.evaluate().isNotEmpty) {
            expect(noProfileFinder, findsOneWidget);
          }

          // Close if needed
          final closeButton = find.byIcon(Icons.close);
          if (closeButton.evaluate().isNotEmpty) {
            await tester.tap(closeButton);
            await tester.pumpAndSettle();
          }
        }
      }
    });
  });
}
</file>

<file path="integration_test/enhanced_tone_analysis_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/features/messages/widgets/tone_detail_sheet.dart';
import 'package:flutter/material.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Enhanced Tone Analysis Integration Tests', () {
    testWidgets('Full flow: Parse analysis -> Display badge -> Show detail sheet',
        (tester) async {
      // Simulate API response with enhanced fields
      final apiResponse = {
        'id': 'analysis-123',
        'message_id': 'msg-456',
        'tone': 'Overwhelmed',
        'urgency_level': 'High',
        'intent': 'expressing severe stress about deadline',
        'confidence_score': 0.95,
        'analysis_timestamp': DateTime.now().millisecondsSinceEpoch ~/ 1000,
        'intensity': 'very_high',
        'secondary_tones': ['Frustrated', 'Concerned'],
        'context_flags': {
          'tone_indicator_present': true,
          'sarcasm_detected': false,
          'ambiguous': false,
        },
        'anxiety_assessment': {
          'risk_level': 'high',
          'mitigation_suggestions': [
            'Urgent tone detected. Consider asking for a specific timeline.',
            'Take a moment before responding to reduce pressure.',
          ],
        },
      };

      // 1. Parse the analysis
      final analysis = AIAnalysis.fromJson(apiResponse);
      expect(analysis.tone, 'Overwhelmed');
      expect(analysis.intensity, 'very_high');
      expect(analysis.contextFlags?['tone_indicator_present'], true);
      expect(analysis.anxietyAssessment?['risk_level'], 'high');

      // 2. Display in ToneBadge
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(
              analysis: analysis,
              onTap: () {},
            ),
          ),
        ),
      );

      expect(find.text('😵'), findsOneWidget, reason: 'Overwhelmed emoji');
      expect(find.text('Overwhelmed'), findsOneWidget);
      
      // Should have intensity and urgency dots
      final containers = tester.widgetList<Container>(find.byType(Container)).toList();
      final circleDots = containers.where((c) {
        final d = c.decoration;
        return d is BoxDecoration && d.shape == BoxShape.circle;
      }).length;
      expect(circleDots, greaterThanOrEqualTo(2));

      // 3. Show detail sheet
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: Builder(
              builder: (context) => ElevatedButton(
                onPressed: () {
                  ToneDetailSheet.show(
                    context,
                    analysis,
                    "I'm SO stressed about this deadline /srs",
                  );
                },
                child: const Text('Show Details'),
              ),
            ),
          ),
        ),
      );

      await tester.tap(find.text('Show Details'));
      await tester.pumpAndSettle();

      // Verify detail sheet content
      expect(find.text('AI Analysis'), findsOneWidget);
      expect(find.text('Overwhelmed'), findsOneWidget);
      expect(find.text('High'), findsOneWidget, reason: 'Urgency level');
      expect(find.text('Very High'), findsOneWidget, reason: 'Intensity formatted');
      
      // Check for anxiety assessment
      expect(find.textContaining('Response Anxiety'), findsOneWidget);
      expect(find.textContaining('HIGH'), findsOneWidget);
    });

    testWidgets('Playful tone with tone indicator /j', (tester) async {
      final apiResponse = {
        'id': 'analysis-789',
        'message_id': 'msg-012',
        'tone': 'Playful',
        'urgency_level': 'Low',
        'intent': 'joking about suggestion',
        'confidence_score': 0.92,
        'analysis_timestamp': DateTime.now().millisecondsSinceEpoch ~/ 1000,
        'intensity': 'medium',
        'context_flags': {
          'tone_indicator_present': true,
          'sarcasm_detected': false,
        },
        'anxiety_assessment': {
          'risk_level': 'low',
          'mitigation_suggestions': [],
        },
      };

      final analysis = AIAnalysis.fromJson(apiResponse);

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      expect(find.text('😜'), findsOneWidget, reason: 'Playful emoji');
      expect(find.text('Playful'), findsOneWidget);
    });

    testWidgets('Sarcastic tone detection', (tester) async {
      final apiResponse = {
        'id': 'analysis-sarcasm',
        'message_id': 'msg-sarcasm',
        'tone': 'Sarcastic',
        'urgency_level': 'Low',
        'intent': 'expressing frustration sarcastically',
        'confidence_score': 0.88,
        'analysis_timestamp': DateTime.now().millisecondsSinceEpoch ~/ 1000,
        'intensity': 'high',
        'context_flags': {
          'sarcasm_detected': true,
          'tone_indicator_present': true,
        },
        'anxiety_assessment': {
          'risk_level': 'medium',
          'mitigation_suggestions': [
            'Sarcasm detected. Literal meaning may differ.',
          ],
        },
      };

      final analysis = AIAnalysis.fromJson(apiResponse);

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      expect(find.text('🙄'), findsOneWidget, reason: 'Sarcastic emoji');
      expect(analysis.contextFlags?['sarcasm_detected'], true);
      expect(analysis.anxietyAssessment?['risk_level'], 'medium');
    });

    testWidgets('All 5 intensity levels display correctly', (tester) async {
      final intensities = ['very_low', 'low', 'medium', 'high', 'very_high'];

      for (final intensity in intensities) {
        final analysis = AIAnalysis(
          id: 'test-$intensity',
          messageId: 'msg-$intensity',
          tone: 'Friendly',
          intensity: intensity,
          analysisTimestamp: DateTime.now().millisecondsSinceEpoch ~/ 1000,
        );

        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: ToneBadge(analysis: analysis),
            ),
          ),
        );

        // Should display intensity dot
        final containers = tester.widgetList<Container>(find.byType(Container));
        final hasIntensityDot = containers.any((c) {
          final d = c.decoration;
          return d is BoxDecoration && d.shape == BoxShape.circle;
        });
        
        expect(hasIntensityDot, true, reason: 'Intensity dot for $intensity');
      }
    });

    testWidgets('Backward compatibility: Analysis without enhanced fields', (tester) async {
      // Old API response without enhanced fields
      final oldApiResponse = {
        'id': 'old-analysis',
        'message_id': 'old-msg',
        'tone': 'Friendly',
        'urgency_level': 'Low',
        'intent': 'greeting',
        'confidence_score': 0.85,
        'analysis_timestamp': DateTime.now().millisecondsSinceEpoch ~/ 1000,
      };

      final analysis = AIAnalysis.fromJson(oldApiResponse);
      expect(analysis.intensity, null);
      expect(analysis.contextFlags, null);

      // Should still display correctly
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      expect(find.text('😊'), findsOneWidget);
      expect(find.text('Friendly'), findsOneWidget);
    });
  });
}
</file>

<file path="integration_test/phase1_smart_interpreter_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/services/tone_analysis_service.dart';
import 'package:messageai/services/message_interpreter_service.dart';

/// Phase 1: Smart Message Interpreter Integration Tests
/// Tests: Enhanced Tone Analysis, RSD Detection, Alternative Interpretations
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Phase 1: Smart Message Interpreter', () {
    late ToneAnalysisService toneService;
    late MessageInterpreterService interpreterService;

    setUp(() {
      toneService = ToneAnalysisService();
      interpreterService = MessageInterpreterService();
    });

    group('Enhanced Tone Analysis (23 tones)', () {
      test('analyzes supportive message correctly', () async {
        final result = await toneService.analyzeTone(
          "You're doing great! I'm here to help if you need anything.",
        );

        expect(result, isNotNull);
        expect(result!.primaryTone, isIn(['supportive', 'encouraging', 'warm']));
        expect(result.intensity, greaterThan(0.5));
        expect(result.neurodivergentContext, isNotNull);
      });

      test('analyzes sarcastic message correctly', () async {
        final result = await toneService.analyzeTone(
          "Oh great, another meeting. Just what I needed today.",
        );

        expect(result, isNotNull);
        expect(result!.primaryTone, contains('sarcastic'));
        expect(result.confidence, greaterThan(0.6));
      });

      test('detects mixed tones', () async {
        final result = await toneService.analyzeTone(
          "I appreciate your help, but I'm a bit frustrated with the delay.",
        );

        expect(result, isNotNull);
        expect(result!.tones.length, greaterThanOrEqualTo(2));
        expect(result.tones, anyElement(contains('appreciative')));
        expect(result.tones, anyElement(contains('frustrated')));
      });

      test('provides neurodivergent-friendly context', () async {
        final result = await toneService.analyzeTone(
          "Can you send me that thing we talked about?",
        );

        expect(result, isNotNull);
        expect(result!.neurodivergentContext, isNotNull);
        expect(result.neurodivergentContext!.needsClarification, isTrue);
      });
    });

    group('RSD Detection', () {
      test('detects potential RSD trigger - criticism', () async {
        final result = await interpreterService.interpretMessage(
          "You didn't do this correctly.",
          senderName: 'Boss',
        );

        expect(result.rsdAlert, isNotNull);
        expect(result.rsdAlert!.triggerType, contains('criticism'));
        expect(result.rsdAlert!.severity, greaterThan(0.5));
      });

      test('detects potential RSD trigger - rejection', () async {
        final result = await interpreterService.interpretMessage(
          "I don't think this is a good fit for us right now.",
          senderName: 'Client',
        );

        expect(result.rsdAlert, isNotNull);
        expect(result.rsdAlert!.triggerType, contains('rejection'));
      });

      test('does not flag neutral messages', () async {
        final result = await interpreterService.interpretMessage(
          "The meeting is scheduled for 3pm tomorrow.",
          senderName: 'Colleague',
        );

        expect(result.rsdAlert, isNull);
      });

      test('provides coping strategies for RSD triggers', () async {
        final result = await interpreterService.interpretMessage(
          "Your work is consistently below expectations.",
          senderName: 'Manager',
        );

        expect(result.rsdAlert, isNotNull);
        expect(result.rsdAlert!.copingStrategies, isNotEmpty);
      });
    });

    group('Alternative Interpretations', () {
      test('provides multiple interpretations for ambiguous messages', () async {
        final result = await interpreterService.interpretMessage(
          "We need to talk.",
          senderName: 'Friend',
        );

        expect(result.alternativeInterpretations, isNotEmpty);
        expect(result.alternativeInterpretations.length, greaterThanOrEqualTo(2));
      });

      test('extracts evidence for each interpretation', () async {
        final result = await interpreterService.interpretMessage(
          "Thanks for your input. I'll consider it.",
          senderName: 'Boss',
        );

        for (final interpretation in result.alternativeInterpretations) {
          expect(interpretation.evidence, isNotEmpty);
          expect(interpretation.likelihood, greaterThan(0));
          expect(interpretation.likelihood, lessThanOrEqualTo(1));
        }
      });

      test('handles literal interpretation for neurodivergent users', () async {
        final result = await interpreterService.interpretMessage(
          "That's interesting.",
          senderName: 'Coworker',
        );

        expect(
          result.alternativeInterpretations,
          anyElement((interp) => interp.interpretation.contains('literal')),
        );
      });
    });

    group('Comprehensive Message Analysis', () {
      test('analyzes complex professional email', () async {
        final message = """
Hi there,

I wanted to follow up on our conversation from last week. 
While I appreciate your efforts, I think we need to reconsider 
our approach. Can we schedule a call to discuss?

Best regards
        """;

        final result = await interpreterService.interpretMessage(
          message,
          senderName: 'Project Lead',
        );

        expect(result.toneAnalysis, isNotNull);
        expect(result.alternativeInterpretations, isNotEmpty);
        // Should detect "reconsider" as potential concern
        expect(result.rsdAlert != null || result.toneAnalysis!.primaryTone.contains('concern'), isTrue);
      });

      test('analyzes casual message with emojis', () async {
        final result = await interpreterService.interpretMessage(
          "Hey! 😊 Just checking in. How's it going?",
          senderName: 'Friend',
        );

        expect(result.toneAnalysis, isNotNull);
        expect(result.toneAnalysis!.primaryTone, contains(['friendly', 'casual', 'warm']));
        expect(result.rsdAlert, isNull);
      });
    });
  });
}
</file>

<file path="integration_test/phase2_response_assistant_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/services/draft_confidence_service.dart';
import 'package:messageai/services/message_formatter_service.dart';

/// Phase 2: Adaptive Response Assistant Integration Tests
/// Tests: Draft Confidence Checker, Social Scripts, Boundary Support
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Phase 2: Adaptive Response Assistant', () {
    late DraftConfidenceService confidenceService;
    late MessageFormatterService formatterService;

    setUp(() {
      confidenceService = DraftConfidenceService();
      formatterService = MessageFormatterService();
    });

    group('Draft Confidence Checker', () {
      test('analyzes confident professional message', () async {
        final result = await confidenceService.analyzeDraft(
          "Thank you for your email. I'll review the proposal and send my feedback by Friday.",
        );

        expect(result, isNotNull);
        expect(result!.overallConfidence, greaterThan(0.7));
        expect(result.flags, isEmpty);
      });

      test('detects excessive apologizing', () async {
        final result = await confidenceService.analyzeDraft(
          "Sorry to bother you, I'm really sorry but I just wanted to ask if maybe you could possibly help me? Sorry!",
        );

        expect(result, isNotNull);
        expect(result!.flags, isNotEmpty);
        expect(
          result.flags,
          anyElement((flag) => flag.type.contains('excessive_apologizing')),
        );
        expect(result.overallConfidence, lessThan(0.5));
      });

      test('detects hedging language', () async {
        final result = await confidenceService.analyzeDraft(
          "I kind of think that maybe we should perhaps consider possibly doing this differently.",
        );

        expect(result, isNotNull);
        expect(
          result!.flags,
          anyElement((flag) => flag.type.contains('hedging')),
        );
        expect(result.suggestions, isNotEmpty);
      });

      test('detects self-deprecation', () async {
        final result = await confidenceService.analyzeDraft(
          "I'm not great at this, but here's my terrible attempt at solving the problem.",
        );

        expect(result, isNotNull);
        expect(
          result!.flags,
          anyElement((flag) => flag.type.contains('self_deprecating')),
        );
      });

      test('provides specific suggestions for improvement', () async {
        final result = await confidenceService.analyzeDraft(
          "Sorry, but I think maybe we could possibly try this?",
        );

        expect(result, isNotNull);
        expect(result!.suggestions, isNotEmpty);
        expect(result.improvedVersion, isNotNull);
        expect(result.improvedVersion, isNot(equals(result.suggestions.first)));
      });
    });

    group('Message Formatter with Templates', () {
      test('formats declining invitation message', () async {
        final result = await formatterService.formatMessage(
          situation: 'declining_invitation',
          context: 'dinner party',
          userInput: "I can't make it",
        );

        expect(result, isNotNull);
        expect(result.formattedMessage, isNotEmpty);
        expect(result.formattedMessage, contains(['thank', 'appreciate', 'unfortunately']));
        expect(result.tone, equals('polite'));
      });

      test('formats boundary setting message', () async {
        final result = await formatterService.formatMessage(
          situation: 'setting_boundary',
          context: 'work hours',
          userInput: "I don't work on weekends",
        );

        expect(result, isNotNull);
        expect(result.formattedMessage, isNotEmpty);
        expect(result.formattedMessage.toLowerCase(), contains(['weekend', 'time', 'balance']));
        expect(result.tone, equals('assertive'));
      });

      test('formats apologizing message', () async {
        final result = await formatterService.formatMessage(
          situation: 'apologizing',
          context: 'missed deadline',
          userInput: "I'm sorry for missing the deadline",
        );

        expect(result, isNotNull);
        expect(result.formattedMessage, contains(['apologize', 'sorry']));
        expect(result.actionItems, isNotEmpty);
      });

      test('formats info dump with structure', () async {
        final result = await formatterService.formatMessage(
          situation: 'info_dump',
          context: 'project explanation',
          userInput: "So there's this thing and it does stuff and also this other thing connects to it...",
        );

        expect(result, isNotNull);
        expect(result.formattedMessage, isNotEmpty);
        // Should have better structure
        expect(result.formattedMessage, contains(['\n', 'first', 'second', '1', '2']));
      });

      test('formats clarifying question', () async {
        final result = await formatterService.formatMessage(
          situation: 'asking_clarification',
          context: 'meeting details',
          userInput: "When is the meeting?",
        );

        expect(result, isNotNull);
        expect(result.formattedMessage, contains(['could', 'please', 'clarify', 'confirm']));
      });
    });

    group('Situation Detection', () {
      test('detects when user is declining', () async {
        final situation = await formatterService.detectSituation(
          "I don't think I can make it to the event",
        );

        expect(situation, isNotNull);
        expect(situation, equals('declining_invitation'));
      });

      test('detects when user is setting boundary', () async {
        final situation = await formatterService.detectSituation(
          "I need you to stop calling me after 9pm",
        );

        expect(situation, isNotNull);
        expect(situation, contains('boundary'));
      });

      test('detects when user is apologizing', () async {
        final situation = await formatterService.detectSituation(
          "I'm really sorry about the mistake I made",
        );

        expect(situation, isNotNull);
        expect(situation, contains('apolog'));
      });
    });

    group('Comprehensive Draft Analysis', () {
      test('analyzes and improves weak professional email', () async {
        final draft = """
Sorry to bother you! I was just wondering if maybe you might possibly 
have a moment to look at my work? I know you're super busy and I'm 
probably not doing this right, but I'd really appreciate it if you could 
possibly give me some feedback? Sorry again for bothering you!
        """;

        final result = await confidenceService.analyzeDraft(draft);

        expect(result, isNotNull);
        expect(result!.flags.length, greaterThanOrEqualTo(3));
        expect(result.overallConfidence, lessThan(0.4));
        expect(result.improvedVersion, isNotNull);
        expect(result.improvedVersion!.length, lessThan(draft.length));
      });

      test('validates strong professional message', () async {
        final draft = """
Hi Sarah,

I wanted to follow up on the project proposal we discussed. I've reviewed 
the requirements and have some suggestions that could improve efficiency.

Could we schedule a 30-minute call this week to discuss?

Best regards,
Alex
        """;

        final result = await confidenceService.analyzeDraft(draft);

        expect(result, isNotNull);
        expect(result!.overallConfidence, greaterThan(0.7));
        expect(result.flags, isEmpty);
      });
    });
  });
}
</file>

<file path="integration_test/phase3_context_system_test.dart">
import 'dart:math' show sqrt;
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/services/context_preloader_service.dart';
import 'package:messageai/services/relationship_summary_service.dart';

/// Phase 3: Smart Inbox with Context Integration Tests
/// Tests: Context Preloading, Relationship Memory, RAG System
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Phase 3: Smart Inbox with Context', () {
    late ContextPreloaderService contextService;
    late RelationshipSummaryService relationshipService;

    setUp(() {
      contextService = ContextPreloaderService();
      relationshipService = RelationshipSummaryService();
    });

    group('Context Preloader', () {
      test('preloads context for conversation', () async {
        final context = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        expect(context, isNotNull);
        expect(context.conversationId, equals('test-conv-123'));
        expect(context.summary, isNotNull);
      });

      test('identifies key topics from conversation history', () async {
        final context = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        expect(context.keyTopics, isNotEmpty);
        expect(context.keyTopics.length, lessThanOrEqualTo(5));
      });

      test('detects recent action items from history', () async {
        final context = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        expect(context.recentActionItems, isNotNull);
      });

      test('identifies unanswered questions', () async {
        final context = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        expect(context.unansweredQuestions, isNotNull);
      });

      test('provides relationship context', () async {
        final context = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        expect(context.relationshipSummary, isNotNull);
        expect(context.relationshipSummary!.communicationStyle, isNotEmpty);
      });

      test('caches context for performance', () async {
        // First call
        final start1 = DateTime.now();
        await contextService.preloadContext(conversationId: 'test-conv-123');
        final duration1 = DateTime.now().difference(start1);

        // Second call (should be cached)
        final start2 = DateTime.now();
        await contextService.preloadContext(conversationId: 'test-conv-123');
        final duration2 = DateTime.now().difference(start2);

        expect(duration2.inMilliseconds, lessThan(duration1.inMilliseconds));
      });
    });

    group('Relationship Summary', () {
      test('generates relationship profile', () async {
        final summary = await relationshipService.generateSummary(
          conversationId: 'test-conv-123',
        );

        expect(summary, isNotNull);
        expect(summary.communicationStyle, isNotEmpty);
        expect(summary.relationshipType, isNotEmpty);
      });

      test('detects professional relationship', () async {
        final summary = await relationshipService.generateSummary(
          conversationId: 'work-conv-456',
        );

        expect(summary, isNotNull);
        expect(summary.relationshipType.toLowerCase(), contains(['professional', 'work', 'colleague']));
      });

      test('detects casual/friend relationship', () async {
        final summary = await relationshipService.generateSummary(
          conversationId: 'friend-conv-789',
        );

        expect(summary, isNotNull);
        expect(summary.relationshipType.toLowerCase(), contains(['friend', 'casual', 'personal']));
      });

      test('identifies communication preferences', () async {
        final summary = await relationshipService.generateSummary(
          conversationId: 'test-conv-123',
        );

        expect(summary.communicationStyle, isNotEmpty);
        expect(summary.communicationStyle, contains(['formal', 'casual', 'direct', 'detailed']));
      });

      test('tracks shared topics and interests', () async {
        final summary = await relationshipService.generateSummary(
          conversationId: 'test-conv-123',
        );

        expect(summary.sharedTopics, isNotEmpty);
      });

      test('provides conversation history stats', () async {
        final summary = await relationshipService.generateSummary(
          conversationId: 'test-conv-123',
        );

        expect(summary.messageCount, greaterThan(0));
        expect(summary.lastInteractionAt, isNotNull);
      });
    });

    group('RAG (Vector Search)', () {
      test('finds relevant past messages by semantic similarity', () async {
        final results = await contextService.searchSimilarMessages(
          query: 'project deadline',
          conversationId: 'test-conv-123',
        );

        expect(results, isNotEmpty);
        expect(results.length, lessThanOrEqualTo(5));
      });

      test('ranks results by relevance', () async {
        final results = await contextService.searchSimilarMessages(
          query: 'meeting schedule',
          conversationId: 'test-conv-123',
        );

        expect(results, isNotEmpty);
        // Should be sorted by relevance score
        for (int i = 0; i < results.length - 1; i++) {
          expect(
            results[i].relevanceScore,
            greaterThanOrEqualTo(results[i + 1].relevanceScore),
          );
        }
      });

      test('searches across all conversations when not limited', () async {
        final results = await contextService.searchSimilarMessages(
          query: 'vacation plans',
          // No conversationId specified = search all
        );

        expect(results, isNotEmpty);
        // Should include results from multiple conversations
        final conversationIds = results.map((r) => r.conversationId).toSet();
        expect(conversationIds.length, greaterThanOrEqualTo(1));
      });
    });

    group('Embeddings Generation', () {
      test('generates embeddings for new message', () async {
        final embedding = await contextService.generateEmbedding(
          'This is a test message about project planning',
        );

        expect(embedding, isNotNull);
        expect(embedding.vector, isNotEmpty);
        expect(embedding.vector.length, equals(1536)); // OpenAI embedding size
      });

      test('similar messages have similar embeddings', () async {
        final embedding1 = await contextService.generateEmbedding(
          'Let\'s schedule a meeting for next week',
        );
        final embedding2 = await contextService.generateEmbedding(
          'Can we set up a meeting next week?',
        );
        final embedding3 = await contextService.generateEmbedding(
          'I love pizza and ice cream',
        );

        final similarity12 = _cosineSimilarity(embedding1.vector, embedding2.vector);
        final similarity13 = _cosineSimilarity(embedding1.vector, embedding3.vector);

        expect(similarity12, greaterThan(similarity13));
      });
    });

    group('Comprehensive Context System', () {
      test('provides full context for conversation', () async {
        final context = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        // Should have all components
        expect(context.summary, isNotEmpty);
        expect(context.keyTopics, isNotEmpty);
        expect(context.relationshipSummary, isNotNull);
        expect(context.recentActionItems, isNotNull);
        expect(context.unansweredQuestions, isNotNull);
      });

      test('handles conversations with no history gracefully', () async {
        final context = await contextService.preloadContext(
          conversationId: 'new-conv-999',
        );

        expect(context, isNotNull);
        expect(context.summary, isNotEmpty); // Should have default message
        expect(context.keyTopics, isEmpty);
      });

      test('updates context when new messages arrive', () async {
        // Get initial context
        final context1 = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        // Simulate new message
        await contextService.invalidateCache('test-conv-123');

        // Get updated context
        final context2 = await contextService.preloadContext(
          conversationId: 'test-conv-123',
        );

        expect(context2, isNotNull);
        // Cache should be refreshed
      });
    });
  });
}

/// Helper function to calculate cosine similarity
double _cosineSimilarity(List<double> a, List<double> b) {
  if (a.length != b.length) return 0.0;

  double dotProduct = 0.0;
  double normA = 0.0;
  double normB = 0.0;

  for (int i = 0; i < a.length; i++) {
    dotProduct += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }

  if (normA == 0.0 || normB == 0.0) return 0.0;

  return dotProduct / (sqrt(normA) * sqrt(normB));
}
</file>

<file path="integration_test/phase4_followup_system_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:messageai/services/follow_up_service.dart';
import 'package:messageai/models/follow_up_item.dart';

/// Phase 4: Smart Follow-up System Integration Tests
/// Tests: Action Item Extraction, Question Detection, Follow-up Dashboard
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Phase 4: Smart Follow-up System', () {
    late FollowUpService followUpService;

    setUp(() {
      followUpService = FollowUpService();
    });

    group('Action Item Extraction', () {
      test('extracts "I\'ll" commitment', () async {
        await followUpService.extractFollowUps('test-conv-123');
        
        // After extraction, check if items were created
        final items = await followUpService.getConversationFollowUps('test-conv-123');
        
        final actionItems = items.where(
          (item) => item.itemType == FollowUpItemType.actionItem,
        ).toList();

        expect(actionItems, isNotEmpty);
      });

      test('extracts "I can" commitment', () async {
        await followUpService.extractFollowUps('test-conv-456');
        
        final items = await followUpService.getConversationFollowUps('test-conv-456');
        expect(items, isNotEmpty);
      });

      test('extracts action with target', () async {
        await followUpService.extractFollowUps('test-conv-789');
        
        final items = await followUpService.getConversationFollowUps('test-conv-789');
        final actionItems = items.where(
          (item) => item.itemType == FollowUpItemType.actionItem,
        ).toList();

        if (actionItems.isNotEmpty) {
          expect(actionItems.first.title, isNotEmpty);
        }
      });

      test('extracts deadline when mentioned', () async {
        // Message: "I'll send the report by Friday"
        await followUpService.extractFollowUps('test-conv-deadline');
        
        final items = await followUpService.getConversationFollowUps('test-conv-deadline');
        final actionItems = items.where(
          (item) => item.itemType == FollowUpItemType.actionItem && item.dueAt != null,
        ).toList();

        if (actionItems.isNotEmpty) {
          expect(actionItems.first.dueAt, isNotNull);
        }
      });

      test('does not extract non-commitments', () async {
        // Message: "You should send the report"
        await followUpService.extractFollowUps('test-conv-no-commit');
        
        final items = await followUpService.getConversationFollowUps('test-conv-no-commit');
        final myCommitments = items.where(
          (item) => item.itemType == FollowUpItemType.actionItem,
        ).toList();

        // Should not extract third-person suggestions
        expect(myCommitments.length, lessThanOrEqualTo(0));
      });
    });

    group('Unanswered Question Detection', () {
      test('detects question without response', () async {
        await followUpService.extractFollowUps('test-conv-question');
        
        final items = await followUpService.getConversationFollowUps('test-conv-question');
        final questions = items.where(
          (item) => item.itemType == FollowUpItemType.unansweredQuestion,
        ).toList();

        expect(questions, isNotEmpty);
      });

      test('identifies "when" questions', () async {
        await followUpService.extractFollowUps('test-conv-when');
        
        final items = await followUpService.getConversationFollowUps('test-conv-when');
        final questions = items.where(
          (item) => item.itemType == FollowUpItemType.unansweredQuestion,
        ).toList();

        if (questions.isNotEmpty) {
          expect(questions.first.description, contains('when'));
        }
      });

      test('identifies "what" questions', () async {
        await followUpService.extractFollowUps('test-conv-what');
        
        final items = await followUpService.getConversationFollowUps('test-conv-what');
        expect(items, isNotEmpty);
      });

      test('does not flag answered questions', () async {
        // Conversation with question and answer
        await followUpService.extractFollowUps('test-conv-answered');
        
        final items = await followUpService.getConversationFollowUps('test-conv-answered');
        final unansweredQuestions = items.where(
          (item) => item.itemType == FollowUpItemType.unansweredQuestion,
        ).toList();

        // Should be empty if question was answered
        expect(unansweredQuestions.length, lessThanOrEqualTo(0));
      });
    });

    group('Follow-up Management', () {
      test('retrieves pending follow-ups', () async {
        final items = await followUpService.getPendingFollowUps();
        
        expect(items, isList);
        // All should be pending status
        for (final item in items) {
          expect(item.status, equals(FollowUpStatus.pending));
        }
      });

      test('retrieves follow-ups for specific conversation', () async {
        final items = await followUpService.getConversationFollowUps('test-conv-123');
        
        expect(items, isList);
        for (final item in items) {
          expect(item.conversationId, equals('test-conv-123'));
        }
      });

      test('completes follow-up item', () async {
        final items = await followUpService.getPendingFollowUps();
        if (items.isNotEmpty) {
          final item = items.first;
          
          await followUpService.completeFollowUp(item.id);
          
          // Verify it's no longer in pending list
          final updatedItems = await followUpService.getPendingFollowUps();
          expect(
            updatedItems.any((i) => i.id == item.id),
            isFalse,
          );
        }
      });

      test('snoozes follow-up item', () async {
        final items = await followUpService.getPendingFollowUps();
        if (items.isNotEmpty) {
          final item = items.first;
          
          await followUpService.snoozeFollowUp(
            item.id,
            const Duration(hours: 1),
          );
          
          // Verify it's snoozed
          final updatedItems = await followUpService.getPendingFollowUps();
          expect(
            updatedItems.any((i) => i.id == item.id),
            isFalse,
          );
        }
      });

      test('dismisses follow-up item', () async {
        final items = await followUpService.getPendingFollowUps();
        if (items.isNotEmpty) {
          final item = items.first;
          
          await followUpService.dismissFollowUp(item.id);
          
          // Verify it's dismissed
          final updatedItems = await followUpService.getPendingFollowUps();
          expect(
            updatedItems.any((i) => i.id == item.id),
            isFalse,
          );
        }
      });
    });

    group('Follow-up Item Properties', () {
      test('identifies overdue items', () async {
        final items = await followUpService.getPendingFollowUps();
        
        // Check if any items have proper overdue detection
        for (final item in items) {
          if (item.dueAt != null) {
            final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
            final isOverdue = now > item.dueAt!;
            expect(item.isOverdue, equals(isOverdue));
          }
        }
      });

      test('identifies due soon items', () async {
        final items = await followUpService.getPendingFollowUps();
        
        for (final item in items) {
          if (item.dueAt != null) {
            final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
            final hoursUntilDue = (item.dueAt! - now) / 3600;
            final isDueSoon = hoursUntilDue > 0 && hoursUntilDue <= 24;
            expect(item.isDueSoon, equals(isDueSoon));
          }
        }
      });

      test('calculates time until due correctly', () async {
        final items = await followUpService.getPendingFollowUps();
        
        for (final item in items) {
          if (item.dueAt != null) {
            final timeStr = item.getTimeUntilDue();
            expect(timeStr, isNotEmpty);
            
            if (item.isOverdue) {
              expect(timeStr, equals('Overdue'));
            } else {
              expect(timeStr, matches(RegExp(r'\d+[mhd]')));
            }
          }
        }
      });

      test('calculates time since detected correctly', () async {
        final items = await followUpService.getPendingFollowUps();
        
        for (final item in items) {
          final timeStr = item.getTimeSinceDetected();
          expect(timeStr, isNotEmpty);
          expect(timeStr, contains('ago'));
        }
      });
    });

    group('Priority and Sorting', () {
      test('assigns priority to follow-ups', () async {
        final items = await followUpService.getPendingFollowUps();
        
        for (final item in items) {
          expect(item.priority, greaterThanOrEqualTo(0));
          expect(item.priority, lessThanOrEqualTo(100));
        }
      });

      test('overdue items have high priority', () async {
        final items = await followUpService.getPendingFollowUps();
        final overdueItems = items.where((item) => item.isOverdue).toList();
        
        for (final item in overdueItems) {
          expect(item.priority, greaterThan(60));
        }
      });
    });

    group('Comprehensive Follow-up System', () {
      test('handles conversation with multiple follow-up types', () async {
        // Conversation with: action item, question, and pending response
        await followUpService.extractFollowUps('test-conv-mixed');
        
        final items = await followUpService.getConversationFollowUps('test-conv-mixed');
        
        expect(items, isNotEmpty);
        
        // Should have different types
        final types = items.map((item) => item.itemType).toSet();
        expect(types.length, greaterThanOrEqualTo(1));
      });

      test('prevents duplicate extraction', () async {
        // Extract twice
        await followUpService.extractFollowUps('test-conv-duplicate');
        await followUpService.extractFollowUps('test-conv-duplicate');
        
        final items = await followUpService.getConversationFollowUps('test-conv-duplicate');
        
        // Should not have duplicates (check by unique IDs)
        final ids = items.map((item) => item.id).toList();
        expect(ids.length, equals(ids.toSet().length));
      });

      test('handles empty conversation', () async {
        await followUpService.extractFollowUps('empty-conv');
        
        final items = await followUpService.getConversationFollowUps('empty-conv');
        
        expect(items, isEmpty);
      });

      test('handles conversation with no follow-ups', () async {
        // Conversation with only statements, no questions or commitments
        await followUpService.extractFollowUps('test-conv-no-followups');
        
        final items = await followUpService.getConversationFollowUps('test-conv-no-followups');
        
        expect(items.length, lessThanOrEqualTo(0));
      });
    });
  });
}
</file>

<file path="lib/app.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/features/auth/screens/auth_screen.dart';
import 'package:messageai/features/conversations/screens/conversations_list_screen.dart';
import 'package:messageai/features/messages/screens/message_screen.dart';
import 'package:messageai/features/follow_ups/screens/follow_up_dashboard_screen.dart';
import 'package:messageai/state/providers.dart';
import 'package:messageai/services/device_registration_service.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

/// Global navigator key for deep linking and navigation from notifications
final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

/// Main application widget with lifecycle monitoring
class MessageAIApp extends ConsumerStatefulWidget {
  const MessageAIApp({Key? key}) : super(key: key);

  @override
  ConsumerState<MessageAIApp> createState() => _MessageAIAppState();
}

class _MessageAIAppState extends ConsumerState<MessageAIApp> with WidgetsBindingObserver {
  final _deviceRegistration = DeviceRegistrationService();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    // Update last_seen on app launch
    _updateLastSeen();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      // App came to foreground - update last_seen
      _updateLastSeen();
    }
  }

  Future<void> _updateLastSeen() async {
    try {
      print('⏰ Updating device last_seen...');
      final token = await FirebaseMessaging.instance.getToken();
      if (token != null) {
        await _deviceRegistration.updateDeviceLastSeen(token);
        print('✅ Device last_seen updated');
      } else {
        print('⚠️ No FCM token available');
      }
    } catch (e) {
      print('❌ Failed to update last_seen: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'MessageAI',
      navigatorKey: navigatorKey,
      theme: AppTheme.lightTheme,
      darkTheme: AppTheme.darkTheme,
      themeMode: ThemeMode.system,
      home: const AuthGate(),
      routes: {
        '/auth': (_) => AuthScreen(onAuthSuccess: () {}),
        '/conversations': (_) => const ConversationsListScreen(),
        '/follow-ups': (_) => const FollowUpDashboardScreen(),
      },
      // ✅ Handle dynamic routes for deep linking (e.g., /conversation/:id)
      onGenerateRoute: (settings) {
        // Handle conversation deep links
        if (settings.name?.startsWith('/conversation/') ?? false) {
          final conversationId = settings.name!.split('/').last;
          
          print('🔗 Deep link: navigating to conversation $conversationId');
          
          return MaterialPageRoute(
            builder: (_) => MessageScreen(
              conversationId: conversationId,
              conversationTitle: 'Chat', // Will be loaded by screen
            ),
            settings: settings,
          );
        }
        
        // Return null for unknown routes (will show error page)
        return null;
      },
    );
  }
}

/// Widget that routes between auth and main screens based on session
class AuthGate extends ConsumerWidget {
  const AuthGate({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isAuthenticated = ref.watch(isAuthenticatedProvider);

    return isAuthenticated.when(
      data: (authenticated) {
        if (authenticated) {
          return const ConversationsListScreen();
        } else {
          return AuthScreen(
            onAuthSuccess: () {
              // Refresh auth state - this will trigger a rebuild
              ref.refresh(isAuthenticatedProvider);
            },
          );
        }
      },
      loading: () {
        return Scaffold(
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.chat_bubble,
                  size: 64,
                  color: Theme.of(context).colorScheme.primary,
                ),
                const SizedBox(height: 24),
                Text(
                  'MessageAI',
                  style: Theme.of(context).textTheme.headlineSmall,
                ),
                const SizedBox(height: 32),
                const CircularProgressIndicator(),
              ],
            ),
          ),
        );
      },
      error: (error, stackTrace) {
        return Scaffold(
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.error_outline,
                  size: 64,
                  color: Theme.of(context).colorScheme.error,
                ),
                const SizedBox(height: 24),
                Text(
                  'Error',
                  style: Theme.of(context).textTheme.headlineSmall,
                ),
                const SizedBox(height: 16),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 24),
                  child: Text(
                    error.toString(),
                    textAlign: TextAlign.center,
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}
</file>

<file path="lib/core/env.dart">
/// Environment configuration for Supabase connection.
/// 
/// Reads SUPABASE_URL and SUPABASE_ANON_KEY from:
/// 1. Dart defines (via --dart-define-from-file=.env.dev.json)
/// 2. Environment variables as fallback

class Env {
  static const String supabaseUrl = String.fromEnvironment(
    'SUPABASE_URL',
    defaultValue: 'https://your-project.supabase.co',
  );

  static const String supabaseAnonKey = String.fromEnvironment(
    'SUPABASE_ANON_KEY',
    defaultValue: 'your-anon-key',
  );

  // Validate that required config is present
  static void validate() {
    assert(
      supabaseUrl != 'https://your-project.supabase.co',
      'SUPABASE_URL not configured',
    );
    assert(
      supabaseAnonKey != 'your-anon-key',
      'SUPABASE_ANON_KEY not configured',
    );
  }
}
</file>

<file path="lib/core/errors/app_error.dart">
/// Application error types and models
/// Provides structured error handling across the app

/// Error categories for classification
enum ErrorCategory {
  auth,
  network,
  database,
  messaging,
  storage,
  permission,
  validation,
  unknown,
}

/// Error severity levels
enum ErrorSeverity {
  info,     // Informational, no action required
  warning,  // Warning, user should be aware
  error,    // Error, user action may help
  critical, // Critical, likely requires app restart or support
}

/// Structured application error
class AppError implements Exception {
  final ErrorCategory category;
  final ErrorSeverity severity;
  final String code;
  final String message;
  final String? userMessage;
  final dynamic originalError;
  final StackTrace? stackTrace;
  final Map<String, dynamic>? context;
  final bool isRetryable;

  const AppError({
    required this.category,
    required this.severity,
    required this.code,
    required this.message,
    this.userMessage,
    this.originalError,
    this.stackTrace,
    this.context,
    this.isRetryable = false,
  });

  /// Get user-friendly error message
  String get displayMessage => userMessage ?? message;

  /// Check if error requires user action
  bool get requiresUserAction => 
      severity == ErrorSeverity.error || 
      severity == ErrorSeverity.critical;

  @override
  String toString() {
    return 'AppError($category.$code): $message';
  }

  /// Copy with modifications
  AppError copyWith({
    ErrorCategory? category,
    ErrorSeverity? severity,
    String? code,
    String? message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    Map<String, dynamic>? context,
    bool? isRetryable,
  }) {
    return AppError(
      category: category ?? this.category,
      severity: severity ?? this.severity,
      code: code ?? this.code,
      message: message ?? this.message,
      userMessage: userMessage ?? this.userMessage,
      originalError: originalError ?? this.originalError,
      stackTrace: stackTrace ?? this.stackTrace,
      context: context ?? this.context,
      isRetryable: isRetryable ?? this.isRetryable,
    );
  }
}

/// Authentication errors
class AuthError extends AppError {
  AuthError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = false,
  }) : super(
          category: ErrorCategory.auth,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory AuthError.invalidCredentials() => AuthError(
        code: 'AUTH001',
        message: 'Invalid email or password',
        userMessage: 'The email or password you entered is incorrect. Please try again.',
      );

  factory AuthError.emailAlreadyExists() => AuthError(
        code: 'AUTH002',
        message: 'Email already registered',
        userMessage: 'An account with this email already exists. Try signing in instead.',
      );

  factory AuthError.weakPassword() => AuthError(
        code: 'AUTH003',
        message: 'Password too weak',
        userMessage: 'Please choose a stronger password (at least 6 characters).',
      );

  factory AuthError.invalidEmail() => AuthError(
        code: 'AUTH004',
        message: 'Invalid email format',
        userMessage: 'Please enter a valid email address.',
      );

  factory AuthError.sessionExpired() => AuthError(
        code: 'AUTH005',
        message: 'Session expired',
        userMessage: 'Your session has expired. Please sign in again.',
      );

  factory AuthError.networkError() => AuthError(
        code: 'AUTH006',
        message: 'Network error during authentication',
        userMessage: 'Unable to connect. Please check your internet connection and try again.',
        isRetryable: true,
      );

  factory AuthError.unknown(dynamic error) => AuthError(
        code: 'AUTH999',
        message: 'Unknown authentication error',
        userMessage: 'Something went wrong during authentication. Please try again.',
        originalError: error,
        isRetryable: true,
      );
}

/// Network errors
class NetworkError extends AppError {
  NetworkError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
  }) : super(
          category: ErrorCategory.network,
          severity: ErrorSeverity.warning,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: true,
        );

  factory NetworkError.noConnection() => NetworkError(
        code: 'NET001',
        message: 'No internet connection',
        userMessage: 'No internet connection. Please check your network settings.',
      );

  factory NetworkError.timeout() => NetworkError(
        code: 'NET002',
        message: 'Request timeout',
        userMessage: 'The request took too long. Please try again.',
      );

  factory NetworkError.serverError() => NetworkError(
        code: 'NET003',
        message: 'Server error',
        userMessage: 'Server is temporarily unavailable. Please try again later.',
      );
}

/// Message sending errors
class MessageError extends AppError {
  MessageError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = true,
  }) : super(
          category: ErrorCategory.messaging,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory MessageError.sendFailed() => MessageError(
        code: 'MSG001',
        message: 'Failed to send message',
        userMessage: 'Unable to send message. Please try again.',
      );

  factory MessageError.networkError() => MessageError(
        code: 'MSG002',
        message: 'Network error while sending message',
        userMessage: 'Message saved offline. It will send when you\'re back online.',
      );

  factory MessageError.unauthorized() => MessageError(
        code: 'MSG003',
        message: 'Not authorized to send message',
        userMessage: 'You don\'t have permission to send messages to this conversation.',
        isRetryable: false,
      );

  factory MessageError.conversationNotFound() => MessageError(
        code: 'MSG004',
        message: 'Conversation not found',
        userMessage: 'This conversation no longer exists.',
        isRetryable: false,
      );

  factory MessageError.mediaTooLarge() => MessageError(
        code: 'MSG005',
        message: 'Media file too large',
        userMessage: 'The image is too large. Please choose a smaller file.',
        isRetryable: false,
      );

  factory MessageError.mediaUploadFailed() => MessageError(
        code: 'MSG006',
        message: 'Failed to upload media',
        userMessage: 'Unable to upload image. Please try again.',
      );
}

/// Storage errors
class StorageError extends AppError {
  StorageError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = true,
  }) : super(
          category: ErrorCategory.storage,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory StorageError.uploadFailed() => StorageError(
        code: 'STR001',
        message: 'Upload failed',
        userMessage: 'Unable to upload file. Please try again.',
      );

  factory StorageError.fileTooLarge() => StorageError(
        code: 'STR002',
        message: 'File too large',
        userMessage: 'The file is too large. Maximum size is 10MB.',
        isRetryable: false,
      );

  factory StorageError.unsupportedFormat() => StorageError(
        code: 'STR003',
        message: 'Unsupported file format',
        userMessage: 'This file type is not supported. Please use JPG, PNG, or GIF.',
        isRetryable: false,
      );
}

/// Database errors
class DatabaseError extends AppError {
  DatabaseError({
    required String code,
    required String message,
    String? userMessage,
    dynamic originalError,
    StackTrace? stackTrace,
    bool isRetryable = true,
  }) : super(
          category: ErrorCategory.database,
          severity: ErrorSeverity.error,
          code: code,
          message: message,
          userMessage: userMessage,
          originalError: originalError,
          stackTrace: stackTrace,
          isRetryable: isRetryable,
        );

  factory DatabaseError.queryFailed() => DatabaseError(
        code: 'DB001',
        message: 'Database query failed',
        userMessage: 'Unable to fetch data. Please try again.',
      );

  factory DatabaseError.syncFailed() => DatabaseError(
        code: 'DB002',
        message: 'Sync failed',
        userMessage: 'Unable to sync data. Your changes are saved locally.',
      );
}

/// Permission errors
class PermissionError extends AppError {
  PermissionError({
    required String code,
    required String message,
    String? userMessage,
    bool isRetryable = false,
  }) : super(
          category: ErrorCategory.permission,
          severity: ErrorSeverity.warning,
          code: code,
          message: message,
          userMessage: userMessage,
          isRetryable: isRetryable,
        );

  factory PermissionError.cameraNotGranted() => PermissionError(
        code: 'PERM001',
        message: 'Camera permission not granted',
        userMessage: 'Camera access is required. Please enable it in Settings.',
      );

  factory PermissionError.storageNotGranted() => PermissionError(
        code: 'PERM002',
        message: 'Storage permission not granted',
        userMessage: 'Storage access is required. Please enable it in Settings.',
      );

  factory PermissionError.notificationsNotGranted() => PermissionError(
        code: 'PERM003',
        message: 'Notification permission not granted',
        userMessage: 'Enable notifications to receive message alerts.',
      );
}
</file>

<file path="lib/core/errors/error_handler.dart">
import 'package:messageai/core/errors/app_error.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

/// Global error handler service
class ErrorHandler {
  static final ErrorHandler _instance = ErrorHandler._internal();

  factory ErrorHandler() {
    return _instance;
  }

  ErrorHandler._internal();

  /// Convert any error to AppError
  AppError handleError(dynamic error, {StackTrace? stackTrace, String? context}) {
    AppError appError;

    if (error is AppError) {
      appError = error;
    } else if (error is AuthException) {
      appError = _handleAuthException(error);
    } else if (error is PostgrestException) {
      appError = _handlePostgrestException(error);
    } else if (error is StorageException) {
      appError = _handleStorageException(error);
    } else if (error is String) {
      appError = _handleStringError(error);
    } else {
      appError = _handleUnknownError(error);
    }

    // Log error
    _logError(appError, stackTrace, context);

    return appError;
  }

  /// Handle Supabase Auth exceptions
  AppError _handleAuthException(AuthException error) {
    final message = error.message.toLowerCase();

    if (message.contains('invalid login credentials') ||
        message.contains('invalid email or password')) {
      return AuthError.invalidCredentials();
    } else if (message.contains('already registered') ||
               message.contains('already been registered')) {
      return AuthError.emailAlreadyExists();
    } else if (message.contains('password') && message.contains('weak')) {
      return AuthError.weakPassword();
    } else if (message.contains('invalid email')) {
      return AuthError.invalidEmail();
    } else if (message.contains('session') && 
               (message.contains('expired') || message.contains('invalid'))) {
      return AuthError.sessionExpired();
    } else if (message.contains('network') || 
               message.contains('connection') ||
               message.contains('timeout')) {
      return AuthError.networkError();
    } else {
      return AuthError.unknown(error);
    }
  }

  /// Handle Supabase Postgrest (database) exceptions
  AppError _handlePostgrestException(PostgrestException error) {
    final message = error.message.toLowerCase();
    final code = error.code ?? '';

    // RLS policy violations
    if (code.contains('42501') || message.contains('permission denied')) {
      return MessageError.unauthorized();
    }

    // Foreign key violations
    if (code.contains('23503') || message.contains('foreign key')) {
      return MessageError.conversationNotFound();
    }

    // Network errors
    if (message.contains('network') || 
        message.contains('timeout') ||
        message.contains('connection')) {
      return NetworkError.noConnection();
    }

    // Server errors
    if (code.startsWith('5')) {
      return NetworkError.serverError();
    }

    // Generic database error
    return DatabaseError.queryFailed();
  }

  /// Handle Supabase Storage exceptions
  AppError _handleStorageException(StorageException error) {
    final message = error.message.toLowerCase();

    if (message.contains('size') || message.contains('too large')) {
      return StorageError.fileTooLarge();
    } else if (message.contains('format') || 
               message.contains('type') ||
               message.contains('invalid file')) {
      return StorageError.unsupportedFormat();
    } else {
      return StorageError.uploadFailed();
    }
  }

  /// Handle string errors (thrown as strings)
  AppError _handleStringError(String error) {
    final message = error.toLowerCase();

    // Auth errors
    if (message.contains('sign in') || message.contains('sign up')) {
      if (message.contains('failed')) {
        return AuthError.unknown(error);
      }
    }

    // Message errors
    if (message.contains('message')) {
      if (message.contains('failed') || message.contains('error')) {
        return MessageError.sendFailed();
      }
    }

    // Network errors
    if (message.contains('network') || 
        message.contains('connection') ||
        message.contains('offline') ||
        message.contains('internet')) {
      return NetworkError.noConnection();
    }

    // Generic error
    return AppError(
      category: ErrorCategory.unknown,
      severity: ErrorSeverity.error,
      code: 'UNK001',
      message: error,
      userMessage: 'Something went wrong. Please try again.',
      isRetryable: true,
    );
  }

  /// Handle unknown errors
  AppError _handleUnknownError(dynamic error) {
    return AppError(
      category: ErrorCategory.unknown,
      severity: ErrorSeverity.error,
      code: 'UNK999',
      message: error.toString(),
      userMessage: 'An unexpected error occurred. Please try again.',
      originalError: error,
      isRetryable: true,
    );
  }

  /// Log error for debugging
  void _logError(AppError error, StackTrace? stackTrace, String? context) {
    // Only log critical errors and non-retryable errors
    if (error.severity == ErrorSeverity.critical || !error.isRetryable) {
      final emoji = _getEmojiForSeverity(error.severity);
      print('$emoji ${error.code}: ${error.userMessage ?? error.message}');
    }
  }

  /// Get emoji for severity level
  String _getEmojiForSeverity(ErrorSeverity severity) {
    switch (severity) {
      case ErrorSeverity.info:
        return 'ℹ️';
      case ErrorSeverity.warning:
        return '⚠️';
      case ErrorSeverity.error:
        return '❌';
      case ErrorSeverity.critical:
        return '🚨';
    }
  }

  /// Check if error is network-related
  bool isNetworkError(AppError error) {
    return error.category == ErrorCategory.network ||
           (error.category == ErrorCategory.auth && error.code == 'AUTH006') ||
           (error.category == ErrorCategory.messaging && error.code == 'MSG002');
  }

  /// Check if error should trigger offline mode
  bool shouldGoOffline(AppError error) {
    return error.category == ErrorCategory.network &&
           error.code == 'NET001';
  }

  /// Get retry delay based on attempt number (exponential backoff)
  Duration getRetryDelay(int attemptNumber) {
    // Exponential backoff: 1s, 2s, 4s, 8s, 16s
    final delaySeconds = (1 << (attemptNumber - 1)).clamp(1, 16);
    return Duration(seconds: delaySeconds);
  }

  /// Check if should retry based on attempt count
  bool shouldRetry(AppError error, int attemptNumber, {int maxAttempts = 3}) {
    return error.isRetryable && attemptNumber < maxAttempts;
  }
}

/// Extension to add error handling to Future
extension FutureErrorHandler<T> on Future<T> {
  /// Handle errors and convert to AppError
  Future<T> handleAppError({String? context}) async {
    try {
      return await this;
    } catch (error, stackTrace) {
      throw ErrorHandler().handleError(error, stackTrace: stackTrace, context: context);
    }
  }
}
</file>

<file path="lib/core/errors/error_ui.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/errors/app_error.dart';

/// UI utilities for displaying errors to users
class ErrorUI {
  /// Show error as snackbar (for non-critical errors)
  static void showErrorSnackbar(
    BuildContext context,
    AppError error, {
    VoidCallback? onRetry,
  }) {
    final snackBar = SnackBar(
      content: Row(
        children: [
          Icon(
            _getIconForError(error),
            color: Colors.white,
            size: 20,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              error.displayMessage,
              style: const TextStyle(fontSize: 14),
            ),
          ),
        ],
      ),
      backgroundColor: _getColorForSeverity(error.severity),
      behavior: SnackBarBehavior.floating,
      action: error.isRetryable && onRetry != null
          ? SnackBarAction(
              label: 'Retry',
              textColor: Colors.white,
              onPressed: onRetry,
            )
          : null,
      duration: Duration(
        seconds: error.severity == ErrorSeverity.critical ? 6 : 4,
      ),
    );

    ScaffoldMessenger.of(context)
      ..hideCurrentSnackBar()
      ..showSnackBar(snackBar);
  }

  /// Show error as dialog (for critical errors or when user action required)
  static Future<bool?> showErrorDialog(
    BuildContext context,
    AppError error, {
    VoidCallback? onRetry,
    String? actionLabel,
  }) {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        icon: Icon(
          _getIconForError(error),
          color: _getColorForSeverity(error.severity),
          size: 48,
        ),
        title: Text(_getTitleForError(error)),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(error.displayMessage),
            if (error.code.isNotEmpty) ...[
              const SizedBox(height: 16),
              Text(
                'Error Code: ${error.code}',
                style: TextStyle(
                  fontSize: 12,
                  color: Colors.grey[600],
                ),
              ),
            ],
          ],
        ),
        actions: [
          if (!error.requiresUserAction)
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Dismiss'),
            ),
          if (error.isRetryable && onRetry != null)
            FilledButton(
              onPressed: () {
                Navigator.of(context).pop(true);
                onRetry();
              },
              child: Text(actionLabel ?? 'Retry'),
            ),
          if (!error.isRetryable || onRetry == null)
            FilledButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('OK'),
            ),
        ],
      ),
    );
  }

  /// Show permission error with option to open settings
  static Future<void> showPermissionError(
    BuildContext context,
    PermissionError error,
  ) {
    return showDialog(
      context: context,
      builder: (context) => AlertDialog(
        icon: const Icon(
          Icons.security,
          color: Colors.orange,
          size: 48,
        ),
        title: const Text('Permission Required'),
        content: Text(error.displayMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              Navigator.of(context).pop();
              // TODO: Open app settings
              // OpenSettings.openAppSettings();
            },
            child: const Text('Open Settings'),
          ),
        ],
      ),
    );
  }

  /// Show loading indicator with cancellation
  static Future<T?> showLoadingDialog<T>(
    BuildContext context, {
    required Future<T> Function() action,
    String message = 'Loading...',
  }) async {
    // Show loading dialog
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        content: Row(
          children: [
            const CircularProgressIndicator(),
            const SizedBox(width: 24),
            Text(message),
          ],
        ),
      ),
    );

    try {
      final result = await action();
      if (context.mounted) {
        Navigator.of(context).pop();
      }
      return result;
    } catch (error) {
      if (context.mounted) {
        Navigator.of(context).pop();
        if (error is AppError) {
          showErrorDialog(context, error);
        }
      }
      return null;
    }
  }

  /// Get icon for error
  static IconData _getIconForError(AppError error) {
    switch (error.category) {
      case ErrorCategory.auth:
        return Icons.lock_outline;
      case ErrorCategory.network:
        return Icons.wifi_off;
      case ErrorCategory.database:
        return Icons.storage_outlined;
      case ErrorCategory.messaging:
        return Icons.message_outlined;
      case ErrorCategory.storage:
        return Icons.cloud_upload_outlined;
      case ErrorCategory.permission:
        return Icons.security;
      case ErrorCategory.validation:
        return Icons.error_outline;
      case ErrorCategory.unknown:
        return Icons.warning_amber;
    }
  }

  /// Get color for severity
  static Color _getColorForSeverity(ErrorSeverity severity) {
    switch (severity) {
      case ErrorSeverity.info:
        return Colors.blue;
      case ErrorSeverity.warning:
        return Colors.orange;
      case ErrorSeverity.error:
        return Colors.red;
      case ErrorSeverity.critical:
        return Colors.red.shade900;
    }
  }

  /// Get title for error dialog
  static String _getTitleForError(AppError error) {
    switch (error.category) {
      case ErrorCategory.auth:
        return 'Authentication Error';
      case ErrorCategory.network:
        return 'Connection Problem';
      case ErrorCategory.database:
        return 'Data Error';
      case ErrorCategory.messaging:
        return 'Message Error';
      case ErrorCategory.storage:
        return 'Upload Error';
      case ErrorCategory.permission:
        return 'Permission Required';
      case ErrorCategory.validation:
        return 'Invalid Input';
      case ErrorCategory.unknown:
        return 'Error';
    }
  }
}

/// Mixin for widgets that need error handling
mixin ErrorHandlerMixin<T extends StatefulWidget> on State<T> {
  /// Show error to user
  void showError(AppError error, {VoidCallback? onRetry}) {
    if (!mounted) return;

    if (error.severity == ErrorSeverity.critical || error.requiresUserAction) {
      ErrorUI.showErrorDialog(context, error, onRetry: onRetry);
    } else {
      ErrorUI.showErrorSnackbar(context, error, onRetry: onRetry);
    }
  }

  /// Handle error from async operation
  Future<T?> handleAsyncError<T>(
    Future<T> Function() operation, {
    String? context,
    VoidCallback? onRetry,
  }) async {
    try {
      return await operation();
    } on AppError catch (error) {
      showError(error, onRetry: onRetry);
      return null;
    } catch (error) {
      final appError = AppError(
        category: ErrorCategory.unknown,
        severity: ErrorSeverity.error,
        code: 'UNK001',
        message: error.toString(),
        userMessage: 'An unexpected error occurred.',
      );
      showError(appError, onRetry: onRetry);
      return null;
    }
  }
}
</file>

<file path="lib/core/theme/app_theme.dart">
import 'package:flutter/material.dart';

/// MessageAI Theme System
/// Monochrome black/white/gray palette for clean, accessible design
class AppTheme {
  // Prevent instantiation
  AppTheme._();

  // ============================================================================
  // COLORS - Grayscale System
  // ============================================================================
  
  /// Pure colors
  static const Color white = Color(0xFFFFFFFF);
  static const Color black = Color(0xFF000000);
  
  /// Gray scale (Light Mode)
  static const Color gray50 = Color(0xFFFAFAFA);   // Almost white
  static const Color gray100 = Color(0xFFF5F5F5);  // Off white
  static const Color gray200 = Color(0xFFEEEEEE);  // Very light gray
  static const Color gray300 = Color(0xFFE0E0E0);  // Light gray
  static const Color gray400 = Color(0xFFBDBDBD);  // Light-medium gray
  static const Color gray500 = Color(0xFF9E9E9E);  // Medium gray
  static const Color gray600 = Color(0xFF757575);  // Medium-dark gray
  static const Color gray700 = Color(0xFF616161);  // Dark gray
  static const Color gray800 = Color(0xFF424242);  // Very dark gray
  static const Color gray900 = Color(0xFF212121);  // Almost black
  
  /// Dark mode grays
  static const Color darkGray100 = Color(0xFF1A1A1A);  // Near black surface
  static const Color darkGray200 = Color(0xFF242424);  // Dark surface
  static const Color darkGray300 = Color(0xFF2E2E2E);  // Medium dark
  static const Color darkGray400 = Color(0xFF3A3A3A);  // Lighter dark
  
  /// Accent colors (minimal use only)
  static const Color accentBlue = Color(0xFF000000);     // Actions, links
  static const Color accentGreen = Color(0xFF4CAF50);    // Online, success
  static const Color accentRed = Color(0xFFF44336);      // Error, urgent
  static const Color accentOrange = Color(0xFFFF9800);   // Warning
  
  // ============================================================================
  // TYPOGRAPHY
  // ============================================================================
  
  /// Font sizes
  static const double fontSizeXXL = 32.0;  // Page titles
  static const double fontSizeXL = 24.0;   // Section headers
  static const double fontSizeL = 20.0;    // Card titles
  static const double fontSizeM = 16.0;    // Body text (BASE)
  static const double fontSizeS = 14.0;    // Captions
  static const double fontSizeXS = 12.0;   // Timestamps
  static const double fontSizeXXS = 10.0;  // Micro-copy
  
  /// Font weights
  static const FontWeight fontWeightLight = FontWeight.w300;
  static const FontWeight fontWeightRegular = FontWeight.w400;
  static const FontWeight fontWeightMedium = FontWeight.w500;
  static const FontWeight fontWeightSemibold = FontWeight.w600;
  static const FontWeight fontWeightBold = FontWeight.w700;
  
  /// Line heights
  static const double lineHeightTight = 1.2;
  static const double lineHeightNormal = 1.5;
  static const double lineHeightRelaxed = 1.75;
  
  // ============================================================================
  // SPACING
  // ============================================================================
  
  /// Base unit: 4px - all spacing uses multiples of this
  static const double spacingXXS = 4.0;
  static const double spacingXS = 8.0;
  static const double spacingS = 12.0;
  static const double spacingM = 16.0;   // Standard spacing (BASE)
  static const double spacingL = 24.0;
  static const double spacingXL = 32.0;
  static const double spacingXXL = 48.0;
  static const double spacingXXXL = 64.0;
  
  // ============================================================================
  // BORDER RADIUS
  // ============================================================================
  
  static const double radiusNone = 0.0;
  static const double radiusXS = 2.0;
  static const double radiusS = 4.0;
  static const double radiusM = 8.0;    // Standard radius (BASE)
  static const double radiusL = 12.0;
  static const double radiusXL = 16.0;
  static const double radiusXXL = 24.0;
  static const double radiusPill = 9999.0;
  
  // ============================================================================
  // SHADOWS
  // ============================================================================
  
  /// Light mode shadows
  static List<BoxShadow> get shadow1Light => [
    BoxShadow(
      color: black.withOpacity(0.12),
      blurRadius: 3,
      offset: const Offset(0, 1),
    ),
    BoxShadow(
      color: black.withOpacity(0.08),
      blurRadius: 2,
      offset: const Offset(0, 1),
    ),
  ];
  
  static List<BoxShadow> get shadow2Light => [
    BoxShadow(
      color: black.withOpacity(0.12),
      blurRadius: 6,
      offset: const Offset(0, 2),
    ),
    BoxShadow(
      color: black.withOpacity(0.08),
      blurRadius: 4,
      offset: const Offset(0, 2),
    ),
  ];
  
  static List<BoxShadow> get shadow3Light => [
    BoxShadow(
      color: black.withOpacity(0.15),
      blurRadius: 12,
      offset: const Offset(0, 4),
    ),
    BoxShadow(
      color: black.withOpacity(0.10),
      blurRadius: 6,
      offset: const Offset(0, 2),
    ),
  ];
  
  /// Dark mode shadows (more subtle)
  static List<BoxShadow> get shadow1Dark => [
    BoxShadow(
      color: black.withOpacity(0.30),
      blurRadius: 3,
      offset: const Offset(0, 1),
    ),
    BoxShadow(
      color: black.withOpacity(0.20),
      blurRadius: 2,
      offset: const Offset(0, 1),
    ),
  ];
  
  static List<BoxShadow> get shadow2Dark => [
    BoxShadow(
      color: black.withOpacity(0.35),
      blurRadius: 6,
      offset: const Offset(0, 2),
    ),
    BoxShadow(
      color: black.withOpacity(0.25),
      blurRadius: 4,
      offset: const Offset(0, 2),
    ),
  ];
  
  // ============================================================================
  // THEME DATA
  // ============================================================================
  
  /// Light theme configuration
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      
      // Color scheme
      colorScheme: const ColorScheme.light(
        primary: accentBlue,
        onPrimary: white,
        secondary: gray900,
        onSecondary: white,
        surface: white,
        onSurface: black,
        surfaceContainerHighest: gray100,
        error: accentRed,
        onError: white,
      ),
      
      // Scaffold
      scaffoldBackgroundColor: white,
      
      // App bar
      appBarTheme: const AppBarTheme(
        backgroundColor: white,
        foregroundColor: black,
        elevation: 0,
        centerTitle: false,
        titleTextStyle: TextStyle(
          color: black,
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
        ),
        iconTheme: IconThemeData(
          color: black,
          size: 24,
        ),
      ),
      
      // Cards
      cardTheme: CardThemeData(
        color: white,
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radiusM),
          side: const BorderSide(color: gray300, width: 1),
        ),
        margin: const EdgeInsets.all(spacingS),
      ),
      
      // Text theme
      textTheme: const TextTheme(
        displayLarge: TextStyle(
          fontSize: fontSizeXXL,
          fontWeight: fontWeightBold,
          color: black,
          height: lineHeightTight,
        ),
        displayMedium: TextStyle(
          fontSize: fontSizeXL,
          fontWeight: fontWeightBold,
          color: black,
          height: lineHeightTight,
        ),
        displaySmall: TextStyle(
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
          color: black,
          height: lineHeightTight,
        ),
        bodyLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightRegular,
          color: black,
          height: lineHeightNormal,
        ),
        bodyMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightRegular,
          color: gray800,
          height: lineHeightNormal,
        ),
        bodySmall: TextStyle(
          fontSize: fontSizeXS,
          fontWeight: fontWeightRegular,
          color: gray600,
          height: lineHeightNormal,
        ),
        labelLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightSemibold,
          color: black,
        ),
        labelMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightMedium,
          color: black,
        ),
      ),
      
      // Buttons
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: accentBlue,
          foregroundColor: white,
          elevation: 0,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingL,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: accentBlue,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingM,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      // FAB
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: black,
        foregroundColor: white,
        elevation: 4,
        shape: CircleBorder(),
      ),
      
      // Input decoration
      inputDecorationTheme: InputDecorationTheme(
        filled: false,
        fillColor: white,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: gray300, width: 1),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: gray300, width: 1),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentBlue, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentRed, width: 1),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: spacingM,
          vertical: spacingS,
        ),
        hintStyle: const TextStyle(color: gray500),
      ),
      
      // Divider
      dividerTheme: const DividerThemeData(
        color: gray300,
        thickness: 1,
        space: 1,
      ),
      
      // Icon theme
      iconTheme: const IconThemeData(
        color: black,
        size: 24,
      ),
    );
  }
  
  /// Dark theme configuration
  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      
      // Color scheme
      colorScheme: const ColorScheme.dark(
        primary: accentBlue,
        onPrimary: black,
        secondary: white,
        onSecondary: black,
        surface: black,
        onSurface: white,
        surfaceContainerHighest: darkGray100,
        error: accentRed,
        onError: black,
      ),
      
      // Scaffold
      scaffoldBackgroundColor: black,
      
      // App bar
      appBarTheme: const AppBarTheme(
        backgroundColor: black,
        foregroundColor: white,
        elevation: 0,
        centerTitle: false,
        titleTextStyle: TextStyle(
          color: white,
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
        ),
        iconTheme: IconThemeData(
          color: white,
          size: 24,
        ),
      ),
      
      // Cards
      cardTheme: CardThemeData(
        color: darkGray100,
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radiusM),
          side: const BorderSide(color: darkGray300, width: 1),
        ),
        margin: const EdgeInsets.all(spacingS),
      ),
      
      // Text theme
      textTheme: const TextTheme(
        displayLarge: TextStyle(
          fontSize: fontSizeXXL,
          fontWeight: fontWeightBold,
          color: white,
          height: lineHeightTight,
        ),
        displayMedium: TextStyle(
          fontSize: fontSizeXL,
          fontWeight: fontWeightBold,
          color: white,
          height: lineHeightTight,
        ),
        displaySmall: TextStyle(
          fontSize: fontSizeL,
          fontWeight: fontWeightSemibold,
          color: white,
          height: lineHeightTight,
        ),
        bodyLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightRegular,
          color: white,
          height: lineHeightNormal,
        ),
        bodyMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightRegular,
          color: gray400,
          height: lineHeightNormal,
        ),
        bodySmall: TextStyle(
          fontSize: fontSizeXS,
          fontWeight: fontWeightRegular,
          color: gray500,
          height: lineHeightNormal,
        ),
        labelLarge: TextStyle(
          fontSize: fontSizeM,
          fontWeight: fontWeightSemibold,
          color: white,
        ),
        labelMedium: TextStyle(
          fontSize: fontSizeS,
          fontWeight: fontWeightMedium,
          color: white,
        ),
      ),
      
      // Buttons
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: white,
          foregroundColor: black,
          elevation: 0,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingL,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: accentBlue,
          padding: const EdgeInsets.symmetric(
            horizontal: spacingM,
            vertical: spacingS,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radiusS),
          ),
          textStyle: const TextStyle(
            fontSize: fontSizeS,
            fontWeight: fontWeightSemibold,
          ),
        ),
      ),
      
      // FAB
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: white,
        foregroundColor: black,
        elevation: 4,
        shape: CircleBorder(),
      ),
      
      // Input decoration
      inputDecorationTheme: InputDecorationTheme(
        filled: false,
        fillColor: darkGray100,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: darkGray300, width: 1),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: darkGray300, width: 1),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentBlue, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radiusS),
          borderSide: const BorderSide(color: accentRed, width: 1),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: spacingM,
          vertical: spacingS,
        ),
        hintStyle: const TextStyle(color: gray600),
      ),
      
      // Divider
      dividerTheme: const DividerThemeData(
        color: darkGray300,
        thickness: 1,
        space: 1,
      ),
      
      // Icon theme
      iconTheme: const IconThemeData(
        color: white,
        size: 24,
      ),
    );
  }
}
</file>

<file path="lib/data/drift/app_db.dart">
import 'package:drift/drift.dart';
import 'package:drift_flutter/drift_flutter.dart';
import 'package:messageai/data/drift/daos/conversation_dao.dart';
import 'package:messageai/data/drift/daos/message_dao.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/drift/daos/participant_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';
// AI Analysis DAO commented out (using remote-only approach)
// Uncomment and restore from backup files when scaling to local cache
// import 'package:messageai/data/drift/daos/ai_analysis_dao.dart';

part 'app_db.g.dart';

// Table definitions
class Conversations extends Table {
  TextColumn get id => text()();
  TextColumn get title => text()();
  TextColumn get description => text().nullable()();
  IntColumn get createdAt => integer()(); // Unix timestamp
  IntColumn get updatedAt => integer()();
  BoolColumn get isGroup => boolean().withDefault(const Constant(false))();
  IntColumn get lastMessageAt => integer().nullable()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};
}

class Messages extends Table {
  TextColumn get id => text()();
  TextColumn get conversationId => text()();
  TextColumn get senderId => text()();
  TextColumn get body => text()();
  TextColumn get mediaUrl => text().nullable()();
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    {conversationId, id}
  ];
}

class Participants extends Table {
  TextColumn get id => text()();
  TextColumn get conversationId => text()();
  TextColumn get userId => text()();
  IntColumn get joinedAt => integer()();
  BoolColumn get isAdmin => boolean().withDefault(const Constant(false))();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    {conversationId, userId}
  ];
}

class Receipts extends Table {
  TextColumn get id => text()();
  TextColumn get messageId => text()();
  TextColumn get userId => text()();
  TextColumn get status => text()(); // 'delivered', 'read'
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    {messageId, userId}
  ];
}

class PendingOutbox extends Table {
  TextColumn get id => text()();
  TextColumn get operation => text()(); // 'send_message', 'ack_receipt'
  TextColumn get payload => text()(); // JSON serialized
  TextColumn get conversationId => text().nullable()();
  IntColumn get createdAt => integer()();
  IntColumn get retryCount => integer().withDefault(const Constant(0))();
  TextColumn get lastError => text().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

// AI Analysis table commented out for now (using remote-only approach)
// Uncomment and restore from backup files when scaling to local cache
/*
class AiAnalysis extends Table {
  TextColumn get id => text()();
  TextColumn get messageId => text()();
  TextColumn get tone => text()();
  TextColumn get urgencyLevel => text().nullable()();
  TextColumn get intent => text().nullable()();
  RealColumn get confidenceScore => real().nullable()();
  IntColumn get analysisTimestamp => integer()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();

  @override
  Set<Column> get primaryKey => {id};
}
*/

// Main database class
// Note: AiAnalysis table and AIAnalysisDao commented out (using remote-only approach)
@DriftDatabase(
  tables: [Conversations, Messages, Participants, Receipts, PendingOutbox],
  daos: [ConversationDao, MessageDao, ReceiptDao, ParticipantDao, PendingOutboxDao],
)
class AppDb extends _$AppDb {
  AppDb() : super(_openConnection());

  @override
  int get schemaVersion => 1; // Reverted to 1 (AI table removed)

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) async {
        await m.createAll();
      },
      onUpgrade: (Migrator m, int from, int to) async {
        // AI Analysis migration commented out (using remote-only approach)
        // if (from == 1 && to == 2) {
        //   await m.createTable(aiAnalysis);
        // }
      },
    );
  }

  /// Get the singleton instance of the database
  static AppDb? _instance;

  static AppDb get instance => _instance ??= AppDb();

  /// Close the database connection
  Future<void> close() async {
    await super.close();
    _instance = null;
  }
}

// Connection logic
QueryExecutor _openConnection() {
  return driftDatabase(
    name: 'messageai_db',
  );
}
</file>

<file path="lib/data/drift/daos/conversation_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'conversation_dao.g.dart';

@DriftAccessor(tables: [Conversations])
class ConversationDao extends DatabaseAccessor<AppDb> with _$ConversationDaoMixin {
  ConversationDao(AppDb db) : super(db);

  /// Get all conversations ordered by last message
  Future<List<Conversation>> getAllConversations() async {
    final query = select(conversations)
      ..orderBy([(c) => OrderingTerm(expression: c.lastMessageAt, mode: OrderingMode.desc)]);
    return query.get();
  }

  /// Get conversation by ID
  Future<Conversation?> getConversationById(String id) async {
    return (select(conversations)..where((c) => c.id.equals(id)))
        .getSingleOrNull();
  }

  /// Insert or update conversation
  Future<void> upsertConversation(Conversation conversation) async {
    await into(conversations).insert(
      conversation,
      onConflict: DoUpdate((_) => conversation),
    );
  }

  /// Batch insert conversations
  Future<void> insertConversations(List<Conversation> convs) async {
    await batch((batch) {
      batch.insertAll(conversations, convs, mode: InsertMode.insertOrReplace);
    });
  }

  /// Delete conversation by ID
  Future<int> deleteConversation(String id) async {
    return (delete(conversations)..where((c) => c.id.equals(id))).go();
  }

  /// Update conversation sync status
  Future<void> markConversationAsSynced(String id) async {
    await (update(conversations)..where((c) => c.id.equals(id)))
        .write(const ConversationsCompanion(isSynced: Value(true)));
  }

  /// Get unsynced conversations
  Future<List<Conversation>> getUnsyncedConversations() async {
    return (select(conversations)..where((c) => c.isSynced.equals(false)))
        .get();
  }

  /// Update last message time
  Future<void> updateLastMessageTime(String conversationId) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    await (update(conversations)..where((c) => c.id.equals(conversationId)))
        .write(ConversationsCompanion(
          updatedAt: Value(now),
          lastMessageAt: Value(now),
        ));
  }

  /// Get recent conversations (for list)
  Future<List<Conversation>> getRecentConversations({int limit = 20}) async {
    return (select(conversations)
          ..orderBy([(c) => OrderingTerm(expression: c.lastMessageAt, mode: OrderingMode.desc)])
          ..limit(limit))
        .get();
  }

  /// Count total conversations
  Future<int> getConversationCount() async {
    final result = await select(conversations).get();
    return result.length;
  }
}
</file>

<file path="lib/data/drift/daos/message_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'message_dao.g.dart';

@DriftAccessor(tables: [Messages])
class MessageDao extends DatabaseAccessor<AppDb> with _$MessageDaoMixin {
  MessageDao(AppDb db) : super(db);

  /// Get all messages for a conversation ordered by creation time (oldest first)
  Future<List<Message>> getMessagesByConversation(String conversationId) async {
    final results = await (select(messages)
          ..where((m) => m.conversationId.equals(conversationId))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.asc)]))
        .get();
    
    // Debug: Print message order
    if (results.isNotEmpty) {
      print('📊 Messages loaded: ${results.length} total');
      final firstBody = results.first.body.length > 20 
          ? '${results.first.body.substring(0, 20)}...' 
          : results.first.body;
      final lastBody = results.last.body.length > 20 
          ? '${results.last.body.substring(0, 20)}...' 
          : results.last.body;
      print('   First message: "$firstBody" at timestamp ${results.first.createdAt}');
      print('   Last message: "$lastBody" at timestamp ${results.last.createdAt}');
    }
    
    return results;
  }

  /// Get recent messages for a conversation
  Future<List<Message>> getRecentMessages(String conversationId, {int limit = 50}) async {
    return (select(messages)
          ..where((m) => m.conversationId.equals(conversationId))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.desc)])
          ..limit(limit))
        .get();
  }

  /// Insert a new message
  Future<void> insertMessage(Message message) async {
    await into(messages).insert(message);
  }

  /// Update message sync status
  Future<void> markMessageAsSynced(String messageId) async {
    await (update(messages)..where((m) => m.id.equals(messageId)))
        .write(const MessagesCompanion(isSynced: Value(true)));
  }

  /// Get unsynced messages
  Future<List<Message>> getUnsyncedMessages() async {
    return (select(messages)..where((m) => m.isSynced.equals(false)))
        .get();
  }

  /// Delete message by ID
  Future<int> deleteMessage(String id) async {
    return (delete(messages)..where((m) => m.id.equals(id))).go();
  }

  /// Get message by ID
  Future<Message?> getMessageById(String id) async {
    return (select(messages)..where((m) => m.id.equals(id)))
        .getSingleOrNull();
  }

  /// Get the most recent message for a conversation
  Future<Message?> getLatestMessageForConversation(String conversationId) async {
    return (select(messages)
          ..where((m) => m.conversationId.equals(conversationId))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.desc)])
          ..limit(1))
        .getSingleOrNull();
  }

  /// Get unsynced message count
  Future<int> getUnsyncedMessageCount() async {
    final result = await (select(messages)..where((m) => m.isSynced.equals(false))).get();
    return result.length;
  }

  /// Search messages in a conversation
  Future<List<Message>> searchMessages(String conversationId, String query) async {
    return (select(messages)
          ..where((m) => m.conversationId.equals(conversationId) & m.body.contains(query))
          ..orderBy([(m) => OrderingTerm(expression: m.createdAt, mode: OrderingMode.desc)]))
        .get();
  }

  /// Insert multiple messages
  Future<void> insertMessages(List<Message> messageList) async {
    await batch((batch) {
      batch.insertAll(messages, messageList);
    });
  }

  /// Upsert a message (insert or update)
  Future<void> upsertMessage(Message message) async {
    await into(messages).insertOnConflictUpdate(message);
  }
}
</file>

<file path="lib/data/drift/daos/participant_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'participant_dao.g.dart';

@DriftAccessor(tables: [Participants])
class ParticipantDao extends DatabaseAccessor<AppDb> with _$ParticipantDaoMixin {
  ParticipantDao(AppDb db) : super(db);

  /// Get all participants in a conversation
  Future<List<Participant>> getParticipantsByConversation(String conversationId) async {
    return (select(participants)
          ..where((p) => p.conversationId.equals(conversationId)))
        .get();
  }

  /// Get participant by ID
  Future<Participant?> getParticipantById(String id) async {
    return (select(participants)..where((p) => p.id.equals(id)))
        .getSingleOrNull();
  }

  /// Get participant by conversation ID and user ID
  Future<Participant?> getParticipant(String conversationId, String userId) async {
    return (select(participants)
          ..where((p) =>
              p.conversationId.equals(conversationId) & p.userId.equals(userId)))
        .getSingleOrNull();
  }

  /// Add participant to conversation (upsert to avoid duplicates)
  Future<void> addParticipant(Participant participant) async {
    await into(participants).insertOnConflictUpdate(participant);
  }

  /// Batch add participants
  Future<void> addParticipants(List<Participant> parts) async {
    await batch((batch) {
      batch.insertAll(participants, parts, mode: InsertMode.insertOrReplace);
    });
  }

  /// Remove participant from conversation
  Future<int> removeParticipant(String conversationId, String userId) async {
    return (delete(participants)
          ..where((p) =>
              p.conversationId.equals(conversationId) & p.userId.equals(userId)))
        .go();
  }

  /// Remove participant by ID
  Future<int> removeParticipantById(String id) async {
    return (delete(participants)..where((p) => p.id.equals(id))).go();
  }

  /// Remove all participants from conversation
  Future<int> removeConversationParticipants(String conversationId) async {
    return (delete(participants)..where((p) => p.conversationId.equals(conversationId)))
        .go();
  }

  /// Promote participant to admin
  Future<void> promoteToAdmin(String id) async {
    await (update(participants)..where((p) => p.id.equals(id)))
        .write(const ParticipantsCompanion(isAdmin: Value(true)));
  }

  /// Demote participant from admin
  Future<void> demoteFromAdmin(String id) async {
    await (update(participants)..where((p) => p.id.equals(id)))
        .write(const ParticipantsCompanion(isAdmin: Value(false)));
  }

  /// Get admin count for conversation
  Future<int> getAdminCount(String conversationId) async {
    final result = await (select(participants)
          ..where((p) =>
              p.conversationId.equals(conversationId) & p.isAdmin.equals(true)))
        .get();
    return result.length;
  }

  /// Get participant count for a conversation
  Future<int> getParticipantCount(String conversationId) async {
    final result = await (select(participants)
          ..where((p) => p.conversationId.equals(conversationId)))
        .get();
    return result.length;
  }

  /// Check if user is participant in conversation
  Future<bool> isParticipant(String conversationId, String userId) async {
    final participant = await getParticipant(conversationId, userId);
    return participant != null;
  }

  /// Check if user is admin in conversation
  Future<bool> isAdmin(String conversationId, String userId) async {
    final participant = await getParticipant(conversationId, userId);
    return participant?.isAdmin ?? false;
  }

  /// Mark participants as synced
  Future<void> markParticipantsAsSynced(List<String> ids) async {
    await batch((batch) {
      for (final id in ids) {
        batch.update(participants, const ParticipantsCompanion(isSynced: Value(true)),
            where: (p) => p.id.equals(id));
      }
    });
  }
}
</file>

<file path="lib/data/drift/daos/pending_outbox_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'pending_outbox_dao.g.dart';

@DriftAccessor(tables: [PendingOutbox])
class PendingOutboxDao extends DatabaseAccessor<AppDb> with _$PendingOutboxDaoMixin {
  PendingOutboxDao(AppDb db) : super(db);

  /// Get all pending operations
  Future<List<PendingOutboxData>> getAllPendingOperations() async {
    return (select(pendingOutbox)
          ..orderBy([(p) => OrderingTerm(expression: p.createdAt)]))
        .get();
  }

  /// Get pending operations for a specific conversation
  Future<List<PendingOutboxData>> getPendingOperationsByConversation(String conversationId) async {
    return (select(pendingOutbox)
          ..where((p) => p.conversationId.equals(conversationId))
          ..orderBy([(p) => OrderingTerm(expression: p.createdAt)]))
        .get();
  }

  /// Add operation to pending outbox
  Future<void> addPendingOperation({
    required String id,
    required String operation,
    required String payload,
    required String? conversationId,
  }) async {
    await into(pendingOutbox).insert(PendingOutboxCompanion(
      id: Value(id),
      operation: Value(operation),
      payload: Value(payload),
      conversationId: Value(conversationId),
      createdAt: Value(DateTime.now().millisecondsSinceEpoch ~/ 1000),
      retryCount: const Value(0),
    ));
  }

  /// Remove operation from pending outbox (after successful sync)
  Future<int> removePendingOperation(String id) async {
    return (delete(pendingOutbox)..where((p) => p.id.equals(id))).go();
  }

  /// Batch remove multiple operations
  Future<int> removePendingOperations(List<String> ids) async {
    return (delete(pendingOutbox)..where((p) => p.id.isIn(ids))).go();
  }

  /// Update retry count and last error
  Future<void> updateRetryInfo(String id, int retryCount, String? lastError) async {
    await (update(pendingOutbox)..where((p) => p.id.equals(id)))
        .write(PendingOutboxCompanion(
          retryCount: Value(retryCount),
          lastError: Value(lastError),
        ));
  }

  /// Get retryable operations (with retry count < max retries)
  Future<List<PendingOutboxData>> getRetryableOperations({int maxRetries = 3}) async {
    return (select(pendingOutbox)
          ..where((p) => p.retryCount.isSmallerThanValue(maxRetries)))
        .get();
  }

  /// Get oldest pending operation
  Future<PendingOutboxData?> getOldestPendingOperation() async {
    return (select(pendingOutbox)
          ..orderBy([(p) => OrderingTerm(expression: p.createdAt)])
          ..limit(1))
        .getSingleOrNull();
  }

  /// Get pending operations by type
  Future<List<PendingOutboxData>> getPendingOperationsByType(String operationType) async {
    return (select(pendingOutbox)
          ..where((p) => p.operation.equals(operationType)))
        .get();
  }

  /// Clean up old pending operations (older than cutoffTime)
  Future<int> cleanupOldOperations(int cutoffTime) async {
    return (delete(pendingOutbox)..where((p) => p.createdAt.isSmallerThanValue(cutoffTime))).go();
  }

  /// Get pending operations count
  Future<int> getPendingOperationCount() async {
    final result = await select(pendingOutbox).get();
    return result.length;
  }

  /// Check if there are any pending operations
  Future<bool> hasPendingOperations() async {
    final count = await getPendingOperationCount();
    return count > 0;
  }
}
</file>

<file path="lib/data/drift/daos/receipt_dao.dart">
import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'receipt_dao.g.dart';

@DriftAccessor(tables: [Receipts, Messages])
class ReceiptDao extends DatabaseAccessor<AppDb> with _$ReceiptDaoMixin {
  ReceiptDao(AppDb db) : super(db);

  /// Get all receipts for a message
  Future<List<Receipt>> getReceiptsByMessage(String messageId) async {
    return (select(receipts)
          ..where((r) => r.messageId.equals(messageId)))
        .get();
  }

  /// Get receipt by ID
  Future<Receipt?> getReceiptById(String id) async {
    return (select(receipts)..where((r) => r.id.equals(id)))
        .getSingleOrNull();
  }

  /// Get receipt by message ID and user ID
  Future<Receipt?> getReceipt(String messageId, String userId) async {
    return (select(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.userId.equals(userId)))
        .getSingleOrNull();
  }

  /// Add receipt
  Future<void> addReceipt(Receipt receipt) async {
    await into(receipts).insert(receipt);
  }

  /// Batch add receipts
  Future<void> addReceipts(List<Receipt> recs) async {
    await batch((batch) {
      batch.insertAll(receipts, recs, mode: InsertMode.insertOrReplace);
    });
  }

  /// Update receipt status
  Future<void> updateReceiptStatus(String messageId, String userId, String status) async {
    await (update(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.userId.equals(userId)))
        .write(ReceiptsCompanion(
          status: Value(status),
          updatedAt: Value(DateTime.now().millisecondsSinceEpoch ~/ 1000),
        ));
  }

  /// Mark receipt as synced
  Future<void> markReceiptAsSynced(String id) async {
    await (update(receipts)..where((r) => r.id.equals(id)))
        .write(const ReceiptsCompanion(isSynced: Value(true)));
  }

  /// Mark multiple receipts as synced
  Future<void> markReceiptsAsSynced(List<String> ids) async {
    await batch((batch) {
      for (final id in ids) {
        batch.update(receipts, const ReceiptsCompanion(isSynced: Value(true)),
            where: (r) => r.id.equals(id));
      }
    });
  }

  /// Delete receipt
  Future<int> deleteReceipt(String id) async {
    return (delete(receipts)..where((r) => r.id.equals(id))).go();
  }

  /// Get unsynced receipts
  Future<List<Receipt>> getUnsyncedReceipts() async {
    return (select(receipts)..where((r) => r.isSynced.equals(false)))
        .get();
  }

  /// Get read count for a message
  Future<int> getReadCount(String messageId) async {
    final countResult = await (select(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.status.equals('read')))
        .get();
    return countResult.length;
  }

  /// Get delivered count for a message
  Future<int> getDeliveredCount(String messageId) async {
    final countResult = await (select(receipts)
          ..where((r) =>
              r.messageId.equals(messageId) & r.status.equals('delivered')))
        .get();
    return countResult.length;
  }

  /// Get all receipts for messages in conversation
  Future<List<Receipt>> getReceiptsByConversation(String conversationId) async {
    return (select(receipts).join([
      innerJoin(messages, messages.id.equalsExp(receipts.messageId)),
    ])
      ..where(messages.conversationId.equals(conversationId)))
        .map((row) => row.readTable(receipts))
        .get();
  }

  /// Check if message is read by all participants
  Future<bool> isReadByAll(String messageId, int expectedCount) async {
    final readCount = await getReadCount(messageId);
    return readCount >= expectedCount;
  }

  /// Get unsynced receipt count
  Future<int> getUnsyncedReceiptCount() async {
    final countResult = await (select(receipts)
          ..where((r) => r.isSynced.equals(false)))
        .get();
    return countResult.length;
  }
}
</file>

<file path="lib/data/drift/entities/conversation.drift">
CREATE TABLE conversations (
  id TEXT PRIMARY KEY NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  is_group BOOLEAN NOT NULL DEFAULT 0,
  last_message_at INTEGER,
  is_synced BOOLEAN NOT NULL DEFAULT 0
) AS Conversation;

CREATE TABLE messages (
  id TEXT PRIMARY KEY NOT NULL,
  conversation_id TEXT NOT NULL,
  sender_id TEXT NOT NULL,
  body TEXT NOT NULL,
  media_url TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  is_synced BOOLEAN NOT NULL DEFAULT 0,
  FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
) AS Message;

CREATE TABLE participants (
  id TEXT PRIMARY KEY NOT NULL,
  conversation_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  joined_at INTEGER NOT NULL,
  is_admin BOOLEAN NOT NULL DEFAULT 0,
  is_synced BOOLEAN NOT NULL DEFAULT 0,
  FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE,
  UNIQUE(conversation_id, user_id)
) AS Participant;

CREATE TABLE receipts (
  id TEXT PRIMARY KEY NOT NULL,
  message_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  status TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  is_synced BOOLEAN NOT NULL DEFAULT 0,
  FOREIGN KEY(message_id) REFERENCES messages(id) ON DELETE CASCADE,
  UNIQUE(message_id, user_id)
) AS Receipt;

CREATE TABLE pending_outbox (
  id TEXT PRIMARY KEY NOT NULL,
  operation TEXT NOT NULL,
  payload TEXT NOT NULL,
  conversation_id TEXT,
  created_at INTEGER NOT NULL,
  retry_count INTEGER NOT NULL DEFAULT 0,
  last_error TEXT,
  FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
) AS PendingOutboxItem;
</file>

<file path="lib/data/remote/supabase_client.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/core/env.dart';

/// Singleton Supabase client for the application.
/// 
/// Initialize with [initializeSupabase] before accessing the client.
class SupabaseClientProvider {
  static late final Supabase _instance;

  /// Get the initialized Supabase client instance
  static Supabase get instance => _instance;

  /// Get the Supabase client for convenience
  static SupabaseClient get client => _instance.client;

  /// Initialize the Supabase client with environment config
  static Future<void> initialize() async {
    Env.validate();
    
    _instance = await Supabase.initialize(
      url: Env.supabaseUrl,
      anonKey: Env.supabaseAnonKey,
      // Enable realtime
      // Note: The underlying realtime_client has heartbeat enabled by default (30s)
      realtimeClientOptions: const RealtimeClientOptions(
        eventsPerSecond: 10,
        logLevel: RealtimeLogLevel.info, // Enable logging for diagnostics
      ),
    );
  }
}
</file>

<file path="lib/data/repositories/group_repository.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/conversation_dao.dart';
import 'package:messageai/data/drift/daos/participant_dao.dart';
import 'package:uuid/uuid.dart';

/// Repository for group operations
class GroupRepository {
  final ConversationDao _conversationDao;
  final ParticipantDao _participantDao;

  GroupRepository({
    required ConversationDao conversationDao,
    required ParticipantDao participantDao,
  })  : _conversationDao = conversationDao,
        _participantDao = participantDao;

  /// Create a new group conversation
  Future<Conversation> createGroup({
    required String title,
    required String description,
    required String creatorId,
    required List<String> memberIds,
  }) async {
    const uuid = Uuid();
    final conversationId = uuid.v4();
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Create conversation
    final conversation = Conversation(
      id: conversationId,
      title: title,
      description: description,
      createdAt: now,
      updatedAt: now,
      isGroup: true,
      isSynced: false,
    );
    
    await _conversationDao.upsertConversation(conversation);
    
    // Add creator as admin
    final creatorParticipant = Participant(
      id: uuid.v4(),
      conversationId: conversationId,
      userId: creatorId,
      joinedAt: now,
      isAdmin: true,
      isSynced: false,
    );
    
    await _participantDao.addParticipant(creatorParticipant);
    
    // Add other members
    final participants = memberIds.map((userId) {
      return Participant(
        id: uuid.v4(),
        conversationId: conversationId,
        userId: userId,
        joinedAt: now,
        isAdmin: false,
        isSynced: false,
      );
    }).toList();
    
    await _participantDao.addParticipants(participants);
    
    return conversation;
  }

  /// Get group details with members
  Future<(Conversation, List<Participant>)> getGroupWithMembers(String groupId) async {
    final conversation = await _conversationDao.getConversationById(groupId);
    if (conversation == null) {
      throw Exception('Group not found: $groupId');
    }
    
    final participants = await _participantDao.getParticipantsByConversation(groupId);
    
    return (conversation, participants);
  }

  /// Update group info
  Future<void> updateGroupInfo({
    required String groupId,
    String? title,
    String? description,
  }) async {
    // This would require a Conversation update method in ConversationDao
    // For now, creating a placeholder
    // TODO: Implement in ConversationDao
  }

  /// Add member to group
  Future<void> addGroupMember({
    required String groupId,
    required String userId,
  }) async {
    const uuid = Uuid();
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Check if already a member
    final existing = await _participantDao.getParticipant(groupId, userId);
    if (existing != null) {
      throw Exception('User is already a member of this group');
    }
    
    final participant = Participant(
      id: uuid.v4(),
      conversationId: groupId,
      userId: userId,
      joinedAt: now,
      isAdmin: false,
      isSynced: false,
    );
    
    await _participantDao.addParticipant(participant);
  }

  /// Remove member from group
  Future<void> removeGroupMember({
    required String groupId,
    required String userId,
  }) async {
    await _participantDao.removeParticipant(groupId, userId);
  }

  /// Promote member to admin
  Future<void> promoteToAdmin({
    required String groupId,
    required String userId,
  }) async {
    final participant = await _participantDao.getParticipant(groupId, userId);
    if (participant == null) {
      throw Exception('Member not found in group');
    }
    
    await _participantDao.promoteToAdmin(participant.id);
  }

  /// Demote admin to member
  Future<void> demoteFromAdmin({
    required String groupId,
    required String userId,
  }) async {
    final participant = await _participantDao.getParticipant(groupId, userId);
    if (participant == null) {
      throw Exception('Member not found in group');
    }
    
    await _participantDao.demoteFromAdmin(participant.id);
  }

  /// Get user's groups
  Future<List<Conversation>> getUserGroups(String userId) async {
    final allConversations = await _conversationDao.getAllConversations();
    
    // Filter to only groups where user is a participant
    final userGroups = <Conversation>[];
    
    for (final conversation in allConversations) {
      if (conversation.isGroup) {
        final isParticipant = await _participantDao.isParticipant(
          conversation.id,
          userId,
        );
        if (isParticipant) {
          userGroups.add(conversation);
        }
      }
    }
    
    return userGroups;
  }

  /// Leave group
  Future<void> leaveGroup({
    required String groupId,
    required String userId,
  }) async {
    await _participantDao.removeParticipant(groupId, userId);
  }

  /// Delete group (admin only)
  Future<void> deleteGroup(String groupId) async {
    // Remove all participants
    await _participantDao.removeConversationParticipants(groupId);
    
    // Delete conversation
    await _conversationDao.deleteConversation(groupId);
  }

  /// Get group members count
  Future<int> getGroupMemberCount(String groupId) async {
    return _participantDao.getParticipantCount(groupId);
  }

  /// Check if user is group admin
  Future<bool> isUserGroupAdmin(String groupId, String userId) async {
    return _participantDao.isAdmin(groupId, userId);
  }
}
</file>

<file path="lib/data/repositories/message_repository.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/message_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';
import 'package:messageai/gen/api/clients/messages_api.dart';
import 'package:messageai/gen/api/models/message_payload.dart';

/// Repository for message operations combining API and local database
class MessageRepository {
  final MessagesApi _messagesApi;
  final MessageDao _messageDao;
  final PendingOutboxDao _outboxDao;

  MessageRepository({
    required MessagesApi messagesApi,
    required MessageDao messageDao,
    required PendingOutboxDao outboxDao,
  })  : _messagesApi = messagesApi,
        _messageDao = messageDao,
        _outboxDao = outboxDao;

  /// Send a message (optimistic - save locally first, sync later)
  Future<Message> sendMessage({
    required String id,
    required String conversationId,
    required String senderId,
    required String body,
    String? mediaUrl,
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Create message locally first (optimistic)
    final message = Message(
      id: id,
      conversationId: conversationId,
      senderId: senderId,
      body: body,
      mediaUrl: mediaUrl,
      createdAt: now,
      updatedAt: now,
      isSynced: false,
    );
    
    // Save to local DB
    await _messageDao.insertMessage(message);
    
    // Queue for sync
    await _outboxDao.addPendingOperation(
      id: '${id}_send',
      operation: 'send_message',
      payload: message.toJson().toString(),
      conversationId: conversationId,
    );
    
    return message;
  }

  /// Get messages for a conversation from local DB
  Future<List<Message>> getConversationMessages(String conversationId) async {
    return _messageDao.getMessagesByConversation(conversationId);
  }

  /// Get recent messages for a conversation (paginated)
  Future<List<Message>> getRecentMessages(String conversationId, {int limit = 50}) async {
    return _messageDao.getRecentMessages(conversationId, limit: limit);
  }

  /// Sync unsynced messages to server
  Future<void> syncUnsyncedMessages() async {
    final unsyncedMessages = await _messageDao.getUnsyncedMessages();
    
    for (final message in unsyncedMessages) {
      try {
        final payload = MessagePayload(
          id: message.id,
          conversationId: message.conversationId,
          body: message.body,
        );
        
        // Send to server
        await _messagesApi.send(payload);
        
        // Mark as synced locally
        await _messageDao.markMessageAsSynced(message.id);
        
        // Remove from outbox
        await _outboxDao.removePendingOperation('${message.id}_send');
      } catch (e) {
        // Log error and continue
        print('Error syncing message ${message.id}: $e');
      }
    }
  }

  /// Search messages in a conversation
  Future<List<Message>> searchMessages(String conversationId, String query) async {
    return _messageDao.searchMessages(conversationId, query);
  }

  /// Insert messages from server
  Future<void> insertServerMessages(List<Message> messages) async {
    await _messageDao.insertMessages(messages);
  }

  /// Update message from server
  Future<void> updateMessageFromServer(Message message) async {
    await _messageDao.upsertMessage(message);
  }

  /// Upsert message (helper)
  Future<void> upsertMessage(Message message) async {
    // This would be added to MessageDao
    await _messageDao.insertMessage(message);
  }

  /// Get pending message count (for UI)
  Future<int> getPendingMessageCount() async {
    return _messageDao.getUnsyncedMessageCount();
  }
}

extension on Message {
  Map<String, dynamic> toJson() => {
    'id': id,
    'conversation_id': conversationId,
    'sender_id': senderId,
    'body': body,
    'media_url': mediaUrl,
    'created_at': createdAt,
    'updated_at': updatedAt,
    'is_synced': isSynced,
  };
}
</file>

<file path="lib/data/repositories/receipt_repository.dart">
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';
import 'package:messageai/gen/api/clients/receipts_api.dart';
import 'package:messageai/gen/api/models/receipt_payload.dart';

/// Repository for receipt operations combining API and local database
class ReceiptRepository {
  final ReceiptsApi _receiptsApi;
  final ReceiptDao _receiptDao;
  final PendingOutboxDao _outboxDao;

  ReceiptRepository({
    required ReceiptsApi receiptsApi,
    required ReceiptDao receiptDao,
    required PendingOutboxDao outboxDao,
  })  : _receiptsApi = receiptsApi,
        _receiptDao = receiptDao,
        _outboxDao = outboxDao;

  /// Acknowledge message receipts (optimistic)
  Future<void> acknowledgeReceipts({
    required List<String> messageIds,
    required String status, // 'delivered' or 'read'
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    // Save receipts locally first
    final receipts = messageIds.map((msgId) {
      return Receipt(
        id: '${msgId}_${status}_$now',
        messageId: msgId,
        userId: '', // Would be current user ID
        status: status,
        createdAt: now,
        updatedAt: now,
        isSynced: false,
      );
    }).toList();
    
    await _receiptDao.addReceipts(receipts);
    
    // Queue for sync
    await _outboxDao.addPendingOperation(
      id: 'ack_${status}_$now',
      operation: 'ack_receipt',
      payload: ReceiptPayload(
        messageIds: messageIds,
        status: status == 'delivered' ? ReceiptStatus.delivered : ReceiptStatus.read,
      ).toJson().toString(),
      conversationId: null,
    );
  }

  /// Get receipts for a message
  Future<List<Receipt>> getMessageReceipts(String messageId) async {
    return _receiptDao.getReceiptsByMessage(messageId);
  }

  /// Get read count for a message
  Future<int> getReadCount(String messageId) async {
    return _receiptDao.getReadCount(messageId);
  }

  /// Get delivered count for a message
  Future<int> getDeliveredCount(String messageId) async {
    return _receiptDao.getDeliveredCount(messageId);
  }

  /// Check if message is read by all participants
  Future<bool> isReadByAll(String messageId, int participantCount) async {
    return _receiptDao.isReadByAll(messageId, participantCount);
  }

  /// Sync unsynced receipts to server
  Future<void> syncUnsyncedReceipts() async {
    final unsyncedReceipts = await _receiptDao.getUnsyncedReceipts();
    
    if (unsyncedReceipts.isEmpty) return;
    
    try {
      // Group by status
      final deliveredIds = unsyncedReceipts
          .where((r) => r.status == 'delivered')
          .map((r) => r.messageId)
          .toList();
      
      final readIds = unsyncedReceipts
          .where((r) => r.status == 'read')
          .map((r) => r.messageId)
          .toList();
      
      // Send to server
      if (deliveredIds.isNotEmpty) {
        final payload = ReceiptPayload(
          messageIds: deliveredIds,
          status: ReceiptStatus.delivered,
        );
        await _receiptsApi.ack(payload);
      }
      
      if (readIds.isNotEmpty) {
        final payload = ReceiptPayload(
          messageIds: readIds,
          status: ReceiptStatus.read,
        );
        await _receiptsApi.ack(payload);
      }
      
      // Mark as synced
      final allIds = unsyncedReceipts.map((r) => r.id).toList();
      await _receiptDao.markReceiptsAsSynced(allIds);
    } catch (e) {
      print('Error syncing receipts: $e');
    }
  }

  /// Insert receipts from server
  Future<void> insertServerReceipts(List<Receipt> receipts) async {
    await _receiptDao.addReceipts(receipts);
  }

  /// Get unsynced receipt count (for UI)
  Future<int> getUnsyncedReceiptCount() async {
    return _receiptDao.getUnsyncedReceiptCount();
  }
}

extension on ReceiptPayload {
  Map<String, dynamic> toJson() => {
    'message_ids': messageIds,
    'status': status.toValue(),
  };
}
</file>

<file path="lib/features/auth/screens/auth_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/auth_service.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_ui.dart';

/// Authentication screen for login/signup
class AuthScreen extends StatefulWidget {
  final VoidCallback onAuthSuccess;

  const AuthScreen({
    Key? key,
    required this.onAuthSuccess,
  }) : super(key: key);

  @override
  State<AuthScreen> createState() => _AuthScreenState();
}

class _AuthScreenState extends State<AuthScreen> with ErrorHandlerMixin {
  late TextEditingController _emailController;
  late TextEditingController _passwordController;
  bool _isLoading = false;
  bool _isSignUp = false;
  final _authService = AuthService();

  @override
  void initState() {
    super.initState();
    _emailController = TextEditingController();
    _passwordController = TextEditingController();
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _handleSignIn() async {
    if (_emailController.text.isEmpty || _passwordController.text.isEmpty) {
      ErrorUI.showErrorSnackbar(
        context,
        AppError(
          category: ErrorCategory.validation,
          severity: ErrorSeverity.warning,
          code: 'VAL001',
          message: 'Please enter email and password',
          userMessage: 'Please enter both email and password',
        ),
      );
      return;
    }

    setState(() => _isLoading = true);

    try {
      await _authService.signIn(
        email: _emailController.text.trim(),
        password: _passwordController.text,
      );

      if (mounted) {
        widget.onAuthSuccess();
      }
    } on AppError catch (error) {
      if (mounted) {
        showError(error, onRetry: _handleSignIn);
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  Future<void> _handleSignUp() async {
    // Validation
    if (_emailController.text.isEmpty || _passwordController.text.isEmpty) {
      ErrorUI.showErrorSnackbar(
        context,
        AppError(
          category: ErrorCategory.validation,
          severity: ErrorSeverity.warning,
          code: 'VAL001',
          message: 'Please enter email and password',
          userMessage: 'Please enter both email and password',
        ),
      );
      return;
    }

    if (!_isValidEmail(_emailController.text.trim())) {
      ErrorUI.showErrorSnackbar(
        context,
        AuthError.invalidEmail(),
      );
      return;
    }

    if (_passwordController.text.length < 6) {
      ErrorUI.showErrorSnackbar(
        context,
        AuthError.weakPassword(),
      );
      return;
    }

    setState(() => _isLoading = true);

    try {
      await _authService.signUp(
        email: _emailController.text.trim(),
        password: _passwordController.text,
      );

      if (mounted) {
        // Show success message
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 12),
                Text('Sign up successful! Signing you in...'),
              ],
            ),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
        
        // Auto sign in after signup
        await Future.delayed(const Duration(seconds: 1));
        if (mounted) {
          await _handleSignIn();
        }
      }
    } on AppError catch (error) {
      if (mounted) {
        showError(error, onRetry: _handleSignUp);
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  /// Validate email format
  bool _isValidEmail(String email) {
    final emailRegex = RegExp(
      r'^[a-zA-Z0-9.]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+',
    );
    return emailRegex.hasMatch(email);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('MessageAI'),
        centerTitle: true,
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.chat_bubble,
                size: 64,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(height: 24),
              Text(
                _isSignUp ? 'Create Account' : 'Welcome to MessageAI',
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32),
              TextField(
                controller: _emailController,
                enabled: !_isLoading,
                decoration: InputDecoration(
                  hintText: 'Email',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  prefixIcon: const Icon(Icons.email),
                ),
                keyboardType: TextInputType.emailAddress,
              ),
              const SizedBox(height: 16),
              TextField(
                controller: _passwordController,
                enabled: !_isLoading,
                decoration: InputDecoration(
                  hintText: 'Password',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  prefixIcon: const Icon(Icons.lock),
                ),
                obscureText: true,
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _isLoading
                      ? null
                      : (_isSignUp ? _handleSignUp : _handleSignIn),
                  child: _isLoading
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : Text(_isSignUp ? 'Sign Up' : 'Sign In'),
                ),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(_isSignUp
                      ? 'Already have an account? '
                      : "Don't have an account? "),
                  TextButton(
                    onPressed: _isLoading
                        ? null
                        : () {
                            setState(() {
                              _isSignUp = !_isSignUp;
                              // Clear any previous error messages when switching modes
                              ScaffoldMessenger.of(context).hideCurrentSnackBar();
                            });
                          },
                    child: Text(_isSignUp ? 'Sign In' : 'Sign Up'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/conversations/screens/conversations_list_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/conversation_service.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/features/messages/screens/message_screen.dart';
import 'package:messageai/features/settings/screens/settings_screen.dart';
import 'package:messageai/features/follow_ups/screens/follow_up_dashboard_screen.dart';
import 'package:messageai/widgets/network_status_banner.dart';
import 'package:messageai/widgets/user_avatar.dart';

/// Screen showing list of conversations
class ConversationsListScreen extends StatefulWidget {
  const ConversationsListScreen({Key? key}) : super(key: key);

  @override
  State<ConversationsListScreen> createState() =>
      _ConversationsListScreenState();
}

class _ConversationsListScreenState extends State<ConversationsListScreen> {
  final _conversationService = ConversationService();
  late Future<List<Conversation>> _conversationsFuture;

  @override
  void initState() {
    super.initState();
    _conversationsFuture = _conversationService.getAllConversations();
  }
  
  // Add pull-to-refresh
  Future<void> _refreshConversations() async {
    setState(() {
      _conversationsFuture = _conversationService.getAllConversations(syncFirst: true);
    });
  }

  void _showNewConversationDialog() {
    final titleController = TextEditingController();
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('New Conversation'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: titleController,
              decoration: InputDecoration(
                hintText: 'Conversation title',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
              autofocus: true,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () async {
              if (titleController.text.isEmpty) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Please enter a title')),
                );
                return;
              }

              try {
                await _conversationService.createConversation(
                  title: titleController.text,
                );
                if (mounted) {
                  Navigator.pop(context);
                  setState(() {
                    // Don't re-sync from backend (keeps deleted convos deleted)
                    _conversationsFuture =
                        _conversationService.getAllConversations(syncFirst: false);
                  });
                }
              } catch (e) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Error: $e')),
                  );
                }
              }
            },
            child: const Text('Create'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('MessageAI'),
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.check_circle_outline, color: Color(0xFFF59E0B)), // Amber - Follow-ups
            onPressed: () {
              // Show modal instead of navigating
              showModalBottomSheet(
                context: context,
                isScrollControlled: true,
                backgroundColor: Colors.transparent,
                builder: (context) => DraggableScrollableSheet(
                  initialChildSize: 0.7,
                  minChildSize: 0.5,
                  maxChildSize: 0.95,
                  builder: (context, scrollController) => Container(
                    decoration: BoxDecoration(
                      color: Theme.of(context).scaffoldBackgroundColor,
                      borderRadius: const BorderRadius.only(
                        topLeft: Radius.circular(20),
                        topRight: Radius.circular(20),
                      ),
                    ),
                    child: const FollowUpDashboardScreen(),
                  ),
                ),
              );
            },
            tooltip: 'Follow-Ups',
          ),
          IconButton(
            icon: const Icon(Icons.settings),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const SettingsScreen(),
                ),
              );
            },
            tooltip: 'Settings',
          ),
        ],
      ),
      body: Column(
        children: [
          const NetworkStatusBanner(),
          Expanded(
            child: RefreshIndicator(
              onRefresh: _refreshConversations,
              child: FutureBuilder<List<Conversation>>(
          future: _conversationsFuture,
          builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.error_outline,
                    size: 64,
                    color: Theme.of(context).colorScheme.error,
                  ),
                  const SizedBox(height: 16),
                  Text('Error: ${snapshot.error}'),
                ],
              ),
            );
          }

          final conversations = snapshot.data ?? [];

          if (conversations.isEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.chat_outlined,
                    size: 80,
                    color: Theme.of(context)
                        .colorScheme
                        .primary
                        .withOpacity(0.3),
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'No conversations yet',
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Start a new conversation to begin messaging',
                    style: Theme.of(context).textTheme.bodyMedium,
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 32),
                  ElevatedButton.icon(
                    onPressed: _showNewConversationDialog,
                    icon: const Icon(Icons.add),
                    label: const Text('New Conversation'),
                  ),
                ],
              ),
            );
          }

          return ListView.separated(
            itemCount: conversations.length,
            separatorBuilder: (context, index) => Divider(
              height: 1,
              indent: 72,
              color: Colors.grey[300],
            ),
            itemBuilder: (context, index) {
              final conv = conversations[index];
              return Dismissible(
                key: Key(conv.id),
                direction: DismissDirection.endToStart,
                background: Container(
                  alignment: Alignment.centerRight,
                  padding: const EdgeInsets.only(right: 20),
                  color: Colors.red,
                  child: const Icon(
                    Icons.delete,
                    color: Colors.white,
                  ),
                ),
                confirmDismiss: (direction) async {
                  return await showDialog(
                    context: context,
                    builder: (BuildContext context) {
                      return AlertDialog(
                        title: const Text('Delete Conversation'),
                        content: Text(
                          'Are you sure you want to delete "${conv.title}"? This cannot be undone.',
                        ),
                        actions: [
                          TextButton(
                            onPressed: () => Navigator.of(context).pop(false),
                            child: const Text('Cancel'),
                          ),
                          TextButton(
                            onPressed: () => Navigator.of(context).pop(true),
                            style: TextButton.styleFrom(
                              foregroundColor: Colors.red,
                            ),
                            child: const Text('Delete'),
                          ),
                        ],
                      );
                    },
                  );
                },
                onDismissed: (direction) async {
                  try {
                    await _conversationService.deleteConversation(conv.id);
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text('Deleted "${conv.title}"')),
                      );
                      setState(() {
                        // Refresh from local DB only (don't re-sync from backend)
                        _conversationsFuture = _conversationService.getAllConversations(syncFirst: false);
                      });
                    }
                  } catch (e) {
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text('Error deleting conversation: $e')),
                      );
                      setState(() {
                        // Re-sync to refresh the list
                        _conversationsFuture = _conversationService.getAllConversations(syncFirst: true);
                      });
                    }
                  }
                },
                child: InkWell(
                  onTap: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => MessageScreen(
                          conversationId: conv.id,
                          conversationTitle: conv.title,
                        ),
                      ),
                    );
                  },
                  child: Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                    child: Row(
                      children: [
                        UserAvatar(
                          fallbackText: conv.title,
                          radius: 28,
                          isGroup: conv.isGroup,
                          // Note: We don't have userId for conversation participant here
                          // In a full implementation, we'd fetch the other user's ID
                          // For now, fallback to initials
                        ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              conv.title,
                              style: const TextStyle(
                                fontSize: 16,
                                fontWeight: FontWeight.w600,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                            const SizedBox(height: 4),
                            FutureBuilder<Message?>(
                              future: _conversationService.getLatestMessage(conv.id),
                              builder: (context, snapshot) {
                                String previewText = 'Tap to start messaging';
                                
                                if (snapshot.hasData && snapshot.data != null) {
                                  final message = snapshot.data!;
                                  if (message.mediaUrl != null && message.mediaUrl!.isNotEmpty) {
                                    previewText = '📷 ${message.body}';
                                  } else {
                                    previewText = message.body;
                                  }
                                }
                                
                                return Text(
                                  previewText,
                                  style: TextStyle(
                                    fontSize: 14,
                                    color: Colors.grey[600],
                                  ),
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis,
                                );
                              },
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(width: 8),
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.end,
                        children: [
                          Text(
                            _formatTime(conv.lastMessageAt),
                            style: TextStyle(
                              fontSize: 12,
                              color: Theme.of(context).colorScheme.primary,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                ),
              );
            },
          );
          },
              ),
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _showNewConversationDialog,
        child: const Icon(Icons.add),
      ),
    );
  }

  String _formatTime(int? timestamp) {
    if (timestamp == null) return '';
    final dateTime = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inMinutes < 1) {
      return 'now';
    } else if (difference.inHours < 1) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inDays < 1) {
      return '${difference.inHours}h ago';
    } else if (difference.inDays < 7) {
      return '${difference.inDays}d ago';
    } else {
      return '${dateTime.month}/${dateTime.day}';
    }
  }
}
</file>

<file path="lib/features/conversations/widgets/context_preview_card.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/conversation_context.dart';

/// Shows conversation context before opening
class ContextPreviewCard extends StatelessWidget {
  final ConversationContext context;
  final VoidCallback? onTap;

  const ContextPreviewCard({
    Key? key,
    required this.context,
    this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      elevation: 2,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(12),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  const Icon(
                    Icons.history,
                    size: 18,
                    color: Colors.blue,
                  ),
                  const SizedBox(width: 8),
                  const Text(
                    'Last Conversation',
                    style: TextStyle(
                      fontSize: 13,
                      fontWeight: FontWeight.bold,
                      color: Colors.blue,
                    ),
                  ),
                  const Spacer(),
                  if (this.context.fromCache)
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 6,
                        vertical: 2,
                      ),
                      decoration: BoxDecoration(
                        color: Colors.grey.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: const Text(
                        'cached',
                        style: TextStyle(
                          fontSize: 10,
                          color: Colors.grey,
                        ),
                      ),
                    ),
                ],
              ),
              const SizedBox(height: 8),

              // Last discussed
              Text(
                this.context.lastDiscussed,
                style: const TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                ),
              ),

              // Key points
              if (this.context.keyPoints.isNotEmpty) ...[
                const SizedBox(height: 12),
                const Text(
                  'Recent topics:',
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                    color: Colors.grey,
                  ),
                ),
                const SizedBox(height: 6),
                ...this.context.keyPoints.take(3).map((point) => Padding(
                      padding: const EdgeInsets.only(bottom: 4),
                      child: Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            '• ',
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.grey,
                            ),
                          ),
                          Expanded(
                            child: Text(
                              point.text,
                              style: TextStyle(
                                fontSize: 12,
                                color: Colors.grey,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                          const SizedBox(width: 4),
                          Text(
                            point.getTimeAgo(),
                            style: TextStyle(
                              fontSize: 10,
                              color: Colors.grey,
                            ),
                          ),
                        ],
                      ),
                    )),
              ],

              // Pending questions
              if (this.context.pendingQuestions.isNotEmpty) ...[
                const SizedBox(height: 12),
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.orange.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(6),
                  ),
                  child: Row(
                    children: [
                      const Icon(
                        Icons.help_outline,
                        size: 16,
                        color: Colors.orange,
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          '${this.context.pendingQuestions.length} unanswered question${this.context.pendingQuestions.length > 1 ? "s" : ""}',
                          style: const TextStyle(
                            fontSize: 12,
                            color: Colors.orange,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/conversations/widgets/message_bubble.dart">
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/features/messages/widgets/tone_detail_sheet.dart';
import 'package:messageai/state/ai_providers.dart';
import 'package:messageai/core/theme/app_theme.dart';

/// Widget to display a single message with AI analysis
class MessageBubble extends ConsumerWidget {
  final Message message;
  final bool isSent;
  final bool isLoading;
  final VoidCallback? onRetry;

  const MessageBubble({
    Key? key,
    required this.message,
    required this.isSent,
    this.isLoading = false,
    this.onRetry,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    
    // Fetch AI analysis for this message
    final analysisAsync = ref.watch(messageAnalysisProvider(message.id));
    
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Row(
        mainAxisAlignment: isSent ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          if (!isSent)
            Padding(
              padding: const EdgeInsets.only(right: 8),
              child: CircleAvatar(
                radius: 16,
                backgroundColor: theme.colorScheme.primaryContainer,
                child: Text(
                  message.senderId.isNotEmpty 
                      ? message.senderId[0].toUpperCase() 
                      : 'U',
                  style: TextStyle(color: theme.colorScheme.onPrimaryContainer),
                ),
              ),
            ),
          Flexible(
            child: GestureDetector(
              onLongPress: () => _showContextMenu(context, ref),
              child: Container(
                decoration: BoxDecoration(
                  color: isSent
                      ? theme.colorScheme.primary
                      : theme.colorScheme.surfaceVariant,
                  borderRadius: BorderRadius.circular(12),
                ),
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    if (message.mediaUrl != null && message.mediaUrl!.isNotEmpty)
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: Container(
                          width: 200,
                          height: 200,
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(8),
                            color: Colors.grey[300],
                          ),
                          child: Icon(
                            Icons.image,
                            size: 80,
                            color: Colors.grey[600],
                          ),
                        ),
                      ),
                    Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        // Check mark for received messages (interpreter feature)
                        if (!isSent)
                          analysisAsync.when(
                            data: (analysis) {
                              // Auto-flag concerning messages or show on all received
                              final showCheckMark = analysis != null && 
                                (analysis.urgencyLevel == 'High' || 
                                 analysis.urgencyLevel == 'Critical' ||
                                 (analysis.contextFlags?['rsd_trigger'] == true));
                              
                              if (showCheckMark) {
                                return Padding(
                                  padding: const EdgeInsets.only(right: 8, top: 2),
                                  child: GestureDetector(
                                    onTap: () {
                                      // Show interpretation
                                      ToneDetailSheet.show(
                                        context,
                                        analysis,
                                        message.body,
                                        message.id,
                                      );
                                    },
                                    child: Container(
                                      padding: const EdgeInsets.all(4),
                                      decoration: BoxDecoration(
                                        color: const Color(0xFF7C3AED).withOpacity(0.15),
                                        shape: BoxShape.circle,
                                      ),
                                      child: const Icon(
                                        Icons.psychology_outlined,
                                        size: 16,
                                        color: Color(0xFF7C3AED), // Purple - interpreter feature
                                      ),
                                    ),
                                  ),
                                );
                              }
                              return const SizedBox.shrink();
                            },
                            loading: () => const SizedBox.shrink(),
                            error: (_, __) => const SizedBox.shrink(),
                          ),
                        Expanded(
                          child: Text(
                            message.body,
                            style: TextStyle(
                              color: isSent ? Colors.white : theme.textTheme.bodyMedium?.color,
                              fontSize: 14,
                            ),
                          ),
                        ),
                      ],
                    ),
                    Padding(
                      padding: const EdgeInsets.only(top: 4),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(
                            _formatTime(DateTime.fromMillisecondsSinceEpoch(
                              message.createdAt * 1000,
                            )),
                            style: TextStyle(
                              color: isSent 
                                  ? Colors.white70 
                                  : theme.textTheme.bodySmall?.color,
                              fontSize: 12,
                            ),
                          ),
                          if (isSent) ...[
                            const SizedBox(width: 4),
                            if (isLoading)
                              SizedBox(
                                width: 12,
                                height: 12,
                                child: CircularProgressIndicator(
                                  strokeWidth: 1.5,
                                  valueColor: AlwaysStoppedAnimation(
                                    Colors.white70,
                                  ),
                                ),
                              )
                            else if (message.isSynced)
                              Icon(
                                Icons.check_circle,
                                size: 12,
                                color: Colors.white70,
                              )
                            else
                              Icon(
                                Icons.schedule,
                                size: 12,
                                color: Colors.white70,
                              ),
                          ],
                        ],
                      ),
                    ),
                    // AI Analysis Badge (shows tone analysis if available)
                    analysisAsync.when(
                      data: (analysis) {
                        if (analysis == null) return const SizedBox.shrink();
                        return Padding(
                          padding: const EdgeInsets.only(top: 8),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              // Tone Badge
                              ToneBadge(
                                analysis: analysis,
                                onTap: () => ToneDetailSheet.show(
                                  context,
                                  analysis,
                                  message.body,
                                  message.id,
                                ),
                              ),
                              // ✅ PHASE 1: RSD Warning Badge (immediate visibility)
                              if (analysis.rsdTriggers?.isNotEmpty ?? false) ...[
                                const SizedBox(height: 4),
                                Container(
                                  padding: const EdgeInsets.symmetric(
                                    horizontal: 8,
                                    vertical: 4,
                                  ),
                                  decoration: BoxDecoration(
                                    color: Colors.orange.withOpacity(0.2),
                                    borderRadius: BorderRadius.circular(8),
                                    border: Border.all(
                                      color: Colors.orange.withOpacity(0.5),
                                      width: 1,
                                    ),
                                  ),
                                  child: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      Icon(
                                        Icons.warning_amber_rounded,
                                        size: 14,
                                        color: Colors.orange[800],
                                      ),
                                      const SizedBox(width: 4),
                                      Text(
                                        'May trigger RSD',
                                        style: TextStyle(
                                          fontSize: 11,
                                          color: Colors.orange[800],
                                          fontWeight: FontWeight.w600,
                                        ),
                                      ),
                                      const SizedBox(width: 2),
                                      Text(
                                        '• Tap for details',
                                        style: TextStyle(
                                          fontSize: 10,
                                          color: Colors.orange[700],
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            ],
                          ),
                        );
                      },
                      loading: () => const SizedBox.shrink(),
                      error: (_, __) => const SizedBox.shrink(),
                    ),
                  ],
                ),
              ),
            ),
          ),
          if (isSent)
            Padding(
              padding: const EdgeInsets.only(left: 8),
              child: CircleAvatar(
                radius: 16,
                backgroundColor: theme.colorScheme.primary,
                child: Icon(
                  Icons.person,
                  size: 12,
                  color: Colors.white,
                ),
              ),
            ),
        ],
      ),
    );
  }

  /// Show context menu with AI features and copy/paste options (iPhone-style)
  void _showContextMenu(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    // iPhone-style popup menu
    showDialog(
      context: context,
      barrierColor: Colors.transparent,
      builder: (context) => GestureDetector(
        onTap: () => Navigator.pop(context),
        child: Material(
          color: Colors.transparent,
          child: Stack(
            children: [
              // Blur background
              Positioned.fill(
                child: Container(
                  color: Colors.black.withOpacity(0.1),
                ),
              ),
              // Center popup
              Center(
                child: Container(
                  margin: const EdgeInsets.symmetric(horizontal: 40),
                  decoration: BoxDecoration(
                    color: isDark ? AppTheme.darkGray100.withOpacity(0.95) : AppTheme.white.withOpacity(0.95),
                    borderRadius: BorderRadius.circular(14),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.3),
                        blurRadius: 30,
                        spreadRadius: 5,
                      ),
                    ],
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // AI Features (for received messages)
                      if (!isSent) ...[
                        _buildPopupOption(
                          context,
                          icon: Icons.psychology_outlined,
                          label: 'Analyze Message',
                          color: const Color(0xFF7C3AED), // Purple - interpreter
                          isDark: isDark,
                          isFirst: true,
                          onTap: () async {
                            Navigator.pop(context);
                            
                            // Show loading indicator
                            showDialog(
                              context: context,
                              barrierDismissible: false,
                              builder: (context) => const Center(
                                child: CircularProgressIndicator(),
                              ),
                            );
                            
                            try {
                              // Trigger analysis if it doesn't exist
                              final requestAnalysis = ref.read(requestAnalysisProvider);
                              final analysis = await requestAnalysis(message.id, message.body);
                              
                              if (context.mounted) {
                                Navigator.pop(context); // Close loading
                                
                                if (analysis != null) {
                                  // Refresh the analysis provider to show new data
                                  ref.invalidate(messageAnalysisProvider(message.id));
                                  
                                  // Show analysis sheet
                                  ToneDetailSheet.show(context, analysis, message.body, message.id);
                                } else {
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    const SnackBar(
                                      content: Text('Failed to analyze message. Please try again.'),
                                      backgroundColor: Colors.red,
                                    ),
                                  );
                                }
                              }
                            } catch (e) {
                              if (context.mounted) {
                                Navigator.pop(context); // Close loading
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text('Error: $e'),
                                    backgroundColor: Colors.red,
                                  ),
                                );
                              }
                            }
                          },
                        ),
                        Divider(height: 1, color: isDark ? AppTheme.darkGray300 : AppTheme.gray300),
                      ],
                      
                      // Copy
                      _buildPopupOption(
                        context,
                        icon: Icons.content_copy,
                        label: 'Copy',
                        color: isDark ? AppTheme.gray400 : AppTheme.gray700,
                        isDark: isDark,
                        isFirst: isSent,
                        onTap: () {
                          Clipboard.setData(ClipboardData(text: message.body));
                          Navigator.pop(context);
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: const Text('Copied to clipboard'),
                              behavior: SnackBarBehavior.floating,
                              duration: const Duration(seconds: 1),
                            ),
                          );
                        },
                      ),
                      
                      // Retry (if unsent)
                      if (isSent && !message.isSynced) ...[
                        Divider(height: 1, color: isDark ? AppTheme.darkGray300 : AppTheme.gray300),
                        _buildPopupOption(
                          context,
                          icon: Icons.refresh,
                          label: 'Retry',
                          color: AppTheme.accentOrange,
                          isDark: isDark,
                          isLast: true,
                          onTap: () {
                            Navigator.pop(context);
                            onRetry?.call();
                          },
                        ),
                      ],
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildPopupOption(
    BuildContext context, {
    required IconData icon,
    required String label,
    required Color color,
    required bool isDark,
    required VoidCallback onTap,
    bool isFirst = false,
    bool isLast = false,
  }) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.vertical(
        top: isFirst ? const Radius.circular(14) : Radius.zero,
        bottom: isLast ? const Radius.circular(14) : Radius.zero,
      ),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 22, color: color),
            const SizedBox(width: 12),
            Text(
              label,
              style: TextStyle(
                fontSize: 17,
                fontWeight: FontWeight.w500,
                color: color,
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// Format time for display
  String _formatTime(DateTime dateTime) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final yesterday = today.subtract(const Duration(days: 1));
    final messageDate = DateTime(dateTime.year, dateTime.month, dateTime.day);

    if (messageDate == today) {
      return '${dateTime.hour}:${dateTime.minute.toString().padLeft(2, '0')}';
    } else if (messageDate == yesterday) {
      return 'Yesterday';
    } else {
      return '${dateTime.month}/${dateTime.day}';
    }
  }
}
</file>

<file path="lib/features/conversations/widgets/relationship_summary_sheet.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/models/relationship_profile.dart';
import 'package:messageai/models/safe_topic.dart';
import 'package:messageai/services/relationship_service.dart';
import 'package:messageai/state/ai_providers.dart';

/// Bottom sheet showing relationship profile
class RelationshipSummarySheet extends ConsumerStatefulWidget {
  final String conversationId;

  const RelationshipSummarySheet({
    Key? key,
    required this.conversationId,
  }) : super(key: key);

  @override
  ConsumerState<RelationshipSummarySheet> createState() =>
      _RelationshipSummarySheetState();
}

class _RelationshipSummarySheetState
    extends ConsumerState<RelationshipSummarySheet> {
  final relationshipService = RelationshipService();

  RelationshipProfile? profile;
  List<SafeTopic>? safeTopics;
  bool isLoading = true;
  bool isGenerating = false;

  @override
  void initState() {
    super.initState();
    _loadProfile();
  }

  Future<void> _loadProfile() async {
    setState(() => isLoading = true);

    try {
      final results = await Future.wait([
        relationshipService.getProfile(widget.conversationId),
        relationshipService.getSafeTopics(widget.conversationId),
      ]);

      setState(() {
        profile = results[0] as RelationshipProfile?;
        safeTopics = results[1] as List<SafeTopic>?;
        isLoading = false;
      });
    } catch (e) {
      setState(() => isLoading = false);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error loading profile: $e')),
        );
      }
    }
  }

  /// Generate relationship summary using AI
  Future<void> _generateSummary({bool forceRegenerate = false}) async {
    setState(() => isGenerating = true);

    try {
      // Use provider to generate summary
      final newProfile = await ref.read(
        generateRelationshipSummaryProvider(widget.conversationId).future,
      );

      if (mounted) {
        setState(() {
          profile = newProfile;
          isGenerating = false;
        });

        // Reload safe topics
        final topics = await relationshipService.getSafeTopics(widget.conversationId);
        setState(() {
          safeTopics = topics;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('✨ Relationship summary generated!'),
            duration: Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        setState(() => isGenerating = false);

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to generate summary: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
      ),
      child: isLoading
          ? const Center(child: CircularProgressIndicator())
          : profile == null
              ? Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.person_outline,
                        size: 64,
                        color: Colors.grey[400],
                      ),
                      const SizedBox(height: 16),
                      const Text(
                        'No relationship profile yet',
                        style: TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'Generate an AI profile to understand\nthis relationship better',
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          fontSize: 14,
                          color: Colors.grey[600],
                        ),
                      ),
                      const SizedBox(height: 24),
                      ElevatedButton.icon(
                        onPressed: isGenerating ? null : _generateSummary,
                        icon: isGenerating
                            ? const SizedBox(
                                width: 16,
                                height: 16,
                                child: CircularProgressIndicator(strokeWidth: 2),
                              )
                            : const Icon(Icons.auto_awesome),
                        label: Text(
                          isGenerating ? 'Generating...' : 'Generate Profile',
                        ),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.purple,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(
                            horizontal: 24,
                            vertical: 12,
                          ),
                        ),
                      ),
                    ],
                  ),
                )
              : SingleChildScrollView(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // Header
                      Row(
                        children: [
                          Text(
                            profile!.getRelationshipEmoji(),
                            style: const TextStyle(fontSize: 32),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  profile!.participantName,
                                  style: const TextStyle(
                                    fontSize: 20,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                                if (profile!.relationshipType != null)
                                  Text(
                                    profile!.relationshipType!,
                                    style: TextStyle(
                                      fontSize: 14,
                                      color: Colors.grey,
                                    ),
                                  ),
                              ],
                            ),
                          ),
                          // ✅ PHASE 3: Refresh button
                          IconButton(
                            icon: isGenerating
                                ? const SizedBox(
                                    width: 20,
                                    height: 20,
                                    child: CircularProgressIndicator(strokeWidth: 2),
                                  )
                                : const Icon(Icons.refresh),
                            onPressed: isGenerating ? null : () => _generateSummary(forceRegenerate: true),
                            tooltip: 'Refresh profile',
                          ),
                          IconButton(
                            icon: const Icon(Icons.close),
                            onPressed: () => Navigator.pop(context),
                          ),
                        ],
                      ),
                      const SizedBox(height: 16),

                      // Summary
                      if (profile!.conversationSummary != null) ...[
                        _buildSection('About This Relationship', [
                          Text(
                            profile!.conversationSummary!,
                            style: const TextStyle(fontSize: 14),
                          ),
                        ]),
                        const SizedBox(height: 16),
                      ],

                      // Communication style
                      if (profile!.communicationStyle != null) ...[
                        _buildSection('Communication Style', [
                          Text(
                            profile!.communicationStyle!,
                            style: const TextStyle(fontSize: 14),
                          ),
                        ]),
                        const SizedBox(height: 16),
                      ],

                      // Response time
                      if (profile!.typicalResponseTime != null) ...[
                        _buildSection('Typical Response Time', [
                          Row(
                            children: [
                              const Icon(Icons.schedule, size: 20),
                              const SizedBox(width: 8),
                              Text(
                                profile!.formatResponseTime(),
                                style: const TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ],
                          ),
                        ]),
                        const SizedBox(height: 16),
                      ],

                      // Safe topics
                      if (profile!.safeTopics.isNotEmpty) ...[
                        _buildSection('Safe Topics', [
                          Wrap(
                            spacing: 8,
                            runSpacing: 8,
                            children: profile!.safeTopics.map((topic) {
                              return Chip(
                                label: Text(
                                  topic,
                                  style: const TextStyle(fontSize: 12),
                                ),
                                backgroundColor: Colors.green.withOpacity(0.1),
                                side: BorderSide(
                                  color: Colors.green.withOpacity(0.3),
                                ),
                              );
                            }).toList(),
                          ),
                        ]),
                        const SizedBox(height: 16),
                      ],

                      // Topics to avoid
                      if (profile!.topicsToAvoid.isNotEmpty) ...[
                        _buildSection('Topics to Avoid', [
                          Wrap(
                            spacing: 8,
                            runSpacing: 8,
                            children: profile!.topicsToAvoid.map((topic) {
                              return Chip(
                                label: Text(
                                  topic,
                                  style: const TextStyle(fontSize: 12),
                                ),
                                backgroundColor: Colors.red.withOpacity(0.1),
                                side: BorderSide(
                                  color: Colors.red.withOpacity(0.3),
                                ),
                              );
                            }).toList(),
                          ),
                        ]),
                        const SizedBox(height: 16),
                      ],

                      // Detailed safe topics
                      if (safeTopics != null && safeTopics!.isNotEmpty) ...[
                        _buildSection('Topic Engagement', [
                          ...safeTopics!.map((topic) => Padding(
                                padding: const EdgeInsets.only(bottom: 8),
                                child: Row(
                                  children: [
                                    Container(
                                      width: 8,
                                      height: 8,
                                      decoration: BoxDecoration(
                                        color: topic.getTopicColor(),
                                        shape: BoxShape.circle,
                                      ),
                                    ),
                                    const SizedBox(width: 8),
                                    Expanded(
                                      child: Text(
                                        topic.topicName,
                                        style: const TextStyle(fontSize: 13),
                                      ),
                                    ),
                                    Text(
                                      topic.getEngagementLabel(),
                                      style: TextStyle(
                                        fontSize: 11,
                                        color: topic.getTopicColor(),
                                        fontWeight: FontWeight.w500,
                                      ),
                                    ),
                                  ],
                                ),
                              )),
                        ]),
                      ],

                      // Stats
                      const SizedBox(height: 16),
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.grey.withOpacity(0.1),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.spaceAround,
                          children: [
                            _buildStat(
                              '${profile!.totalMessages}',
                              'messages',
                            ),
                            if (profile!.firstMessageAt != null)
                              _buildStat(
                                _getTimeSince(profile!.firstMessageAt!),
                                'talking',
                              ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
    );
  }

  Widget _buildSection(String title, List<Widget> children) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.bold,
            color: Colors.grey,
          ),
        ),
        const SizedBox(height: 8),
        ...children,
      ],
    );
  }

  Widget _buildStat(String value, String label) {
    return Column(
      children: [
        Text(
          value,
          style: const TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
        ),
        Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: Colors.grey,
          ),
        ),
      ],
    );
  }

  String _getTimeSince(int timestamp) {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final diff = now - timestamp;

    final days = diff ~/ 86400;
    if (days < 30) return '${days}d';

    final months = days ~/ 30;
    if (months < 12) return '${months}mo';

    final years = months ~/ 12;
    return '${years}yr';
  }
}

/// Show relationship summary sheet
void showRelationshipSummary(BuildContext context, String conversationId) {
  showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    builder: (context) => SizedBox(
      height: MediaQuery.of(context).size.height * 0.8,
      child: RelationshipSummarySheet(conversationId: conversationId),
    ),
  );
}
</file>

<file path="lib/features/conversations/widgets/who_is_this_button.dart">
import 'package:flutter/material.dart';
import 'package:messageai/features/conversations/widgets/relationship_summary_sheet.dart';

/// Quick access button to see who someone is
class WhoIsThisButton extends StatelessWidget {
  final String conversationId;
  final bool compact;

  const WhoIsThisButton({
    Key? key,
    required this.conversationId,
    this.compact = false,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return compact
        ? IconButton(
            icon: const Icon(Icons.info_outline),
            tooltip: 'Who is this?',
            onPressed: () => _showSummary(context),
          )
        : OutlinedButton.icon(
            icon: const Icon(Icons.info_outline, size: 18),
            label: const Text('Who is this?'),
            onPressed: () => _showSummary(context),
            style: OutlinedButton.styleFrom(
              foregroundColor: Colors.blue,
            ),
          );
  }

  void _showSummary(BuildContext context) {
    showRelationshipSummary(context, conversationId);
  }
}
</file>

<file path="lib/features/follow_ups/screens/follow_up_dashboard_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/follow_up_item.dart';
import 'package:messageai/state/ai_providers.dart';
import 'package:messageai/services/follow_up_service.dart';

/// Dashboard screen showing all pending follow-up items
class FollowUpDashboardScreen extends ConsumerStatefulWidget {
  const FollowUpDashboardScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<FollowUpDashboardScreen> createState() => _FollowUpDashboardScreenState();
}

class _FollowUpDashboardScreenState extends ConsumerState<FollowUpDashboardScreen> {
  final _followUpService = FollowUpService();
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final followUpsAsync = ref.watch(pendingFollowUpsProvider);

    return Scaffold(
      backgroundColor: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
      appBar: AppBar(
        title: const Text('Follow-Ups'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () {
              ref.invalidate(pendingFollowUpsProvider);
            },
            tooltip: 'Refresh',
          ),
        ],
      ),
      body: followUpsAsync.when(
        data: (followUps) {
          if (followUps.isEmpty) {
            return _buildEmptyState(context, isDark);
          }
          
          return _buildFollowUpsList(context, followUps, isDark);
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.error_outline,
                size: 64,
                color: Colors.red[300],
              ),
              const SizedBox(height: 16),
              Text(
                'Error loading follow-ups',
                style: theme.textTheme.titleMedium,
              ),
              const SizedBox(height: 8),
              Text(
                error.toString(),
                style: theme.textTheme.bodySmall,
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildEmptyState(BuildContext context, bool isDark) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.check_circle_outline,
            size: 80,
            color: isDark ? AppTheme.gray600 : AppTheme.gray400,
          ),
          const SizedBox(height: 16),
          Text(
            'All caught up!',
            style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
          ),
          const SizedBox(height: 8),
          Text(
            'No pending follow-ups',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: isDark ? AppTheme.gray600 : AppTheme.gray500,
                ),
          ),
        ],
      ),
    );
  }

  Widget _buildFollowUpsList(BuildContext context, List<FollowUpItem> followUps, bool isDark) {
    // Group by type
    final actionItems = followUps.where((f) => f.itemType == FollowUpItemType.actionItem).toList();
    final questions = followUps.where((f) => f.itemType == FollowUpItemType.unansweredQuestion).toList();
    final pending = followUps.where((f) => f.itemType == FollowUpItemType.pendingResponse).toList();
    final scheduled = followUps.where((f) => f.itemType == FollowUpItemType.scheduledFollowup).toList();

    return RefreshIndicator(
      onRefresh: () async {
        ref.invalidate(pendingFollowUpsProvider);
      },
      child: ListView(
        padding: const EdgeInsets.all(AppTheme.spacingM),
        children: [
          // Summary Card
          _buildSummaryCard(context, followUps, isDark),
          
          const SizedBox(height: AppTheme.spacingL),
          
          // Action Items
          if (actionItems.isNotEmpty) ...[
            _buildSectionHeader(
              context,
              'Action Items',
              actionItems.length,
              Icons.task_alt,
              Colors.orange,
            ),
            const SizedBox(height: AppTheme.spacingS),
            ...actionItems.map((item) => _buildFollowUpCard(context, item, isDark)),
            const SizedBox(height: AppTheme.spacingL),
          ],
          
          // Unanswered Questions
          if (questions.isNotEmpty) ...[
            _buildSectionHeader(
              context,
              'Unanswered Questions',
              questions.length,
              Icons.help_outline,
              Colors.blue,
            ),
            const SizedBox(height: AppTheme.spacingS),
            ...questions.map((item) => _buildFollowUpCard(context, item, isDark)),
            const SizedBox(height: AppTheme.spacingL),
          ],
          
          // Pending Responses
          if (pending.isNotEmpty) ...[
            _buildSectionHeader(
              context,
              'Pending Responses',
              pending.length,
              Icons.pending,
              Colors.purple,
            ),
            const SizedBox(height: AppTheme.spacingS),
            ...pending.map((item) => _buildFollowUpCard(context, item, isDark)),
            const SizedBox(height: AppTheme.spacingL),
          ],
          
          // Scheduled
          if (scheduled.isNotEmpty) ...[
            _buildSectionHeader(
              context,
              'Scheduled',
              scheduled.length,
              Icons.schedule,
              Colors.green,
            ),
            const SizedBox(height: AppTheme.spacingS),
            ...scheduled.map((item) => _buildFollowUpCard(context, item, isDark)),
          ],
        ],
      ),
    );
  }

  Widget _buildSummaryCard(BuildContext context, List<FollowUpItem> followUps, bool isDark) {
    final overdue = followUps.where((f) => f.isOverdue).length;
    final dueSoon = followUps.where((f) => f.isDueSoon).length;
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: isDark
              ? [AppTheme.darkGray100, AppTheme.darkGray200]
              : [Colors.purple[50]!, Colors.purple[100]!],
        ),
        borderRadius: BorderRadius.circular(AppTheme.radiusL),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceAround,
        children: [
          _buildSummaryItem('Total', followUps.length.toString(), Icons.list, Colors.purple),
          if (overdue > 0)
            _buildSummaryItem('Overdue', overdue.toString(), Icons.warning, Colors.red),
          if (dueSoon > 0)
            _buildSummaryItem('Due Soon', dueSoon.toString(), Icons.schedule, Colors.orange),
        ],
      ),
    );
  }

  Widget _buildSummaryItem(String label, String value, IconData icon, Color color) {
    return Column(
      children: [
        Icon(icon, color: color, size: 28),
        const SizedBox(height: 4),
        Text(
          value,
          style: TextStyle(
            fontSize: 24,
            fontWeight: FontWeight.bold,
            color: color,
          ),
        ),
        Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: Colors.grey[600],
          ),
        ),
      ],
    );
  }

  Widget _buildSectionHeader(BuildContext context, String title, int count, IconData icon, Color color) {
    return Row(
      children: [
        Icon(icon, size: 24, color: color),
        const SizedBox(width: 8),
        Text(
          title,
          style: Theme.of(context).textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
        ),
        const SizedBox(width: 8),
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
          decoration: BoxDecoration(
            color: color.withOpacity(0.2),
            borderRadius: BorderRadius.circular(AppTheme.radiusPill),
          ),
          child: Text(
            count.toString(),
            style: TextStyle(
              fontSize: 12,
              color: color,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildFollowUpCard(BuildContext context, FollowUpItem item, bool isDark) {
    final theme = Theme.of(context);
    
    return Card(
      margin: const EdgeInsets.only(bottom: AppTheme.spacingS),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        side: BorderSide(
          color: item.isOverdue
              ? Colors.red.withOpacity(0.5)
              : item.isDueSoon
                  ? Colors.orange.withOpacity(0.5)
                  : Colors.transparent,
          width: item.isOverdue || item.isDueSoon ? 2 : 0,
        ),
      ),
      child: InkWell(
        onTap: () {
          // Navigate to conversation
          // Navigator.push(context, MaterialPageRoute(
          //   builder: (context) => MessageScreen(conversationId: item.conversationId)
          // ));
        },
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        child: Padding(
          padding: const EdgeInsets.all(AppTheme.spacingM),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  Icon(
                    item.itemType.icon,
                    size: 20,
                    color: item.itemType.getColor(),
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      item.title,
                      style: theme.textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
              
              if (item.description != null) ...[
                const SizedBox(height: 8),
                Text(
                  item.description!,
                  style: theme.textTheme.bodySmall,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
              
              const SizedBox(height: 12),
              
              // Footer
              Row(
                children: [
                  // Priority badge
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: _getPriorityColor(item.priority).withOpacity(0.2),
                      borderRadius: BorderRadius.circular(AppTheme.radiusS),
                    ),
                    child: Text(
                      _getPriorityLabel(item.priority),
                      style: TextStyle(
                        fontSize: 10,
                        fontWeight: FontWeight.w600,
                        color: _getPriorityColor(item.priority),
                      ),
                    ),
                  ),
                  
                  const SizedBox(width: 8),
                  
                  // Time info
                  Text(
                    item.dueAt != null ? item.getTimeUntilDue() : item.getTimeSinceDetected(),
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: item.isOverdue
                          ? Colors.red
                          : item.isDueSoon
                              ? Colors.orange
                              : Colors.grey,
                      fontWeight: item.isOverdue || item.isDueSoon
                          ? FontWeight.w600
                          : FontWeight.normal,
                    ),
                  ),
                  
                  const Spacer(),
                  
                  // Actions
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // Complete
                      IconButton(
                        icon: const Icon(Icons.check_circle_outline, size: 20),
                        onPressed: () => _completeFollowUp(item.id),
                        tooltip: 'Complete',
                        padding: EdgeInsets.zero,
                        constraints: const BoxConstraints(),
                        color: Colors.green,
                      ),
                      const SizedBox(width: 8),
                      
                      // Snooze
                      IconButton(
                        icon: const Icon(Icons.snooze, size: 20),
                        onPressed: () => _showSnoozeDialog(item.id),
                        tooltip: 'Snooze',
                        padding: EdgeInsets.zero,
                        constraints: const BoxConstraints(),
                        color: Colors.orange,
                      ),
                      const SizedBox(width: 8),
                      
                      // Dismiss
                      IconButton(
                        icon: const Icon(Icons.close, size: 20),
                        onPressed: () => _dismissFollowUp(item.id),
                        tooltip: 'Dismiss',
                        padding: EdgeInsets.zero,
                        constraints: const BoxConstraints(),
                        color: Colors.grey,
                      ),
                    ],
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Color _getPriorityColor(int priority) {
    if (priority >= 80) return Colors.red;
    if (priority >= 60) return Colors.orange;
    if (priority >= 40) return Colors.blue;
    return Colors.grey;
  }

  String _getPriorityLabel(int priority) {
    if (priority >= 80) return 'HIGH';
    if (priority >= 60) return 'MEDIUM';
    return 'LOW';
  }

  Future<void> _completeFollowUp(String itemId) async {
    try {
      await _followUpService.completeFollowUp(itemId);
      ref.invalidate(pendingFollowUpsProvider);
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('✅ Follow-up marked as complete'),
            duration: Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _dismissFollowUp(String itemId) async {
    try {
      await _followUpService.dismissFollowUp(itemId);
      ref.invalidate(pendingFollowUpsProvider);
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Dismissed'),
            duration: Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  void _showSnoozeDialog(String itemId) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Snooze Follow-up'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              title: const Text('1 hour'),
              onTap: () {
                Navigator.pop(context);
                _snoozeFollowUp(itemId, const Duration(hours: 1));
              },
            ),
            ListTile(
              title: const Text('3 hours'),
              onTap: () {
                Navigator.pop(context);
                _snoozeFollowUp(itemId, const Duration(hours: 3));
              },
            ),
            ListTile(
              title: const Text('Tomorrow'),
              onTap: () {
                Navigator.pop(context);
                _snoozeFollowUp(itemId, const Duration(days: 1));
              },
            ),
            ListTile(
              title: const Text('3 days'),
              onTap: () {
                Navigator.pop(context);
                _snoozeFollowUp(itemId, const Duration(days: 3));
              },
            ),
            ListTile(
              title: const Text('1 week'),
              onTap: () {
                Navigator.pop(context);
                _snoozeFollowUp(itemId, const Duration(days: 7));
              },
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _snoozeFollowUp(String itemId, Duration duration) async {
    try {
      await _followUpService.snoozeFollowUp(itemId, duration);
      ref.invalidate(pendingFollowUpsProvider);
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('⏰ Snoozed for ${_formatDuration(duration)}'),
            duration: const Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  String _formatDuration(Duration duration) {
    if (duration.inDays > 0) return '${duration.inDays} day${duration.inDays > 1 ? 's' : ''}';
    if (duration.inHours > 0) return '${duration.inHours} hour${duration.inHours > 1 ? 's' : ''}';
    return '${duration.inMinutes} minute${duration.inMinutes > 1 ? 's' : ''}';
  }
}
</file>

<file path="lib/features/follow_ups/widgets/extract_follow_ups_button.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/ai_providers.dart';

/// Button to extract follow-ups from a conversation
class ExtractFollowUpsButton extends ConsumerWidget {
  final String conversationId;
  final bool compact;

  const ExtractFollowUpsButton({
    Key? key,
    required this.conversationId,
    this.compact = false,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final extractionState = ref.watch(followUpExtractionProvider);

    final isExtracting = extractionState.isLoading;

    if (compact) {
      return IconButton(
        icon: isExtracting
            ? const SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(strokeWidth: 2),
              )
            : const Icon(Icons.search),
        onPressed: isExtracting
            ? null
            : () => _extractFollowUps(context, ref),
        tooltip: 'Scan for follow-ups',
      );
    }

    return ElevatedButton.icon(
      onPressed: isExtracting
          ? null
          : () => _extractFollowUps(context, ref),
      icon: isExtracting
          ? const SizedBox(
              width: 16,
              height: 16,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                color: Colors.white,
              ),
            )
          : const Icon(Icons.search, size: 18),
      label: Text(
        isExtracting ? 'Scanning...' : '🔍 Scan for Follow-ups',
      ),
      style: ElevatedButton.styleFrom(
        backgroundColor: Colors.purple,
        foregroundColor: Colors.white,
        padding: const EdgeInsets.symmetric(
          horizontal: 16,
          vertical: 8,
        ),
      ),
    );
  }

  Future<void> _extractFollowUps(BuildContext context, WidgetRef ref) async {
    try {
      await ref.read(followUpExtractionProvider.notifier).extractFollowUps(
            conversationId,
            scanAll: false,
          );

      // Invalidate follow-up providers to reload data
      ref.invalidate(conversationFollowUpsProvider(conversationId));
      ref.invalidate(pendingFollowUpsProvider);

      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('✨ Follow-ups extracted!'),
            duration: Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}
</file>

<file path="lib/features/follow_ups/widgets/follow_up_badge.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/ai_providers.dart';

/// Badge showing number of pending follow-ups for a conversation
class FollowUpBadge extends ConsumerWidget {
  final String conversationId;
  final bool compact;

  const FollowUpBadge({
    Key? key,
    required this.conversationId,
    this.compact = true,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final followUpsAsync = ref.watch(conversationFollowUpsProvider(conversationId));

    return followUpsAsync.when(
      data: (followUps) {
        if (followUps.isEmpty) {
          return const SizedBox.shrink();
        }

        final overdue = followUps.where((f) => f.isOverdue).length;
        final dueSoon = followUps.where((f) => f.isDueSoon).length;

        if (compact) {
          return _buildCompactBadge(followUps.length, overdue, dueSoon);
        } else {
          return _buildExpandedBadge(followUps.length, overdue, dueSoon);
        }
      },
      loading: () => const SizedBox.shrink(),
      error: (_, __) => const SizedBox.shrink(),
    );
  }

  Widget _buildCompactBadge(int total, int overdue, int dueSoon) {
    Color color;
    if (overdue > 0) {
      color = Colors.red;
    } else if (dueSoon > 0) {
      color = Colors.orange;
    } else {
      color = Colors.blue;
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: color,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            Icons.notification_important,
            size: 12,
            color: Colors.white,
          ),
          const SizedBox(width: 4),
          Text(
            total.toString(),
            style: const TextStyle(
              color: Colors.white,
              fontSize: 11,
              fontWeight: FontWeight.bold,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildExpandedBadge(int total, int overdue, int dueSoon) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: Colors.purple.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: Colors.purple.withOpacity(0.3),
          width: 1,
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            Icons.task_alt,
            size: 16,
            color: Colors.purple,
          ),
          const SizedBox(width: 6),
          Text(
            '$total follow-up${total != 1 ? 's' : ''}',
            style: TextStyle(
              color: Colors.purple[800],
              fontSize: 12,
              fontWeight: FontWeight.w600,
            ),
          ),
          if (overdue > 0) ...[
            const SizedBox(width: 6),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
              decoration: BoxDecoration(
                color: Colors.red,
                borderRadius: BorderRadius.circular(4),
              ),
              child: Text(
                '$overdue overdue',
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 10,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/messages/screens/message_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/message_service.dart';
import 'package:messageai/services/conversation_service.dart';
import 'package:messageai/services/presence_service.dart';
import 'package:messageai/services/realtime_message_service.dart';
import 'package:messageai/services/typing_indicator_service.dart';
import 'package:messageai/services/context_preloader_service.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/features/messages/widgets/message_list_panel.dart';
import 'package:messageai/features/messages/widgets/ai_insights_panel.dart';
import 'package:messageai/features/messages/widgets/smart_inbox_panel.dart';
import 'package:messageai/features/conversations/widgets/context_preview_card.dart';
import 'package:messageai/features/conversations/widgets/who_is_this_button.dart';
import 'package:messageai/features/follow_ups/widgets/extract_follow_ups_button.dart';
import 'package:messageai/models/conversation_context.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/services/ai_analysis_service.dart';
import 'package:image_picker/image_picker.dart';
import 'package:uuid/uuid.dart';
import 'dart:async';

class MessageScreen extends StatefulWidget {
  final String conversationId;
  final String conversationTitle;

  const MessageScreen({
    Key? key,
    required this.conversationId,
    required this.conversationTitle,
  }) : super(key: key);

  @override
  State<MessageScreen> createState() => _MessageScreenState();
}

class _MessageScreenState extends State<MessageScreen> {
  final _messageService = MessageService();
  final _conversationService = ConversationService();
  final _presenceService = PresenceService();
  final _realtimeService = RealTimeMessageService();
  final _typingService = TypingIndicatorService();
  final _contextService = ContextPreloaderService();
  final _aiAnalysisService = AIAnalysisService();
  final _receiptDao = AppDb.instance.receiptDao;
  final _messageController = TextEditingController();
  final _imagePicker = ImagePicker();
  late Future<List<Message>> _messagesFuture;
  late Future<List<Participant>> _participantsFuture;
  bool _isSending = false;
  bool _isUploadingImage = false;
  String? _currentUserId;
  Map<String, List<Receipt>> _receiptsCache = {};
  Set<String> _typingUsers = {};
  Timer? _typingTimer;
  XFile? _selectedImage;
  Set<String> _onlineUsers = {};
  double _panelPosition = 0.8; // Track sliding panel position (0.0 = down, 1.0 = up)
  ConversationContext? _conversationContext;

  @override
  void initState() {
    super.initState();
    _currentUserId = _messageService.getCurrentUserId();
    
    // Sync messages from backend first, then load
    _messagesFuture = _messageService.getMessagesByConversation(
      widget.conversationId,
      syncFirst: true,
    );
    _participantsFuture = _conversationService.getParticipants(widget.conversationId);
    
    // Initialize real-time features
    _initializeRealtime();
    
    // Load receipts
    _loadReceipts();
    
    // Load conversation context
    _loadContext();
    
    // Mark messages as read when opening conversation
    _messagesFuture.then((_) => _markMessagesAsRead());
    
    // Auto-analyze recent messages from others (Phase 1: Smart Interpreter)
    _messagesFuture.then((messages) => _autoAnalyzeRecentMessages(messages));
    
    // Listen for text changes to send typing indicators
    _messageController.addListener(_onTextChanged);
  }

  Future<void> _loadContext() async {
    try {
      final context = await _contextService.loadContext(widget.conversationId);
      if (mounted) {
        setState(() {
          _conversationContext = context;
        });
      }
    } catch (e) {
      print('Error loading context: $e');
    }
  }

  Future<void> _loadReceipts() async {
    try {
      final receipts = await _receiptDao.getReceiptsByConversation(widget.conversationId);
      setState(() {
        _receiptsCache.clear();
        for (final receipt in receipts) {
          if (!_receiptsCache.containsKey(receipt.messageId)) {
            _receiptsCache[receipt.messageId] = [];
          }
          _receiptsCache[receipt.messageId]!.add(receipt);
        }
      });
    } catch (e) {
      print('Error loading receipts: $e');
    }
  }

  Future<void> _markMessagesAsRead() async {
    try {
      if (_currentUserId == null) return;
      
      // Get all messages
      final messages = await _messagesFuture;
      
      // Find unread messages from others
      for (final message in messages) {
        // Skip own messages
        if (message.senderId == _currentUserId) continue;
        
        // Check if we already have a read receipt
        final existingReceipts = _receiptsCache[message.id] ?? [];
        final hasReadReceipt = existingReceipts.any((r) => 
          r.userId == _currentUserId && r.status == 'read'
        );
        
        if (!hasReadReceipt) {
          await _createReadReceipt(message.id);
        }
      }
    } catch (e) {
      print('Error marking messages as read: $e');
    }
  }

  /// Auto-analyze recent messages from others (non-blocking)
  Future<void> _autoAnalyzeRecentMessages(List<Message> messages) async {
    try {
      if (_currentUserId == null) return;
      
      // Only analyze the last 10 messages from others
      final recentMessages = messages
          .where((m) => m.senderId != _currentUserId)
          .toList()
          ..sort((a, b) => b.createdAt.compareTo(a.createdAt)); // Most recent first
      
      final messagesToAnalyze = recentMessages.take(10).toList();
      
      print('🤖 Auto-analyzing ${messagesToAnalyze.length} recent messages...');
      
      // Trigger analysis in background (don't await)
      for (final message in messagesToAnalyze) {
        _aiAnalysisService.requestAnalysis(message.id, message.body).then((analysis) {
          if (analysis != null) {
            print('✨ Auto-analysis complete for message ${message.id.substring(0, 8)}');
          }
        }).catchError((error) {
          print('⚠️ Auto-analysis failed for ${message.id.substring(0, 8)}: $error');
        });
      }
    } catch (e) {
      print('Error auto-analyzing messages: $e');
    }
  }

  Future<void> _createReadReceipt(String messageId) async {
    try {
      if (_currentUserId == null) return;
      
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      
      // Check if receipt already exists
      final existingReceipt = await _receiptDao.getReceipt(messageId, _currentUserId!);
      
      if (existingReceipt != null) {
        // Update existing receipt to "read"
        await _receiptDao.updateReceiptStatus(messageId, _currentUserId!, 'read');
        
        // Sync to backend
        final supabase = SupabaseClientProvider.client;
        await supabase.from('message_receipts')
          .update({
            'status': 'read',
            'at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
          })
          .eq('message_id', messageId)
          .eq('user_id', _currentUserId!);
      } else {
        // Create new receipt
        final receiptId = const Uuid().v4();
        final receipt = Receipt(
          id: receiptId,
          messageId: messageId,
          userId: _currentUserId!,
          status: 'read',
          createdAt: now,
          updatedAt: now,
          isSynced: false,
        );
        
        await _receiptDao.addReceipt(receipt);
        
        final supabase = SupabaseClientProvider.client;
        await supabase.from('message_receipts').insert({
          'id': receiptId,
          'message_id': messageId,
          'user_id': _currentUserId,
          'status': 'read',
          'at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
        });
        
        await _receiptDao.markReceiptAsSynced(receiptId);
      }
    } catch (e) {
      print('Error creating read receipt: $e');
    }
  }

  Timer? _pollTimer;
  Timer? _presenceCheckTimer;

  Future<void> _initializeRealtime() async {
    try {
      // Subscribe to presence updates
      await _presenceService.subscribeToPresence(widget.conversationId);
      // Set current user as online
      await _presenceService.setPresenceStatus(widget.conversationId, true);
      
      // Poll presence status every 2 seconds to update UI
      _presenceCheckTimer = Timer.periodic(const Duration(seconds: 2), (timer) {
        if (mounted) {
          setState(() {
            _onlineUsers = _presenceService.getOnlineUsers(widget.conversationId);
          });
        }
      });
      
      // Subscribe to real-time messages
      _realtimeService.subscribeToMessages(widget.conversationId).listen((messages) {
        setState(() {
          _messagesFuture = Future.value(messages);
        });
        _loadReceipts();
        _markMessagesAsRead(); // Mark new messages as read
      });
      
      // Subscribe to real-time receipts
      _realtimeService.subscribeToReceipts(widget.conversationId).listen((receipts) {
        print('📬 Receipt update: ${receipts.length} total receipts');
        setState(() {
          _receiptsCache.clear();
          for (final receipt in receipts) {
            if (!_receiptsCache.containsKey(receipt.messageId)) {
              _receiptsCache[receipt.messageId] = [];
            }
            _receiptsCache[receipt.messageId]!.add(receipt);
            print('   - Message ${receipt.messageId.substring(0, 8)}: ${receipt.status} by ${receipt.userId.substring(0, 8)}');
          }
        });
      });
      
      // Subscribe to typing indicators
      _typingService.subscribeToTyping(widget.conversationId).listen((typingUserIds) {
        setState(() {
          _typingUsers = typingUserIds;
        });
      });
    } catch (e) {
      print('❌ Realtime init failed: $e');
    }
  }

  @override
  void dispose() {
    _messageController.removeListener(_onTextChanged);
    _messageController.dispose();
    _typingTimer?.cancel();
    _pollTimer?.cancel();
    _presenceCheckTimer?.cancel();
    // Set user as offline before leaving
    _presenceService.setPresenceStatus(widget.conversationId, false);
    // Clean up realtime subscriptions
    _presenceService.unsubscribeFromPresence(widget.conversationId);
    _realtimeService.unsubscribeFromMessages(widget.conversationId);
    _realtimeService.unsubscribeFromReceipts(widget.conversationId);
    _typingService.unsubscribeFromTyping(widget.conversationId);
    super.dispose();
  }

  void _onTextChanged() {
    if (_messageController.text.isNotEmpty) {
      // User is typing
      _typingService.sendTypingIndicator(widget.conversationId, true);
      
      // Reset the timer
      _typingTimer?.cancel();
      _typingTimer = Timer(const Duration(seconds: 2), () {
        // Stop typing after 2 seconds of inactivity
        _typingService.sendTypingIndicator(widget.conversationId, false);
      });
    } else {
      // User cleared text, stop typing
      _typingTimer?.cancel();
      _typingService.sendTypingIndicator(widget.conversationId, false);
    }
  }

  Future<void> _pickImage() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 1920,
        maxHeight: 1920,
        imageQuality: 85,
      );
      
      if (image != null) {
        setState(() {
          _selectedImage = image;
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error picking image: $e')),
        );
      }
    }
  }

  Future<String?> _uploadImage(XFile image) async {
    setState(() => _isUploadingImage = true);
    
    try {
      final userId = SupabaseClientProvider.client.auth.currentUser?.id;
      if (userId == null) throw Exception('User not authenticated');
      
      final fileBytes = await image.readAsBytes();
      final fileName = '${DateTime.now().millisecondsSinceEpoch}_${image.name}';
      final path = '$userId/$fileName';
      
      await SupabaseClientProvider.client.storage
          .from('media')
          .uploadBinary(path, fileBytes);
      
      final url = SupabaseClientProvider.client.storage
          .from('media')
          .getPublicUrl(path);
      
      return url;
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error uploading image: $e')),
        );
      }
      return null;
    } finally {
      if (mounted) {
        setState(() => _isUploadingImage = false);
      }
    }
  }

  Future<void> _sendMessage() async {
    final messageText = _messageController.text.trim();
    final hasText = messageText.isNotEmpty;
    final hasImage = _selectedImage != null;
    
    if (!hasText && !hasImage) return;
    if (_isSending || _isUploadingImage) return;

    // Clear input immediately for better UX
    _messageController.clear();
    final imageToSend = _selectedImage;
    setState(() {
      _selectedImage = null;
    });
    
    // Stop typing indicator when message is sent
    _typingTimer?.cancel();
    _typingService.sendTypingIndicator(widget.conversationId, false);

    setState(() => _isSending = true);

    try {
      String? mediaUrl;
      
      // Upload image if present
      if (imageToSend != null) {
        mediaUrl = await _uploadImage(imageToSend);
        if (mediaUrl == null) {
          throw Exception('Failed to upload image');
        }
      }
      
      await _messageService.sendMessage(
        conversationId: widget.conversationId,
        body: hasText ? messageText : '📷 Photo',
        mediaUrl: mediaUrl,
      );

      setState(() {
        _messagesFuture = _messageService.getMessagesByConversation(widget.conversationId);
      });
      
      // Reload receipts to update delivery status
      _loadReceipts();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
        _messageController.text = messageText;
        if (imageToSend != null) {
          setState(() {
            _selectedImage = imageToSend;
          });
        }
      }
    } finally {
      if (mounted) {
        setState(() => _isSending = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    return Scaffold(
      backgroundColor: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
      appBar: AppBar(
        title: Row(
          children: [
            Stack(
              children: [
                CircleAvatar(
                  radius: 18,
                  backgroundColor: Colors.grey[300],
                  child: Icon(
                    Icons.group,
                    size: 20,
                    color: Colors.grey[700],
                  ),
                ),
                if (_onlineUsers.isNotEmpty)
                  Positioned(
                    right: 0,
                    bottom: 0,
                    child: Container(
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(
                        color: Colors.green,
                        shape: BoxShape.circle,
                        border: Border.all(color: Colors.white, width: 2),
                      ),
                      child: Text(
                        '${_onlineUsers.length}',
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
              ],
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    widget.conversationTitle,
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  if (_onlineUsers.isNotEmpty)
                    Text(
                      '${_onlineUsers.length} online',
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.white.withOpacity(0.8),
                      ),
                    ),
                ],
              ),
            ),
          ],
        ),
        elevation: 1,
        actions: [
          WhoIsThisButton(
            conversationId: widget.conversationId,
            compact: true,
          ),
          ExtractFollowUpsButton(
            conversationId: widget.conversationId,
            compact: true,
          ),
          IconButton(
            icon: const Icon(Icons.person_add),
            onPressed: _showAddParticipantsDialog,
            tooltip: 'Add participants',
          ),
          IconButton(
            icon: const Icon(Icons.more_vert),
            onPressed: () => _showParticipantsInfo(context),
            tooltip: 'Options',
          ),
        ],
      ),
      body: FutureBuilder<List<Message>>(
        future: _messagesFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(
              child: Text(
                'Error: ${snapshot.error}',
                style: theme.textTheme.bodyMedium,
              ),
            );
          }

          final messages = snapshot.data ?? [];

          return Column(
            children: [
              // Context Preview at top
              if (_conversationContext != null)
                ContextPreviewCard(
                  context: _conversationContext!,
                  onTap: () {
                    // Could expand to show more details or scroll
                  },
                ),
              
              // Main area: AI panel with sliding overlay
              Expanded(
                child: Stack(
                  children: [
                    // Background: AI panels (always visible)
                    Container(
                      color: Theme.of(context).brightness == Brightness.dark 
                        ? AppTheme.darkGray200 
                        : AppTheme.gray50,
                      child: CustomScrollView(
                        slivers: [
                          // Smart Inbox (at the top)
                          SliverToBoxAdapter(
                            child: SmartInboxPanel(
                              conversationId: widget.conversationId,
                              messages: messages,
                              onMessageTap: (message) {
                                // Scroll to message
                                // TODO: Implement scroll to message
                              },
                            ),
                          ),
                          
                          // AI Insights Panel below
                          SliverFillRemaining(
                            child: AIInsightsPanel(
                              conversationId: widget.conversationId,
                              messages: messages,
                              panelPosition: _panelPosition,
                            ),
                          ),
                        ],
                      ),
                    ),
                    
                    // Foreground: Sliding message panel (bottom fixed, top slides)
                    Align(
                      alignment: Alignment.bottomCenter,
                      child: GestureDetector(
                        onVerticalDragUpdate: (details) {
                          setState(() {
                            // Convert drag to panel height (inverted - drag down = smaller)
                            final screenHeight = MediaQuery.of(context).size.height;
                            final delta = -details.delta.dy / screenHeight;
                            _panelPosition = (_panelPosition + delta).clamp(0.12, 1.0);
                          });
                        },
                        onVerticalDragEnd: (details) {
                          // Snap to nearest position
                          setState(() {
                            if (_panelPosition < 0.18) {
                              _panelPosition = 0.12; // Minimized - just input + handle
                            } else if (_panelPosition < 0.4) {
                              _panelPosition = 0.3; // Small peek
                            } else if (_panelPosition < 0.65) {
                              _panelPosition = 0.5; // Half
                            } else if (_panelPosition < 0.9) {
                              _panelPosition = 0.85; // Most
                            } else {
                              _panelPosition = 1.0; // Full
                            }
                          });
                        },
                        child: AnimatedContainer(
                          duration: const Duration(milliseconds: 200),
                          curve: Curves.easeOut,
                          height: MediaQuery.of(context).size.height * _panelPosition,
                          width: double.infinity,
                          decoration: BoxDecoration(
                            color: isDark ? AppTheme.black : AppTheme.white,
                            borderRadius: const BorderRadius.only(
                              topLeft: Radius.circular(16),
                              topRight: Radius.circular(16),
                            ),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.black.withOpacity(0.3),
                                blurRadius: 20,
                                spreadRadius: 5,
                                offset: const Offset(0, -5),
                              ),
                            ],
                          ),
                          child: Column(
                            children: [
                              // Drag handle at TOP
                              InkWell(
                                onTap: () {
                                  setState(() {
                                    // Cycle through positions
                                    if (_panelPosition >= 1.0) {
                                      _panelPosition = 0.85; // Most
                                    } else if (_panelPosition >= 0.85) {
                                      _panelPosition = 0.5; // Half
                                    } else if (_panelPosition >= 0.5) {
                                      _panelPosition = 0.3; // Peek
                                    } else if (_panelPosition >= 0.3) {
                                      _panelPosition = 0.12; // Minimized
                                    } else {
                                      _panelPosition = 1.0; // Full
                                    }
                                  });
                                },
                                child: Container(
                                  width: double.infinity,
                                  padding: const EdgeInsets.symmetric(vertical: AppTheme.spacingM),
                                  child: Center(
                                    child: Container(
                                      width: 40,
                                      height: 5,
                                      decoration: BoxDecoration(
                                        color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                                        borderRadius: BorderRadius.circular(AppTheme.radiusPill),
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                              
                              // Message list
                              Expanded(
                                child: MessageListPanel(
                                  messages: messages,
                                  currentUserId: _currentUserId,
                                  receiptsCache: _receiptsCache,
                                  typingUsers: _typingUsers,
                                  onlineUsers: _onlineUsers,
                                  messageController: _messageController,
                                  isSending: _isSending,
                                  isUploadingImage: _isUploadingImage,
                                  selectedImage: _selectedImage,
                                  onSendMessage: _sendMessage,
                                  onPickImage: _pickImage,
                                  onClearImage: () {
                                    setState(() {
                                      _selectedImage = null;
                                    });
                                  },
                                  showComposeBar: true,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  void _showAddParticipantsDialog() {
    final emailController = TextEditingController();
    bool isSearching = false;
    
    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: const Text('Add Participant'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                controller: emailController,
                decoration: InputDecoration(
                  hintText: 'Enter email address',
                  helperText: 'Example: user@example.com',
                  prefixIcon: const Icon(Icons.email),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
                keyboardType: TextInputType.emailAddress,
                autofocus: true,
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: isSearching ? null : () async {
                final email = emailController.text.trim();
                if (email.isEmpty) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Please enter an email')),
                  );
                  return;
                }

                setState(() => isSearching = true);

                try {
                  // Add participant by email using database function
                  final response = await SupabaseClientProvider.client
                      .rpc('add_participant_by_email', params: {
                    'p_conversation_id': widget.conversationId,
                    'p_email': email,
                  });

                  final result = response as Map<String, dynamic>;
                  
                  if (result['success'] == false) {
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text(result['error'] ?? 'Failed to add participant')),
                      );
                    }
                    setState(() => isSearching = false);
                    return;
                  }
                  
                  if (mounted) {
                    Navigator.pop(context);
                    // Force refresh participants from backend
                    this.setState(() {
                      _participantsFuture = _conversationService.getParticipants(
                        widget.conversationId, 
                        syncFirst: true,  // Force sync from backend
                      );
                    });
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Added $email to conversation')),
                    );
                  }
                } catch (e) {
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Error: $e')),
                    );
                  }
                  setState(() => isSearching = false);
                }
              },
              child: isSearching 
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Text('Add'),
            ),
          ],
        ),
      ),
    );
  }

  void _showParticipantsInfo(BuildContext context) {
    showModalBottomSheet(
      context: context,
      builder: (context) => FutureBuilder<List<Participant>>(
        future: _participantsFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(child: Text('Error: ${snapshot.error}'));
          }

          final participants = snapshot.data ?? [];

          return SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Participants (${participants.length})',
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                  const SizedBox(height: 16),
                  if (participants.isEmpty)
                    const Center(
                      child: Padding(
                        padding: EdgeInsets.all(16),
                        child: Text('No participants yet'),
                      ),
                    )
                  else
                    ListView.builder(
                      shrinkWrap: true,
                      physics: const NeverScrollableScrollPhysics(),
                      itemCount: participants.length,
                      itemBuilder: (context, index) {
                        final participant = participants[index];
                        final isOnline = _presenceService.isUserOnline(
                          widget.conversationId,
                          participant.userId,
                        );
                        
                        return FutureBuilder<Map<String, dynamic>?>(
                          future: _conversationService.getParticipantProfile(participant.userId),
                          builder: (context, profileSnapshot) {
                            final profile = profileSnapshot.data;
                            final displayName = profile?['email'] as String? ?? 
                                              profile?['username'] as String? ?? 
                                              profile?['display_name'] as String? ??
                                              participant.userId.substring(0, 8);
                            final avatarUrl = profile?['avatar_url'] as String?;
                            final initial = displayName.isNotEmpty 
                                ? displayName[0].toUpperCase() 
                                : 'U';
                            
                            return ListTile(
                              leading: Stack(
                                children: [
                                  CircleAvatar(
                                    backgroundImage: avatarUrl != null
                                        ? NetworkImage(avatarUrl)
                                        : null,
                                    child: avatarUrl == null
                                        ? Text(initial)
                                        : null,
                                  ),
                                  Positioned(
                                    right: 0,
                                    bottom: 0,
                                    child: Container(
                                      width: 12,
                                      height: 12,
                                      decoration: BoxDecoration(
                                        color: isOnline ? Colors.green : Colors.grey,
                                        shape: BoxShape.circle,
                                        border: Border.all(
                                          color: Colors.white,
                                          width: 2,
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                              title: Text(displayName),
                              subtitle: Text(
                                isOnline
                                    ? (participant.isAdmin ? 'Admin • Online' : 'Member • Online')
                                    : (participant.isAdmin ? 'Admin • Offline' : 'Member • Offline'),
                              ),
                              trailing: participant.userId != _currentUserId
                                  ? IconButton(
                                      icon: const Icon(Icons.remove_circle),
                                      onPressed: () {
                                        Navigator.pop(context);
                                        _removeParticipant(participant.userId);
                                      },
                                    )
                                  : null,
                            );
                          },
                        );
                      },
                    ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Future<void> _removeParticipant(String userId) async {
    try {
      await _conversationService.removeParticipant(
        widget.conversationId,
        userId,
      );
      setState(() {
        _participantsFuture = _conversationService.getParticipants(widget.conversationId);
      });
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Participant removed')),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    }
  }

}
</file>

<file path="lib/features/messages/widgets/ai_insights_background.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';

/// Background panel for AI insights that appears behind the sliding message panel
/// Users can swipe down the message panel to reveal this content
class AIInsightsBackground extends StatelessWidget {
  final String conversationId;
  final double panelPosition;

  const AIInsightsBackground({
    Key? key,
    required this.conversationId,
    this.panelPosition = 0.0,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    // Calculate opacity based on panel position
    // When panel is fully up (position = 1.0), fade out insights
    // When panel is down (position = 0.0), show insights fully
    final opacity = 1.0 - panelPosition;
    
    return Container(
      color: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
      padding: const EdgeInsets.all(AppTheme.spacingL),
      child: SafeArea(
        child: Opacity(
          opacity: opacity.clamp(0.3, 1.0), // Keep minimum visibility
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  Icon(
                    Icons.auto_awesome,
                    size: 28,
                    color: isDark ? AppTheme.white : AppTheme.black,
                  ),
                  const SizedBox(width: AppTheme.spacingS),
                  Text(
                    'AI Insights',
                    style: theme.textTheme.displaySmall?.copyWith(
                      fontWeight: AppTheme.fontWeightBold,
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: AppTheme.spacingXL),
              
              // Placeholder content
              _buildPlaceholderCard(
                context,
                icon: Icons.insights,
                title: 'Tone Analysis',
                description: 'Pull down to see how messages are being interpreted',
                isDark: isDark,
              ),
              
              const SizedBox(height: AppTheme.spacingM),
              
              _buildPlaceholderCard(
                context,
                icon: Icons.lightbulb_outline,
                title: 'Smart Suggestions',
                description: 'AI-powered response recommendations coming soon',
                isDark: isDark,
              ),
              
              const SizedBox(height: AppTheme.spacingM),
              
              _buildPlaceholderCard(
                context,
                icon: Icons.analytics_outlined,
                title: 'Conversation Health',
                description: 'Monitor communication patterns and insights',
                isDark: isDark,
              ),
              
              const Spacer(),
              
              // Hint text
              Center(
                child: Column(
                  children: [
                    Icon(
                      Icons.keyboard_arrow_down,
                      size: 32,
                      color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                    ),
                    const SizedBox(height: AppTheme.spacingXS),
                    Text(
                      'Pull down messages to view insights',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: isDark ? AppTheme.gray600 : AppTheme.gray500,
                      ),
                    ),
                  ],
                ),
              ),
              
              const SizedBox(height: AppTheme.spacingXXL),
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildPlaceholderCard(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String description,
    required bool isDark,
  }) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingS),
            decoration: BoxDecoration(
              color: isDark 
                ? AppTheme.darkGray300 
                : AppTheme.gray100,
              borderRadius: BorderRadius.circular(AppTheme.radiusS),
            ),
            child: Icon(
              icon,
              size: 24,
              color: isDark ? AppTheme.white : AppTheme.black,
            ),
          ),
          const SizedBox(width: AppTheme.spacingM),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: theme.textTheme.labelLarge?.copyWith(
                    fontWeight: AppTheme.fontWeightSemibold,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  description,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/messages/widgets/ai_insights_panel.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/data/drift/app_db.dart';

/// AI Feature definition with color and metadata
class AIFeature {
  final String id;
  final String name;
  final String description;
  final String whereToFind;
  final IconData icon;
  final Color color;
  final bool hasSettings;
  final bool hasManualInput;
  
  const AIFeature({
    required this.id,
    required this.name,
    required this.description,
    required this.whereToFind,
    required this.icon,
    required this.color,
    this.hasSettings = true,
    this.hasManualInput = false,
  });
}

/// AI Features list with calming colors - 4 Unified Features
final aiFeatures = [
  const AIFeature(
    id: 'message_interpreter',
    name: 'Smart Message Interpreter',
    description: 'Understand tone, detect RSD triggers, and decode literal language with alternative interpretations',
    whereToFind: 'Tap any message bubble • Auto-alerts on concerning messages',
    icon: Icons.psychology_outlined,
    color: Color(0xFF7C3AED), // Calming purple
    hasSettings: true,
  ),
  const AIFeature(
    id: 'response_assistant',
    name: 'Adaptive Response Assistant',
    description: 'Get confidence scoring, situation-aware templates, and boundary support for your replies',
    whereToFind: 'Tap ✓ button while typing • Access templates in draft feedback',
    icon: Icons.verified_outlined,
    color: Color(0xFF06B6D4), // Calming cyan
    hasSettings: true,
  ),
  const AIFeature(
    id: 'smart_inbox',
    name: 'Smart Inbox with Context',
    description: 'Priority filtering, conversation context, and relationship memory for better understanding',
    whereToFind: 'Auto-sorts conversations • Tap for context preview • Swipe for relationship',
    icon: Icons.inbox_outlined,
    color: Color(0xFF10B981), // Calming green
    hasSettings: true,
    hasManualInput: true,
  ),
  const AIFeature(
    id: 'follow_up_system',
    name: 'Smart Follow-up System',
    description: 'Never miss action items, questions, or important reminders from conversations',
    whereToFind: 'Auto-extracted from messages • View follow-up dashboard',
    icon: Icons.notifications_outlined,
    color: Color(0xFFF59E0B), // Warm amber
    hasSettings: true,
  ),
];

/// Enhanced AI insights panel with feature cards and settings
class AIInsightsPanel extends ConsumerStatefulWidget {
  final String conversationId;
  final List<Message> messages;
  final double panelPosition;

  const AIInsightsPanel({
    Key? key,
    required this.conversationId,
    required this.messages,
    this.panelPosition = 0.0,
  }) : super(key: key);

  @override
  ConsumerState<AIInsightsPanel> createState() => _AIInsightsPanelState();
}

class _AIInsightsPanelState extends ConsumerState<AIInsightsPanel> {
  String? _expandedFeatureId;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    // Calculate opacity based on panel position
    final opacity = (1.0 - widget.panelPosition).clamp(0.0, 1.0);
    
    return Container(
      color: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
      child: SafeArea(
        child: Opacity(
          opacity: opacity.clamp(0.3, 1.0),
          child: CustomScrollView(
            slivers: [
              // Simple header
              SliverToBoxAdapter(
                child: Padding(
                  padding: const EdgeInsets.fromLTRB(
                    AppTheme.spacingL,
                    AppTheme.spacingL,
                    AppTheme.spacingL,
                    AppTheme.spacingM,
                  ),
                  child: Row(
                    children: [
                      Icon(
                        Icons.auto_awesome_rounded,
                        size: 24,
                        color: isDark ? AppTheme.gray400 : AppTheme.gray600,
                      ),
                      const SizedBox(width: AppTheme.spacingS),
                      Text(
                        'AI Tools',
                        style: theme.textTheme.titleLarge?.copyWith(
                          fontWeight: FontWeight.w600,
                          color: isDark ? AppTheme.white : AppTheme.darkGray100,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
              
              // Feature cards (simplified)
              SliverPadding(
                padding: const EdgeInsets.symmetric(horizontal: AppTheme.spacingL),
                sliver: SliverList(
                  delegate: SliverChildBuilderDelegate(
                    (context, index) {
                      final feature = aiFeatures[index];
                      return Padding(
                        padding: const EdgeInsets.only(bottom: AppTheme.spacingM),
                        child: _buildSimpleFeatureCard(context, feature, isDark),
                      );
                    },
                    childCount: aiFeatures.length,
                  ),
                ),
              ),
              
              // Bottom spacing
              const SliverToBoxAdapter(
                child: SizedBox(height: AppTheme.spacingXXL),
              ),
            ],
          ),
        ),
      ),
    );
  }

  /// Old complex feature card (kept for reference but not used)
  Widget _buildFeatureCard(BuildContext context, AIFeature feature, bool isDark) {
    final theme = Theme.of(context);
    final isExpanded = _expandedFeatureId == feature.id;
    final isEnabled = true; // Always enabled now
    
    return AnimatedContainer(
      duration: const Duration(milliseconds: 200),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: BorderRadius.circular(AppTheme.radiusL),
        border: Border.all(
          color: isExpanded 
            ? feature.color.withOpacity(0.5)
            : (isDark ? AppTheme.darkGray300 : AppTheme.gray300),
          width: isExpanded ? 2 : 1,
        ),
        boxShadow: isExpanded
          ? [
              BoxShadow(
                color: feature.color.withOpacity(0.1),
                blurRadius: 12,
                spreadRadius: 2,
              ),
            ]
          : null,
      ),
      child: Column(
        children: [
          // Header (always visible)
          InkWell(
            onTap: () {
              setState(() {
                _expandedFeatureId = isExpanded ? null : feature.id;
              });
            },
            borderRadius: BorderRadius.circular(AppTheme.radiusL),
            child: Padding(
              padding: const EdgeInsets.all(AppTheme.spacingM),
              child: Row(
                children: [
                  // Icon with color
                  Container(
                    padding: const EdgeInsets.all(AppTheme.spacingS),
                    decoration: BoxDecoration(
                      color: feature.color.withOpacity(0.15),
                      borderRadius: BorderRadius.circular(AppTheme.radiusS),
                    ),
                    child: Icon(
                      feature.icon,
                      size: 24,
                      color: feature.color,
                    ),
                  ),
                  const SizedBox(width: AppTheme.spacingM),
                  
                  // Name and status
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          feature.name,
                          style: theme.textTheme.titleSmall?.copyWith(
                            fontWeight: AppTheme.fontWeightBold,
                            color: isDark ? AppTheme.gray200 : AppTheme.gray900,
                          ),
                        ),
                        const SizedBox(height: AppTheme.spacingXXS),
                        Row(
                          children: [
                            Container(
                              width: 8,
                              height: 8,
                              decoration: BoxDecoration(
                                color: isEnabled ? feature.color : AppTheme.gray400,
                                shape: BoxShape.circle,
                              ),
                            ),
                            const SizedBox(width: AppTheme.spacingXXS),
                            Text(
                              isEnabled ? 'Active' : 'Disabled',
                              style: theme.textTheme.bodySmall?.copyWith(
                                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                  
                  // Status indicator
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: feature.color.withOpacity(0.2),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      'Active',
                      style: TextStyle(
                        fontSize: 11,
                        fontWeight: FontWeight.w600,
                        color: feature.color,
                      ),
                    ),
                  ),
                  
                  const SizedBox(width: AppTheme.spacingXS),
                  
                  // Expand icon
                  Icon(
                    isExpanded ? Icons.expand_less : Icons.expand_more,
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                  ),
                ],
              ),
            ),
          ),
          
          // Expanded content
          if (isExpanded)
            Container(
              padding: const EdgeInsets.fromLTRB(
                AppTheme.spacingM,
                0,
                AppTheme.spacingM,
                AppTheme.spacingM,
              ),
              decoration: BoxDecoration(
                border: Border(
                  top: BorderSide(
                    color: feature.color.withOpacity(0.2),
                    width: 1,
                  ),
                ),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const SizedBox(height: AppTheme.spacingM),
                  
                  // Description
                  Text(
                    'What it does',
                    style: theme.textTheme.labelSmall?.copyWith(
                      fontWeight: AppTheme.fontWeightBold,
                      color: feature.color,
                    ),
                  ),
                  const SizedBox(height: AppTheme.spacingXS),
                  Text(
                    feature.description,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: isDark ? AppTheme.gray400 : AppTheme.gray700,
                    ),
                  ),
                  
                  const SizedBox(height: AppTheme.spacingM),
                  
                  // Where to find
                  Container(
                    padding: const EdgeInsets.all(AppTheme.spacingS),
                    decoration: BoxDecoration(
                      color: feature.color.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(AppTheme.radiusS),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.location_on_outlined,
                          size: 16,
                          color: feature.color,
                        ),
                        const SizedBox(width: AppTheme.spacingXS),
                        Expanded(
                          child: Text(
                            feature.whereToFind,
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: isDark ? AppTheme.gray400 : AppTheme.gray700,
                              fontWeight: AppTheme.fontWeightMedium,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  
                  // Manual input section
                  if (feature.hasManualInput) ...[
                    const SizedBox(height: AppTheme.spacingM),
                    OutlinedButton.icon(
                      onPressed: isEnabled ? () {
                        // TODO: Open manual input dialog
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text('${feature.name} settings (coming soon)'),
                            backgroundColor: feature.color,
                          ),
                        );
                      } : null,
                      icon: Icon(Icons.edit_outlined, size: 18, color: feature.color),
                      label: const Text('Manual Input'),
                      style: OutlinedButton.styleFrom(
                        foregroundColor: feature.color,
                        side: BorderSide(color: feature.color),
                      ),
                    ),
                  ],
                ],
              ),
            ),
        ],
      ),
    );
  }

  /// Simplified feature card - less overwhelming, progressive disclosure
  Widget _buildSimpleFeatureCard(BuildContext context, AIFeature feature, bool isDark) {
    final theme = Theme.of(context);
    final isExpanded = _expandedFeatureId == feature.id;
    
    return InkWell(
      onTap: () {
        setState(() {
          _expandedFeatureId = isExpanded ? null : feature.id;
        });
      },
      borderRadius: BorderRadius.circular(14),
      child: Container(
        padding: const EdgeInsets.all(AppTheme.spacingM),
        decoration: BoxDecoration(
          color: isDark ? AppTheme.darkGray100 : AppTheme.white,
          borderRadius: BorderRadius.circular(14),
          border: Border.all(
            color: isExpanded 
              ? feature.color.withOpacity(0.4)
              : (isDark ? AppTheme.darkGray300.withOpacity(0.3) : AppTheme.gray200),
            width: 1.5,
          ),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header row
            Row(
              children: [
                // Icon
                Container(
                  padding: const EdgeInsets.all(10),
                  decoration: BoxDecoration(
                    color: feature.color.withOpacity(0.12),
                    borderRadius: BorderRadius.circular(10),
                  ),
                  child: Icon(
                    feature.icon,
                    size: 20,
                    color: feature.color,
                  ),
                ),
                
                const SizedBox(width: AppTheme.spacingM),
                
                // Title
                Expanded(
                  child: Text(
                    feature.name,
                    style: theme.textTheme.titleSmall?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: isDark ? AppTheme.white : AppTheme.darkGray100,
                    ),
                  ),
                ),
                
                // Expand icon
                Icon(
                  isExpanded ? Icons.expand_less_rounded : Icons.chevron_right_rounded,
                  color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                  size: 20,
                ),
              ],
            ),
            
            // Expanded description (progressive disclosure)
            if (isExpanded) ...[
              const SizedBox(height: AppTheme.spacingM),
              Container(
                padding: const EdgeInsets.all(AppTheme.spacingS),
                decoration: BoxDecoration(
                  color: feature.color.withOpacity(0.05),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  feature.description,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray400 : AppTheme.gray700,
                    height: 1.4,
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/messages/widgets/draft_feedback_panel.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/draft_analysis.dart';
import 'package:messageai/features/messages/widgets/template_picker.dart';
import 'package:messageai/features/messages/widgets/message_formatter_panel.dart';

/// Collapsible feedback panel for draft message analysis
/// Shows confidence score prominently with progressive disclosure
class DraftFeedbackPanel extends StatefulWidget {
  final DraftAnalysis? analysis;
  final bool isLoading;
  final String? draftMessage; // NEW: For formatting long messages
  final Function(String)? onApplySuggestion;
  final Function(String)? onTemplateSelected; // NEW: For templates
  final VoidCallback? onClose;

  const DraftFeedbackPanel({
    Key? key,
    required this.analysis,
    this.isLoading = false,
    this.draftMessage,
    this.onApplySuggestion,
    this.onTemplateSelected,
    this.onClose,
  }) : super(key: key);

  @override
  State<DraftFeedbackPanel> createState() => _DraftFeedbackPanelState();
}

class _DraftFeedbackPanelState extends State<DraftFeedbackPanel> {
  bool _isExpanded = true;
  bool _strengthsExpanded = true; // Always show strengths
  bool _warningsExpanded = true; // Always show warnings
  bool _suggestionsExpanded = false;
  bool _situationExpanded = false;
  bool _templatesExpanded = false;
  bool _formattingExpanded = false;
  bool _reasoningExpanded = false;

  @override
  Widget build(BuildContext context) {
    if (widget.isLoading) {
      return _buildLoadingState(context);
    }

    if (widget.analysis == null) {
      return const SizedBox.shrink();
    }

    if (!_isExpanded) {
      return _buildCollapsedState(context, widget.analysis!);
    }

    return _buildExpandedState(context, widget.analysis!);
  }

  Widget _buildLoadingState(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: (isDark ? AppTheme.darkGray200 : AppTheme.gray100),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          const SizedBox(
            width: 20,
            height: 20,
            child: CircularProgressIndicator(strokeWidth: 2),
          ),
          const SizedBox(width: AppTheme.spacingS),
          Text(
            'Checking message...',
            style: theme.textTheme.bodyMedium?.copyWith(
              fontWeight: AppTheme.fontWeightMedium,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCollapsedState(BuildContext context, DraftAnalysis analysis) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final confidenceColor = analysis.getConfidenceColor();

    return GestureDetector(
      onTap: () => setState(() => _isExpanded = true),
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: AppTheme.spacingM,
          vertical: AppTheme.spacingS,
        ),
        decoration: BoxDecoration(
          color: confidenceColor.withOpacity(0.1),
          borderRadius: BorderRadius.circular(AppTheme.radiusM),
          border: Border.all(color: confidenceColor.withOpacity(0.3)),
        ),
        child: Row(
          children: [
            Icon(
              analysis.getAppropriatenessIcon(),
              color: confidenceColor,
              size: 20,
            ),
            const SizedBox(width: AppTheme.spacingS),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    '${analysis.confidenceScore}% Confidence',
                    style: theme.textTheme.titleSmall?.copyWith(
                      color: confidenceColor,
                      fontWeight: AppTheme.fontWeightBold,
                    ),
                  ),
                  Text(
                    analysis.getStatusMessage(),
                    style: theme.textTheme.bodySmall,
                  ),
                ],
              ),
            ),
            Icon(
              Icons.expand_more,
              color: isDark ? AppTheme.gray500 : AppTheme.gray600,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildExpandedState(BuildContext context, DraftAnalysis analysis) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final confidenceColor = analysis.getConfidenceColor();

    return Container(
      constraints: const BoxConstraints(maxHeight: 600),
      decoration: BoxDecoration(
        color: confidenceColor.withOpacity(0.1),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(color: confidenceColor.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          // Header with title and controls
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingM),
            decoration: BoxDecoration(
              border: Border(
                bottom: BorderSide(
                  color: confidenceColor.withOpacity(0.3),
                  width: 1,
                ),
              ),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Icon(
                      Icons.analytics_outlined,
                      color: confidenceColor,
                      size: 20,
                    ),
                    const SizedBox(width: AppTheme.spacingXS),
                    Text(
                      'Draft Analysis',
                      style: theme.textTheme.titleSmall?.copyWith(
                        fontWeight: AppTheme.fontWeightBold,
                        color: isDark ? AppTheme.gray200 : AppTheme.gray800,
                      ),
                    ),
                    const Spacer(),
                    IconButton(
                      icon: const Icon(Icons.expand_less, size: 20),
                      onPressed: () => setState(() => _isExpanded = false),
                      tooltip: 'Minimize',
                      padding: EdgeInsets.zero,
                      constraints: const BoxConstraints(),
                    ),
                    if (widget.onClose != null) ...[
                      const SizedBox(width: AppTheme.spacingXS),
                      IconButton(
                        icon: const Icon(Icons.close, size: 20),
                        onPressed: widget.onClose,
                        tooltip: 'Close',
                        padding: EdgeInsets.zero,
                        constraints: const BoxConstraints(),
                      ),
                    ],
                  ],
                ),
                const SizedBox(height: AppTheme.spacingS),
                Row(
                  children: [
                    Icon(
                      analysis.getAppropriatenessIcon(),
                      color: confidenceColor,
                      size: 20,
                    ),
                    const SizedBox(width: AppTheme.spacingXS),
                    Text(
                      '${analysis.confidenceScore}% Confidence',
                      style: theme.textTheme.titleMedium?.copyWith(
                        color: confidenceColor,
                        fontWeight: AppTheme.fontWeightBold,
                      ),
                    ),
                    const SizedBox(width: AppTheme.spacingS),
                    Expanded(
                      child: Text(
                        '${analysis.tone} • ${analysis.appropriateness.displayName}',
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),

          // Scrollable content with invisible scrollbar
          Flexible(
            child: Scrollbar(
              thumbVisibility: false,
              child: SingleChildScrollView(
                padding: const EdgeInsets.all(AppTheme.spacingM),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    // Strengths (collapsible)
                    if (analysis.strengths.isNotEmpty) ...[
                      _buildCollapsibleSection(
                        context,
                        '✅ Strengths',
                        analysis.strengths,
                        Colors.green,
                        _strengthsExpanded,
                        (expanded) => setState(() => _strengthsExpanded = expanded),
                        showApplyButton: false,
                      ),
                      const SizedBox(height: AppTheme.spacingS),
                    ],

                    // Warnings (collapsible)
                    if (analysis.warnings.isNotEmpty) ...[
                      _buildCollapsibleSection(
                        context,
                        '⚠️ Watch Out',
                        analysis.warnings,
                        Colors.orange,
                        _warningsExpanded,
                        (expanded) => setState(() => _warningsExpanded = expanded),
                        showApplyButton: false,
                      ),
                      const SizedBox(height: AppTheme.spacingS),
                    ],

                    // Suggestions (collapsible)
                    if (analysis.suggestions.isNotEmpty) ...[
                      _buildCollapsibleSection(
                        context,
                        '💡 Suggestions',
                        analysis.suggestions,
                        Colors.blue,
                        _suggestionsExpanded,
                        (expanded) => setState(() => _suggestionsExpanded = expanded),
                        showApplyButton: widget.onApplySuggestion != null,
                      ),
                      const SizedBox(height: AppTheme.spacingS),
                    ],

                    // Situation Detection (collapsible)
                    if (analysis.situationDetection != null) ...[
                      _buildCollapsibleSituationSection(context, analysis),
                      const SizedBox(height: AppTheme.spacingS),
                    ],

                    // Suggested Templates (collapsible)
                    if (analysis.suggestedTemplates != null &&
                        analysis.suggestedTemplates!.isNotEmpty) ...[
                      _buildCollapsibleTemplatesSection(context, analysis),
                      const SizedBox(height: AppTheme.spacingS),
                    ],

                    // Message Formatting (collapsible)
                    if (widget.draftMessage != null && widget.draftMessage!.length > 500) ...[
                      _buildCollapsibleFormattingSection(context),
                      const SizedBox(height: AppTheme.spacingS),
                    ],

                    // Reasoning (collapsible)
                    if (analysis.reasoning != null && analysis.reasoning!.isNotEmpty) ...[
                      _buildCollapsibleReasoningSection(context, analysis),
                    ],
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  // Collapsible section for list items
  Widget _buildCollapsibleSection(
    BuildContext context,
    String title,
    List<String> items,
    Color color,
    bool isExpanded,
    Function(bool) onExpansionChanged, {
    required bool showApplyButton,
  }) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      decoration: BoxDecoration(
        color: color.withOpacity(0.05),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(color: color.withOpacity(0.2)),
      ),
      child: Theme(
        data: Theme.of(context).copyWith(dividerColor: Colors.transparent),
        child: ExpansionTile(
          tilePadding: const EdgeInsets.symmetric(
            horizontal: AppTheme.spacingS,
            vertical: AppTheme.spacingXXS,
          ),
          childrenPadding: const EdgeInsets.only(
            left: AppTheme.spacingS,
            right: AppTheme.spacingS,
            bottom: AppTheme.spacingS,
          ),
          initiallyExpanded: isExpanded,
          onExpansionChanged: onExpansionChanged,
          leading: Icon(Icons.check_circle_outline, size: 16, color: color),
          title: Row(
            children: [
              Expanded(
                child: Text(
                  title,
                  style: theme.textTheme.labelMedium?.copyWith(
                    color: isDark ? AppTheme.gray300 : AppTheme.gray800,
                    fontWeight: AppTheme.fontWeightBold,
                  ),
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppTheme.spacingXS,
                  vertical: 2,
                ),
                decoration: BoxDecoration(
                  color: color.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(AppTheme.radiusXS),
                ),
                child: Text(
                  '${items.length}',
                  style: theme.textTheme.labelSmall?.copyWith(
                    color: color,
                    fontWeight: AppTheme.fontWeightBold,
                  ),
                ),
              ),
            ],
          ),
          children: items.map((item) => Padding(
            padding: const EdgeInsets.only(top: AppTheme.spacingXXS),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: const EdgeInsets.only(top: 2),
                  child: Icon(
                    Icons.circle,
                    size: 6,
                    color: color,
                  ),
                ),
                const SizedBox(width: AppTheme.spacingXS),
                Expanded(
                  child: Text(
                    item,
                    style: theme.textTheme.bodySmall,
                  ),
                ),
                if (showApplyButton && widget.onApplySuggestion != null) ...[
                  const SizedBox(width: AppTheme.spacingXS),
                  TextButton(
                    onPressed: () => widget.onApplySuggestion!(item),
                    style: TextButton.styleFrom(
                      padding: const EdgeInsets.symmetric(
                        horizontal: AppTheme.spacingS,
                        vertical: AppTheme.spacingXXS,
                      ),
                      minimumSize: Size.zero,
                      tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    ),
                    child: Text(
                      'Apply',
                      style: TextStyle(
                        fontSize: AppTheme.fontSizeXS,
                        color: color,
                      ),
                    ),
                  ),
                ],
              ],
            ),
          )).toList(),
        ),
      ),
    );
  }

  // Collapsible situation detection section
  Widget _buildCollapsibleSituationSection(BuildContext context, DraftAnalysis analysis) {
    final detection = analysis.situationDetection!;
    final color = detection.situationType.getColor();
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      decoration: BoxDecoration(
        color: color.withOpacity(0.05),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(color: color.withOpacity(0.2)),
      ),
      child: Theme(
        data: Theme.of(context).copyWith(dividerColor: Colors.transparent),
        child: ExpansionTile(
          tilePadding: const EdgeInsets.symmetric(
            horizontal: AppTheme.spacingS,
            vertical: AppTheme.spacingXXS,
          ),
          childrenPadding: const EdgeInsets.only(
            left: AppTheme.spacingS,
            right: AppTheme.spacingS,
            bottom: AppTheme.spacingS,
          ),
          initiallyExpanded: _situationExpanded,
          onExpansionChanged: (expanded) => setState(() => _situationExpanded = expanded),
          leading: Icon(detection.situationType.icon, size: 16, color: color),
          title: Text(
            '${detection.situationType.displayName} Detected',
            style: theme.textTheme.labelMedium?.copyWith(
              color: isDark ? AppTheme.gray300 : AppTheme.gray800,
              fontWeight: AppTheme.fontWeightBold,
            ),
          ),
          trailing: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppTheme.spacingXS,
                  vertical: 2,
                ),
                decoration: BoxDecoration(
                  color: color.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(AppTheme.radiusXS),
                ),
                child: Text(
                  '${(detection.confidence * 100).toInt()}%',
                  style: theme.textTheme.labelSmall?.copyWith(
                    color: color,
                    fontWeight: AppTheme.fontWeightBold,
                  ),
                ),
              ),
              Icon(
                _situationExpanded ? Icons.expand_less : Icons.expand_more,
                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
              ),
            ],
          ),
          children: [
            Text(
              detection.reasoning,
              style: theme.textTheme.bodySmall?.copyWith(
                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
              ),
            ),
          ],
        ),
      ),
    );
  }

  // Collapsible templates section
  Widget _buildCollapsibleTemplatesSection(BuildContext context, DraftAnalysis analysis) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final color = Colors.blue;
    final templates = analysis.suggestedTemplates!;

    return Container(
      decoration: BoxDecoration(
        color: color.withOpacity(0.05),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(color: color.withOpacity(0.2)),
      ),
      child: Theme(
        data: Theme.of(context).copyWith(dividerColor: Colors.transparent),
        child: ExpansionTile(
          tilePadding: const EdgeInsets.symmetric(
            horizontal: AppTheme.spacingS,
            vertical: AppTheme.spacingXXS,
          ),
          childrenPadding: const EdgeInsets.only(
            left: AppTheme.spacingS,
            right: AppTheme.spacingS,
            bottom: AppTheme.spacingS,
          ),
          initiallyExpanded: _templatesExpanded,
          onExpansionChanged: (expanded) => setState(() => _templatesExpanded = expanded),
          leading: const Icon(Icons.lightbulb_outline, size: 16, color: Colors.blue),
          title: Row(
            children: [
              Expanded(
                child: Text(
                  'Response Templates',
                  style: theme.textTheme.labelMedium?.copyWith(
                    color: isDark ? AppTheme.gray300 : AppTheme.gray800,
                    fontWeight: AppTheme.fontWeightBold,
                  ),
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppTheme.spacingXS,
                  vertical: 2,
                ),
                decoration: BoxDecoration(
                  color: color.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(AppTheme.radiusXS),
                ),
                child: Text(
                  '${templates.length}',
                  style: theme.textTheme.labelSmall?.copyWith(
                    color: color,
                    fontWeight: AppTheme.fontWeightBold,
                  ),
                ),
              ),
            ],
          ),
          children: [
            ...templates.take(3).map((template) => Padding(
              padding: const EdgeInsets.only(top: AppTheme.spacingXXS),
              child: InkWell(
                onTap: () {
                  if (widget.onTemplateSelected != null) {
                    widget.onTemplateSelected!(template.template);
                  }
                },
                child: Container(
                  padding: const EdgeInsets.all(AppTheme.spacingXS),
                  decoration: BoxDecoration(
                    color: isDark ? AppTheme.darkGray300 : AppTheme.gray100,
                    borderRadius: BorderRadius.circular(AppTheme.radiusXS),
                  ),
                  child: Row(
                    children: [
                      Icon(
                        Icons.check_circle_outline,
                        size: 14,
                        color: color,
                      ),
                      const SizedBox(width: AppTheme.spacingXS),
                      Expanded(
                        child: Text(
                          template.name,
                          style: theme.textTheme.bodySmall?.copyWith(
                            fontWeight: AppTheme.fontWeightMedium,
                          ),
                        ),
                      ),
                      Icon(
                        Icons.arrow_forward,
                        size: 14,
                        color: color,
                      ),
                    ],
                  ),
                ),
              ),
            )),
            const SizedBox(height: AppTheme.spacingS),
            SizedBox(
              width: double.infinity,
              child: OutlinedButton(
                onPressed: () {
                  showTemplatePicker(
                    context,
                    analysis.situationDetection?.situationType,
                    (selectedText) {
                      if (widget.onTemplateSelected != null) {
                        widget.onTemplateSelected!(selectedText);
                      }
                    },
                  );
                },
                style: OutlinedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(
                    vertical: AppTheme.spacingXS,
                  ),
                  side: BorderSide(color: color),
                ),
                child: const Text(
                  'Browse All Templates',
                  style: TextStyle(fontSize: AppTheme.fontSizeXS),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  // Collapsible formatting section
  Widget _buildCollapsibleFormattingSection(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final color = Colors.orange;

    return Container(
      decoration: BoxDecoration(
        color: color.withOpacity(0.05),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(color: color.withOpacity(0.2)),
      ),
      child: Theme(
        data: Theme.of(context).copyWith(dividerColor: Colors.transparent),
        child: ExpansionTile(
          tilePadding: const EdgeInsets.symmetric(
            horizontal: AppTheme.spacingS,
            vertical: AppTheme.spacingXXS,
          ),
          childrenPadding: const EdgeInsets.only(
            left: AppTheme.spacingS,
            right: AppTheme.spacingS,
            bottom: AppTheme.spacingS,
          ),
          initiallyExpanded: _formattingExpanded,
          onExpansionChanged: (expanded) => setState(() => _formattingExpanded = expanded),
          leading: const Icon(Icons.format_list_bulleted, size: 16, color: Colors.orange),
          title: Text(
            'Message Formatting',
            style: theme.textTheme.labelMedium?.copyWith(
              color: isDark ? AppTheme.gray300 : AppTheme.gray800,
              fontWeight: AppTheme.fontWeightBold,
            ),
          ),
          children: [
            Text(
              'This message is quite long (${widget.draftMessage!.length} characters). Consider breaking it into sections or using bullet points to make it easier to read.',
              style: theme.textTheme.bodySmall?.copyWith(
                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
              ),
            ),
            const SizedBox(height: AppTheme.spacingS),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: () {
                  showDialog(
                    context: context,
                    builder: (context) => Dialog(
                      child: MessageFormatterPanel(
                        originalMessage: widget.draftMessage!,
                        onFormatted: (formatted) {
                          if (widget.onTemplateSelected != null) {
                            widget.onTemplateSelected!(formatted);
                          }
                          Navigator.pop(context);
                        },
                      ),
                    ),
                  );
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: color,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(
                    vertical: AppTheme.spacingS,
                  ),
                ),
                icon: const Icon(Icons.auto_fix_high, size: 16),
                label: const Text(
                  'Auto-Format Message',
                  style: TextStyle(fontSize: AppTheme.fontSizeS),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  // NEW: Collapsible reasoning section
  Widget _buildCollapsibleReasoningSection(BuildContext context, DraftAnalysis analysis) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      decoration: BoxDecoration(
        color: (isDark ? AppTheme.darkGray300 : AppTheme.gray100),
        borderRadius: BorderRadius.circular(AppTheme.radiusS),
        border: Border.all(
          color: isDark ? AppTheme.darkGray400 : AppTheme.gray300,
        ),
      ),
      child: Theme(
        data: Theme.of(context).copyWith(dividerColor: Colors.transparent),
        child: ExpansionTile(
          tilePadding: const EdgeInsets.symmetric(
            horizontal: AppTheme.spacingS,
            vertical: AppTheme.spacingXXS,
          ),
          childrenPadding: const EdgeInsets.only(
            left: AppTheme.spacingS,
            right: AppTheme.spacingS,
            bottom: AppTheme.spacingS,
          ),
          initiallyExpanded: _reasoningExpanded,
          onExpansionChanged: (expanded) => setState(() => _reasoningExpanded = expanded),
          leading: Icon(
            Icons.info_outline,
            size: 16,
            color: isDark ? AppTheme.gray500 : AppTheme.gray600,
          ),
          title: Text(
            'Why This Score?',
            style: theme.textTheme.labelMedium?.copyWith(
              color: isDark ? AppTheme.gray400 : AppTheme.gray700,
              fontWeight: AppTheme.fontWeightMedium,
            ),
          ),
          children: [
            Text(
              analysis.reasoning!,
              style: theme.textTheme.bodySmall?.copyWith(
                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
              ),
            ),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/messages/widgets/evidence_viewer.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Widget showing evidence that supports the tone analysis
class EvidenceViewer extends StatefulWidget {
  final List<Evidence> evidence;

  const EvidenceViewer({super.key, required this.evidence});

  @override
  State<EvidenceViewer> createState() => _EvidenceViewerState();
}

class _EvidenceViewerState extends State<EvidenceViewer> {
  bool _expanded = false;

  @override
  Widget build(BuildContext context) {
    if (widget.evidence.isEmpty) {
      return Container(
        padding: const EdgeInsets.all(10),
        decoration: BoxDecoration(
          color: Colors.grey.withOpacity(0.1),
          borderRadius: BorderRadius.circular(6),
        ),
        child: const Row(
          children: [
            Icon(Icons.info_outline, size: 16, color: Colors.grey),
            SizedBox(width: 8),
            Expanded(
              child: Text(
                'No specific evidence found in message',
                style: TextStyle(fontSize: 12, color: Colors.grey),
              ),
            ),
          ],
        ),
      );
    }

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.teal.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.teal.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          InkWell(
            onTap: () => setState(() => _expanded = !_expanded),
            child: Row(
              children: [
                const Icon(Icons.search, color: Colors.teal, size: 20),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    'Evidence (${widget.evidence.length})',
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      color: Colors.teal,
                    ),
                  ),
                ),
                Icon(
                  _expanded ? Icons.expand_less : Icons.expand_more,
                  color: Colors.teal,
                ),
              ],
            ),
          ),
          if (_expanded) ...[
            const SizedBox(height: 12),
            const Text(
              'Specific evidence supporting this analysis:',
              style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic),
            ),
            const SizedBox(height: 8),
            
            // Evidence items
            ...widget.evidence.map((evidence) => Padding(
              padding: const EdgeInsets.only(bottom: 8),
              child: _EvidenceItem(evidence: evidence),
            )),
          ],
        ],
      ),
    );
  }
}

class _EvidenceItem extends StatelessWidget {
  final Evidence evidence;

  const _EvidenceItem({required this.evidence});

  @override
  Widget build(BuildContext context) {
    final typeColor = _getTypeColor(evidence.type);
    final typeIcon = _getTypeIcon(evidence.type);

    return Container(
      padding: const EdgeInsets.all(10),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(6),
        border: Border.all(color: typeColor.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Type and quote
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Icon(typeIcon, size: 16, color: typeColor),
              const SizedBox(width: 8),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                      decoration: BoxDecoration(
                        color: typeColor.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(3),
                      ),
                      child: Text(
                        evidence.type.toUpperCase(),
                        style: TextStyle(
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                          color: typeColor,
                        ),
                      ),
                    ),
                    const SizedBox(height: 6),
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      decoration: BoxDecoration(
                        color: Colors.grey.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(4),
                      ),
                      child: Text(
                        '"${evidence.quote}"',
                        style: const TextStyle(
                          fontSize: 13,
                          fontWeight: FontWeight.w600,
                          fontFamily: 'monospace',
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          
          // What it supports
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Icon(Icons.arrow_forward, size: 14, color: Colors.grey),
              const SizedBox(width: 6),
              Expanded(
                child: Text(
                  'Supports: ${evidence.supports}',
                  style: const TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                    color: Colors.black87,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 4),
          
          // Reasoning
          Padding(
            padding: const EdgeInsets.only(left: 20),
            child: Text(
              evidence.reasoning,
              style: const TextStyle(
                fontSize: 11,
                color: Colors.black54,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Color _getTypeColor(String type) {
    switch (type) {
      case 'keyword':
        return Colors.blue;
      case 'punctuation':
        return Colors.orange;
      case 'emoji':
        return Colors.pink;
      case 'length':
        return Colors.purple;
      case 'pattern':
        return Colors.teal;
      case 'timing':
        return Colors.amber;
      default:
        return Colors.grey;
    }
  }

  IconData _getTypeIcon(String type) {
    switch (type) {
      case 'keyword':
        return Icons.text_fields;
      case 'punctuation':
        return Icons.format_quote;
      case 'emoji':
        return Icons.emoji_emotions;
      case 'length':
        return Icons.straighten;
      case 'pattern':
        return Icons.pattern;
      case 'timing':
        return Icons.access_time;
      default:
        return Icons.info;
    }
  }
}
</file>

<file path="lib/features/messages/widgets/interpretation_options.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Widget showing alternative interpretations for ambiguous messages
class InterpretationOptions extends StatefulWidget {
  final List<MessageInterpretation> interpretations;

  const InterpretationOptions({super.key, required this.interpretations});

  @override
  State<InterpretationOptions> createState() => _InterpretationOptionsState();
}

class _InterpretationOptionsState extends State<InterpretationOptions> {
  bool _expanded = false;

  @override
  Widget build(BuildContext context) {
    if (widget.interpretations.isEmpty) return const SizedBox.shrink();

    // Sort by likelihood (highest first)
    final sorted = List<MessageInterpretation>.from(widget.interpretations)
      ..sort((a, b) => b.likelihood.compareTo(a.likelihood));

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.purple.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.purple.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          InkWell(
            onTap: () => setState(() => _expanded = !_expanded),
            child: Row(
              children: [
                const Icon(Icons.lightbulb_outline, color: Colors.purple, size: 20),
                const SizedBox(width: 8),
                const Expanded(
                  child: Text(
                    'Alternative Interpretations',
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                      color: Colors.purple,
                    ),
                  ),
                ),
                Icon(
                  _expanded ? Icons.expand_less : Icons.expand_more,
                  color: Colors.purple,
                ),
              ],
            ),
          ),
          if (_expanded) ...[
            const SizedBox(height: 12),
            const Text(
              'This message could be interpreted in multiple ways:',
              style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic),
            ),
            const SizedBox(height: 8),
            
            // Interpretations
            ...sorted.asMap().entries.map((entry) {
              final index = entry.key;
              final interp = entry.value;
              return Padding(
                padding: const EdgeInsets.only(bottom: 12),
                child: _InterpretationCard(
                  interpretation: interp,
                  rank: index + 1,
                ),
              );
            }),
          ],
        ],
      ),
    );
  }
}

class _InterpretationCard extends StatelessWidget {
  final MessageInterpretation interpretation;
  final int rank;

  const _InterpretationCard({
    required this.interpretation,
    required this.rank,
  });

  @override
  Widget build(BuildContext context) {
    Color likelihoodColor;
    if (interpretation.isLikely) {
      likelihoodColor = Colors.green;
    } else if (interpretation.isPossible) {
      likelihoodColor = Colors.orange;
    } else {
      likelihoodColor = Colors.grey;
    }

    return Container(
      padding: const EdgeInsets.all(10),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(6),
        border: Border.all(color: likelihoodColor.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Rank and likelihood
          Row(
            children: [
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: likelihoodColor.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Text(
                  '#$rank',
                  style: TextStyle(
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                    color: likelihoodColor,
                  ),
                ),
              ),
              const SizedBox(width: 8),
              Text(
                '${interpretation.likelihood}% likely',
                style: TextStyle(
                  fontSize: 12,
                  fontWeight: FontWeight.w600,
                  color: likelihoodColor,
                ),
              ),
              const Spacer(),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                decoration: BoxDecoration(
                  color: Colors.grey.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Text(
                  interpretation.tone,
                  style: const TextStyle(
                    fontSize: 11,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          
          // Interpretation text
          Text(
            interpretation.interpretation,
            style: const TextStyle(
              fontSize: 13,
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 6),
          
          // Reasoning
          Text(
            interpretation.reasoning,
            style: const TextStyle(
              fontSize: 12,
              color: Colors.black87,
            ),
          ),
          
          // Context clues
          if (interpretation.contextClues.isNotEmpty) ...[
            const SizedBox(height: 6),
            Wrap(
              spacing: 4,
              runSpacing: 4,
              children: interpretation.contextClues.map((clue) {
                return Container(
                  padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                  decoration: BoxDecoration(
                    color: Colors.blue.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(3),
                  ),
                  child: Text(
                    clue,
                    style: const TextStyle(
                      fontSize: 10,
                      color: Colors.blue,
                    ),
                  ),
                );
              }).toList(),
            ),
          ],
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/messages/widgets/message_formatter_panel.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/services/message_formatter_service.dart';
import 'package:messageai/models/formatted_message.dart';

/// Panel for formatting long messages
class MessageFormatterPanel extends ConsumerStatefulWidget {
  final String originalMessage;
  final Function(String) onFormatted;

  const MessageFormatterPanel({
    super.key,
    required this.originalMessage,
    required this.onFormatted,
  });

  @override
  ConsumerState<MessageFormatterPanel> createState() => 
      _MessageFormatterPanelState();
}

class _MessageFormatterPanelState extends ConsumerState<MessageFormatterPanel> {
  late final MessageFormatterService formatterService;
  
  bool condense = false;
  bool chunk = false;
  bool addTldr = false;
  bool addStructure = false;
  
  FormattedMessage? formattedResult;
  bool isFormatting = false;

  @override
  void initState() {
    super.initState();
    formatterService = MessageFormatterService(Supabase.instance.client);
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      constraints: const BoxConstraints(maxHeight: 600),
      child: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header
            Row(
              children: [
                const Icon(Icons.auto_fix_high, color: Colors.purple, size: 20),
                const SizedBox(width: 8),
                const Text(
                  'Message Formatter',
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 16,
                  ),
                ),
                const Spacer(),
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () => Navigator.pop(context),
                ),
              ],
            ),
            Text(
              'Original: ${widget.originalMessage.length} characters',
              style: const TextStyle(
                fontSize: 12,
                color: Colors.grey,
              ),
            ),
            const SizedBox(height: 4),
            const Text(
              'Make your message more digestible',
              style: TextStyle(
                fontSize: 13,
                color: Colors.grey,
              ),
            ),
            const SizedBox(height: 16),

            // Formatting options
            CheckboxListTile(
              title: const Text('Condense', style: TextStyle(fontSize: 14)),
              subtitle: const Text(
                'Reduce length while keeping key points (50-70% shorter)',
                style: TextStyle(fontSize: 11),
              ),
              value: condense,
              dense: true,
              onChanged: (value) => setState(() => condense = value!),
            ),
            CheckboxListTile(
              title: const Text('Break into Chunks', style: TextStyle(fontSize: 14)),
              subtitle: const Text(
                'Add sections with headers for easier reading',
                style: TextStyle(fontSize: 11),
              ),
              value: chunk,
              dense: true,
              onChanged: (value) => setState(() => chunk = value!),
            ),
            CheckboxListTile(
              title: const Text('Add TL;DR', style: TextStyle(fontSize: 14)),
              subtitle: const Text(
                'Brief 1-2 sentence summary at the top',
                style: TextStyle(fontSize: 11),
              ),
              value: addTldr,
              dense: true,
              onChanged: (value) => setState(() => addTldr = value!),
            ),
            CheckboxListTile(
              title: const Text('Add Structure', style: TextStyle(fontSize: 14)),
              subtitle: const Text(
                'Headings, bullets, and emphasis for clarity',
                style: TextStyle(fontSize: 11),
              ),
              value: addStructure,
              dense: true,
              onChanged: (value) => setState(() => addStructure = value!),
            ),

            const SizedBox(height: 16),

            // Format button
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: isFormatting ? null : _formatMessage,
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.purple,
                ),
                child: isFormatting
                    ? const SizedBox(
                        width: 16,
                        height: 16,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          color: Colors.white,
                        ),
                      )
                    : const Text('Format Message'),
              ),
            ),

            // Result preview
            if (formattedResult != null) ...[
              const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.green.shade50,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.green.shade300),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        const Text(
                          'Formatted Result',
                          style: TextStyle(
                            fontSize: 13,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const Spacer(),
                        Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 8,
                            vertical: 4,
                          ),
                          decoration: BoxDecoration(
                            color: Colors.green,
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Text(
                            '-${formattedResult!.getSavingsPercentage().toStringAsFixed(0)}% shorter',
                            style: const TextStyle(
                              fontSize: 10,
                              fontWeight: FontWeight.bold,
                              color: Colors.white,
                            ),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Text(
                      '${formattedResult!.characterCount} chars • ${formattedResult!.estimatedReadTime}',
                      style: const TextStyle(
                        fontSize: 11,
                        color: Colors.grey,
                      ),
                    ),
                    const SizedBox(height: 8),
                    ConstrainedBox(
                      constraints: const BoxConstraints(maxHeight: 150),
                      child: SingleChildScrollView(
                        child: Text(
                          formattedResult!.formattedMessage,
                          style: const TextStyle(fontSize: 12),
                        ),
                      ),
                    ),
                    const SizedBox(height: 12),
                    Row(
                      children: [
                        Expanded(
                          child: OutlinedButton(
                            onPressed: () {
                              // Show full preview
                              showDialog(
                                context: context,
                                builder: (context) => AlertDialog(
                                  title: const Text('Formatted Message'),
                                  content: SingleChildScrollView(
                                    child: Text(formattedResult!.formattedMessage),
                                  ),
                                  actions: [
                                    TextButton(
                                      onPressed: () => Navigator.pop(context),
                                      child: const Text('Close'),
                                    ),
                                  ],
                                ),
                              );
                            },
                            child: const Text('Preview Full', style: TextStyle(fontSize: 12)),
                          ),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: ElevatedButton(
                            onPressed: () {
                              widget.onFormatted(formattedResult!.formattedMessage);
                              Navigator.pop(context);
                            },
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.purple,
                            ),
                            child: const Text('Use This', style: TextStyle(fontSize: 12)),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Future<void> _formatMessage() async {
    if (!condense && !chunk && !addTldr && !addStructure) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Select at least one formatting option')),
      );
      return;
    }

    setState(() => isFormatting = true);

    try {
      final result = await formatterService.formatMessage(
        message: widget.originalMessage,
        condense: condense,
        chunk: chunk,
        addTldr: addTldr,
        addStructure: addStructure,
      );

      if (mounted) {
        setState(() {
          formattedResult = result;
          isFormatting = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() => isFormatting = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error formatting message: $e')),
        );
      }
    }
  }
}
</file>

<file path="lib/features/messages/widgets/message_list_panel.dart">
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/features/messages/widgets/tone_detail_sheet.dart';
import 'package:messageai/features/messages/widgets/draft_feedback_panel.dart';
import 'package:messageai/state/ai_providers.dart';
import 'package:messageai/widgets/user_avatar.dart';

/// Panel containing the message list and compose bar
/// This widget slides up and down over the AI insights background
class MessageListPanel extends ConsumerWidget {
  final List<Message>? messages;
  final String? currentUserId;
  final Map<String, List<Receipt>>? receiptsCache;
  final Set<String>? typingUsers;
  final Set<String>? onlineUsers;
  final TextEditingController messageController;
  final bool isSending;
  final bool isUploadingImage;
  final XFile? selectedImage;
  final VoidCallback onSendMessage;
  final VoidCallback onPickImage;
  final VoidCallback onClearImage;
  final ScrollController? scrollController; // For DraggableScrollableSheet
  final bool showComposeBar; // Whether to show the compose bar
  final bool _composeBarOnly; // Internal flag for compose bar only mode

  const MessageListPanel({
    Key? key,
    required this.messages,
    required this.currentUserId,
    required this.receiptsCache,
    required this.typingUsers,
    required this.onlineUsers,
    required this.messageController,
    required this.isSending,
    required this.isUploadingImage,
    required this.selectedImage,
    required this.onSendMessage,
    required this.onPickImage,
    required this.onClearImage,
    this.scrollController,
    this.showComposeBar = true,
  })  : _composeBarOnly = false,
        super(key: key);

  // Constructor for compose bar only (pinned at bottom)
  const MessageListPanel.composeBarOnly({
    Key? key,
    required this.messageController,
    required this.isSending,
    required this.isUploadingImage,
    required this.selectedImage,
    required this.onSendMessage,
    required this.onPickImage,
    required this.onClearImage,
  })  : messages = null,
        currentUserId = null,
        receiptsCache = null,
        typingUsers = null,
        onlineUsers = null,
        scrollController = null,
        showComposeBar = true,
        _composeBarOnly = true,
        super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    // If compose bar only mode, just return the compose bar
    if (_composeBarOnly) {
      return _buildComposeBar(context, ref, isDark);
    }
    
    // Otherwise, show message list and optionally compose bar
    return Column(
      children: [
        // Message list
        Expanded(
          child: messages == null || messages!.isEmpty
              ? Center(
                  child: Text(
                    'No messages yet. Start the conversation!',
                    style: theme.textTheme.bodyMedium,
                  ),
                )
              : ListView.builder(
                  controller: scrollController, // Use provided scroll controller for dragging
                  reverse: true,
                  padding: const EdgeInsets.symmetric(
                    vertical: AppTheme.spacingS,
                    horizontal: AppTheme.spacingXS,
                  ),
                  itemCount: messages!.length + ((typingUsers?.isNotEmpty ?? false) ? 1 : 0),
                  itemBuilder: (context, index) {
                    // Show typing indicator as first item (at bottom)
                    if (index == 0 && (typingUsers?.isNotEmpty ?? false)) {
                      return _buildTypingIndicator(context, isDark);
                    }
                    
                    // Adjust index if typing indicator is showing
                    final messageIndex = (typingUsers?.isNotEmpty ?? false) ? index - 1 : index;
                    final message = messages![messages!.length - 1 - messageIndex];
                    final isOwn = message.senderId == currentUserId;
                    final isOnline = onlineUsers?.contains(message.senderId) ?? false;

                    return _buildMessageBubble(
                      context,
                      ref,
                      message,
                      isOwn,
                      isOnline,
                      isDark,
                    );
                  },
                ),
        ),
        
        // Compose bar (conditionally shown)
        if (showComposeBar)
          _buildComposeBar(context, ref, isDark),
      ],
    );
  }
  
  Widget _buildMessageBubble(
    BuildContext context,
    WidgetRef ref,
    Message message,
    bool isOwn,
    bool isOnline,
    bool isDark,
  ) {
    // Fetch AI analysis for this message
    final analysisAsync = ref.watch(messageAnalysisProvider(message.id));
    return Align(
      alignment: isOwn ? Alignment.centerRight : Alignment.centerLeft,
      child: Row(
        mainAxisAlignment: isOwn ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          // Show avatar for other users' messages (left side)
          if (!isOwn) ...[
            Padding(
              padding: const EdgeInsets.only(
                left: AppTheme.spacingS,
                right: AppTheme.spacingXXS,
                bottom: AppTheme.spacingXXS,
              ),
              child: Stack(
                children: [
                  UserAvatar(
                    userId: message.senderId,
                    fallbackText: message.senderId.substring(0, 1).toUpperCase(),
                    radius: 16,
                  ),
                  Positioned(
                    right: 0,
                    bottom: 0,
                    child: Container(
                      width: 12,
                      height: 12,
                      decoration: BoxDecoration(
                        color: isOnline ? AppTheme.accentGreen : AppTheme.gray500,
                        shape: BoxShape.circle,
                        border: Border.all(
                          color: isDark ? AppTheme.black : AppTheme.white,
                          width: 2,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
          
          // Message bubble (wrapped with GestureDetector for long-press)
          GestureDetector(
            onLongPress: () => _showMessageContextMenu(context, ref, message, isOwn, isDark),
            child: Container(
              constraints: BoxConstraints(
                maxWidth: MediaQuery.of(context).size.width * 0.65,
              ),
              margin: EdgeInsets.only(
                left: isOwn ? 64 : 0,
                right: isOwn ? AppTheme.spacingS : 64,
                top: AppTheme.spacingXXS,
                bottom: AppTheme.spacingXXS,
              ),
              padding: const EdgeInsets.symmetric(
                horizontal: AppTheme.spacingS,
                vertical: AppTheme.spacingS,
              ),
              decoration: BoxDecoration(
                color: isOwn
                    ? (isDark ? AppTheme.darkGray300 : AppTheme.gray200)
                    : (isDark ? AppTheme.darkGray100 : AppTheme.white),
                borderRadius: BorderRadius.only(
                  topLeft: const Radius.circular(AppTheme.radiusXL),
                  topRight: const Radius.circular(AppTheme.radiusXL),
                  bottomLeft: Radius.circular(isOwn ? AppTheme.radiusXL : AppTheme.radiusXS),
                  bottomRight: Radius.circular(isOwn ? AppTheme.radiusXS : AppTheme.radiusXL),
                ),
                border: !isOwn
                    ? Border.all(
                        color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                        width: 1,
                      )
                    : null,
              ),
              child: Column(
              crossAxisAlignment: isOwn ? CrossAxisAlignment.end : CrossAxisAlignment.start,
              children: [
                // Show image if present
                if (message.mediaUrl != null && message.mediaUrl!.isNotEmpty) ...[
                  ClipRRect(
                    borderRadius: BorderRadius.circular(AppTheme.radiusS),
                    child: Image.network(
                      message.mediaUrl!,
                      width: 250,
                      fit: BoxFit.cover,
                      loadingBuilder: (context, child, loadingProgress) {
                        if (loadingProgress == null) return child;
                        return Container(
                          width: 250,
                          height: 250,
                          color: isDark ? AppTheme.darkGray200 : AppTheme.gray200,
                          child: Center(
                            child: CircularProgressIndicator(
                              value: loadingProgress.expectedTotalBytes != null
                                  ? loadingProgress.cumulativeBytesLoaded /
                                      loadingProgress.expectedTotalBytes!
                                  : null,
                            ),
                          ),
                        );
                      },
                      errorBuilder: (context, error, stackTrace) {
                        return Container(
                          width: 250,
                          height: 250,
                          color: isDark ? AppTheme.darkGray200 : AppTheme.gray200,
                          child: const Icon(Icons.broken_image, size: 50),
                        );
                      },
                    ),
                  ),
                  const SizedBox(height: AppTheme.spacingXXS),
                ],
                
                // Message text
                Text(
                  message.body,
                  style: TextStyle(
                    color: isDark ? AppTheme.white : AppTheme.black,
                    fontSize: AppTheme.fontSizeM,
                    height: AppTheme.lineHeightNormal,
                  ),
                ),
                
                const SizedBox(height: AppTheme.spacingXXS),
                
                // Timestamp and delivery indicator
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      _formatTime(message.createdAt),
                      style: TextStyle(
                        fontSize: AppTheme.fontSizeXS,
                        color: isDark ? AppTheme.gray600 : AppTheme.gray600,
                      ),
                    ),
                    if (isOwn) ...[
                      const SizedBox(width: AppTheme.spacingXXS),
                      _buildDeliveryIndicator(message),
                    ],
                  ],
                ),
                
                // AI Analysis Badge (shows tone analysis if available)
                analysisAsync.when(
                  data: (analysis) {
                    if (analysis == null) return const SizedBox.shrink();
                    return Padding(
                      padding: const EdgeInsets.only(top: 8),
                      child: ToneBadge(
                        analysis: analysis,
                        onTap: () => ToneDetailSheet.show(
                          context,
                          analysis,
                          message.body,
                          message.id,
                        ),
                      ),
                    );
                  },
                  loading: () => const SizedBox.shrink(),
                  error: (_, __) => const SizedBox.shrink(),
                ),
              ],
            ),
            ),
          ),
        ],
      ),
    );
  }
  
  /// Show context menu with AI features and copy/paste options
  void _showMessageContextMenu(
    BuildContext context,
    WidgetRef ref,
    Message message,
    bool isOwn,
    bool isDark,
  ) {
    showDialog(
      context: context,
      barrierColor: Colors.transparent,
      builder: (context) => GestureDetector(
        onTap: () => Navigator.pop(context),
        child: Material(
          color: Colors.transparent,
          child: Stack(
            children: [
              // Blur background
              Positioned.fill(
                child: Container(
                  color: Colors.black.withOpacity(0.1),
                ),
              ),
              // Center popup
              Center(
                child: Container(
                  margin: const EdgeInsets.symmetric(horizontal: 40),
                  decoration: BoxDecoration(
                    color: isDark ? AppTheme.darkGray100.withOpacity(0.95) : AppTheme.white.withOpacity(0.95),
                    borderRadius: BorderRadius.circular(14),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.3),
                        blurRadius: 30,
                        spreadRadius: 5,
                      ),
                    ],
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // AI Features (for received messages)
                      if (!isOwn) ...[
                        _buildPopupOption(
                          context,
                          ref,
                          message,
                          icon: Icons.psychology_outlined,
                          label: 'Analyze Message',
                          color: const Color(0xFF7C3AED), // Purple - interpreter
                          isDark: isDark,
                          isFirst: true,
                        ),
                        Divider(height: 1, color: isDark ? AppTheme.darkGray300 : AppTheme.gray300),
                      ],
                      
                      // Copy
                      _buildCopyOption(
                        context,
                        message,
                        isDark: isDark,
                        isFirst: isOwn,
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildPopupOption(
    BuildContext context,
    WidgetRef ref,
    Message message, {
    required IconData icon,
    required String label,
    required Color color,
    required bool isDark,
    bool isFirst = false,
  }) {
    return InkWell(
      onTap: () async {
        Navigator.pop(context);
        
        // Show loading indicator
        showDialog(
          context: context,
          barrierDismissible: false,
          builder: (context) => const Center(
            child: CircularProgressIndicator(),
          ),
        );
        
        try {
          // Trigger analysis if it doesn't exist
          final requestAnalysis = ref.read(requestAnalysisProvider);
          final analysis = await requestAnalysis(message.id, message.body);
          
          if (context.mounted) {
            Navigator.pop(context); // Close loading
            
            if (analysis != null) {
              // Refresh the analysis provider to show new data
              ref.invalidate(messageAnalysisProvider(message.id));
              
              // Show analysis sheet
              ToneDetailSheet.show(context, analysis, message.body, message.id);
            } else {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Failed to analyze message. Please try again.'),
                  backgroundColor: Colors.red,
                ),
              );
            }
          }
        } catch (e) {
          if (context.mounted) {
            Navigator.pop(context); // Close loading
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Error: $e'),
                backgroundColor: Colors.red,
              ),
            );
          }
        }
      },
      borderRadius: BorderRadius.vertical(
        top: isFirst ? const Radius.circular(14) : Radius.zero,
      ),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 22, color: color),
            const SizedBox(width: 12),
            Text(
              label,
              style: TextStyle(
                fontSize: 17,
                fontWeight: FontWeight.w500,
                color: color,
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildCopyOption(
    BuildContext context,
    Message message, {
    required bool isDark,
    bool isFirst = false,
  }) {
    return InkWell(
      onTap: () {
        Clipboard.setData(ClipboardData(text: message.body));
        Navigator.pop(context);
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Copied to clipboard'),
            behavior: SnackBarBehavior.floating,
            duration: Duration(seconds: 1),
          ),
        );
      },
      borderRadius: BorderRadius.vertical(
        top: isFirst ? const Radius.circular(14) : Radius.zero,
        bottom: const Radius.circular(14),
      ),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.content_copy, size: 22, color: isDark ? AppTheme.gray400 : AppTheme.gray700),
            const SizedBox(width: 12),
            Text(
              'Copy',
              style: TextStyle(
                fontSize: 17,
                fontWeight: FontWeight.w500,
                color: isDark ? AppTheme.gray400 : AppTheme.gray700,
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildTypingIndicator(BuildContext context, bool isDark) {
    final count = typingUsers?.length ?? 0;
    final text = count == 1 
        ? 'Someone is typing...' 
        : '$count people are typing...';
    
    return Padding(
      padding: const EdgeInsets.symmetric(
        horizontal: AppTheme.spacingM,
        vertical: AppTheme.spacingS,
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.symmetric(
              horizontal: AppTheme.spacingS,
              vertical: AppTheme.spacingS,
            ),
            decoration: BoxDecoration(
              color: isDark ? AppTheme.darkGray100 : AppTheme.white,
              borderRadius: BorderRadius.circular(AppTheme.radiusM),
              border: Border.all(
                color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                width: 1,
              ),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  text,
                  style: TextStyle(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                    fontSize: AppTheme.fontSizeS,
                    fontStyle: FontStyle.italic,
                  ),
                ),
                const SizedBox(width: AppTheme.spacingS),
                SizedBox(
                  width: 20,
                  height: 20,
                  child: _TypingAnimation(isDark: isDark),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildComposeBar(BuildContext context, WidgetRef ref, bool isDark) {
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingS),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        border: Border(
          top: BorderSide(
            color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
            width: 1,
          ),
        ),
      ),
      child: SafeArea(
        top: false,
        child: Column(
          children: [
            // ✅ PHASE 2: Draft Feedback Panel
            Consumer(
              builder: (context, ref, child) {
                final draftAnalysis = ref.watch(draftAnalysisProvider);
                
                return draftAnalysis.when(
                  data: (analysis) {
                    if (analysis == null) return const SizedBox.shrink();
                    
                    return DraftFeedbackPanel(
                      analysis: analysis,
                      draftMessage: messageController.text,
                      onApplySuggestion: (suggestion) {
                        messageController.text = suggestion;
                      },
                      onTemplateSelected: (template) {
                        messageController.text = template;
                      },
                      onClose: () {
                        ref.read(draftAnalysisProvider.notifier).clear();
                      },
                    );
                  },
                  loading: () => const LinearProgressIndicator(
                    backgroundColor: Colors.transparent,
                  ),
                  error: (_, __) => const SizedBox.shrink(),
                );
              },
            ),
            
            // Show selected image preview
            if (selectedImage != null) ...[
              Container(
                padding: const EdgeInsets.all(AppTheme.spacingS),
                child: Stack(
                  children: [
                    ClipRRect(
                      borderRadius: BorderRadius.circular(AppTheme.radiusS),
                      child: Image.file(
                        File(selectedImage!.path),
                        height: 150,
                        width: 150,
                        fit: BoxFit.cover,
                      ),
                    ),
                    Positioned(
                      top: AppTheme.spacingXXS,
                      right: AppTheme.spacingXXS,
                      child: GestureDetector(
                        onTap: onClearImage,
                        child: Container(
                          decoration: BoxDecoration(
                            color: AppTheme.black.withOpacity(0.6),
                            shape: BoxShape.circle,
                          ),
                          padding: const EdgeInsets.all(AppTheme.spacingXXS),
                          child: const Icon(
                            Icons.close,
                            color: AppTheme.white,
                            size: 20,
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
            
            // Input row
            Row(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                // Image picker button
                IconButton(
                  onPressed: isUploadingImage || isSending ? null : onPickImage,
                  icon: Icon(
                    Icons.image,
                    color: isUploadingImage || isSending
                        ? (isDark ? AppTheme.gray600 : AppTheme.gray400)
                        : AppTheme.accentBlue,
                  ),
                  padding: const EdgeInsets.all(AppTheme.spacingS),
                ),
                
                const SizedBox(width: AppTheme.spacingXXS),
                
                // Text input
                Expanded(
                  child: Container(
                    decoration: BoxDecoration(
                      color: isDark ? AppTheme.darkGray200 : AppTheme.gray100,
                      borderRadius: BorderRadius.circular(AppTheme.radiusXL),
                      border: Border.all(
                        color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                        width: 1,
                      ),
                    ),
                    padding: const EdgeInsets.symmetric(
                      horizontal: AppTheme.spacingM,
                    ),
                    child: TextField(
                      controller: messageController,
                      enabled: !isSending && !isUploadingImage,
                      decoration: const InputDecoration(
                        hintText: 'Message',
                        border: InputBorder.none,
                        contentPadding: EdgeInsets.symmetric(
                          vertical: AppTheme.spacingS,
                        ),
                      ),
                      maxLines: 5,
                      minLines: 1,
                      textCapitalization: TextCapitalization.sentences,
                      style: TextStyle(
                        color: isDark ? AppTheme.white : AppTheme.black,
                      ),
                    ),
                  ),
                ),
                
                const SizedBox(width: AppTheme.spacingXXS),
                
                // ✅ PHASE 2: Check Message Button (Draft Analysis)
                Consumer(
                  builder: (context, ref, child) {
                    final hasText = messageController.text.trim().isNotEmpty;
                    
                    return IconButton(
                      onPressed: !hasText ? null : () {
                        ref.read(draftAnalysisProvider.notifier).analyzeDraft(
                          draftMessage: messageController.text,
                        );
                      },
                      icon: Icon(
                        Icons.verified_outlined,
                        color: !hasText
                            ? (isDark ? AppTheme.gray600 : AppTheme.gray400)
                            : const Color(0xFF06B6D4), // Cyan - Response Assistant feature
                      ),
                      tooltip: 'Check message confidence',
                      padding: const EdgeInsets.all(AppTheme.spacingS),
                    );
                  },
                ),
                
                // Send button
                Container(
                  decoration: BoxDecoration(
                    color: isDark ? AppTheme.white : AppTheme.black,
                    shape: BoxShape.circle,
                  ),
                  child: IconButton(
                    onPressed: (isSending || isUploadingImage) ? null : onSendMessage,
                    icon: (isSending || isUploadingImage)
                        ? SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              color: isDark ? AppTheme.black : AppTheme.white,
                            ),
                          )
                        : Icon(
                            Icons.send,
                            size: 20,
                            color: isDark ? AppTheme.black : AppTheme.white,
                          ),
                    padding: const EdgeInsets.all(AppTheme.spacingS),
                    constraints: const BoxConstraints(),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildDeliveryIndicator(Message message) {
    final receipts = receiptsCache?[message.id] ?? [];
    
    // Filter out own receipts (shouldn't exist for sent messages, but just in case)
    final otherReceipts = receipts.where((r) => r.userId != currentUserId).toList();
    
    final hasDelivered = otherReceipts.any((r) => r.status == 'delivered' || r.status == 'read');
    final hasRead = otherReceipts.any((r) => r.status == 'read');

    IconData icon;
    Color color;

    if (hasRead) {
      icon = Icons.done_all;
      color = AppTheme.accentBlue;
    } else if (hasDelivered) {
      icon = Icons.done_all;
      color = AppTheme.gray600;
    } else {
      icon = Icons.done;
      color = AppTheme.gray600;
    }

    return Icon(
      icon,
      size: 14,
      color: color,
    );
  }
  
  String _formatTime(int timestamp) {
    final dateTime = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);
    final hour = dateTime.hour.toString().padLeft(2, '0');
    final minute = dateTime.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }
}

/// Animated typing indicator dots
class _TypingAnimation extends StatefulWidget {
  final bool isDark;
  
  const _TypingAnimation({required this.isDark});

  @override
  State<_TypingAnimation> createState() => _TypingAnimationState();
}

class _TypingAnimationState extends State<_TypingAnimation>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1000),
    )..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return Row(
          mainAxisSize: MainAxisSize.min,
          children: List.generate(3, (index) {
            final delay = index * 0.2;
            final value = (_controller.value - delay) % 1.0;
            final opacity = value < 0.5 ? value * 2 : (1 - value) * 2;
            
            return Container(
              width: 4,
              height: 4,
              margin: const EdgeInsets.symmetric(horizontal: 1),
              decoration: BoxDecoration(
                color: (widget.isDark ? AppTheme.gray600 : AppTheme.gray600)
                    .withOpacity(opacity),
                shape: BoxShape.circle,
              ),
            );
          }),
        );
      },
    );
  }
}
</file>

<file path="lib/features/messages/widgets/relationship_type_selector.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/draft_analysis.dart';

/// Simple dialog for selecting relationship type
class RelationshipTypeSelector extends StatelessWidget {
  final RelationshipType currentType;
  final Function(RelationshipType) onSelected;

  const RelationshipTypeSelector({
    Key? key,
    required this.currentType,
    required this.onSelected,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AlertDialog(
      title: const Text('Set Relationship Type'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: RelationshipType.values.map((type) {
          final isSelected = type == currentType;
          return ListTile(
            leading: Icon(
              type.icon,
              color: isSelected ? AppTheme.accentBlue : null,
            ),
            title: Text(
              type.displayName,
              style: isSelected
                  ? TextStyle(
                      color: AppTheme.accentBlue,
                      fontWeight: AppTheme.fontWeightBold,
                    )
                  : null,
            ),
            trailing: isSelected
                ? const Icon(Icons.check, color: AppTheme.accentBlue)
                : null,
            onTap: () {
              onSelected(type);
              Navigator.pop(context);
            },
          );
        }).toList(),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Cancel'),
        ),
      ],
    );
  }

  static Future<void> show(
    BuildContext context,
    RelationshipType currentType,
    Function(RelationshipType) onSelected,
  ) {
    return showDialog(
      context: context,
      builder: (context) => RelationshipTypeSelector(
        currentType: currentType,
        onSelected: onSelected,
      ),
    );
  }
}
</file>

<file path="lib/features/messages/widgets/rsd_alert_card.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Alert card for RSD triggers
class RSDAlertCard extends StatelessWidget {
  final List<RSDTrigger> triggers;

  const RSDAlertCard({super.key, required this.triggers});

  @override
  Widget build(BuildContext context) {
    if (triggers.isEmpty) return const SizedBox.shrink();

    final highSeverity = triggers.any((t) => t.isHighSeverity);

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: highSeverity 
            ? Colors.orange.withOpacity(0.1)
            : Colors.blue.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: highSeverity 
              ? Colors.orange.withOpacity(0.5)
              : Colors.blue.withOpacity(0.5),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Row(
            children: [
              Icon(
                highSeverity ? Icons.warning_amber : Icons.info_outline,
                color: highSeverity ? Colors.orange : Colors.blue,
                size: 20,
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  'RSD Alert: This might not be what it seems',
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                    color: highSeverity ? Colors.orange : Colors.blue,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          
          // Triggers
          ...triggers.map((trigger) => Padding(
            padding: const EdgeInsets.only(bottom: 8),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  '📌 "${trigger.pattern}"',
                  style: const TextStyle(
                    fontWeight: FontWeight.w600,
                    fontSize: 13,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  '⚠️ ${trigger.explanation}',
                  style: const TextStyle(fontSize: 12),
                ),
                const SizedBox(height: 4),
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.green.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Row(
                    children: [
                      const Icon(Icons.check_circle, size: 16, color: Colors.green),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          trigger.reassurance,
                          style: const TextStyle(
                            fontSize: 12,
                            color: Colors.green,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          )),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/messages/widgets/smart_inbox_panel.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/state/ai_providers.dart';

/// Smart Inbox: Filter messages by concern level for this conversation
/// Calm, neurodivergent-friendly design with progressive disclosure
class SmartInboxPanel extends ConsumerStatefulWidget {
  final String conversationId;
  final List<Message> messages;
  final Function(Message)? onMessageTap;

  const SmartInboxPanel({
    Key? key,
    required this.conversationId,
    required this.messages,
    this.onMessageTap,
  }) : super(key: key);

  @override
  ConsumerState<SmartInboxPanel> createState() => _SmartInboxPanelState();
}

class _SmartInboxPanelState extends ConsumerState<SmartInboxPanel> {
  String _selectedFilter = 'all'; // all, urgent, rsd, questions
  bool _isExpanded = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    // Get analysis for all messages
    final filteredMessages = _getFilteredMessages();
    
    return Container(
      margin: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: const Color(0xFF10B981).withOpacity(0.2),
          width: 2,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          _buildHeader(isDark, filteredMessages.length),
          
          // Filters (only show if expanded)
          if (_isExpanded) ...[
            const Divider(height: 1),
            _buildFilters(isDark),
          ],
          
          // Message list (only show if expanded and has messages)
          if (_isExpanded && filteredMessages.isNotEmpty) ...[
            const Divider(height: 1),
            _buildMessageList(filteredMessages, isDark),
          ],
          
          // Empty state
          if (_isExpanded && filteredMessages.isEmpty)
            _buildEmptyState(isDark),
        ],
      ),
    );
  }

  /// Header with expand/collapse
  Widget _buildHeader(bool isDark, int count) {
    final theme = Theme.of(context);
    
    return InkWell(
      onTap: () => setState(() => _isExpanded = !_isExpanded),
      borderRadius: BorderRadius.circular(16),
      child: Padding(
        padding: const EdgeInsets.all(AppTheme.spacingM),
        child: Row(
          children: [
            // Icon
            Container(
              padding: const EdgeInsets.all(10),
              decoration: BoxDecoration(
                color: const Color(0xFF10B981).withOpacity(0.1),
                borderRadius: BorderRadius.circular(10),
              ),
              child: const Icon(
                Icons.filter_list_rounded,
                color: Color(0xFF10B981),
                size: 20,
              ),
            ),
            
            const SizedBox(width: AppTheme.spacingM),
            
            // Title & subtitle
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Smart Filter',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: isDark ? AppTheme.white : AppTheme.darkGray100,
                    ),
                  ),
                  const SizedBox(height: 2),
                  Text(
                    count > 0 
                      ? '$count ${_getFilterLabel()} message${count == 1 ? '' : 's'}'
                      : 'No messages need attention',
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: isDark ? AppTheme.gray400 : AppTheme.gray600,
                    ),
                  ),
                ],
              ),
            ),
            
            // Expand icon
            Icon(
              _isExpanded ? Icons.expand_less : Icons.expand_more,
              color: isDark ? AppTheme.gray400 : AppTheme.gray600,
            ),
          ],
        ),
      ),
    );
  }

  /// Filter chips
  Widget _buildFilters(bool isDark) {
    final theme = Theme.of(context);
    
    return Padding(
      padding: const EdgeInsets.fromLTRB(
        AppTheme.spacingM,
        AppTheme.spacingS,
        AppTheme.spacingM,
        AppTheme.spacingS,
      ),
      child: Wrap(
        spacing: AppTheme.spacingS,
        runSpacing: AppTheme.spacingS,
        children: [
          _buildFilterChip('all', 'All Messages', Icons.inbox_rounded, isDark, theme),
          _buildFilterChip('urgent', 'Urgent', Icons.priority_high_rounded, isDark, theme),
          _buildFilterChip('rsd', 'RSD Triggers', Icons.warning_amber_rounded, isDark, theme),
          _buildFilterChip('questions', 'Questions', Icons.help_outline_rounded, isDark, theme),
        ],
      ),
    );
  }

  Widget _buildFilterChip(String filter, String label, IconData icon, bool isDark, ThemeData theme) {
    final isSelected = _selectedFilter == filter;
    
    return FilterChip(
      selected: isSelected,
      label: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 16),
          const SizedBox(width: 6),
          Text(label),
        ],
      ),
      onSelected: (selected) {
        setState(() => _selectedFilter = filter);
      },
      backgroundColor: isDark ? AppTheme.darkGray200 : AppTheme.gray100,
      selectedColor: const Color(0xFF10B981).withOpacity(0.2),
      checkmarkColor: const Color(0xFF10B981),
      labelStyle: TextStyle(
        color: isSelected
            ? const Color(0xFF10B981)
            : (isDark ? AppTheme.gray400 : AppTheme.gray700),
        fontSize: 13,
        fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
      ),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
        side: BorderSide(
          color: isSelected
              ? const Color(0xFF10B981)
              : Colors.transparent,
          width: 1.5,
        ),
      ),
    );
  }

  /// Message list
  Widget _buildMessageList(List<_FilteredMessage> messages, bool isDark) {
    return Container(
      constraints: const BoxConstraints(maxHeight: 300),
      child: ListView.separated(
        shrinkWrap: true,
        padding: const EdgeInsets.all(AppTheme.spacingM),
        itemCount: messages.length,
        separatorBuilder: (context, index) => const SizedBox(height: AppTheme.spacingS),
        itemBuilder: (context, index) {
          final item = messages[index];
          return _buildMessageCard(item, isDark);
        },
      ),
    );
  }

  /// Individual message card
  Widget _buildMessageCard(_FilteredMessage item, bool isDark) {
    return InkWell(
      onTap: () => widget.onMessageTap?.call(item.message),
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.all(AppTheme.spacingM),
        decoration: BoxDecoration(
          color: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: _getSeverityColor(item.severity).withOpacity(0.3),
            width: 1,
          ),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header: severity badge + timestamp
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: _getSeverityColor(item.severity).withOpacity(0.15),
                    borderRadius: BorderRadius.circular(6),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(
                        _getSeverityIcon(item.severity),
                        size: 14,
                        color: _getSeverityColor(item.severity),
                      ),
                      const SizedBox(width: 4),
                      Text(
                        item.severity,
                        style: TextStyle(
                          fontSize: 11,
                          fontWeight: FontWeight.w600,
                          color: _getSeverityColor(item.severity),
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(width: AppTheme.spacingS),
                Text(
                  _formatTime(DateTime.fromMillisecondsSinceEpoch(item.message.createdAt * 1000)),
                  style: TextStyle(
                    fontSize: 12,
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                  ),
                ),
              ],
            ),
            
            const SizedBox(height: AppTheme.spacingS),
            
            // Message body (truncated)
            Text(
              item.message.body,
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
              style: TextStyle(
                fontSize: 14,
                color: isDark ? AppTheme.gray300 : AppTheme.gray800,
              ),
            ),
            
            // Analysis reason
            if (item.reason != null) ...[
              const SizedBox(height: AppTheme.spacingXS),
              Text(
                item.reason!,
                style: TextStyle(
                  fontSize: 12,
                  fontStyle: FontStyle.italic,
                  color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  /// Empty state
  Widget _buildEmptyState(bool isDark) {
    return Padding(
      padding: const EdgeInsets.all(AppTheme.spacingXL),
      child: Center(
        child: Column(
          children: [
            Icon(
              Icons.check_circle_outline,
              size: 48,
              color: const Color(0xFF10B981).withOpacity(0.5),
            ),
            const SizedBox(height: AppTheme.spacingM),
            Text(
              _getEmptyMessage(),
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 14,
                color: isDark ? AppTheme.gray400 : AppTheme.gray600,
              ),
            ),
          ],
        ),
      ),
    );
  }

  // ============================================================================
  // Helper Methods
  // ============================================================================

  List<_FilteredMessage> _getFilteredMessages() {
    final List<_FilteredMessage> filtered = [];
    
    for (final message in widget.messages) {
      // Get analysis (if any)
      final analysisAsync = ref.watch(messageAnalysisProvider(message.id));
      final analysis = analysisAsync.value;
      
      // Apply filter
      final item = _shouldIncludeMessage(message, analysis);
      if (item != null) {
        filtered.add(item);
      }
    }
    
    // Sort by severity then time
    filtered.sort((a, b) {
      final severityCompare = _getSeverityPriority(a.severity)
          .compareTo(_getSeverityPriority(b.severity));
      if (severityCompare != 0) return severityCompare;
      return b.message.createdAt.compareTo(a.message.createdAt);
    });
    
    return filtered;
  }

  _FilteredMessage? _shouldIncludeMessage(Message message, AIAnalysis? analysis) {
    if (_selectedFilter == 'all') {
      // Show high urgency or RSD triggers only
      if (analysis == null) return null;
      
      if (analysis.urgencyLevel == 'high' || analysis.urgencyLevel == 'critical') {
        return _FilteredMessage(
          message: message,
          severity: analysis.urgencyLevel == 'critical' ? 'Critical' : 'Urgent',
          reason: 'Needs attention',
        );
      }
      
      if (analysis.rsdTriggers != null && analysis.rsdTriggers!.isNotEmpty) {
        final highSeverity = analysis.rsdTriggers!
            .where((t) => t.severity == 'high')
            .toList();
        if (highSeverity.isNotEmpty) {
          return _FilteredMessage(
            message: message,
            severity: 'RSD Trigger',
            reason: highSeverity.first.explanation,
          );
        }
      }
      
      return null;
    }
    
    if (analysis == null) return null;
    
    switch (_selectedFilter) {
      case 'urgent':
        if (analysis.urgencyLevel == 'high' || analysis.urgencyLevel == 'critical') {
          return _FilteredMessage(
            message: message,
            severity: analysis.urgencyLevel == 'critical' ? 'Critical' : 'Urgent',
            reason: 'Marked as ${analysis.urgencyLevel} priority',
          );
        }
        break;
        
      case 'rsd':
        if (analysis.rsdTriggers != null && analysis.rsdTriggers!.isNotEmpty) {
          final highSeverity = analysis.rsdTriggers!
              .where((t) => t.severity == 'high')
              .toList();
          if (highSeverity.isNotEmpty) {
            return _FilteredMessage(
              message: message,
              severity: 'RSD Trigger',
              reason: highSeverity.first.explanation,
            );
          }
        }
        break;
        
      case 'questions':
        if (message.body.contains('?')) {
          return _FilteredMessage(
            message: message,
            severity: 'Question',
            reason: 'Contains unanswered question',
          );
        }
        break;
    }
    
    return null;
  }

  String _getFilterLabel() {
    switch (_selectedFilter) {
      case 'urgent': return 'urgent';
      case 'rsd': return 'triggering';
      case 'questions': return 'unanswered';
      default: return 'filtered';
    }
  }

  String _getEmptyMessage() {
    switch (_selectedFilter) {
      case 'urgent':
        return 'No urgent messages at this time.\nYou\'re all caught up! 🎉';
      case 'rsd':
        return 'No RSD triggers detected.\nConversation feels safe! ✨';
      case 'questions':
        return 'No unanswered questions.\nYou\'re on top of it! 💪';
      default:
        return 'Everything looks good!';
    }
  }

  Color _getSeverityColor(String severity) {
    switch (severity.toLowerCase()) {
      case 'critical':
        return const Color(0xFFEF4444); // Red
      case 'urgent':
        return const Color(0xFFF59E0B); // Amber
      case 'rsd trigger':
        return const Color(0xFFEC4899); // Pink
      case 'question':
        return const Color(0xFF06B6D4); // Cyan
      default:
        return const Color(0xFF10B981); // Green
    }
  }

  IconData _getSeverityIcon(String severity) {
    switch (severity.toLowerCase()) {
      case 'critical':
        return Icons.error_rounded;
      case 'urgent':
        return Icons.priority_high_rounded;
      case 'rsd trigger':
        return Icons.warning_amber_rounded;
      case 'question':
        return Icons.help_outline_rounded;
      default:
        return Icons.info_outline_rounded;
    }
  }

  int _getSeverityPriority(String severity) {
    switch (severity.toLowerCase()) {
      case 'critical': return 0;
      case 'urgent': return 1;
      case 'rsd trigger': return 2;
      case 'question': return 3;
      default: return 999;
    }
  }

  String _formatTime(DateTime dt) {
    final now = DateTime.now();
    final diff = now.difference(dt);
    
    if (diff.inMinutes < 1) return 'Just now';
    if (diff.inHours < 1) return '${diff.inMinutes}m ago';
    if (diff.inDays < 1) return '${diff.inHours}h ago';
    if (diff.inDays < 7) return '${diff.inDays}d ago';
    
    // Format as "MMM d" (e.g., "Jan 15")
    final months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    return '${months[dt.month - 1]} ${dt.day}';
  }
}

/// Internal model for filtered messages
class _FilteredMessage {
  final Message message;
  final String severity;
  final String? reason;

  _FilteredMessage({
    required this.message,
    required this.severity,
    this.reason,
  });
}
</file>

<file path="lib/features/messages/widgets/template_picker.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/models/response_template.dart';
import 'package:messageai/models/situation_type.dart';
import 'package:messageai/services/response_template_service.dart';

/// Widget for picking and using response templates
class TemplatePicker extends ConsumerStatefulWidget {
  final SituationType? detectedSituation;
  final Function(String) onTemplateSelected;

  const TemplatePicker({
    super.key,
    this.detectedSituation,
    required this.onTemplateSelected,
  });

  @override
  ConsumerState<TemplatePicker> createState() => _TemplatePickerState();
}

class _TemplatePickerState extends ConsumerState<TemplatePicker> {
  final templateService = ResponseTemplateService();
  ResponseTemplate? selectedTemplate;
  final Map<String, TextEditingController> _fieldControllers = {};

  @override
  void initState() {
    super.initState();
    templateService.loadTemplates();
  }

  @override
  void dispose() {
    // Dispose all controllers
    for (final controller in _fieldControllers.values) {
      controller.dispose();
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final templates = widget.detectedSituation != null
        ? templateService.getTemplatesForSituation(widget.detectedSituation!)
        : templateService.getAllTemplates();

    if (templates.isEmpty) {
      return const SizedBox.shrink();
    }

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).scaffoldBackgroundColor,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 10,
            offset: const Offset(0, -2),
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Row(
            children: [
              Icon(
                widget.detectedSituation?.icon ?? Icons.lightbulb,
                color: widget.detectedSituation?.getColor() ?? Colors.blue,
              ),
              const SizedBox(width: 8),
              const Expanded(
                child: Text(
                  'Response Templates',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              IconButton(
                icon: const Icon(Icons.close),
                onPressed: () => Navigator.pop(context),
              ),
            ],
          ),
          
          if (widget.detectedSituation != null) ...[
            const SizedBox(height: 8),
            Text(
              'Detected: ${widget.detectedSituation!.displayName}',
              style: const TextStyle(
                fontSize: 13,
                color: Colors.grey,
              ),
            ),
          ],
          
          const SizedBox(height: 16),

          // Template list
          Expanded(
            child: ListView.builder(
              itemCount: templates.length,
              itemBuilder: (context, index) {
                final template = templates[index];
                final isSelected = selectedTemplate?.id == template.id;

                return Card(
                  margin: const EdgeInsets.only(bottom: 8),
                  elevation: isSelected ? 4 : 1,
                  color: isSelected ? Colors.blue.shade50 : null,
                  child: ListTile(
                    title: Text(
                      template.name,
                      style: TextStyle(
                        fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                      ),
                    ),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const SizedBox(height: 4),
                        Text(
                          template.situation,
                          style: const TextStyle(fontSize: 12),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          template.template,
                          style: const TextStyle(
                            fontSize: 11,
                            fontStyle: FontStyle.italic,
                            color: Colors.grey,
                          ),
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ],
                    ),
                    trailing: Icon(
                      isSelected ? Icons.check_circle : Icons.chevron_right,
                      color: isSelected ? Colors.blue : null,
                    ),
                    onTap: () {
                      setState(() {
                        selectedTemplate = template;
                        // Initialize controllers for this template's fields
                        _fieldControllers.clear();
                        if (template.customizableFields != null) {
                          for (final field in template.customizableFields!) {
                            _fieldControllers[field] = TextEditingController();
                          }
                        }
                      });
                    },
                  ),
                );
              },
            ),
          ),

          // Customization section (if template selected with fields)
          if (selectedTemplate != null &&
              selectedTemplate!.customizableFields != null &&
              selectedTemplate!.customizableFields!.isNotEmpty) ...[
            const SizedBox(height: 16),
            const Text(
              'Fill in the blanks:',
              style: TextStyle(
                fontSize: 14,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            ...selectedTemplate!.customizableFields!.map((field) {
              return Padding(
                padding: const EdgeInsets.only(bottom: 8),
                child: TextField(
                  controller: _fieldControllers[field],
                  decoration: InputDecoration(
                    labelText: field.replaceAll('_', ' ').toUpperCase(),
                    border: const OutlineInputBorder(),
                    isDense: true,
                  ),
                  onChanged: (_) => setState(() {}),
                ),
              );
            }),
          ],

          // Preview and use button
          if (selectedTemplate != null) ...[
            const SizedBox(height: 16),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.grey.shade200,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Preview:',
                    style: TextStyle(
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    _getPreviewText(),
                    style: const TextStyle(fontSize: 13),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () {
                  final filledTemplate = _getPreviewText();
                  widget.onTemplateSelected(filledTemplate);
                  Navigator.pop(context);
                },
                child: const Text('Use This Template'),
              ),
            ),
          ],
        ],
      ),
    );
  }

  String _getPreviewText() {
    if (selectedTemplate == null) return '';
    
    final values = <String, String>{};
    for (final entry in _fieldControllers.entries) {
      values[entry.key] = entry.value.text;
    }
    
    return selectedTemplate!.fillTemplate(values);
  }
}

/// Show template picker as bottom sheet
void showTemplatePicker(
  BuildContext context,
  SituationType? detectedSituation,
  Function(String) onTemplateSelected,
) {
  showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    builder: (context) => SizedBox(
      height: MediaQuery.of(context).size.height * 0.7,
      child: TemplatePicker(
        detectedSituation: detectedSituation,
        onTemplateSelected: onTemplateSelected,
      ),
    ),
  );
}
</file>

<file path="lib/features/messages/widgets/tone_badge.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/ai_analysis.dart';

/// A small badge widget that displays tone analysis for a message
/// Appears at the bottom-right of message bubbles
class ToneBadge extends StatelessWidget {
  final AIAnalysis analysis;
  final VoidCallback? onTap;

  const ToneBadge({
    Key? key,
    required this.analysis,
    this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    final toneInfo = _getToneInfo(analysis.tone);
    final urgencyColor = _getUrgencyColor(analysis.urgencyLevel);

    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: AppTheme.spacingXS,
          vertical: AppTheme.spacingXXS,
        ),
        decoration: BoxDecoration(
          color: (isDark ? AppTheme.darkGray200 : AppTheme.gray100)
              .withOpacity(0.9),
          borderRadius: BorderRadius.circular(AppTheme.radiusS),
          border: Border.all(
            color: urgencyColor.withOpacity(0.3),
            width: 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              toneInfo.emoji,
              style: const TextStyle(fontSize: 12),
            ),
            const SizedBox(width: AppTheme.spacingXXS),
            Text(
              toneInfo.label,
              style: TextStyle(
                fontSize: AppTheme.fontSizeXXS,
                fontWeight: AppTheme.fontWeightMedium,
                color: isDark ? AppTheme.white : AppTheme.black,
              ),
            ),
            // ✅ NEW: Show intensity dot
            if (analysis.intensity != null) ...[
              const SizedBox(width: AppTheme.spacingXXS),
              Container(
                width: 6,
                height: 6,
                decoration: BoxDecoration(
                  color: _getIntensityColor(analysis.intensity!),
                  shape: BoxShape.circle,
                ),
              ),
            ],
            // Existing urgency dot
            if (analysis.urgencyLevel != null && analysis.urgencyLevel != 'Low') ...[
              const SizedBox(width: AppTheme.spacingXXS),
              Container(
                width: 6,
                height: 6,
                decoration: BoxDecoration(
                  color: urgencyColor,
                  shape: BoxShape.circle,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  ToneInfo _getToneInfo(String tone) {
    switch (tone.toLowerCase()) {
      // Original 8
      case 'friendly':
        return ToneInfo(emoji: '😊', label: 'Friendly');
      case 'professional':
        return ToneInfo(emoji: '💼', label: 'Professional');
      case 'urgent':
        return ToneInfo(emoji: '⚠️', label: 'Urgent');
      case 'casual':
        return ToneInfo(emoji: '😎', label: 'Casual');
      case 'formal':
        return ToneInfo(emoji: '🎩', label: 'Formal');
      case 'concerned':
        return ToneInfo(emoji: '😟', label: 'Concerned');
      case 'excited':
        return ToneInfo(emoji: '🎉', label: 'Excited');
      case 'neutral':
        return ToneInfo(emoji: '😐', label: 'Neutral');
      
      // ✅ NEW: 15 additional tones
      case 'apologetic':
        return ToneInfo(emoji: '🙏', label: 'Apologetic');
      case 'appreciative':
        return ToneInfo(emoji: '🙌', label: 'Appreciative');
      case 'frustrated':
        return ToneInfo(emoji: '😤', label: 'Frustrated');
      case 'playful':
        return ToneInfo(emoji: '😜', label: 'Playful');
      case 'sarcastic':
        return ToneInfo(emoji: '🙄', label: 'Sarcastic');
      case 'empathetic':
        return ToneInfo(emoji: '🤗', label: 'Empathetic');
      case 'inquisitive':
        return ToneInfo(emoji: '🤔', label: 'Inquisitive');
      case 'assertive':
        return ToneInfo(emoji: '💪', label: 'Assertive');
      case 'tentative':
        return ToneInfo(emoji: '😬', label: 'Tentative');
      case 'defensive':
        return ToneInfo(emoji: '🛡️', label: 'Defensive');
      case 'encouraging':
        return ToneInfo(emoji: '💚', label: 'Encouraging');
      case 'disappointed':
        return ToneInfo(emoji: '😞', label: 'Disappointed');
      case 'overwhelmed':
        return ToneInfo(emoji: '😵', label: 'Overwhelmed');
      case 'relieved':
        return ToneInfo(emoji: '😌', label: 'Relieved');
      case 'confused':
        return ToneInfo(emoji: '😕', label: 'Confused');
      
      default:
        return ToneInfo(emoji: '💬', label: 'Neutral');
    }
  }

  Color _getUrgencyColor(String? urgencyLevel) {
    if (urgencyLevel == null) return AppTheme.gray500;
    
    switch (urgencyLevel.toLowerCase()) {
      case 'critical':
        return AppTheme.accentRed;
      case 'high':
        return AppTheme.accentOrange;
      case 'medium':
        return AppTheme.accentBlue;
      case 'low':
      default:
        return AppTheme.accentGreen;
    }
  }

  // ✅ NEW: Helper for intensity colors
  Color _getIntensityColor(int intensity) {
    // Map intensity (1-10) to colors
    if (intensity >= 8) {
      return Colors.red;
    } else if (intensity >= 6) {
      return Colors.orange;
    } else if (intensity >= 4) {
      return Colors.blue;
    } else if (intensity >= 2) {
      return Colors.green;
    } else {
      return Colors.grey;
    }
  }
}

class ToneInfo {
  final String emoji;
  final String label;

  ToneInfo({required this.emoji, required this.label});
}
</file>

<file path="lib/features/messages/widgets/tone_detail_sheet_simplified.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/state/ai_providers.dart';

/// Simplified tone detail sheet with progressive disclosure
/// Designed for neurodivergent users - calm, clear, less overwhelming
class ToneDetailSheetSimplified extends ConsumerStatefulWidget {
  final AIAnalysis analysis;
  final String messageBody;
  final String messageId;

  const ToneDetailSheetSimplified({
    Key? key,
    required this.analysis,
    required this.messageBody,
    required this.messageId,
  }) : super(key: key);

  @override
  ConsumerState<ToneDetailSheetSimplified> createState() => _ToneDetailSheetSimplifiedState();

  static void show(
    BuildContext context,
    AIAnalysis analysis,
    String messageBody,
    String messageId,
  ) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => DraggableScrollableSheet(
        initialChildSize: 0.7,
        minChildSize: 0.4,
        maxChildSize: 0.9,
        builder: (context, scrollController) => ToneDetailSheetSimplified(
          analysis: analysis,
          messageBody: messageBody,
          messageId: messageId,
        ),
      ),
    );
  }
}

class _ToneDetailSheetSimplifiedState extends ConsumerState<ToneDetailSheetSimplified> {
  String? _expandedSection;
  bool _isLoadingInterpretation = false;
  AIAnalysis? _enhancedAnalysis;

  @override
  void initState() {
    super.initState();
    _enhancedAnalysis = widget.analysis;
  }

  /// Trigger deeper interpretation
  Future<void> _interpretMessage() async {
    if (_isLoadingInterpretation) return;

    setState(() => _isLoadingInterpretation = true);

    try {
      final service = ref.read(messageInterpreterServiceProvider);
      final analysis = await service.interpretMessage(
        widget.messageId,
        widget.messageBody,
      );

      if (mounted) {
        setState(() {
          _enhancedAnalysis = analysis;
          _isLoadingInterpretation = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isLoadingInterpretation = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final analysis = _enhancedAnalysis ?? widget.analysis;
    
    return Container(
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          // Handle bar
          Container(
            margin: const EdgeInsets.only(top: 12),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: isDark ? AppTheme.gray600 : AppTheme.gray300,
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          // Content
          Expanded(
            child: ListView(
              padding: const EdgeInsets.all(AppTheme.spacingL),
              children: [
                // Quick summary (always visible)
                _buildQuickSummary(analysis, isDark),
                
                const SizedBox(height: AppTheme.spacingL),
                
                // RSD Alert (if present - always visible, high priority)
                if (analysis.rsdTriggers != null && analysis.rsdTriggers!.isNotEmpty)
                  _buildRSDAlert(analysis.rsdTriggers!, isDark),
                
                // Deeper interpretation button
                if (analysis.alternativeInterpretations == null ||
                    analysis.alternativeInterpretations!.isEmpty)
                  _buildInterpretButton(isDark),
                
                const SizedBox(height: AppTheme.spacingM),
                
                // Expandable sections (progressive disclosure)
                _buildExpandableSection(
                  'details',
                  'More Details',
                  Icons.info_outline_rounded,
                  isDark,
                  () => _buildDetailsSection(analysis, isDark),
                ),
                
                if (analysis.alternativeInterpretations != null &&
                    analysis.alternativeInterpretations!.isNotEmpty) ...[
                  const SizedBox(height: AppTheme.spacingS),
                  _buildExpandableSection(
                    'interpretations',
                    'Other Meanings',
                    Icons.lightbulb_outline_rounded,
                    isDark,
                    () => _buildInterpretationsSection(analysis.alternativeInterpretations!, isDark),
                  ),
                ],
                
                if (analysis.evidence != null && analysis.evidence!.isNotEmpty) ...[
                  const SizedBox(height: AppTheme.spacingS),
                  _buildExpandableSection(
                    'evidence',
                    'Why AI Thinks This',
                    Icons.checklist_rounded,
                    isDark,
                    () => _buildEvidenceSection(analysis.evidence!, isDark),
                  ),
                ],
              ],
            ),
          ),
          
          // Close button
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingL),
            decoration: BoxDecoration(
              border: Border(
                top: BorderSide(
                  color: isDark ? AppTheme.darkGray300 : AppTheme.gray200,
                ),
              ),
            ),
            child: SafeArea(
              top: false,
              child: SizedBox(
                width: double.infinity,
                child: FilledButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text('Done'),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  /// Quick summary - always visible, easy to scan
  Widget _buildQuickSummary(AIAnalysis analysis, bool isDark) {
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: _getToneColor(analysis.tone).withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: _getToneColor(analysis.tone).withOpacity(0.3),
          width: 2,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Tone (primary info)
          Row(
            children: [
              Icon(
                _getToneIcon(analysis.tone),
                color: _getToneColor(analysis.tone),
                size: 24,
              ),
              const SizedBox(width: AppTheme.spacingS),
              Expanded(
                child: Text(
                  analysis.tone,
                  style: TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.w600,
                    color: isDark ? AppTheme.white : AppTheme.darkGray100,
                  ),
                ),
              ),
            ],
          ),
          
          const SizedBox(height: AppTheme.spacingS),
          
          // Key stats (urgency, intensity)
          Wrap(
            spacing: AppTheme.spacingS,
            runSpacing: AppTheme.spacingXS,
            children: [
              if (analysis.urgencyLevel != null)
                _buildChip(
                  analysis.urgencyLevel!,
                  _getUrgencyColor(analysis.urgencyLevel),
                  isDark,
                ),
              if (analysis.intensity != null)
                _buildChip(
                  'Intensity: ${analysis.intensity}/10',
                  Colors.blue,
                  isDark,
                ),
              if (analysis.intent != null)
                _buildChip(
                  analysis.intent!,
                  Colors.purple,
                  isDark,
                ),
            ],
          ),
        ],
      ),
    );
  }

  /// RSD alert - high priority, always visible
  Widget _buildRSDAlert(List<RSDTrigger> triggers, bool isDark) {
    final highSeverity = triggers.where((t) => t.severity == 'high').toList();
    
    return Container(
      margin: const EdgeInsets.only(bottom: AppTheme.spacingM),
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: const Color(0xFFEC4899).withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: const Color(0xFFEC4899).withOpacity(0.3),
          width: 2,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.warning_amber_rounded,
                color: const Color(0xFFEC4899),
                size: 20,
              ),
              const SizedBox(width: AppTheme.spacingS),
              Text(
                'RSD Alert',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                  color: isDark ? AppTheme.white : AppTheme.darkGray100,
                ),
              ),
            ],
          ),
          const SizedBox(height: AppTheme.spacingS),
          Text(
            highSeverity.isNotEmpty
                ? highSeverity.first.explanation
                : triggers.first.explanation,
            style: TextStyle(
              fontSize: 14,
              color: isDark ? AppTheme.gray400 : AppTheme.gray700,
            ),
          ),
        ],
      ),
    );
  }

  /// Interpret button
  Widget _buildInterpretButton(bool isDark) {
    return FilledButton.icon(
      onPressed: _isLoadingInterpretation ? null : _interpretMessage,
      icon: _isLoadingInterpretation
          ? const SizedBox(
              width: 16,
              height: 16,
              child: CircularProgressIndicator(strokeWidth: 2),
            )
          : const Icon(Icons.psychology_outlined, size: 20),
      label: Text(
        _isLoadingInterpretation
            ? 'Analyzing...'
            : 'Get Deeper Interpretation',
      ),
      style: FilledButton.styleFrom(
        backgroundColor: const Color(0xFF7C3AED),
        padding: const EdgeInsets.symmetric(
          horizontal: AppTheme.spacingM,
          vertical: 12,
        ),
      ),
    );
  }

  /// Expandable section with progressive disclosure
  Widget _buildExpandableSection(
    String id,
    String title,
    IconData icon,
    bool isDark,
    Widget Function() contentBuilder,
  ) {
    final isExpanded = _expandedSection == id;
    
    return Container(
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray200 : AppTheme.gray50,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        children: [
          InkWell(
            onTap: () {
              setState(() {
                _expandedSection = isExpanded ? null : id;
              });
            },
            borderRadius: BorderRadius.circular(12),
            child: Padding(
              padding: const EdgeInsets.all(AppTheme.spacingM),
              child: Row(
                children: [
                  Icon(
                    icon,
                    size: 20,
                    color: isDark ? AppTheme.gray400 : AppTheme.gray600,
                  ),
                  const SizedBox(width: AppTheme.spacingS),
                  Expanded(
                    child: Text(
                      title,
                      style: TextStyle(
                        fontSize: 15,
                        fontWeight: FontWeight.w600,
                        color: isDark ? AppTheme.white : AppTheme.darkGray100,
                      ),
                    ),
                  ),
                  Icon(
                    isExpanded ? Icons.expand_less_rounded : Icons.expand_more_rounded,
                    color: isDark ? AppTheme.gray400 : AppTheme.gray600,
                  ),
                ],
              ),
            ),
          ),
          if (isExpanded)
            Padding(
              padding: const EdgeInsets.fromLTRB(
                AppTheme.spacingM,
                0,
                AppTheme.spacingM,
                AppTheme.spacingM,
              ),
              child: contentBuilder(),
            ),
        ],
      ),
    );
  }

  /// Details section content
  Widget _buildDetailsSection(AIAnalysis analysis, bool isDark) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (analysis.confidenceScore != null) ...[
          _buildDetailItem(
            'Confidence',
            '${(analysis.confidenceScore! * 100).toStringAsFixed(0)}%',
            isDark,
          ),
          const SizedBox(height: AppTheme.spacingS),
        ],
        if (analysis.contextFlags != null && analysis.contextFlags!.isNotEmpty)
          ...analysis.contextFlags!.entries
              .where((e) => e.value == true)
              .map((e) => Padding(
                    padding: const EdgeInsets.only(bottom: AppTheme.spacingXS),
                    child: _buildDetailItem(
                      _formatFlag(e.key),
                      '✓',
                      isDark,
                    ),
                  )),
      ],
    );
  }

  /// Interpretations section content
  Widget _buildInterpretationsSection(List<MessageInterpretation> interps, bool isDark) {
    return Column(
      children: interps.map((interp) {
        return Container(
          margin: const EdgeInsets.only(bottom: AppTheme.spacingS),
          padding: const EdgeInsets.all(AppTheme.spacingS),
          decoration: BoxDecoration(
            color: isDark ? AppTheme.darkGray100 : AppTheme.white,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                    decoration: BoxDecoration(
                      color: _getLikelihoodColor(interp.likelihood).withOpacity(0.2),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      '${interp.likelihood}%',
                      style: TextStyle(
                        fontSize: 11,
                        fontWeight: FontWeight.w600,
                        color: _getLikelihoodColor(interp.likelihood),
                      ),
                    ),
                  ),
                  const SizedBox(width: AppTheme.spacingXS),
                  Expanded(
                    child: Text(
                      interp.interpretation,
                      style: TextStyle(
                        fontSize: 14,
                        fontWeight: FontWeight.w500,
                        color: isDark ? AppTheme.white : AppTheme.darkGray100,
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        );
      }).toList(),
    );
  }

  /// Evidence section content
  Widget _buildEvidenceSection(List<Evidence> evidence, bool isDark) {
    return Column(
      children: evidence.map((e) {
        return Container(
          margin: const EdgeInsets.only(bottom: AppTheme.spacingXS),
          padding: const EdgeInsets.all(AppTheme.spacingS),
          decoration: BoxDecoration(
            color: isDark ? AppTheme.darkGray100 : AppTheme.white,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Row(
            children: [
              Icon(
                Icons.format_quote,
                size: 16,
                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
              ),
              const SizedBox(width: AppTheme.spacingXS),
              Expanded(
                child: Text(
                  e.quote,
                  style: TextStyle(
                    fontSize: 13,
                    fontStyle: FontStyle.italic,
                    color: isDark ? AppTheme.gray400 : AppTheme.gray700,
                  ),
                ),
              ),
            ],
          ),
        );
      }).toList(),
    );
  }

  Widget _buildChip(String label, Color color, bool isDark) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
      decoration: BoxDecoration(
        color: color.withOpacity(0.15),
        borderRadius: BorderRadius.circular(6),
      ),
      child: Text(
        label,
        style: TextStyle(
          fontSize: 12,
          fontWeight: FontWeight.w600,
          color: color,
        ),
      ),
    );
  }

  Widget _buildDetailItem(String label, String value, bool isDark) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          label,
          style: TextStyle(
            fontSize: 14,
            color: isDark ? AppTheme.gray500 : AppTheme.gray600,
          ),
        ),
        Text(
          value,
          style: TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            color: isDark ? AppTheme.white : AppTheme.darkGray100,
          ),
        ),
      ],
    );
  }

  // Helper methods
  Color _getToneColor(String tone) {
    final lower = tone.toLowerCase();
    if (lower.contains('urgent') || lower.contains('critical')) return Colors.red;
    if (lower.contains('sad') || lower.contains('disappointed')) return Colors.blue;
    if (lower.contains('angry') || lower.contains('frustrated')) return Colors.orange;
    if (lower.contains('happy') || lower.contains('excited')) return Colors.green;
    return const Color(0xFF7C3AED);
  }

  IconData _getToneIcon(String tone) {
    final lower = tone.toLowerCase();
    if (lower.contains('urgent') || lower.contains('critical')) return Icons.error_rounded;
    if (lower.contains('sad')) return Icons.sentiment_dissatisfied_rounded;
    if (lower.contains('angry')) return Icons.sentiment_very_dissatisfied_rounded;
    if (lower.contains('happy')) return Icons.sentiment_satisfied_rounded;
    return Icons.sentiment_neutral_rounded;
  }

  Color _getUrgencyColor(String? urgency) {
    switch (urgency?.toLowerCase()) {
      case 'critical':
        return const Color(0xFFEF4444);
      case 'high':
        return const Color(0xFFF59E0B);
      case 'medium':
        return const Color(0xFF06B6D4);
      default:
        return const Color(0xFF10B981);
    }
  }

  Color _getLikelihoodColor(int likelihood) {
    if (likelihood >= 70) return Colors.green;
    if (likelihood >= 40) return Colors.orange;
    return Colors.red;
  }

  String _formatFlag(String flag) {
    return flag.replaceAll('_', ' ').split(' ').map((w) => 
      w[0].toUpperCase() + w.substring(1)
    ).join(' ');
  }
}
</file>

<file path="lib/features/messages/widgets/tone_detail_sheet.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/core/theme/app_theme.dart';
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/features/messages/widgets/rsd_alert_card.dart';
import 'package:messageai/features/messages/widgets/interpretation_options.dart';
import 'package:messageai/features/messages/widgets/evidence_viewer.dart';
import 'package:messageai/state/ai_providers.dart';

/// Bottom sheet showing detailed tone analysis
class ToneDetailSheet extends ConsumerStatefulWidget {
  final AIAnalysis analysis;
  final String messageBody;
  final String messageId;

  const ToneDetailSheet({
    Key? key,
    required this.analysis,
    required this.messageBody,
    required this.messageId,
  }) : super(key: key);

  @override
  ConsumerState<ToneDetailSheet> createState() => _ToneDetailSheetState();

  /// Static method to show the sheet
  static void show(
    BuildContext context,
    AIAnalysis analysis,
    String messageBody,
    String messageId,
  ) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => DraggableScrollableSheet(
        initialChildSize: 0.9,
        minChildSize: 0.5,
        maxChildSize: 0.95,
        builder: (context, scrollController) => SingleChildScrollView(
          controller: scrollController,
          child: ToneDetailSheet(
            analysis: analysis,
            messageBody: messageBody,
            messageId: messageId,
          ),
        ),
      ),
    );
  }
}

class _ToneDetailSheetState extends ConsumerState<ToneDetailSheet> {
  bool _isLoadingInterpretation = false;
  AIAnalysis? _enhancedAnalysis;

  @override
  void initState() {
    super.initState();
    _enhancedAnalysis = widget.analysis;
  }

  /// Trigger deeper interpretation with RSD detection and alternatives
  Future<void> _interpretMessage() async {
    if (_isLoadingInterpretation) return;

    setState(() {
      _isLoadingInterpretation = true;
    });

    try {
      final service = ref.read(messageInterpreterServiceProvider);
      final analysis = await service.interpretMessage(
        widget.messageId,
        widget.messageBody,
      );

      if (mounted) {
        setState(() {
          _enhancedAnalysis = analysis;
          _isLoadingInterpretation = false;
        });

        // Show success message
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('✨ Deeper interpretation complete!'),
            duration: Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoadingInterpretation = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to interpret message: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final analysis = _enhancedAnalysis ?? widget.analysis;

    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingL),
      decoration: BoxDecoration(
        color: isDark ? AppTheme.darkGray100 : AppTheme.white,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(AppTheme.radiusXL),
          topRight: Radius.circular(AppTheme.radiusXL),
        ),
      ),
      child: SafeArea(
        top: false,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Handle bar
            Center(
              child: Container(
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                  borderRadius: BorderRadius.circular(AppTheme.radiusPill),
                ),
              ),
            ),
            
            const SizedBox(height: AppTheme.spacingL),
            
            // Header
            Row(
              children: [
                Icon(
                  Icons.psychology,
                  size: 28,
                  color: isDark ? AppTheme.white : AppTheme.black,
                ),
                const SizedBox(width: AppTheme.spacingS),
                Text(
                  'AI Analysis',
                  style: theme.textTheme.displaySmall?.copyWith(
                    fontWeight: AppTheme.fontWeightBold,
                  ),
                ),
              ],
            ),
            
            const SizedBox(height: AppTheme.spacingL),
            
            // Message preview
            _buildSection(
              context,
              'Message',
              widget.messageBody.length > 100
                  ? '${widget.messageBody.substring(0, 100)}...'
                  : widget.messageBody,
              Icons.chat_bubble_outline,
              isDark,
            ),
            
            const SizedBox(height: AppTheme.spacingM),
            
            // ✅ PHASE 1: Interpret Message Button
            if (analysis.alternativeInterpretations == null ||
                analysis.alternativeInterpretations!.isEmpty) ...[
              ElevatedButton.icon(
                onPressed: _isLoadingInterpretation ? null : _interpretMessage,
                icon: _isLoadingInterpretation
                    ? const SizedBox(
                        width: 16,
                        height: 16,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                    : const Icon(Icons.lightbulb_outline),
                label: Text(
                  _isLoadingInterpretation
                      ? 'Analyzing...'
                      : '✨ Get Deeper Interpretation',
                ),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.purple,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 12,
                  ),
                ),
              ),
              const SizedBox(height: AppTheme.spacingM),
            ],
            
            // ✅ PHASE 1: RSD Alert
            if (analysis.rsdTriggers != null && analysis.rsdTriggers!.isNotEmpty) ...[
              RSDAlertCard(triggers: analysis.rsdTriggers!),
              const SizedBox(height: AppTheme.spacingM),
            ],
            
            // Tone
            _buildSection(
              context,
              'Tone',
              analysis.tone,
              Icons.sentiment_satisfied,
              isDark,
              highlight: true,
            ),
            
            const SizedBox(height: AppTheme.spacingM),
            
            // Urgency
            if (analysis.urgencyLevel != null)
              _buildSection(
                context,
                'Urgency Level',
                analysis.urgencyLevel!,
                Icons.priority_high,
                isDark,
                color: _getUrgencyColor(analysis.urgencyLevel),
              ),
            
            if (analysis.urgencyLevel != null)
              const SizedBox(height: AppTheme.spacingM),
            
            // Intent
            if (analysis.intent != null)
              _buildSection(
                context,
                'Intent',
                analysis.intent!,
                Icons.lightbulb_outline,
                isDark,
              ),
            
            if (analysis.intent != null)
              const SizedBox(height: AppTheme.spacingM),
            
            // Confidence
            if (analysis.confidenceScore != null) ...[
              _buildConfidenceBar(
                context,
                analysis.confidenceScore!,
                isDark,
              ),
              const SizedBox(height: AppTheme.spacingM),
            ],
            
            // ✅ NEW: Intensity section
            if (analysis.intensity != null) ...[
              _buildSection(
                context,
                'Intensity',
                _formatIntensity(analysis.intensity!),
                Icons.trending_up,
                isDark,
              ),
              const SizedBox(height: AppTheme.spacingM),
            ],
            
            // ✅ NEW: Context flags
            if (analysis.contextFlags != null && analysis.contextFlags!.isNotEmpty) ...[
              _buildContextFlags(context, analysis.contextFlags!, isDark),
              const SizedBox(height: AppTheme.spacingM),
            ],
            
            // ✅ NEW: Anxiety assessment
            if (analysis.anxietyAssessment != null) ...[
              _buildAnxietyAssessment(context, analysis.anxietyAssessment!, isDark),
              const SizedBox(height: AppTheme.spacingM),
            ],
            
            // ✅ PHASE 1: Alternative Interpretations
            if (analysis.alternativeInterpretations != null && 
                analysis.alternativeInterpretations!.isNotEmpty) ...[
              InterpretationOptions(interpretations: analysis.alternativeInterpretations!),
              const SizedBox(height: AppTheme.spacingM),
            ],
            
            // ✅ PHASE 1: Evidence
            if (analysis.evidence != null) ...[
              EvidenceViewer(evidence: analysis.evidence!),
              const SizedBox(height: AppTheme.spacingL),
            ],
            
            // Feedback section
            _buildFeedbackSection(context, isDark),
            
            const SizedBox(height: AppTheme.spacingM),
            
            // Close button
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () => Navigator.pop(context),
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(
                    vertical: AppTheme.spacingM,
                  ),
                ),
                child: const Text('Close'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSection(
    BuildContext context,
    String label,
    String value,
    IconData icon,
    bool isDark, {
    bool highlight = false,
    Color? color,
  }) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: highlight
            ? (isDark ? AppTheme.darkGray200 : AppTheme.gray100)
            : (isDark ? AppTheme.darkGray200.withOpacity(0.5) : AppTheme.gray50),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: color ?? (isDark ? AppTheme.darkGray300 : AppTheme.gray300),
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingS),
            decoration: BoxDecoration(
              color: (color ?? (isDark ? AppTheme.darkGray300 : AppTheme.gray200))
                  .withOpacity(0.3),
              borderRadius: BorderRadius.circular(AppTheme.radiusS),
            ),
            child: Icon(
              icon,
              size: 20,
              color: color ?? (isDark ? AppTheme.white : AppTheme.black),
            ),
          ),
          const SizedBox(width: AppTheme.spacingM),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  label,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                    fontWeight: AppTheme.fontWeightMedium,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  value,
                  style: theme.textTheme.bodyLarge?.copyWith(
                    fontWeight: AppTheme.fontWeightSemibold,
                    color: color,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildConfidenceBar(
    BuildContext context,
    double confidence,
    bool isDark,
  ) {
    final theme = Theme.of(context);
    final percentage = (confidence * 100).round();
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Confidence',
              style: theme.textTheme.bodySmall?.copyWith(
                color: isDark ? AppTheme.gray500 : AppTheme.gray600,
                fontWeight: AppTheme.fontWeightMedium,
              ),
            ),
            Text(
              '$percentage%',
              style: theme.textTheme.bodySmall?.copyWith(
                fontWeight: AppTheme.fontWeightBold,
              ),
            ),
          ],
        ),
        const SizedBox(height: AppTheme.spacingXS),
        ClipRRect(
          borderRadius: BorderRadius.circular(AppTheme.radiusPill),
          child: LinearProgressIndicator(
            value: confidence,
            minHeight: 8,
            backgroundColor: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
            valueColor: AlwaysStoppedAnimation<Color>(
              confidence > 0.8
                  ? AppTheme.accentGreen
                  : confidence > 0.6
                      ? AppTheme.accentBlue
                      : AppTheme.accentOrange,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildFeedbackSection(BuildContext context, bool isDark) {
    final theme = Theme.of(context);
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Was this analysis helpful?',
          style: theme.textTheme.bodySmall?.copyWith(
            color: isDark ? AppTheme.gray500 : AppTheme.gray600,
            fontWeight: AppTheme.fontWeightMedium,
          ),
        ),
        const SizedBox(height: AppTheme.spacingXS),
        Row(
          children: [
            OutlinedButton.icon(
              onPressed: () {
                // TODO: Implement feedback logic
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Thanks for your feedback!')),
                );
              },
              icon: const Icon(Icons.thumb_up_outlined, size: 18),
              label: const Text('Helpful'),
              style: OutlinedButton.styleFrom(
                side: BorderSide(
                  color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                ),
              ),
            ),
            const SizedBox(width: AppTheme.spacingS),
            OutlinedButton.icon(
              onPressed: () {
                // TODO: Implement feedback logic
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Thanks for your feedback!')),
                );
              },
              icon: const Icon(Icons.thumb_down_outlined, size: 18),
              label: const Text('Not helpful'),
              style: OutlinedButton.styleFrom(
                side: BorderSide(
                  color: isDark ? AppTheme.darkGray300 : AppTheme.gray300,
                ),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Color _getUrgencyColor(String? urgencyLevel) {
    if (urgencyLevel == null) return AppTheme.gray500;
    
    switch (urgencyLevel.toLowerCase()) {
      case 'critical':
        return AppTheme.accentRed;
      case 'high':
        return AppTheme.accentOrange;
      case 'medium':
        return AppTheme.accentBlue;
      case 'low':
      default:
        return AppTheme.accentGreen;
    }
  }

  // ✅ NEW: Helper methods for enhanced fields
  String _formatIntensity(int intensity) {
    // Convert number (1-10) to descriptive text
    if (intensity >= 9) {
      return 'Very High';
    } else if (intensity >= 7) {
      return 'High';
    } else if (intensity >= 5) {
      return 'Medium';
    } else if (intensity >= 3) {
      return 'Low';
    } else {
      return 'Very Low';
    }
  }

  Widget _buildContextFlags(BuildContext context, Map<String, dynamic> flags, bool isDark) {
    final activeFlags = flags.entries
        .where((e) => e.value == true)
        .map((e) => _formatFlag(e.key))
        .toList();
    
    if (activeFlags.isEmpty) return const SizedBox.shrink();
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: Colors.blue.withOpacity(0.1),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(
          color: Colors.blue.withOpacity(0.3),
        ),
      ),
      child: Row(
        children: [
          Icon(
            Icons.info_outline,
            size: 20,
            color: Colors.blue,
          ),
          const SizedBox(width: AppTheme.spacingS),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Context Flags',
                  style: TextStyle(
                    fontSize: AppTheme.fontSizeXS,
                    fontWeight: AppTheme.fontWeightBold,
                    color: Colors.blue,
                  ),
                ),
                const SizedBox(height: AppTheme.spacingXXS),
                Text(
                  activeFlags.join(', '),
                  style: TextStyle(fontSize: AppTheme.fontSizeXS),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  String _formatFlag(String flag) {
    return flag.replaceAll('_', ' ').split(' ').map((word) => 
      word[0].toUpperCase() + word.substring(1)
    ).join(' ');
  }

  Widget _buildAnxietyAssessment(BuildContext context, Map<String, dynamic> assessment, bool isDark) {
    final riskLevel = assessment['risk_level'] as String?;
    final suggestions = (assessment['mitigation_suggestions'] as List<dynamic>?)
        ?.map((e) => e as String)
        .toList() ?? [];
    
    if (riskLevel == null) return const SizedBox.shrink();
    
    final riskColor = _getRiskColor(riskLevel);
    
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingM),
      decoration: BoxDecoration(
        color: riskColor.withOpacity(0.1),
        borderRadius: BorderRadius.circular(AppTheme.radiusM),
        border: Border.all(color: riskColor),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.psychology, size: 20, color: riskColor),
              const SizedBox(width: AppTheme.spacingS),
              Text(
                'Response Anxiety: ${riskLevel.toUpperCase()}',
                style: TextStyle(
                  fontWeight: AppTheme.fontWeightBold,
                  color: riskColor,
                ),
              ),
            ],
          ),
          if (suggestions.isNotEmpty) ...[
            const SizedBox(height: AppTheme.spacingS),
            ...suggestions.map((s) => Padding(
              padding: const EdgeInsets.only(top: AppTheme.spacingXXS),
              child: Text(
                '• $s',
                style: TextStyle(fontSize: AppTheme.fontSizeXS),
              ),
            )),
          ],
        ],
      ),
    );
  }

  Color _getRiskColor(String level) {
    switch (level.toLowerCase()) {
      case 'high':
        return Colors.red;
      case 'medium':
        return Colors.orange;
      case 'low':
        return Colors.green;
      default:
        return Colors.grey;
    }
  }
}
</file>

<file path="lib/features/notifications/widgets/notification_widgets.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/notification_providers.dart';
import 'package:messageai/services/notification_service.dart' hide notificationServiceProvider;

/// Widget to request notification permissions
class NotificationPermissionRequest extends ConsumerWidget {
  final VoidCallback? onPermissionGranted;
  final VoidCallback? onPermissionDenied;

  const NotificationPermissionRequest({
    Key? key,
    this.onPermissionGranted,
    this.onPermissionDenied,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final hasPermission = ref.watch(notificationPermissionProvider);

    return hasPermission.when(
      data: (hasPermission) {
        if (hasPermission) {
          return const SizedBox.shrink();
        }
        return _PermissionBanner(
          onGranted: onPermissionGranted,
          onDenied: onPermissionDenied,
        );
      },
      loading: () => const SizedBox.shrink(),
      error: (error, st) => const SizedBox.shrink(),
    );
  }
}

/// Permission request banner
class _PermissionBanner extends ConsumerWidget {
  final VoidCallback? onGranted;
  final VoidCallback? onDenied;

  const _PermissionBanner({
    this.onGranted,
    this.onDenied,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Container(
      color: Colors.blue.shade50,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      child: Row(
        children: [
          Icon(
            Icons.notifications_none,
            color: Colors.blue.shade700,
            size: 24,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  'Enable Notifications',
                  style: Theme.of(context).textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                ),
                Text(
                  'Get notified when you receive messages',
                  style: Theme.of(context).textTheme.bodySmall,
                ),
              ],
            ),
          ),
          const SizedBox(width: 12),
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextButton(
                onPressed: () {
                  onDenied?.call();
                },
                child: const Text('Not Now'),
              ),
              const SizedBox(width: 8),
              ElevatedButton(
                onPressed: () async {
                  final service = ref.read(notificationServiceProvider);
                  final granted = await service.areNotificationsEnabled();
                  if (granted) {
                    onGranted?.call();
                  } else {
                    onDenied?.call();
                  }
                },
                child: const Text('Enable'),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

/// Notification status indicator
class NotificationStatusIndicator extends ConsumerWidget {
  const NotificationStatusIndicator({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);

    if (!notificationState.isInitialized) {
      return const SizedBox.shrink();
    }

    final hasPermission = notificationState.hasPermission;

    return Tooltip(
      message: hasPermission ? 'Notifications enabled' : 'Notifications disabled',
      child: Icon(
        hasPermission ? Icons.notifications_active : Icons.notifications_off,
        color: hasPermission ? Colors.green : Colors.grey,
        size: 24,
      ),
    );
  }
}

/// Notification settings tile
class NotificationSettingsTile extends ConsumerWidget {
  final VoidCallback? onPressed;

  const NotificationSettingsTile({
    Key? key,
    this.onPressed,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);
    final hasPermission = notificationState.hasPermission;

    return ListTile(
      leading: Icon(
        hasPermission ? Icons.notifications_active : Icons.notifications_off,
        color: hasPermission ? Colors.green : Colors.grey,
      ),
      title: const Text('Notifications'),
      subtitle: Text(
        hasPermission ? 'Enabled' : 'Disabled',
        style: TextStyle(
          color: hasPermission ? Colors.green : Colors.grey,
        ),
      ),
      trailing: Icon(
        Icons.chevron_right,
        color: Theme.of(context).dividerColor,
      ),
      onTap: onPressed,
    );
  }
}

/// Unread notification badge
class NotificationBadge extends ConsumerWidget {
  final Widget child;
  final Color? backgroundColor;
  final TextStyle? textStyle;

  const NotificationBadge({
    Key? key,
    required this.child,
    this.backgroundColor,
    this.textStyle,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);
    final unreadCount = notificationState.unreadCount;

    if (unreadCount == 0) {
      return child;
    }

    return Badge(
      label: Text(
        unreadCount > 99 ? '99+' : '$unreadCount',
        style: textStyle,
      ),
      backgroundColor: backgroundColor ?? Colors.red,
      child: child,
    );
  }
}

/// Notification bottom sheet
class NotificationSettingsBottomSheet extends ConsumerWidget {
  const NotificationSettingsBottomSheet({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notificationState = ref.watch(notificationStateProvider);
    final hasPermission = notificationState.hasPermission;
    final deviceToken = notificationState.deviceToken;

    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Text(
            'Notification Settings',
            style: Theme.of(context).textTheme.headlineSmall,
          ),
          const SizedBox(height: 24),

          // Permission status
          ListTile(
            leading: Icon(
              hasPermission ? Icons.check_circle : Icons.cancel,
              color: hasPermission ? Colors.green : Colors.red,
            ),
            title: const Text('Notifications'),
            subtitle: Text(
              hasPermission ? 'Enabled' : 'Disabled',
              style: TextStyle(
                color: hasPermission ? Colors.green : Colors.red,
              ),
            ),
          ),
          const Divider(),

          // Device token info
          if (deviceToken != null)
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 8.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Device Token',
                    style: Theme.of(context).textTheme.labelMedium,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    deviceToken.substring(0, 20) + '...',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          fontFamily: 'monospace',
                        ),
                  ),
                ],
              ),
            ),
          const SizedBox(height: 24),

          // Close button
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Close'),
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/settings/screens/settings_screen.dart">
import 'package:flutter/material.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/features/auth/screens/auth_screen.dart';
import 'package:messageai/services/avatar_service.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_ui.dart';

/// User settings and account management screen
class SettingsScreen extends StatefulWidget {
  const SettingsScreen({Key? key}) : super(key: key);

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> with ErrorHandlerMixin {
  final _supabase = SupabaseClientProvider.client;
  final _avatarService = AvatarService();
  bool _notificationsEnabled = true;
  bool _isLoading = false;
  bool _isUploadingAvatar = false;
  String? _avatarUrl;

  @override
  void initState() {
    super.initState();
    _loadProfile();
  }

  Future<void> _loadProfile() async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      final response = await _supabase
          .from('profiles')
          .select('avatar_url')
          .eq('user_id', userId)
          .maybeSingle();

      if (response != null && mounted) {
        setState(() {
          _avatarUrl = response['avatar_url'] as String?;
        });
      }
    } catch (e) {
      print('Error loading profile: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    final user = _supabase.auth.currentUser;
    final email = user?.email ?? 'Not logged in';
    final userId = user?.id ?? '';

    return Scaffold(
      appBar: AppBar(
        title: const Text('Settings'),
        elevation: 1,
      ),
      body: ListView(
        children: [
          // Profile Section
          Container(
            padding: const EdgeInsets.all(24),
            color: Theme.of(context).colorScheme.surfaceContainer,
            child: Column(
              children: [
                Stack(
                  children: [
                    _isUploadingAvatar
                        ? const CircleAvatar(
                            radius: 50,
                            child: CircularProgressIndicator(),
                          )
                        : CircleAvatar(
                            radius: 50,
                            backgroundColor: Theme.of(context).colorScheme.primary,
                            backgroundImage: _avatarUrl != null
                                ? NetworkImage(_avatarUrl!)
                                : null,
                            child: _avatarUrl == null
                                ? Text(
                                    email[0].toUpperCase(),
                                    style: const TextStyle(
                                      fontSize: 40,
                                      fontWeight: FontWeight.bold,
                                      color: Colors.white,
                                    ),
                                  )
                                : null,
                          ),
                    Positioned(
                      bottom: 0,
                      right: 0,
                      child: Container(
                        decoration: BoxDecoration(
                          color: Theme.of(context).colorScheme.primary,
                          shape: BoxShape.circle,
                        ),
                        child: IconButton(
                          icon: const Icon(Icons.camera_alt, color: Colors.white, size: 20),
                          onPressed: _isUploadingAvatar ? null : _showAvatarOptions,
                          padding: const EdgeInsets.all(8),
                          constraints: const BoxConstraints(),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                Text(
                  email,
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                const SizedBox(height: 4),
                Text(
                  'ID: ${userId.substring(0, 8)}...',
                  style: Theme.of(context).textTheme.bodySmall,
                ),
              ],
            ),
          ),

          const SizedBox(height: 8),

          // Account Settings
          _buildSectionTitle('Account'),
          _buildSettingsTile(
            icon: Icons.person,
            title: 'Display Name',
            subtitle: email.split('@')[0],
            onTap: () => _showEditDisplayNameDialog(),
          ),
          _buildSettingsTile(
            icon: Icons.email,
            title: 'Email',
            subtitle: email,
            onTap: () {},
          ),
          _buildSettingsTile(
            icon: Icons.lock,
            title: 'Change Password',
            onTap: () => _showComingSoonDialog('Change Password'),
          ),

          const Divider(height: 1),

          // Notifications
          _buildSectionTitle('Notifications'),
          SwitchListTile(
            secondary: const Icon(Icons.notifications),
            title: const Text('Push Notifications'),
            subtitle: const Text('Receive message notifications'),
            value: _notificationsEnabled,
            onChanged: (value) {
              setState(() => _notificationsEnabled = value);
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(
                    value ? 'Notifications enabled' : 'Notifications disabled',
                  ),
                ),
              );
            },
          ),
          _buildSettingsTile(
            icon: Icons.volume_up,
            title: 'Notification Sound',
            subtitle: 'Default',
            onTap: () => _showComingSoonDialog('Notification Sounds'),
          ),

          const Divider(height: 1),

          // Privacy & Security
          _buildSectionTitle('Privacy & Security'),
          _buildSettingsTile(
            icon: Icons.shield,
            title: 'Blocked Users',
            onTap: () => _showComingSoonDialog('Blocked Users'),
          ),
          _buildSettingsTile(
            icon: Icons.visibility,
            title: 'Online Status',
            subtitle: 'Visible to everyone',
            onTap: () => _showComingSoonDialog('Online Status Settings'),
          ),
          _buildSettingsTile(
            icon: Icons.check_circle,
            title: 'Read Receipts',
            subtitle: 'Enabled',
            onTap: () => _showComingSoonDialog('Read Receipts Settings'),
          ),

          const Divider(height: 1),

          // Storage
          _buildSectionTitle('Storage'),
          _buildSettingsTile(
            icon: Icons.storage,
            title: 'Storage Usage',
            subtitle: 'Calculate storage...',
            onTap: () => _showComingSoonDialog('Storage Management'),
          ),
          _buildSettingsTile(
            icon: Icons.delete_sweep,
            title: 'Clear Cache',
            onTap: () => _showClearCacheDialog(),
          ),

          const Divider(height: 1),

          // About
          _buildSectionTitle('About'),
          _buildSettingsTile(
            icon: Icons.info,
            title: 'App Version',
            subtitle: '1.0.0 (MVP)',
            onTap: () {},
          ),
          _buildSettingsTile(
            icon: Icons.privacy_tip,
            title: 'Privacy Policy',
            onTap: () => _showComingSoonDialog('Privacy Policy'),
          ),
          _buildSettingsTile(
            icon: Icons.description,
            title: 'Terms of Service',
            onTap: () => _showComingSoonDialog('Terms of Service'),
          ),

          const SizedBox(height: 16),

          // Logout Button
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: ElevatedButton.icon(
              onPressed: _isLoading ? null : _handleLogout,
              icon: _isLoading
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Icon(Icons.logout),
              label: const Text('Log Out'),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.red,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(vertical: 16),
              ),
            ),
          ),

          const SizedBox(height: 32),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 24, 16, 8),
      child: Text(
        title.toUpperCase(),
        style: TextStyle(
          fontSize: 12,
          fontWeight: FontWeight.w600,
          color: Theme.of(context).colorScheme.primary,
        ),
      ),
    );
  }

  Widget _buildSettingsTile({
    required IconData icon,
    required String title,
    String? subtitle,
    VoidCallback? onTap,
  }) {
    return ListTile(
      leading: Icon(icon),
      title: Text(title),
      subtitle: subtitle != null ? Text(subtitle) : null,
      trailing: const Icon(Icons.chevron_right),
      onTap: onTap,
    );
  }

  /// Show avatar options (Gallery, Camera, Delete)
  void _showAvatarOptions() {
    showModalBottomSheet(
      context: context,
      builder: (BuildContext context) {
        return SafeArea(
          child: Wrap(
            children: [
              ListTile(
                leading: const Icon(Icons.photo_library),
                title: const Text('Choose from Gallery'),
                onTap: () {
                  Navigator.pop(context);
                  _uploadAvatarFromGallery();
                },
              ),
              ListTile(
                leading: const Icon(Icons.camera_alt),
                title: const Text('Take Photo'),
                onTap: () {
                  Navigator.pop(context);
                  _uploadAvatarFromCamera();
                },
              ),
              if (_avatarUrl != null)
                ListTile(
                  leading: const Icon(Icons.delete, color: Colors.red),
                  title: const Text('Remove Photo', style: TextStyle(color: Colors.red)),
                  onTap: () {
                    Navigator.pop(context);
                    _deleteAvatar();
                  },
                ),
              ListTile(
                leading: const Icon(Icons.cancel),
                title: const Text('Cancel'),
                onTap: () => Navigator.pop(context),
              ),
            ],
          ),
        );
      },
    );
  }

  /// Upload avatar from gallery
  Future<void> _uploadAvatarFromGallery() async {
    try {
      final image = await _avatarService.pickImage();
      if (image == null) return;

      await _uploadAvatar(image);
    } on AppError catch (error) {
      if (mounted) {
        showError(error);
      }
    }
  }

  /// Upload avatar from camera
  Future<void> _uploadAvatarFromCamera() async {
    try {
      final image = await _avatarService.pickImageFromCamera();
      if (image == null) return;

      await _uploadAvatar(image);
    } on AppError catch (error) {
      if (mounted) {
        showError(error);
      }
    }
  }

  /// Upload avatar to server
  Future<void> _uploadAvatar(image) async {
    if (mounted) {
      setState(() => _isUploadingAvatar = true);
    }

    try {
      final url = await _avatarService.uploadAvatar(image);

      if (mounted) {
        setState(() {
          _avatarUrl = url;
          _isUploadingAvatar = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 12),
                Text('Profile picture updated successfully'),
              ],
            ),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
      }
    } on AppError catch (error) {
      if (mounted) {
        setState(() => _isUploadingAvatar = false);
        showError(error);
      }
    }
  }

  /// Delete avatar
  Future<void> _deleteAvatar() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Remove Photo'),
        content: const Text('Are you sure you want to remove your profile picture?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('Remove'),
          ),
        ],
      ),
    );

    if (confirm != true) return;

    setState(() => _isUploadingAvatar = true);

    try {
      await _avatarService.deleteAvatar();

      if (mounted) {
        setState(() {
          _avatarUrl = null;
          _isUploadingAvatar = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Profile picture removed')),
        );
      }
    } on AppError catch (error) {
      if (mounted) {
        setState(() => _isUploadingAvatar = false);
        showError(error);
      }
    }
  }

  void _showEditDisplayNameDialog() {
    final controller = TextEditingController();
    final user = _supabase.auth.currentUser;
    controller.text = user?.email?.split('@')[0] ?? '';

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Edit Display Name'),
        content: TextField(
          controller: controller,
          decoration: const InputDecoration(
            labelText: 'Display Name',
            border: OutlineInputBorder(),
          ),
          autofocus: true,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Display name updated')),
              );
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  void _showComingSoonDialog(String feature) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Coming Soon'),
        content: Text('$feature will be available in a future update.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  void _showClearCacheDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Clear Cache'),
        content: const Text(
          'This will clear all cached images and files. Your messages will not be affected.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Cache cleared')),
              );
            },
            child: const Text('Clear'),
          ),
        ],
      ),
    );
  }

  Future<void> _handleLogout() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Log Out'),
        content: const Text('Are you sure you want to log out?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('Log Out'),
          ),
        ],
      ),
    );

    if (confirm == true && mounted) {
      setState(() => _isLoading = true);
      
      try {
        await _supabase.auth.signOut();
        
        if (mounted) {
          Navigator.of(context).pushAndRemoveUntil(
            MaterialPageRoute(
              builder: (context) => AuthScreen(onAuthSuccess: () {}),
            ),
            (route) => false,
          );
        }
      } catch (e) {
        if (mounted) {
          setState(() => _isLoading = false);
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error logging out: $e')),
          );
        }
      }
    }
  }
}
</file>

<file path="lib/firebase_options.dart">
// File generated by FlutterFire CLI.
// This is a placeholder file. To use Firebase, you need to:
// 1. Install FlutterFire CLI: dart pub global activate flutterfire_cli
// 2. Run: flutterfire configure
// 3. Follow the prompts to select your Firebase project
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import firebase_options.dart;
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyABa-DcxTR4T4CHlfJuy-7DKG1F_hDRNcg',
    appId: '1:397483513751:web:3121cbb846ddd8381c56d2',
    messagingSenderId: '397483513751',
    projectId: 'messageai-e2e9e',
    authDomain: 'messageai-e2e9e.firebaseapp.com',
    storageBucket: 'messageai-e2e9e.firebasestorage.app',
    measurementId: 'G-VCVQDFPTLV',
  );

  // Placeholder values - replace with your actual Firebase configuration

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyBBc-17a_EvWPvCutNSTEV9QEB2w2DUM_4',
    appId: '1:397483513751:android:bb838799a2cd3f7f1c56d2',
    messagingSenderId: '397483513751',
    projectId: 'messageai-e2e9e',
    storageBucket: 'messageai-e2e9e.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIza...',  // Replace with your iOS API key
    appId: '1:...',     // Replace with your iOS app ID
    messagingSenderId: '...',  // Replace with your sender ID
    projectId: 'your-project-id',  // Replace with your project ID
    storageBucket: 'your-project-id.appspot.com',
    iosBundleId: 'com.example.messageai',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIza...',  // Replace with your macOS API key
    appId: '1:...',     // Replace with your macOS app ID
    messagingSenderId: '...',  // Replace with your sender ID
    projectId: 'your-project-id',  // Replace with your project ID
    storageBucket: 'your-project-id.appspot.com',
    iosBundleId: 'com.example.messageai',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyABa-DcxTR4T4CHlfJuy-7DKG1F_hDRNcg',
    appId: '1:397483513751:web:ba73c764d577f4f51c56d2',
    messagingSenderId: '397483513751',
    projectId: 'messageai-e2e9e',
    authDomain: 'messageai-e2e9e.firebaseapp.com',
    storageBucket: 'messageai-e2e9e.firebasestorage.app',
    measurementId: 'G-C6R3PHYG95',
  );

}
</file>

<file path="lib/gen/api/api.dart">
// Generated API models and clients
export 'models/message_payload.dart';
export 'models/receipt_payload.dart';
export 'clients/messages_api.dart';
export 'clients/receipts_api.dart';
</file>

<file path="lib/gen/api/clients/messages_api.dart">
import 'package:dio/dio.dart';
import '../models/message_payload.dart';

/// API client for message operations
class MessagesApi {
  final Dio dio;
  final String baseUrl;

  MessagesApi({
    required this.dio,
    required this.baseUrl,
  });

  /// Send a message to the backend
  /// 
  /// [message] - The message payload to send
  /// 
  /// Returns the response from the server
  Future<Response> send(MessagePayload message) async {
    try {
      final response = await dio.post(
        '$baseUrl/v1/messages.send',
        data: message.toJson(),
      );
      return response;
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Exception _handleDioError(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.receiveTimeout:
      case DioExceptionType.sendTimeout:
        return Exception('Connection timeout: ${e.message}');
      case DioExceptionType.badResponse:
        return Exception(
          'Server error: ${e.response?.statusCode} - ${e.response?.data}',
        );
      case DioExceptionType.cancel:
        return Exception('Request cancelled');
      default:
        return Exception('Network error: ${e.message}');
    }
  }
}
</file>

<file path="lib/gen/api/clients/receipts_api.dart">
import 'package:dio/dio.dart';
import '../models/receipt_payload.dart';

/// API client for receipt operations
class ReceiptsApi {
  final Dio dio;
  final String baseUrl;

  ReceiptsApi({
    required this.dio,
    required this.baseUrl,
  });

  /// Acknowledge message receipts to the backend
  /// 
  /// [receipt] - The receipt payload to send
  /// 
  /// Returns the response from the server
  Future<Response> ack(ReceiptPayload receipt) async {
    try {
      final response = await dio.post(
        '$baseUrl/v1/receipts.ack',
        data: receipt.toJson(),
      );
      return response;
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Exception _handleDioError(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.receiveTimeout:
      case DioExceptionType.sendTimeout:
        return Exception('Connection timeout: ${e.message}');
      case DioExceptionType.badResponse:
        return Exception(
          'Server error: ${e.response?.statusCode} - ${e.response?.data}',
        );
      case DioExceptionType.cancel:
        return Exception('Request cancelled');
      default:
        return Exception('Network error: ${e.message}');
    }
  }
}
</file>

<file path="lib/gen/api/models/message_payload.dart">
class MessagePayload {
  final String id;
  final String conversationId;
  final String? body;

  MessagePayload({
    required this.id,
    required this.conversationId,
    this.body,
  });

  factory MessagePayload.fromJson(Map<String, dynamic> json) {
    return MessagePayload(
      id: json['id'] as String,
      conversationId: json['conversation_id'] as String,
      body: json['body'] as String?,
    );
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'conversation_id': conversationId,
        if (body != null) 'body': body,
      };

  @override
  String toString() =>
      'MessagePayload(id: $id, conversationId: $conversationId, body: $body)';
}
</file>

<file path="lib/gen/api/models/receipt_payload.dart">
enum ReceiptStatus {
  delivered,
  read;

  static ReceiptStatus fromString(String value) {
    return ReceiptStatus.values.firstWhere(
      (e) => e.name == value,
      orElse: () => throw ArgumentError('Unknown status: $value'),
    );
  }

  String toValue() => name;
}

class ReceiptPayload {
  final List<String> messageIds;
  final ReceiptStatus status;

  ReceiptPayload({
    required this.messageIds,
    required this.status,
  });

  factory ReceiptPayload.fromJson(Map<String, dynamic> json) {
    return ReceiptPayload(
      messageIds: List<String>.from(json['message_ids'] as List),
      status: ReceiptStatus.fromString(json['status'] as String),
    );
  }

  Map<String, dynamic> toJson() => {
        'message_ids': messageIds,
        'status': status.toValue(),
      };

  @override
  String toString() =>
      'ReceiptPayload(messageIds: $messageIds, status: ${status.name})';
}
</file>

<file path="lib/main.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:messageai/core/env.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/state/notification_providers.dart';
import 'package:messageai/services/network_connectivity_service.dart';
import 'package:messageai/services/offline_queue_service.dart';
import 'package:messageai/app.dart';
import 'firebase_options.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

/// Background message handler for Firebase Cloud Messaging
/// This MUST be a top-level function (not inside a class)
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // Initialize Firebase if not already done
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  
  print('🔔 Background message received!');
  print('   Title: ${message.notification?.title}');
  print('   Body: ${message.notification?.body}');
  print('   Data: ${message.data}');
  
  // Handle the background message here if needed
  // For now, just log it - the system notification will still appear
}

void main() async {
  // Ensure Flutter bindings are initialized
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase (required before any Firebase services)
  try {
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    print('✅ Firebase initialized successfully');
    
    // Register background message handler (must be done after Firebase init)
    FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
    print('✅ Background message handler registered');
  } catch (e) {
    print('❌ Firebase initialization error: $e');
    print('Push notifications will not work. Run "flutterfire configure" to set up Firebase.');
  }

  // Validate environment configuration
  Env.validate();

  // Initialize Supabase client
  await SupabaseClientProvider.initialize();

  // Initialize Drift database
  final db = AppDb.instance;
  
  // Initialize network services
  final connectivityService = NetworkConnectivityService();
  connectivityService.startMonitoring();
  
  final offlineQueueService = OfflineQueueService();
  offlineQueueService.startMonitoring();
  
  print('✅ Network services initialized');
  
  // Run the app with Riverpod provider scope
  runApp(
    ProviderScope(
      child: _AppWithNotifications(),
    ),
  );
}

/// Wrapper widget to initialize notifications after ProviderScope
class _AppWithNotifications extends ConsumerWidget {
  const _AppWithNotifications();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Initialize notifications on app start
    final notificationInit = ref.watch(notificationInitializerProvider);
    
    notificationInit.when(
      data: (_) {
        print('🔔 Notifications fully initialized!');
      },
      loading: () {
        print('🔄 Initializing notifications...');
      },
      error: (error, stack) {
        print('❌ Notification initialization error: $error');
        print('Stack trace: $stack');
      },
    );

    return const MessageAIApp();
  }
}
</file>

<file path="lib/models/action_item.dart">
/// Model for action item details
class ActionItem {
  final String id;
  final String followUpItemId;
  final String actionType;
  final String? actionTarget;
  final String commitmentText;
  final String? mentionedDeadline;
  final int? extractedDeadline;

  ActionItem({
    required this.id,
    required this.followUpItemId,
    required this.actionType,
    this.actionTarget,
    required this.commitmentText,
    this.mentionedDeadline,
    this.extractedDeadline,
  });

  factory ActionItem.fromJson(Map<String, dynamic> json) {
    return ActionItem(
      id: json['id'] as String,
      followUpItemId: json['follow_up_item_id'] as String,
      actionType: json['action_type'] as String,
      actionTarget: json['action_target'] as String?,
      commitmentText: json['commitment_text'] as String,
      mentionedDeadline: json['mentioned_deadline'] as String?,
      extractedDeadline: json['extracted_deadline'] as int?,
    );
  }

  String getActionEmoji() {
    switch (actionType.toLowerCase()) {
      case 'send':
        return '📤';
      case 'call':
        return '📞';
      case 'meet':
        return '🤝';
      case 'review':
        return '📋';
      case 'decide':
        return '🤔';
      case 'follow_up':
        return '🔄';
      case 'check':
        return '✅';
      case 'schedule':
        return '📅';
      default:
        return '📌';
    }
  }
}
</file>

<file path="lib/models/ai_analysis.dart">
/// Simple AI Analysis model - no Drift dependency
/// Fetched directly from Supabase with in-memory session caching
class AIAnalysis {
  final String id;
  final String messageId;
  final String tone;
  final String? urgencyLevel;
  final String? intent;
  final double? confidenceScore;
  final int analysisTimestamp;
  
  // ✅ NEW ENHANCED FIELDS
  final int? intensity;
  final List<String>? secondaryTones;
  final Map<String, dynamic>? contextFlags;
  final Map<String, dynamic>? anxietyAssessment;
  
  // ✅ PHASE 1: Smart Message Interpreter fields
  final List<RSDTrigger>? rsdTriggers;
  final List<MessageInterpretation>? alternativeInterpretations;
  final List<Evidence>? evidence;
  
  const AIAnalysis({
    required this.id,
    required this.messageId,
    required this.tone,
    this.urgencyLevel,
    this.intent,
    this.confidenceScore,
    required this.analysisTimestamp,
    // ✅ NEW
    this.intensity,
    this.secondaryTones,
    this.contextFlags,
    this.anxietyAssessment,
    // ✅ PHASE 1
    this.rsdTriggers,
    this.alternativeInterpretations,
    this.evidence,
  });
  
  /// Create from Supabase JSON response
  factory AIAnalysis.fromJson(Map<String, dynamic> json) {
    try {
      // Handle both direct table columns and RPC function results
      final id = json['id'] as String? ?? json['analysis_id'] as String?;
      final messageId = json['message_id'] as String?;
      final tone = json['tone'] as String?;
      
      if (id == null || messageId == null || tone == null) {
        throw FormatException(
          'Missing required fields in AI analysis JSON: '
          'id=$id, message_id=$messageId, tone=$tone. '
          'Full JSON: $json'
        );
      }
      
      // Helper function to safely parse numbers
      num? parseNum(dynamic value) {
        if (value == null) return null;
        if (value is num) return value;
        if (value is String) return num.tryParse(value);
        return null;
      }
      
      return AIAnalysis(
        id: id,
        messageId: messageId,
        tone: tone,
        urgencyLevel: json['urgency_level'] as String?,
        intent: json['intent'] as String?,
        confidenceScore: parseNum(json['confidence_score'])?.toDouble(),
        analysisTimestamp: parseNum(json['analysis_timestamp'])?.toInt() ?? 
                           DateTime.now().millisecondsSinceEpoch ~/ 1000,
        // ✅ Parse new fields
        intensity: parseNum(json['intensity'])?.toInt(),
        secondaryTones: (json['secondary_tones'] as List<dynamic>?)
            ?.map((e) => e as String)
            .toList(),
        contextFlags: json['context_flags'] as Map<String, dynamic>?,
        anxietyAssessment: json['anxiety_assessment'] as Map<String, dynamic>?,
        // ✅ PHASE 1: Parse RSD, interpretations, evidence (with error handling)
        rsdTriggers: (json['rsd_triggers'] as List<dynamic>?)
            ?.map((e) {
              try {
                return RSDTrigger.fromJson(e as Map<String, dynamic>);
              } catch (err) {
                print('⚠️ Failed to parse RSD trigger: $err');
                return null;
              }
            })
            .whereType<RSDTrigger>()
            .toList(),
        alternativeInterpretations: (json['alternative_interpretations'] as List<dynamic>?)
            ?.map((e) {
              try {
                return MessageInterpretation.fromJson(e as Map<String, dynamic>);
              } catch (err) {
                print('⚠️ Failed to parse interpretation: $err');
                return null;
              }
            })
            .whereType<MessageInterpretation>()
            .toList(),
        evidence: (json['evidence'] as List<dynamic>?)
            ?.map((e) {
              try {
                return Evidence.fromJson(e);
              } catch (err) {
                print('⚠️ Failed to parse evidence: $err');
                return null;
              }
            })
            .whereType<Evidence>()
            .toList(),
      );
    } catch (e) {
      throw FormatException('Failed to parse AIAnalysis from JSON: $e\nJSON: $json');
    }
  }
  
  /// Convert to JSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'message_id': messageId,
      'tone': tone,
      'urgency_level': urgencyLevel,
      'intent': intent,
      'confidence_score': confidenceScore,
      'analysis_timestamp': analysisTimestamp,
      // ✅ Include new fields
      if (intensity != null) 'intensity': intensity,
      if (secondaryTones != null) 'secondary_tones': secondaryTones,
      if (contextFlags != null) 'context_flags': contextFlags,
      if (anxietyAssessment != null) 'anxiety_assessment': anxietyAssessment,
      // ✅ PHASE 1 fields
      if (rsdTriggers != null) 'rsd_triggers': rsdTriggers!.map((e) => e.toJson()).toList(),
      if (alternativeInterpretations != null) 'alternative_interpretations': 
          alternativeInterpretations!.map((e) => e.toJson()).toList(),
      if (evidence != null) 'evidence': evidence!.map((e) => e.toJson()).toList(),
    };
  }
  
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AIAnalysis &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          messageId == other.messageId;
  
  @override
  int get hashCode => id.hashCode ^ messageId.hashCode;
  
  @override
  String toString() {
    return 'AIAnalysis(id: $id, messageId: $messageId, tone: $tone, '
           'urgency: $urgencyLevel, intensity: $intensity, intent: $intent, confidence: $confidenceScore)';
  }
}

// ============================================================================
// PHASE 1: Smart Message Interpreter - Helper Classes
// ============================================================================

/// RSD Trigger model
class RSDTrigger {
  final String pattern;
  final String severity; // high, medium, low
  final String explanation;
  final String reassurance;

  const RSDTrigger({
    required this.pattern,
    required this.severity,
    required this.explanation,
    required this.reassurance,
  });

  factory RSDTrigger.fromJson(Map<String, dynamic> json) {
    return RSDTrigger(
      pattern: (json['pattern'] ?? json['trigger']) as String,
      severity: json['severity'] as String,
      explanation: json['explanation'] as String,
      reassurance: (json['reassurance'] ?? 'This is a common concern and doesn\'t reflect your worth.') as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'pattern': pattern,
      'severity': severity,
      'explanation': explanation,
      'reassurance': reassurance,
    };
  }

  bool get isHighSeverity => severity == 'high';
  bool get isMediumSeverity => severity == 'medium';
  bool get isLowSeverity => severity == 'low';
}

/// Alternative Interpretation model
class MessageInterpretation {
  final String interpretation;
  final String tone;
  final int likelihood; // 0-100
  final String reasoning;
  final List<String> contextClues;

  const MessageInterpretation({
    required this.interpretation,
    required this.tone,
    required this.likelihood,
    required this.reasoning,
    required this.contextClues,
  });

  factory MessageInterpretation.fromJson(Map<String, dynamic> json) {
    // Handle both 'likelihood' as string or int
    int parsedLikelihood;
    final likelihoodValue = json['likelihood'];
    if (likelihoodValue is int) {
      parsedLikelihood = likelihoodValue;
    } else if (likelihoodValue is String) {
      // Map text likelihood to percentage
      switch (likelihoodValue.toLowerCase()) {
        case 'high':
          parsedLikelihood = 80;
          break;
        case 'medium':
          parsedLikelihood = 50;
          break;
        case 'low':
          parsedLikelihood = 20;
          break;
        default:
          parsedLikelihood = 50;
      }
    } else {
      parsedLikelihood = 50;
    }
    
    return MessageInterpretation(
      interpretation: json['interpretation'] as String,
      tone: (json['tone'] ?? 'neutral') as String,
      likelihood: parsedLikelihood,
      reasoning: (json['reasoning'] ?? json['explanation'] ?? '') as String,
      contextClues: (json['context_clues'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ?? [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'interpretation': interpretation,
      'tone': tone,
      'likelihood': likelihood,
      'reasoning': reasoning,
      'context_clues': contextClues,
    };
  }

  bool get isLikely => likelihood >= 60;
  bool get isPossible => likelihood >= 30 && likelihood < 60;
  bool get isUnlikely => likelihood < 30;
}

/// Evidence model
class Evidence {
  final String type; // keyword, punctuation, emoji, etc.
  final String quote;
  final String supports;
  final String reasoning;

  const Evidence({
    required this.type,
    required this.quote,
    required this.supports,
    required this.reasoning,
  });

  factory Evidence.fromJson(dynamic json) {
    // Handle evidence as either object or simple string
    if (json is String) {
      return Evidence(
        type: 'keyword',
        quote: json,
        supports: 'tone',
        reasoning: 'Key phrase in message',
      );
    }
    
    final jsonMap = json as Map<String, dynamic>;
    return Evidence(
      type: (jsonMap['type'] ?? 'keyword') as String,
      quote: (jsonMap['quote'] ?? jsonMap.toString()) as String,
      supports: (jsonMap['supports'] ?? 'tone') as String,
      reasoning: (jsonMap['reasoning'] ?? '') as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'type': type,
      'quote': quote,
      'supports': supports,
      'reasoning': reasoning,
    };
  }

  bool get isKeywordEvidence => type == 'keyword';
  bool get isPunctuationEvidence => type == 'punctuation';
  bool get isEmojiEvidence => type == 'emoji';
}
</file>

<file path="lib/models/context_trigger.dart">
/// Model for context triggers
class ContextTrigger {
  final String id;
  final String userId;
  final String followUpItemId;
  final String triggerType;
  final Map<String, dynamic> triggerConfig;
  final bool isActive;
  final int? lastTriggered;
  final int triggerCount;
  final int createdAt;
  final int updatedAt;

  ContextTrigger({
    required this.id,
    required this.userId,
    required this.followUpItemId,
    required this.triggerType,
    required this.triggerConfig,
    required this.isActive,
    this.lastTriggered,
    required this.triggerCount,
    required this.createdAt,
    required this.updatedAt,
  });

  factory ContextTrigger.fromJson(Map<String, dynamic> json) {
    return ContextTrigger(
      id: json['id'] as String,
      userId: json['user_id'] as String,
      followUpItemId: json['follow_up_item_id'] as String,
      triggerType: json['trigger_type'] as String,
      triggerConfig: json['trigger_config'] as Map<String, dynamic>,
      isActive: json['is_active'] as bool? ?? true,
      lastTriggered: json['last_triggered'] as int?,
      triggerCount: json['trigger_count'] as int? ?? 0,
      createdAt: json['created_at'] as int,
      updatedAt: json['updated_at'] as int,
    );
  }

  String getTriggerLabel() {
    switch (triggerType) {
      case 'app_opened':
        final app = triggerConfig['app'] as String?;
        return 'When you open ${app ?? "the app"}';
      case 'calendar_event':
        final event = triggerConfig['event'] as String?;
        return 'Before ${event ?? "calendar event"}';
      case 'location':
        final location = triggerConfig['location'] as String?;
        return 'At ${location ?? "this location"}';
      case 'time_of_day':
        final time = triggerConfig['time'] as String?;
        return 'At $time';
      case 'day_of_week':
        final day = triggerConfig['day'] as String?;
        return 'Every $day';
      default:
        return 'Context trigger';
    }
  }

  String getTriggerEmoji() {
    switch (triggerType) {
      case 'app_opened':
        return '📱';
      case 'calendar_event':
        return '📅';
      case 'location':
        return '📍';
      case 'time_of_day':
        return '⏰';
      case 'day_of_week':
        return '📆';
      default:
        return '🔔';
    }
  }
}
</file>

<file path="lib/models/conversation_context.dart">
/// Model for conversation context
class ConversationContext {
  final String conversationId;
  final String lastDiscussed;
  final List<KeyPoint> keyPoints;
  final List<String> pendingQuestions;
  final bool fromCache;
  final int? cacheAge;

  ConversationContext({
    required this.conversationId,
    required this.lastDiscussed,
    required this.keyPoints,
    required this.pendingQuestions,
    this.fromCache = false,
    this.cacheAge,
  });

  factory ConversationContext.fromJson(Map<String, dynamic> json) {
    return ConversationContext(
      conversationId: json['conversation_id'] as String? ?? '',
      lastDiscussed: json['last_discussed'] as String,
      keyPoints: (json['key_points'] as List<dynamic>)
          .map((e) => KeyPoint.fromJson(e as Map<String, dynamic>))
          .toList(),
      pendingQuestions: (json['pending_questions'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ??
          [],
      fromCache: json['from_cache'] as bool? ?? false,
      cacheAge: json['cache_age'] as int?,
    );
  }
}

/// Key point from conversation
class KeyPoint {
  final String text;
  final int timestamp;

  KeyPoint({
    required this.text,
    required this.timestamp,
  });

  factory KeyPoint.fromJson(Map<String, dynamic> json) {
    return KeyPoint(
      text: json['text'] as String,
      timestamp: json['timestamp'] as int,
    );
  }

  String getTimeAgo() {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final diff = now - timestamp;

    if (diff < 60) return 'just now';
    if (diff < 3600) return '${diff ~/ 60}m ago';
    if (diff < 86400) return '${diff ~/ 3600}h ago';
    if (diff < 604800) return '${diff ~/ 86400}d ago';
    return '${diff ~/ 604800}w ago';
  }
}
</file>

<file path="lib/models/draft_analysis.dart">
import 'package:flutter/material.dart';
import 'package:messageai/models/situation_type.dart';
import 'package:messageai/models/response_template.dart';

/// Model for draft message analysis results
/// Extends tone analysis with confidence scoring and suggestions
class DraftAnalysis {
  // Tone analysis fields
  final String tone;
  final String? intensity;
  final String? urgencyLevel;
  final String? intent;
  final Map<String, dynamic>? contextFlags;
  final String? reasoning;
  
  // Draft-specific fields
  final int confidenceScore; // 0-100
  final AppropriatenessLevel appropriateness;
  final List<String> suggestions;
  final List<String> warnings;
  final List<String> strengths;
  
  // ✅ NEW: Phase 2 fields
  final SituationDetection? situationDetection;
  final List<ResponseTemplate>? suggestedTemplates;

  const DraftAnalysis({
    required this.tone,
    this.intensity,
    this.urgencyLevel,
    this.intent,
    this.contextFlags,
    this.reasoning,
    required this.confidenceScore,
    required this.appropriateness,
    required this.suggestions,
    required this.warnings,
    required this.strengths,
    // NEW
    this.situationDetection,
    this.suggestedTemplates,
  });

  factory DraftAnalysis.fromJson(Map<String, dynamic> json) {
    return DraftAnalysis(
      // Tone fields
      tone: json['tone'] as String,
      intensity: json['intensity'] as String?,
      urgencyLevel: json['urgency_level'] as String?,
      intent: json['intent'] as String?,
      contextFlags: json['context_flags'] as Map<String, dynamic>?,
      reasoning: json['reasoning'] as String?,
      
      // Draft fields
      confidenceScore: json['confidence_score'] as int,
      appropriateness: AppropriatenessLevel.fromString(
        json['appropriateness'] as String,
      ),
      suggestions: (json['suggestions'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ?? [],
      warnings: (json['warnings'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ?? [],
      strengths: (json['strengths'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ?? [],
      
      // NEW: Phase 2 fields
      situationDetection: json['situation_detection'] != null
          ? SituationDetection.fromJson(json['situation_detection'] as Map<String, dynamic>)
          : null,
      suggestedTemplates: (json['suggested_templates'] as List<dynamic>?)
          ?.map((e) => ResponseTemplate.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  /// Get color based on confidence score
  Color getConfidenceColor() {
    if (confidenceScore >= 90) return Colors.green;
    if (confidenceScore >= 75) return Colors.lightGreen;
    if (confidenceScore >= 60) return Colors.orange;
    return Colors.red;
  }

  /// Get icon based on appropriateness
  IconData getAppropriatenessIcon() {
    switch (appropriateness) {
      case AppropriatenessLevel.excellent:
        return Icons.check_circle;
      case AppropriatenessLevel.good:
        return Icons.thumb_up;
      case AppropriatenessLevel.okay:
        return Icons.info;
      case AppropriatenessLevel.needsWork:
        return Icons.warning;
    }
  }

  /// Get brief status message
  String getStatusMessage() {
    if (confidenceScore >= 90) return 'Ready to send!';
    if (confidenceScore >= 75) return 'Looking good';
    if (confidenceScore >= 60) return 'Could be improved';
    return 'Needs revision';
  }
}

enum AppropriatenessLevel {
  excellent('excellent'),
  good('good'),
  okay('okay'),
  needsWork('needs_work');

  final String value;
  const AppropriatenessLevel(this.value);

  static AppropriatenessLevel fromString(String value) {
    return AppropriatenessLevel.values.firstWhere(
      (e) => e.value == value,
      orElse: () => AppropriatenessLevel.okay,
    );
  }

  String get displayName {
    switch (this) {
      case AppropriatenessLevel.excellent:
        return 'Excellent';
      case AppropriatenessLevel.good:
        return 'Good';
      case AppropriatenessLevel.okay:
        return 'Okay';
      case AppropriatenessLevel.needsWork:
        return 'Needs Work';
    }
  }
}

enum RelationshipType {
  boss('boss', 'Boss/Manager'),
  colleague('colleague', 'Colleague'),
  friend('friend', 'Friend'),
  family('family', 'Family'),
  client('client', 'Client'),
  none('none', 'Not specified');

  final String value;
  final String displayName;
  const RelationshipType(this.value, this.displayName);

  static RelationshipType fromString(String? value) {
    if (value == null) return RelationshipType.none;
    return RelationshipType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => RelationshipType.none,
    );
  }

  IconData get icon {
    switch (this) {
      case RelationshipType.boss:
        return Icons.business;
      case RelationshipType.colleague:
        return Icons.people;
      case RelationshipType.friend:
        return Icons.emoji_people;
      case RelationshipType.family:
        return Icons.family_restroom;
      case RelationshipType.client:
        return Icons.handshake;
      case RelationshipType.none:
        return Icons.help_outline;
    }
  }
}
</file>

<file path="lib/models/draft_confidence.dart">
/// Result of draft confidence analysis (Phase 2: Response Assistant)
class DraftConfidence {
  final String draft;
  final int overallScore;
  final Map<String, int> scores;
  final List<String> strengths;
  final List<String> weaknesses;
  final List<String> suggestions;
  final bool readyToSend;

  DraftConfidence({
    required this.draft,
    required this.overallScore,
    required this.scores,
    required this.strengths,
    required this.weaknesses,
    required this.suggestions,
    required this.readyToSend,
  });

  factory DraftConfidence.fromJson(Map<String, dynamic> json) {
    return DraftConfidence(
      draft: json['draft'] as String? ?? '',
      overallScore: json['overall_score'] as int? ?? 0,
      scores: (json['scores'] as Map<String, dynamic>?)?.map(
            (key, value) => MapEntry(key, value as int),
          ) ??
          {},
      strengths: (json['strengths'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          [],
      weaknesses: (json['weaknesses'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          [],
      suggestions: (json['suggestions'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          [],
      readyToSend: json['ready_to_send'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'draft': draft,
      'overall_score': overallScore,
      'scores': scores,
      'strengths': strengths,
      'weaknesses': weaknesses,
      'suggestions': suggestions,
      'ready_to_send': readyToSend,
    };
  }

  /// Get confidence level as a string
  String get confidenceLevel {
    if (overallScore >= 80) return 'High';
    if (overallScore >= 60) return 'Medium';
    return 'Low';
  }

  /// Get color for confidence level
  String get confidenceColor {
    if (overallScore >= 80) return 'green';
    if (overallScore >= 60) return 'orange';
    return 'red';
  }

  bool get hasStrengths => strengths.isNotEmpty;
  bool get hasWeaknesses => weaknesses.isNotEmpty;
  bool get hasSuggestions => suggestions.isNotEmpty;

  @override
  String toString() {
    return 'DraftConfidence(score: $overallScore%, level: $confidenceLevel, ready: $readyToSend)';
  }
}
</file>

<file path="lib/models/follow_up_item.dart">
import 'package:flutter/material.dart';

/// Follow-up item types
enum FollowUpItemType {
  actionItem('action_item', 'Action Item', Icons.task_alt),
  unansweredQuestion('unanswered_question', 'Unanswered Question', Icons.help_outline),
  pendingResponse('pending_response', 'Pending Response', Icons.pending),
  scheduledFollowup('scheduled_followup', 'Scheduled', Icons.schedule);

  final String value;
  final String displayName;
  final IconData icon;

  const FollowUpItemType(this.value, this.displayName, this.icon);

  static FollowUpItemType fromString(String value) {
    return FollowUpItemType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => FollowUpItemType.pendingResponse,
    );
  }

  Color getColor() {
    switch (this) {
      case FollowUpItemType.actionItem:
        return Colors.orange;
      case FollowUpItemType.unansweredQuestion:
        return Colors.blue;
      case FollowUpItemType.pendingResponse:
        return Colors.purple;
      case FollowUpItemType.scheduledFollowup:
        return Colors.green;
    }
  }
}

/// Follow-up item status
enum FollowUpStatus {
  pending('pending'),
  completed('completed'),
  dismissed('dismissed'),
  snoozed('snoozed');

  final String value;
  const FollowUpStatus(this.value);

  static FollowUpStatus fromString(String value) {
    return FollowUpStatus.values.firstWhere(
      (e) => e.value == value,
      orElse: () => FollowUpStatus.pending,
    );
  }
}

/// Model for follow-up item
class FollowUpItem {
  final String id;
  final String userId;
  final String conversationId;
  final String? messageId;
  final FollowUpItemType itemType;
  final String title;
  final String? description;
  final String? extractedText;
  final FollowUpStatus status;
  final int priority;
  final int detectedAt;
  final int? dueAt;
  final int? remindAt;
  final int? snoozedUntil;
  final int? completedAt;
  final Map<String, dynamic>? triggers;

  FollowUpItem({
    required this.id,
    required this.userId,
    required this.conversationId,
    this.messageId,
    required this.itemType,
    required this.title,
    this.description,
    this.extractedText,
    required this.status,
    required this.priority,
    required this.detectedAt,
    this.dueAt,
    this.remindAt,
    this.snoozedUntil,
    this.completedAt,
    this.triggers,
  });

  factory FollowUpItem.fromJson(Map<String, dynamic> json) {
    return FollowUpItem(
      id: json['item_id'] as String? ?? json['id'] as String,
      userId: json['user_id'] as String,
      conversationId: json['conversation_id'] as String,
      messageId: json['message_id'] as String?,
      itemType: FollowUpItemType.fromString(json['item_type'] as String),
      title: json['title'] as String,
      description: json['description'] as String?,
      extractedText: json['extracted_text'] as String?,
      status: FollowUpStatus.fromString(json['status'] as String? ?? 'pending'),
      priority: json['priority'] as int,
      detectedAt: json['detected_at'] as int,
      dueAt: json['due_at'] as int?,
      remindAt: json['remind_at'] as int?,
      snoozedUntil: json['snoozed_until'] as int?,
      completedAt: json['completed_at'] as int?,
      triggers: json['triggers'] as Map<String, dynamic>?,
    );
  }

  bool get isOverdue {
    if (dueAt == null) return false;
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    return now > dueAt!;
  }

  bool get isDueSoon {
    if (dueAt == null) return false;
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final hoursUntilDue = (dueAt! - now) / 3600;
    return hoursUntilDue > 0 && hoursUntilDue <= 24;
  }

  String getTimeUntilDue() {
    if (dueAt == null) return '';
    
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final diff = dueAt! - now;
    
    if (diff < 0) return 'Overdue';
    if (diff < 3600) return '${diff ~/ 60}m';
    if (diff < 86400) return '${diff ~/ 3600}h';
    return '${diff ~/ 86400}d';
  }

  String getTimeSinceDetected() {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final diff = now - detectedAt;
    
    if (diff < 3600) return '${diff ~/ 60}m ago';
    if (diff < 86400) return '${diff ~/ 3600}h ago';
    return '${diff ~/ 86400}d ago';
  }
}
</file>

<file path="lib/models/formatted_message.dart">
/// Result of message formatting
class FormattedMessage {
  final int originalLength;
  final String formattedMessage;
  final List<String> formattingApplied;
  final int characterCount;
  final String estimatedReadTime;
  final String? tone;
  final List<String>? actionItems;

  FormattedMessage({
    required this.originalLength,
    required this.formattedMessage,
    required this.formattingApplied,
    required this.characterCount,
    required this.estimatedReadTime,
    this.tone,
    this.actionItems,
  });

  factory FormattedMessage.fromJson(Map<String, dynamic> json) {
    return FormattedMessage(
      originalLength: json['original_length'] as int,
      formattedMessage: json['formatted_message'] as String,
      formattingApplied: (json['formatting_applied'] as List<dynamic>)
          .map((e) => e as String)
          .toList(),
      characterCount: json['character_count'] as int,
      estimatedReadTime: json['estimated_read_time'] as String,
      tone: json['tone'] as String?,
      actionItems: json['action_items'] != null
          ? (json['action_items'] as List<dynamic>)
              .map((e) => e as String)
              .toList()
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'original_length': originalLength,
      'formatted_message': formattedMessage,
      'formatting_applied': formattingApplied,
      'character_count': characterCount,
      'estimated_read_time': estimatedReadTime,
      if (tone != null) 'tone': tone,
      if (actionItems != null) 'action_items': actionItems,
    };
  }

  double getSavingsPercentage() {
    if (originalLength == 0) return 0;
    return ((originalLength - characterCount) / originalLength) * 100;
  }

  @override
  String toString() {
    return 'FormattedMessage(original: $originalLength chars, formatted: $characterCount chars, saved: ${getSavingsPercentage().toStringAsFixed(0)}%)';
  }
}
</file>

<file path="lib/models/relationship_profile.dart">
/// Model for relationship profile
class RelationshipProfile {
  final String id;
  final String userId;
  final String conversationId;
  final String participantName;
  final String? participantUserId;
  final String? relationshipType;
  final String? relationshipNotes;
  final String? conversationSummary;
  final List<String> safeTopics;
  final List<String> topicsToAvoid;
  final String? communicationStyle;
  final int? typicalResponseTime;
  final int totalMessages;
  final int? firstMessageAt;
  final int? lastMessageAt;

  RelationshipProfile({
    required this.id,
    required this.userId,
    required this.conversationId,
    required this.participantName,
    this.participantUserId,
    this.relationshipType,
    this.relationshipNotes,
    this.conversationSummary,
    this.safeTopics = const [],
    this.topicsToAvoid = const [],
    this.communicationStyle,
    this.typicalResponseTime,
    this.totalMessages = 0,
    this.firstMessageAt,
    this.lastMessageAt,
  });

  factory RelationshipProfile.fromJson(Map<String, dynamic> json) {
    return RelationshipProfile(
      id: json['profile_id'] as String? ?? json['id'] as String,
      userId: json['user_id'] as String,
      conversationId: json['conversation_id'] as String,
      participantName: json['participant_name'] as String,
      participantUserId: json['participant_user_id'] as String?,
      relationshipType: json['relationship_type'] as String?,
      relationshipNotes: json['relationship_notes'] as String?,
      conversationSummary: json['conversation_summary'] as String?,
      safeTopics: (json['safe_topics'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ??
          [],
      topicsToAvoid: (json['topics_to_avoid'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ??
          [],
      communicationStyle: json['communication_style'] as String?,
      typicalResponseTime: json['typical_response_time'] as int?,
      totalMessages: json['total_messages'] as int? ?? 0,
      firstMessageAt: json['first_message_at'] as int?,
      lastMessageAt: json['last_message_at'] as int?,
    );
  }

  String getRelationshipEmoji() {
    switch (relationshipType?.toLowerCase()) {
      case 'boss':
        return '👔';
      case 'colleague':
        return '🤝';
      case 'friend':
        return '😊';
      case 'family':
        return '👨‍👩‍👧‍👦';
      case 'client':
        return '💼';
      default:
        return '👤';
    }
  }

  String formatResponseTime() {
    if (typicalResponseTime == null) return 'Unknown';

    final minutes = typicalResponseTime! ~/ 60;
    if (minutes < 60) return '$minutes min';

    final hours = minutes ~/ 60;
    if (hours < 24) return '$hours hr';

    final days = hours ~/ 24;
    return '$days days';
  }
}
</file>

<file path="lib/models/response_template.dart">
/// Model for response templates
class ResponseTemplate {
  final String id;
  final String name;
  final String situation;
  final String template;
  final String tone; // polite, casual, direct, apologetic
  final List<String> context;
  final bool neurodivergentFriendly;
  final List<String>? customizableFields;

  ResponseTemplate({
    required this.id,
    required this.name,
    required this.situation,
    required this.template,
    required this.tone,
    required this.context,
    required this.neurodivergentFriendly,
    this.customizableFields,
  });

  factory ResponseTemplate.fromJson(Map<String, dynamic> json) {
    return ResponseTemplate(
      id: json['id'] as String,
      name: json['name'] as String,
      situation: json['situation'] as String,
      template: json['template'] as String,
      tone: json['tone'] as String,
      context: (json['context'] as List<dynamic>).map((e) => e as String).toList(),
      neurodivergentFriendly: json['neurodivergent_friendly'] as bool,
      customizableFields: (json['customizable_fields'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'situation': situation,
      'template': template,
      'tone': tone,
      'context': context,
      'neurodivergent_friendly': neurodivergentFriendly,
      if (customizableFields != null) 'customizable_fields': customizableFields,
    };
  }

  /// Fill in customizable fields in the template
  String fillTemplate(Map<String, String> values) {
    String result = template;
    if (customizableFields != null) {
      for (final field in customizableFields!) {
        final value = values[field] ?? '{$field}';
        result = result.replaceAll('{$field}', value);
      }
    }
    return result;
  }

  /// Check if template has unfilled fields
  bool hasUnfilledFields(String text) {
    return text.contains(RegExp(r'\{[^}]+\}'));
  }

  @override
  String toString() {
    return 'ResponseTemplate(id: $id, name: $name, tone: $tone)';
  }
}
</file>

<file path="lib/models/safe_topic.dart">
import 'package:flutter/material.dart';

/// Model for safe topics
class SafeTopic {
  final String id;
  final String topicName;
  final List<String> keywords;
  final int messageCount;
  final int? avgResponseTime;
  final double? positiveToneRate;
  final bool isSafe;
  final int? lastDiscussed;

  SafeTopic({
    required this.id,
    required this.topicName,
    required this.keywords,
    required this.messageCount,
    this.avgResponseTime,
    this.positiveToneRate,
    this.isSafe = true,
    this.lastDiscussed,
  });

  factory SafeTopic.fromJson(Map<String, dynamic> json) {
    return SafeTopic(
      id: json['id'] as String,
      topicName: json['topic_name'] as String,
      keywords: (json['topic_keywords'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ??
          [],
      messageCount: json['message_count'] as int,
      avgResponseTime: json['avg_response_time'] as int?,
      positiveToneRate: (json['positive_tone_rate'] as num?)?.toDouble(),
      isSafe: json['is_safe'] as bool? ?? true,
      lastDiscussed: json['last_discussed'] as int?,
    );
  }

  Color getTopicColor() {
    if (positiveToneRate == null) return Colors.grey;
    if (positiveToneRate! >= 0.8) return Colors.green;
    if (positiveToneRate! >= 0.6) return Colors.blue;
    return Colors.orange;
  }

  String getEngagementLabel() {
    if (positiveToneRate == null) return 'Unknown';
    if (positiveToneRate! >= 0.8) return 'Great topic!';
    if (positiveToneRate! >= 0.6) return 'Good topic';
    return 'Neutral';
  }
}
</file>

<file path="lib/models/situation_type.dart">
import 'package:flutter/material.dart';

/// Types of situations for response templates
enum SituationType {
  declining('declining', 'Saying No', Icons.cancel),
  boundarySetting('boundary_setting', 'Setting Boundary', Icons.shield),
  infoDumping('info_dumping', 'Sharing Info', Icons.lightbulb),
  apologizing('apologizing', 'Apologizing', Icons.handshake),
  clarifying('clarifying', 'Clarifying', Icons.help_outline),
  casualChat('casual_chat', 'Casual Chat', Icons.chat),
  workProfessional('work_professional', 'Professional', Icons.work),
  emotionalSupport('emotional_support', 'Support', Icons.favorite),
  unknown('unknown', 'Unknown', Icons.question_mark);

  final String value;
  final String displayName;
  final IconData icon;

  const SituationType(this.value, this.displayName, this.icon);

  static SituationType fromString(String value) {
    return SituationType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => SituationType.unknown,
    );
  }

  Color getColor() {
    switch (this) {
      case SituationType.declining:
        return Colors.red;
      case SituationType.boundarySetting:
        return Colors.orange;
      case SituationType.infoDumping:
        return Colors.purple;
      case SituationType.apologizing:
        return Colors.blue;
      case SituationType.clarifying:
        return Colors.teal;
      case SituationType.casualChat:
        return Colors.green;
      case SituationType.workProfessional:
        return Colors.indigo;
      case SituationType.emotionalSupport:
        return Colors.pink;
      case SituationType.unknown:
        return Colors.grey;
    }
  }
}

/// Situation detection result
class SituationDetection {
  final SituationType situationType;
  final double confidence;
  final String reasoning;
  final List<String> suggestedTemplateIds;

  SituationDetection({
    required this.situationType,
    required this.confidence,
    required this.reasoning,
    required this.suggestedTemplateIds,
  });

  factory SituationDetection.fromJson(Map<String, dynamic> json) {
    return SituationDetection(
      situationType: SituationType.fromString(json['situation_type'] as String),
      confidence: (json['confidence'] as num).toDouble(),
      reasoning: json['reasoning'] as String,
      suggestedTemplateIds: (json['suggested_templates'] as List<dynamic>)
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'situation_type': situationType.value,
      'confidence': confidence,
      'reasoning': reasoning,
      'suggested_templates': suggestedTemplateIds,
    };
  }

  @override
  String toString() {
    return 'SituationDetection(type: ${situationType.displayName}, confidence: ${(confidence * 100).toInt()}%)';
  }
}
</file>

<file path="lib/services/ai_analysis_service.dart">
import 'dart:async';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Simple AI Analysis Service - Supabase only, no local persistence
/// Uses in-memory cache for current session to reduce API calls
class AIAnalysisService {
  final _supabase = SupabaseClientProvider.client;
  
  /// In-memory cache (cleared on app restart)
  final Map<String, AIAnalysis> _sessionCache = {};
  
  /// Pending requests to avoid duplicate API calls
  final Map<String, Future<AIAnalysis?>> _pendingRequests = {};
  
  /// Request AI analysis for a message
  /// Returns cached result if available, otherwise calls Edge Function
  Future<AIAnalysis?> requestAnalysis(
    String messageId,
    String messageBody, {
    List<String>? conversationContext,
  }) async {
    // Check session cache first
    if (_sessionCache.containsKey(messageId)) {
      print('📊 Using cached analysis for $messageId');
      return _sessionCache[messageId];
    }
    
    // Check if request is already in progress
    if (_pendingRequests.containsKey(messageId)) {
      print('⏳ Analysis already in progress for $messageId');
      return _pendingRequests[messageId];
    }
    
    // Make new request
    print('🤖 Requesting new analysis for $messageId');
    final future = _callAnalysisAPI(messageId, messageBody, conversationContext);
    _pendingRequests[messageId] = future;
    
    try {
      final result = await future;
      if (result != null) {
        _sessionCache[messageId] = result;
      }
      return result;
    } finally {
      _pendingRequests.remove(messageId);
    }
  }
  
  /// Call the Edge Function to analyze a message
  Future<AIAnalysis?> _callAnalysisAPI(
    String messageId,
    String messageBody,
    List<String>? conversationContext,
  ) async {
    try {
      final response = await _supabase.functions.invoke(
        'ai_analyze_tone',
        body: {
          'message_id': messageId,
          'message_body': messageBody,
          if (conversationContext != null)
            'conversation_context': conversationContext,
        },
      );
      
      if (response.status != 200) {
        throw Exception('API returned status ${response.status}');
      }
      
      final data = response.data;
      if (data == null || !data['success']) {
        throw Exception(data?['error'] ?? 'Unknown error');
      }
      
      return AIAnalysis.fromJson(data['analysis']);
    } catch (e) {
      print('❌ Analysis request failed: $e');
      return null;
    }
  }
  
  /// Fetch existing analysis from Supabase
  Future<AIAnalysis?> getAnalysis(String messageId) async {
    // Check cache
    if (_sessionCache.containsKey(messageId)) {
      return _sessionCache[messageId];
    }
    
    try {
      final response = await _supabase.rpc(
        'get_message_ai_analysis',
        params: {'p_message_id': messageId},
      );
      
      if (response == null || (response as List).isEmpty) {
        return null;
      }
      
      final analysis = AIAnalysis.fromJson(response[0]);
      _sessionCache[messageId] = analysis;
      return analysis;
    } catch (e) {
      print('❌ Failed to fetch analysis: $e');
      return null;
    }
  }
  
  /// Fetch all analyses for a conversation
  Future<Map<String, AIAnalysis>> getConversationAnalyses(
    String conversationId,
  ) async {
    try {
      final response = await _supabase.rpc(
        'get_conversation_ai_analysis',
        params: {'p_conversation_id': conversationId},
      );
      
      if (response == null || (response as List).isEmpty) {
        return {};
      }
      
      final Map<String, AIAnalysis> analyses = {};
      for (final item in response) {
        final analysis = AIAnalysis.fromJson(item);
        analyses[analysis.messageId] = analysis;
        _sessionCache[analysis.messageId] = analysis; // Cache it
      }
      
      return analyses;
    } catch (e) {
      print('❌ Failed to fetch conversation analyses: $e');
      return {};
    }
  }
  
  /// Clear the session cache
  void clearCache() {
    _sessionCache.clear();
    print('🧹 Analysis cache cleared');
  }
  
  /// Get cache statistics
  Map<String, dynamic> getCacheStats() {
    return {
      'cached_count': _sessionCache.length,
      'pending_count': _pendingRequests.length,
    };
  }
}
</file>

<file path="lib/services/auth_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/services/device_registration_service.dart';
import 'package:messageai/services/notification_service.dart';
import 'package:messageai/core/errors/error_handler.dart';

class AuthService {
  static final AuthService _instance = AuthService._internal();

  factory AuthService() {
    return _instance;
  }

  AuthService._internal();

  final _supabase = SupabaseClientProvider.client;
  final _deviceRegistrationService = DeviceRegistrationService();
  final _notificationService = NotificationService();
  final _errorHandler = ErrorHandler();

  /// Sign up with email and password
  Future<AuthResponse> signUp({
    required String email,
    required String password,
  }) async {
    try {
      print('📝 Attempting sign up for: $email');
      
      final response = await _supabase.auth.signUp(
        email: email,
        password: password,
      );
      
      print('✅ Sign up successful: ${response.user?.id}');
      return response;
    } catch (error, stackTrace) {
      print('❌ Sign up failed: $error');
      throw _errorHandler.handleError(error, stackTrace: stackTrace, context: 'Sign Up');
    }
  }

  /// Sign in with email and password
  Future<AuthResponse> signIn({
    required String email,
    required String password,
  }) async {
    try {
      print('🔐 Attempting sign in for: $email');
      
      final response = await _supabase.auth.signInWithPassword(
        email: email,
        password: password,
      );
      
      print('✅ Sign in successful: ${response.user?.id}');
      return response;
    } catch (error, stackTrace) {
      print('❌ Sign in failed: $error');
      throw _errorHandler.handleError(error, stackTrace: stackTrace, context: 'Sign In');
    }
  }

  /// Sign out
  Future<void> signOut() async {
    try {
      print('👋 Attempting sign out');
      
      // Unregister device token before signing out
      final token = await _notificationService.getDeviceToken();
      if (token != null) {
        try {
          await _deviceRegistrationService.unregisterDeviceToken(token);
          print('✅ Device token unregistered on sign out');
        } catch (e) {
          print('⚠️  Failed to unregister device token: $e');
          // Continue with sign out even if unregistration fails
        }
      }
      
      await _supabase.auth.signOut();
      print('✅ Sign out successful');
    } catch (error, stackTrace) {
      print('❌ Sign out failed: $error');
      throw _errorHandler.handleError(error, stackTrace: stackTrace, context: 'Sign Out');
    }
  }

  /// Get current user
  User? getCurrentUser() {
    return _supabase.auth.currentUser;
  }

  /// Check if user is authenticated
  bool isAuthenticated() {
    return _supabase.auth.currentUser != null;
  }

  /// Get current session
  Session? getCurrentSession() {
    return _supabase.auth.currentSession;
  }
}
</file>

<file path="lib/services/avatar_service.dart">
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:image_picker/image_picker.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_handler.dart';

/// Service for handling avatar uploads and management
class AvatarService {
  static final AvatarService _instance = AvatarService._internal();

  factory AvatarService() {
    return _instance;
  }

  AvatarService._internal();

  final _supabase = SupabaseClientProvider.client;
  final _errorHandler = ErrorHandler();
  final _imagePicker = ImagePicker();

  /// Pick an image from gallery
  Future<XFile?> pickImage() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 512,
        maxHeight: 512,
        imageQuality: 85,
      );
      return image;
    } catch (error, stackTrace) {
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Pick Image',
      );
    }
  }

  /// Pick an image from camera
  Future<XFile?> pickImageFromCamera() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.camera,
        maxWidth: 512,
        maxHeight: 512,
        imageQuality: 85,
      );
      return image;
    } catch (error, stackTrace) {
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Take Photo',
      );
    }
  }

  /// Upload avatar to Supabase Storage and update profile
  Future<String> uploadAvatar(XFile imageFile) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      print('📤 Uploading avatar for user: ${currentUser.id}');

      // Generate unique filename
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final extension = imageFile.path.split('.').last;
      final fileName = '${currentUser.id}/avatar_$timestamp.$extension';

      // Read file bytes
      final Uint8List fileBytes;
      if (kIsWeb) {
        fileBytes = await imageFile.readAsBytes();
      } else {
        fileBytes = await File(imageFile.path).readAsBytes();
      }

      print('📁 File size: ${fileBytes.length} bytes');
      print('📁 File name: $fileName');

      // Delete old avatar if exists
      await _deleteOldAvatar(currentUser.id);

      // Upload to Supabase Storage
      final uploadPath = await _supabase.storage
          .from('avatars')
          .uploadBinary(fileName, fileBytes);

      print('✅ Avatar uploaded: $uploadPath');

      // Get public URL
      final publicUrl = _supabase.storage
          .from('avatars')
          .getPublicUrl(fileName);

      print('🔗 Public URL: $publicUrl');

      // Update profile with new avatar URL
      await _updateProfileAvatar(currentUser.id, publicUrl);

      return publicUrl;
    } catch (error, stackTrace) {
      print('❌ Error uploading avatar: $error');
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Upload Avatar',
      );
    }
  }

  /// Delete old avatar files for a user
  Future<void> _deleteOldAvatar(String userId) async {
    try {
      // List all files in user's folder
      final files = await _supabase.storage
          .from('avatars')
          .list(path: userId);

      // Delete each file
      for (final file in files) {
        final filePath = '$userId/${file.name}';
        await _supabase.storage
            .from('avatars')
            .remove([filePath]);
        print('🗑️  Deleted old avatar: $filePath');
      }
    } catch (e) {
      print('⚠️  Error deleting old avatar (non-critical): $e');
      // Don't throw - old avatar deletion is non-critical
    }
  }

  /// Update profile table with new avatar URL
  Future<void> _updateProfileAvatar(String userId, String avatarUrl) async {
    try {
      await _supabase
          .from('profiles')
          .update({'avatar_url': avatarUrl, 'updated_at': DateTime.now().toIso8601String()})
          .eq('user_id', userId);

      print('✅ Profile updated with new avatar URL');
    } catch (error, stackTrace) {
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Update Profile Avatar',
      );
    }
  }

  /// Get avatar URL for a user
  Future<String?> getAvatarUrl(String userId) async {
    try {
      final response = await _supabase
          .from('profiles')
          .select('avatar_url')
          .eq('user_id', userId)
          .maybeSingle();

      if (response != null && response['avatar_url'] != null) {
        return response['avatar_url'] as String;
      }
      return null;
    } catch (error, stackTrace) {
      print('⚠️  Error fetching avatar URL: $error');
      // Return null instead of throwing - missing avatar is not critical
      return null;
    }
  }

  /// Delete avatar for current user
  Future<void> deleteAvatar() async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      print('🗑️  Deleting avatar for user: ${currentUser.id}');

      // Delete from storage
      await _deleteOldAvatar(currentUser.id);

      // Update profile to remove avatar URL
      await _supabase
          .from('profiles')
          .update({'avatar_url': null, 'updated_at': DateTime.now().toIso8601String()})
          .eq('user_id', currentUser.id);

      print('✅ Avatar deleted successfully');
    } catch (error, stackTrace) {
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error,
        stackTrace: stackTrace,
        context: 'Delete Avatar',
      );
    }
  }

  /// Get current user's avatar URL
  Future<String?> getCurrentUserAvatar() async {
    final currentUser = _supabase.auth.currentUser;
    if (currentUser == null) {
      return null;
    }
    return getAvatarUrl(currentUser.id);
  }
}
</file>

<file path="lib/services/context_preloader_service.dart">
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/models/conversation_context.dart';

/// Service for loading conversation context
class ContextPreloaderService {
  static final ContextPreloaderService _instance =
      ContextPreloaderService._internal();
  factory ContextPreloaderService() => _instance;
  ContextPreloaderService._internal();

  static String get baseUrl {
    final supabaseUrl = SupabaseClientProvider.client.supabaseUrl;
    return '$supabaseUrl/functions/v1';
  }

  // In-memory cache
  final Map<String, ConversationContext> _cache = {};

  /// Load context for a conversation
  Future<ConversationContext> loadContext(String conversationId) async {
    // Check in-memory cache first
    if (_cache.containsKey(conversationId)) {
      final cached = _cache[conversationId]!;
      // Return if less than 5 minutes old
      if (cached.cacheAge != null && cached.cacheAge! < 300) {
        return cached;
      }
    }

    try {
      final token =
          SupabaseClientProvider.client.auth.currentSession?.accessToken;
      if (token == null) {
        throw Exception('Not authenticated');
      }

      final response = await http.post(
        Uri.parse('$baseUrl/ai-context-preloader'),
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
        body: jsonEncode({
          'conversation_id': conversationId,
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true) {
          final context = ConversationContext.fromJson({
            'conversation_id': conversationId,
            ...data['context'],
            'from_cache': data['from_cache'],
          });

          // Update in-memory cache
          _cache[conversationId] = context;

          return context;
        } else {
          throw Exception(data['error'] ?? 'Failed to load context');
        }
      } else {
        throw Exception('HTTP ${response.statusCode}: ${response.body}');
      }
    } catch (e) {
      print('Error loading context: $e');
      rethrow;
    }
  }

  /// Preload context for multiple conversations
  Future<void> preloadContexts(List<String> conversationIds) async {
    // Load in parallel with rate limiting
    final futures = conversationIds.take(5).map((id) => loadContext(id));
    await Future.wait(futures, eagerError: false);
  }

  /// Preload context for a conversation (alias for loadContext)
  Future<ConversationContext> preloadContext(String conversationId) async {
    return loadContext(conversationId);
  }

  /// Search for similar messages using semantic search
  Future<List<Map<String, dynamic>>> searchSimilarMessages({
    required String query,
    String? conversationId,
    int limit = 5,
  }) async {
    try {
      final token =
          SupabaseClientProvider.client.auth.currentSession?.accessToken;
      if (token == null) {
        throw Exception('Not authenticated');
      }

      final response = await http.post(
        Uri.parse('$baseUrl/ai-generate-embeddings'),
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
        body: jsonEncode({
          'query': query,
          'conversation_id': conversationId,
          'limit': limit,
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true) {
          return List<Map<String, dynamic>>.from(data['results'] ?? []);
        } else {
          throw Exception(data['error'] ?? 'Search failed');
        }
      } else {
        throw Exception('HTTP ${response.statusCode}: ${response.body}');
      }
    } catch (e) {
      print('Error searching similar messages: $e');
      return [];
    }
  }

  /// Generate embedding for text
  Future<List<double>> generateEmbedding(String text) async {
    try {
      final token =
          SupabaseClientProvider.client.auth.currentSession?.accessToken;
      if (token == null) {
        throw Exception('Not authenticated');
      }

      final response = await http.post(
        Uri.parse('$baseUrl/ai-generate-embeddings'),
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
        body: jsonEncode({
          'text': text,
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true && data['embedding'] != null) {
          return List<double>.from(data['embedding']);
        } else {
          throw Exception(data['error'] ?? 'Embedding generation failed');
        }
      } else {
        throw Exception('HTTP ${response.statusCode}: ${response.body}');
      }
    } catch (e) {
      print('Error generating embedding: $e');
      return [];
    }
  }

  /// Invalidate cache for a conversation
  void invalidateCache([String? conversationId]) {
    if (conversationId != null) {
      _cache.remove(conversationId);
    } else {
      _cache.clear();
    }
  }

  /// Clear cache (alias for backwards compatibility)
  void clearCache() {
    _cache.clear();
  }
}
</file>

<file path="lib/services/conversation_service.dart">
import 'package:uuid/uuid.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';

class ConversationService {
  static final ConversationService _instance =
      ConversationService._internal();

  factory ConversationService() {
    return _instance;
  }

  ConversationService._internal();

  final _db = AppDb.instance;
  final _supabase = SupabaseClientProvider.client;

  /// Create a new conversation
  Future<Conversation> createConversation({
    required String title,
    String? description,
    bool isGroup = false,
  }) async {
    final currentUser = _supabase.auth.currentUser;
    if (currentUser == null) {
      throw 'User not authenticated';
    }

    final now = DateTime.now();
    final timestamp = now.millisecondsSinceEpoch ~/ 1000;
    final conversationId = const Uuid().v4();
    
    final conversation = Conversation(
      id: conversationId,
      title: title,
      description: description,
      createdAt: timestamp,
      updatedAt: timestamp,
      isGroup: isGroup,
      lastMessageAt: timestamp,
      isSynced: false,
    );

    // Save to local database first (optimistic UI)
    await _db.conversationDao.upsertConversation(conversation);

    // Sync to backend
    try {
      // Create conversation in backend
      await _supabase.from('conversations').insert({
        'id': conversationId,
        'title': title,
        'description': description,
        'is_group': isGroup,
        'created_by': currentUser.id,
        'created_at': DateTime.fromMillisecondsSinceEpoch(timestamp * 1000).toIso8601String(),
        'updated_at': DateTime.fromMillisecondsSinceEpoch(timestamp * 1000).toIso8601String(),
      });

      // Add current user as participant
      final participantId = const Uuid().v4();
      await _supabase.from('conversation_participants').insert({
        'id': participantId,
        'conversation_id': conversationId,
        'user_id': currentUser.id,
        'joined_at': DateTime.fromMillisecondsSinceEpoch(timestamp * 1000).toIso8601String(),
      });

      // Save participant locally
      await _db.participantDao.addParticipant(Participant(
        id: participantId,
        conversationId: conversationId,
        userId: currentUser.id,
        joinedAt: timestamp,
        isAdmin: true,
        isSynced: true,
      ));

      // Mark conversation as synced
      await _db.conversationDao.markConversationAsSynced(conversationId);
      
      print('Conversation synced to backend: $conversationId');
    } catch (e) {
      print('Error syncing conversation to backend: $e');
      // Conversation stays in local DB with isSynced=false for retry later
    }

    return conversation;
  }

  /// Sync conversations from backend
  Future<void> syncConversations() async {
    try {
      print('🔄 Syncing conversations from backend...');
      
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        print('❌ User not authenticated, skipping sync');
        return;
      }

      // Fetch conversations where user is a participant
      final response = await _supabase
          .from('conversation_participants')
          .select('conversation_id')
          .eq('user_id', currentUser.id);

      final conversationIds = (response as List)
          .map((p) => p['conversation_id'] as String)
          .toList();

      if (conversationIds.isEmpty) {
        print('ℹ️  No conversations found for user');
        return;
      }

      // Fetch full conversation details
      final conversationsResponse = await _supabase
          .from('conversations')
          .select('*')
          .in_('id', conversationIds);

      print('📥 Fetched ${(conversationsResponse as List).length} conversations from backend');

      // Save to local database
      for (final convData in conversationsResponse) {
        final conversation = Conversation(
          id: convData['id'] as String,
          title: convData['title'] as String,
          description: convData['description'] as String?,
          createdAt: DateTime.parse(convData['created_at'] as String)
              .millisecondsSinceEpoch ~/
              1000,
          updatedAt: DateTime.parse(convData['updated_at'] as String)
              .millisecondsSinceEpoch ~/
              1000,
          isGroup: convData['is_group'] as bool? ?? false,
          lastMessageAt: convData['last_message_at'] != null
              ? DateTime.parse(convData['last_message_at'] as String)
                  .millisecondsSinceEpoch ~/
                  1000
              : DateTime.parse(convData['created_at'] as String)
                  .millisecondsSinceEpoch ~/
                  1000,
          isSynced: true,
        );

        await _db.conversationDao.upsertConversation(conversation);
      }

      print('✅ Conversations synced successfully');
    } catch (e) {
      print('❌ Error syncing conversations: $e');
    }
  }

  /// Get all conversations (with optional sync)
  Future<List<Conversation>> getAllConversations({bool syncFirst = true}) async {
    if (syncFirst) {
      await syncConversations();
    }
    return _db.conversationDao.getAllConversations();
  }

  /// Get recent conversations
  Future<List<Conversation>> getRecentConversations({int limit = 20}) async {
    return _db.conversationDao.getRecentConversations(limit: limit);
  }

  /// Get conversation by ID
  Future<Conversation?> getConversationById(String id) async {
    return _db.conversationDao.getConversationById(id);
  }

  /// Delete conversation (local and remote)
  Future<void> deleteConversation(String id) async {
    final currentUser = _supabase.auth.currentUser;
    print('━' * 60);
    print('🗑️ DELETING CONVERSATION');
    print('━' * 60);
    print('Conversation ID: $id');
    print('User ID: ${currentUser?.id}');
    
    // Delete from local database first
    await _db.conversationDao.deleteConversation(id);
    print('✅ Deleted from local database');
    
    // Try to delete from Supabase
    try {
      print('Attempting to delete from Supabase...');
      
      // Delete from Supabase (CASCADE will delete participants and messages)
      await _supabase
          .from('conversations')
          .delete()
          .eq('id', id);
      
      print('✅ Conversation deleted from backend: $id');
      print('━' * 60);
    } catch (e) {
      print('━' * 60);
      print('❌ ERROR DELETING FROM BACKEND');
      print('━' * 60);
      print('Error: $e');
      print('Error Type: ${e.runtimeType}');
      
      if (e.toString().contains('row-level security')) {
        print('🔒 RLS POLICY BLOCKING DELETE!');
        print('Solution: Run the SQL in FIX_DELETE_CONVERSATION.md');
      }
      
      print('━' * 60);
      // Already deleted locally, so this is non-critical
      // But we should rethrow so the UI can show the error
      rethrow;
    }
  }

  /// Update conversation title
  Future<void> updateConversationTitle(String id, String title) async {
    final conv = await getConversationById(id);
    if (conv != null) {
      final updated = conv.copyWith(
        title: title,
        updatedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );
      await _db.conversationDao.upsertConversation(updated);
    }
  }

  /// Count conversations
  Future<int> getConversationCount() async {
    return _db.conversationDao.getConversationCount();
  }

  /// Sync participants from backend
  Future<void> syncParticipants(String conversationId) async {
    try {
      print('🔄 Syncing participants for conversation: $conversationId');
      
      // Fetch participants from backend
      final response = await _supabase
          .from('conversation_participants')
          .select('*')
          .eq('conversation_id', conversationId);

      print('📥 Fetched ${(response as List).length} participants from backend');

      // Save participants to local database
      for (final partData in response) {
        final participant = Participant(
          id: partData['id'] as String,
          conversationId: partData['conversation_id'] as String,
          userId: partData['user_id'] as String,
          joinedAt: DateTime.parse(partData['joined_at'] as String)
              .millisecondsSinceEpoch ~/
              1000,
          isAdmin: partData['is_admin'] as bool? ?? false,
          isSynced: true,
        );
        
        await _db.participantDao.addParticipant(participant);
      }

      print('✅ Participants synced successfully');
    } catch (e) {
      print('❌ Error syncing participants: $e');
    }
  }

  /// Get participants in a conversation
  Future<List<Participant>> getParticipants(String conversationId, {bool syncFirst = true}) async {
    if (syncFirst) {
      await syncParticipants(conversationId);
    }
    return _db.participantDao.getParticipantsByConversation(conversationId);
  }
  
  /// Get participant profile from Supabase by user ID
  Future<Map<String, dynamic>?> getParticipantProfile(String userId) async {
    try {
      final response = await _supabase
          .from('profiles')
          .select('user_id, username, email, avatar_url, display_name')
          .eq('user_id', userId)
          .single();
      
      return response as Map<String, dynamic>;
    } catch (e) {
      print('Error fetching profile for $userId: $e');
      return null;
    }
  }

  /// Add participant to conversation
  Future<void> addParticipant({
    required String conversationId,
    required String userId,
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final participantId = const Uuid().v4();
    
    final participant = Participant(
      id: participantId,
      conversationId: conversationId,
      userId: userId,
      joinedAt: now,
      isAdmin: false,
      isSynced: false,
    );
    
    // Save to local database first (optimistic UI)
    await _db.participantDao.addParticipant(participant);
    
    // Sync to backend
    try {
      await _supabase.from('conversation_participants').insert({
        'id': participantId,
        'conversation_id': conversationId,
        'user_id': userId,
        'joined_at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
      });
      
      print('Participant added to backend: $userId');
    } catch (e) {
      print('Error syncing participant to backend: $e');
    }
  }

  /// Remove participant from conversation
  Future<void> removeParticipant(String conversationId, String userId) async {
    await _db.participantDao.removeParticipant(conversationId, userId);
  }

  /// Add current user as participant to conversation
  Future<void> addCurrentUserAsParticipant(String conversationId) async {
    // This would typically be called after creating a conversation
    // For now, we'll add the creator automatically in createConversation
  }

  /// Get the latest message for a conversation
  Future<Message?> getLatestMessage(String conversationId) async {
    return _db.messageDao.getLatestMessageForConversation(conversationId);
  }
}
</file>

<file path="lib/services/deep_link_handler.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Handles deep linking and navigation from notifications
class DeepLinkHandler {
  final WidgetRef ref;
  final NavigatorState? navigatorState;

  DeepLinkHandler({
    required this.ref,
    this.navigatorState,
  });

  /// Handle notification tap - navigate to conversation
  Future<void> handleNotificationTap(String conversationId) async {
    try {
      // Navigate to conversation detail screen
      navigatorState?.pushNamed(
        '/conversation/$conversationId',
      );
      print('Navigated to conversation: $conversationId');
    } catch (e) {
      print('Error handling notification tap: $e');
    }
  }

  /// Handle initial message (app terminated)
  Future<void> handleInitialMessage(String conversationId) async {
    try {
      // Wait for app to fully initialize
      await Future.delayed(const Duration(milliseconds: 500));
      
      // Navigate to conversation
      navigatorState?.pushNamedAndRemoveUntil(
        '/conversation/$conversationId',
        ModalRoute.withName('/conversations'),
      );
      print('Navigated from initial message to: $conversationId');
    } catch (e) {
      print('Error handling initial message: $e');
    }
  }

  /// Handle background message (app in background)
  Future<void> handleBackgroundMessage(String conversationId) async {
    try {
      // Just navigate normally
      navigatorState?.pushNamed('/conversation/$conversationId');
      print('Navigated from background message to: $conversationId');
    } catch (e) {
      print('Error handling background message: $e');
    }
  }

  /// Parse notification payload to extract conversation ID
  String? extractConversationId(Map<String, dynamic> data) {
    return data['conversation_id'] as String?;
  }

  /// Parse notification payload to extract message metadata
  Map<String, dynamic> extractMessageMetadata(Map<String, dynamic> data) {
    return {
      'conversation_id': data['conversation_id'],
      'sender_id': data['sender_id'],
      'message_id': data['message_id'],
      'sender_name': data['sender_name'],
    };
  }
}

/// Notification route arguments
class NotificationRouteArgs {
  final String conversationId;
  final String? senderId;
  final String? messageId;
  final String? senderName;

  NotificationRouteArgs({
    required this.conversationId,
    this.senderId,
    this.messageId,
    this.senderName,
  });

  factory NotificationRouteArgs.fromPayload(Map<String, dynamic> payload) {
    return NotificationRouteArgs(
      conversationId: payload['conversation_id'] as String,
      senderId: payload['sender_id'] as String?,
      messageId: payload['message_id'] as String?,
      senderName: payload['sender_name'] as String?,
    );
  }
}

/// Generate named route for conversation
String conversationRoute(String conversationId) => '/conversation/$conversationId';

/// Parse conversation ID from route
String? parseConversationIdFromRoute(String route) {
  if (route.startsWith('/conversation/')) {
    return route.replaceFirst('/conversation/', '');
  }
  return null;
}
</file>

<file path="lib/services/device_registration_service.dart">
import 'dart:io' show Platform;
import 'package:messageai/data/remote/supabase_client.dart';

/// Service for registering and managing device tokens with the backend
class DeviceRegistrationService {
  /// Register or update device token in Supabase
  Future<void> registerDeviceToken(String token) async {
    try {
      final supabase = SupabaseClientProvider.client;
      final userId = supabase.auth.currentUser?.id;
      
      if (userId == null) {
        print('⚠️ Cannot register device: user not authenticated');
        throw Exception('User not authenticated');
      }
      
      // Determine platform
      String platform;
      if (Platform.isIOS) {
        platform = 'ios';
      } else if (Platform.isAndroid) {
        platform = 'android';
      } else {
        platform = 'web';
      }
      
      print('📱 Registering device token...');
      print('   User ID: $userId');
      print('   Platform: $platform');
      print('   Token: ${token.substring(0, 20)}...');
      
      // Use secure function to bypass RLS issues
      await supabase.rpc('upsert_device_token', params: {
        'p_fcm_token': token,
        'p_platform': platform,
      });
      
      print('✅ Device token registered successfully!');
    } catch (e) {
      print('❌ Failed to register device token: $e');
      rethrow;
    }
  }
  
  /// Unregister device token (e.g., on logout)
  Future<void> unregisterDeviceToken(String token) async {
    try {
      final supabase = SupabaseClientProvider.client;
      
      print('🗑️ Unregistering device token...');
      
      await supabase
          .from('profile_devices')
          .delete()
          .eq('fcm_token', token);
      
      print('✅ Device token unregistered');
    } catch (e) {
      print('❌ Failed to unregister device token: $e');
      rethrow;
    }
  }
  
  /// Update last seen timestamp for device
  Future<void> updateDeviceLastSeen(String token) async {
    try {
      final supabase = SupabaseClientProvider.client;
      
      print('🔄 Updating last_seen for token: ${token.substring(0, 20)}...');
      
      final response = await supabase
          .from('profile_devices')
          .update({
            'last_seen': DateTime.now().toIso8601String(),
          })
          .eq('fcm_token', token)
          .select();
      
      if (response.isEmpty) {
        print('⚠️ No device found with that token - device may not be registered');
      } else {
        print('✅ Device last_seen updated successfully');
      }
    } catch (e) {
      print('❌ Failed to update device last_seen: $e');
      // Don't rethrow - this is not critical
    }
  }
}
</file>

<file path="lib/services/draft_analysis_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/models/draft_analysis.dart';

/// Service for analyzing draft messages on-demand
/// User manually requests analysis via button press
class DraftAnalysisService {
  final SupabaseClient _supabase;

  DraftAnalysisService(this._supabase);

  /// Analyze a draft message (called when user clicks "Check" button)
  Future<DraftAnalysis> analyzeDraft({
    required String draftMessage,
    String? conversationId,
    RelationshipType? relationshipType,
    List<String>? conversationHistory,
  }) async {
    try {
      print('🔍 Analyzing draft message...');
      
      final response = await _supabase.functions.invoke(
        'ai_analyze_draft',
        body: {
          'draft_message': draftMessage,
          if (conversationId != null) 'conversation_id': conversationId,
          if (relationshipType != null && relationshipType != RelationshipType.none)
            'relationship_type': relationshipType.value,
          if (conversationHistory != null && conversationHistory.isNotEmpty)
            'conversation_history': conversationHistory,
        },
      );

      if (response.data == null) {
        throw Exception('No response from draft analysis service');
      }

      final data = response.data as Map<String, dynamic>;
      
      if (data['success'] != true) {
        throw Exception(data['error'] ?? 'Analysis failed');
      }

      final analysis = DraftAnalysis.fromJson(data['analysis'] as Map<String, dynamic>);
      
      print('✅ Draft analysis complete: ${analysis.confidenceScore}% confidence');
      
      return analysis;
    } catch (e) {
      print('❌ Error analyzing draft: $e');
      rethrow;
    }
  }

  /// Get recent messages from conversation for context
  Future<List<String>> getConversationContext(String conversationId, {int limit = 3}) async {
    try {
      final response = await _supabase
          .from('messages')
          .select('body')
          .eq('conversation_id', conversationId)
          .order('created_at', ascending: false)
          .limit(limit);

      return (response as List).map((m) => m['body'] as String).toList();
    } catch (e) {
      print('Warning: Could not fetch conversation context: $e');
      return [];
    }
  }

  /// Get or detect relationship type for conversation
  Future<RelationshipType> getRelationshipType(String conversationId) async {
    try {
      final response = await _supabase
          .from('conversations')
          .select('relationship_type')
          .eq('id', conversationId)
          .single();

      return RelationshipType.fromString(response['relationship_type'] as String?);
    } catch (e) {
      print('Warning: Could not fetch relationship type: $e');
      return RelationshipType.none;
    }
  }

  /// Update relationship type for conversation
  Future<void> setRelationshipType(String conversationId, RelationshipType type) async {
    try {
      await _supabase
          .from('conversations')
          .update({'relationship_type': type.value})
          .eq('id', conversationId);
      
      print('✅ Relationship type updated to: ${type.displayName}');
    } catch (e) {
      print('❌ Error updating relationship type: $e');
      rethrow;
    }
  }
}
</file>

<file path="lib/services/draft_confidence_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/models/draft_confidence.dart';

/// Service for analyzing draft confidence (Phase 2: Response Assistant)
class DraftConfidenceService {
  final SupabaseClient _supabase;

  DraftConfidenceService(this._supabase);

  /// Analyze the confidence/quality of a draft response
  Future<DraftConfidence> analyzeDraft(String draft) async {
    try {
      print('✍️ Analyzing draft...');
      
      final response = await _supabase.functions.invoke(
        'ai_analyze_draft',
        body: {
          'draft': draft,
        },
      );

      if (response.data == null) {
        throw Exception('No response from draft confidence service');
      }

      final data = response.data as Map<String, dynamic>;
      
      if (data['success'] != true) {
        throw Exception(data['error'] ?? 'Draft analysis failed');
      }

      final confidence = DraftConfidence.fromJson(
        data['analysis'] as Map<String, dynamic>,
      );
      
      print('✅ Draft analyzed: ${confidence.overallScore}% confidence');
      
      return confidence;
    } catch (e) {
      print('❌ Error analyzing draft: $e');
      rethrow;
    }
  }

  /// Quick check: is draft good enough to send?
  Future<bool> isReadyToSend(String draft) async {
    final confidence = await analyzeDraft(draft);
    return confidence.overallScore >= 70; // 70% threshold
  }

  /// Get suggestions for improving draft
  Future<List<String>> getSuggestions(String draft) async {
    final confidence = await analyzeDraft(draft);
    return confidence.suggestions;
  }
}
</file>

<file path="lib/services/follow_up_service.dart">
// ignore_for_file: avoid_print

import 'package:http/http.dart' as http;
import 'dart:convert';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/models/follow_up_item.dart';

/// Service for managing follow-up items
class FollowUpService {
  static final FollowUpService _instance = FollowUpService._internal();
  factory FollowUpService() => _instance;
  FollowUpService._internal();

  final _supabase = SupabaseClientProvider.client;

  String get _baseUrl {
    final supabaseUrl = _supabase.supabaseUrl;
    return '$supabaseUrl/functions/v1';
  }

  /// Extract follow-ups from conversation
  Future<void> extractFollowUps(String conversationId, {bool scanAll = false}) async {
    try {
      final token = _supabase.auth.currentSession?.accessToken;
      if (token == null) throw Exception('Not authenticated');

      await http.post(
        Uri.parse('$_baseUrl/ai-extract-followups'),
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
        body: jsonEncode({
          'conversation_id': conversationId,
          'scan_recent_messages': scanAll,
        }),
      );
    } catch (e) {
      print('Error extracting follow-ups: $e');
      rethrow;
    }
  }

  /// Get all pending follow-ups for user
  Future<List<FollowUpItem>> getPendingFollowUps() async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return [];

      final response = await _supabase.rpc('get_pending_followups', params: {
        'p_user_id': userId,
        'p_limit': 50,
      });

      if (response == null) return [];

      return (response as List)
          .map((data) => FollowUpItem.fromJson({
                'user_id': userId,
                ...data as Map<String, dynamic>,
              }))
          .toList();
    } catch (e) {
      print('Error getting pending follow-ups: $e');
      return [];
    }
  }

  /// Get follow-ups for specific conversation
  Future<List<FollowUpItem>> getConversationFollowUps(String conversationId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return [];

      final response = await _supabase.rpc('get_conversation_followups', params: {
        'p_user_id': userId,
        'p_conversation_id': conversationId,
      });

      if (response == null) return [];

      return (response as List)
          .map((data) => FollowUpItem.fromJson({
                'user_id': userId,
                'conversation_id': conversationId,
                ...data as Map<String, dynamic>,
              }))
          .toList();
    } catch (e) {
      print('Error getting conversation follow-ups: $e');
      return [];
    }
  }

  /// Mark follow-up as completed
  Future<void> completeFollowUp(String itemId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      await _supabase.rpc('complete_followup', params: {
        'p_user_id': userId,
        'p_item_id': itemId,
      });
    } catch (e) {
      print('Error completing follow-up: $e');
      rethrow;
    }
  }

  /// Snooze follow-up
  Future<void> snoozeFollowUp(String itemId, Duration duration) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      await _supabase.rpc('snooze_followup', params: {
        'p_user_id': userId,
        'p_item_id': itemId,
        'p_snooze_duration': duration.inSeconds,
      });
    } catch (e) {
      print('Error snoozing follow-up: $e');
      rethrow;
    }
  }

  /// Dismiss follow-up
  Future<void> dismissFollowUp(String itemId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;

      await _supabase.from('follow_up_items').update({
        'status': 'dismissed',
        'updated_at': now,
      }).eq('id', itemId).eq('user_id', userId);
    } catch (e) {
      print('Error dismissing follow-up: $e');
      rethrow;
    }
  }
}
</file>

<file path="lib/services/local_notification_service.dart">
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter/material.dart';

/// Local notification service for displaying notifications in foreground
class LocalNotificationService {
  static const String _channelId = 'messages';
  static const String _channelName = 'Message Notifications';
  
  final FlutterLocalNotificationsPlugin _plugin;

  LocalNotificationService({FlutterLocalNotificationsPlugin? plugin})
      : _plugin = plugin ?? FlutterLocalNotificationsPlugin();

  /// Initialize local notifications
  Future<void> initialize() async {
    try {
      // Android initialization
      const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');

      // iOS initialization
      const iosSettings = DarwinInitializationSettings(
        requestAlertPermission: true,
        requestBadgePermission: true,
        requestSoundPermission: true,
      );

      const settings = InitializationSettings(
        android: androidSettings,
        iOS: iosSettings,
      );

      await _plugin.initialize(settings);
      print('Local notifications initialized');
    } catch (e) {
      print('Error initializing local notifications: $e');
    }
  }

  /// Show a notification
  Future<void> showNotification({
    required int id,
    required String title,
    required String body,
    String? payload,
  }) async {
    try {
      // Android notification details
      const androidDetails = AndroidNotificationDetails(
        _channelId,
        _channelName,
        channelDescription: 'Notifications for incoming messages',
        importance: Importance.max,
        priority: Priority.high,
        showWhen: true,
        enableVibration: true,
        playSound: true,
        icon: '@mipmap/ic_launcher',
      );

      // iOS notification details
      const iosDetails = DarwinNotificationDetails(
        presentAlert: true,
        presentBadge: true,
        presentSound: true,
        badgeNumber: 1,
      );

      const details = NotificationDetails(
        android: androidDetails,
        iOS: iosDetails,
      );

      await _plugin.show(
        id,
        title,
        body,
        details,
        payload: payload,
      );

      print('Notification shown: $title - $body');
    } catch (e) {
      print('Error showing notification: $e');
    }
  }

  /// Show message notification
  Future<void> showMessageNotification({
    required String conversationId,
    required String senderName,
    required String messageBody,
  }) async {
    final id = conversationId.hashCode % 100000;
    await showNotification(
      id: id,
      title: senderName,
      body: messageBody,
      payload: conversationId,
    );
  }

  /// Cancel a notification
  Future<void> cancelNotification(int id) async {
    try {
      await _plugin.cancel(id);
    } catch (e) {
      print('Error canceling notification: $e');
    }
  }

  /// Cancel all notifications
  Future<void> cancelAllNotifications() async {
    try {
      await _plugin.cancelAll();
    } catch (e) {
      print('Error canceling all notifications: $e');
    }
  }

  /// Get pending notifications
  Future<List<PendingNotificationRequest>> getPendingNotifications() async {
    try {
      return await _plugin.pendingNotificationRequests();
    } catch (e) {
      print('Error getting pending notifications: $e');
      return [];
    }
  }

  /// Setup notification response handler
  void setupNotificationResponseHandler({
    required Function(String) onNotificationTapped,
  }) {
    _plugin.getNotificationAppLaunchDetails().then((details) {
      if (details?.didNotificationLaunchApp ?? false) {
        final payload = details?.notificationResponse?.payload;
        if (payload != null) {
          onNotificationTapped(payload);
        }
      }
    });

    // Listen for notification taps in foreground
  }

  /// Request notification permissions (Android 13+)
  Future<bool> requestPermissions() async {
    try {
      final result = await _plugin
          .resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin>()
          ?.requestNotificationsPermission();
      return result ?? false;
    } catch (e) {
      print('Error requesting permissions: $e');
      return false;
    }
  }
}
</file>

<file path="lib/services/media_service.dart">
import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path/path.dart' as p;
import 'package:uuid/uuid.dart';
import 'package:messageai/state/providers.dart';

/// Media upload progress
class MediaUploadProgress {
  final int bytesTransferred;
  final int totalBytes;
  
  MediaUploadProgress({
    required this.bytesTransferred,
    required this.totalBytes,
  });
  
  double get progress => totalBytes > 0 ? bytesTransferred / totalBytes : 0;
  double get percentage => progress * 100;
}

/// Media service for handling uploads
class MediaService {
  final Ref ref;
  
  static const String _mediaBucket = 'media';
  static const String _avatarBucket = 'avatars';
  
  MediaService({required this.ref});

  /// Pick image from gallery
  Future<XFile?> pickImageFromGallery() async {
    final picker = ImagePicker();
    return picker.pickImage(source: ImageSource.gallery);
  }

  /// Pick image from camera
  Future<XFile?> pickImageFromCamera() async {
    final picker = ImagePicker();
    return picker.pickImage(source: ImageSource.camera);
  }

  /// Upload image to Supabase Storage
  Future<String> uploadImage(XFile file, {String bucket = 'media'}) async {
    final supabase = ref.watch(supabaseClientProvider);
    final userId = supabase.auth.currentUser?.id;
    
    if (userId == null) {
      throw Exception('User not authenticated');
    }
    
    try {
      // Generate unique filename
      const uuid = Uuid();
      final fileName = '${uuid.v4()}_${p.basename(file.path)}';
      final path = '$userId/$fileName';
      
      // Read file bytes
      final fileBytes = await file.readAsBytes();
      
      // Upload to storage
      await supabase.storage
          .from(bucket)
          .uploadBinary(
            path,
            fileBytes,
          );
      
      // Get public URL
      final url = supabase.storage
          .from(bucket)
          .getPublicUrl(path);
      
      return url;
    } catch (e) {
      print('Error uploading image: $e');
      rethrow;
    }
  }
  
  /// Upload avatar image
  Future<String> uploadAvatar(XFile file) async {
    return uploadImage(file, bucket: _avatarBucket);
  }

  /// Upload image with progress tracking
  Future<String> uploadImageWithProgress(
    XFile file,
    Function(MediaUploadProgress) onProgress,
  ) async {
    final supabase = ref.watch(supabaseClientProvider);
    
    try {
      // Generate unique filename
      const uuid = Uuid();
      final fileName = '${uuid.v4()}_${p.basename(file.path)}';
      final path = 'conversations/$fileName';
      
      // Read file bytes
      final fileBytes = await file.readAsBytes();
      final totalBytes = fileBytes.length;
      
      // Simulate progress (Supabase doesn't provide built-in progress)
      // In production, use a dedicated upload library
      int bytesTransferred = 0;
      
      // Upload to storage
      await supabase.storage
          .from(_mediaBucket)
          .uploadBinary(
            path,
            fileBytes,
          );
      
      bytesTransferred = totalBytes;
      onProgress(MediaUploadProgress(
        bytesTransferred: bytesTransferred,
        totalBytes: totalBytes,
      ));
      
      // Get public URL
      final url = supabase.storage
          .from(_mediaBucket)
          .getPublicUrl(path);
      
      return url;
    } catch (e) {
      print('Error uploading image with progress: $e');
      rethrow;
    }
  }

  /// Delete image from storage
  Future<void> deleteImage(String url) async {
    final supabase = ref.watch(supabaseClientProvider);
    
    try {
      // Extract path from URL
      final uri = Uri.parse(url);
      final pathSegments = uri.pathSegments;
      final path = pathSegments.sublist(4).join('/'); // Skip storage, v1, object, public
      
      await supabase.storage.from(_mediaBucket).remove([path]);
    } catch (e) {
      print('Error deleting image: $e');
    }
  }

  /// Compress image before upload
  Future<File> compressImage(XFile file, {int quality = 85}) async {
    // TODO: Implement image compression using image package
    // For now, return original file
    return File(file.path);
  }
}

/// Provider for media service
final mediaServiceProvider = Provider<MediaService>((ref) {
  return MediaService(ref: ref);
});

/// State notifier for handling media uploads
class MediaUploadNotifier extends StateNotifier<AsyncValue<String>> {
  final Ref ref;

  MediaUploadNotifier({required this.ref}) : super(const AsyncValue.data(''));

  /// Upload image
  Future<String> uploadImage(XFile file) async {
    state = const AsyncValue.loading();
    
    try {
      final mediaService = ref.watch(mediaServiceProvider);
      final url = await mediaService.uploadImage(file);
      state = AsyncValue.data(url);
      return url;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }

  /// Upload image with progress
  Future<String> uploadImageWithProgress(
    XFile file,
    Function(MediaUploadProgress) onProgress,
  ) async {
    state = const AsyncValue.loading();
    
    try {
      final mediaService = ref.watch(mediaServiceProvider);
      final url = await mediaService.uploadImageWithProgress(file, onProgress);
      state = AsyncValue.data(url);
      return url;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }
}

/// State notifier provider for media uploads
final mediaUploadNotifierProvider =
    StateNotifierProvider<MediaUploadNotifier, AsyncValue<String>>((ref) {
  return MediaUploadNotifier(ref: ref);
});
</file>

<file path="lib/services/message_formatter_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/models/formatted_message.dart';

/// Service for formatting messages
class MessageFormatterService {
  final SupabaseClient _supabase;

  MessageFormatterService(this._supabase);

  /// Format a message with specified options
  Future<FormattedMessage> formatMessage({
    required String message,
    bool condense = false,
    bool chunk = false,
    bool addTldr = false,
    bool addStructure = false,
  }) async {
    try {
      print('🎨 Formatting message...');
      
      final response = await _supabase.functions.invoke(
        'ai-format-message',
        body: {
          'message': message,
          'options': {
            'condense': condense,
            'chunk': chunk,
            'add_tldr': addTldr,
            'add_structure': addStructure,
          },
        },
      );

      if (response.data == null) {
        throw Exception('No response from message formatting service');
      }

      final data = response.data as Map<String, dynamic>;
      
      if (data['success'] != true) {
        throw Exception(data['error'] ?? 'Formatting failed');
      }

      final formatted = FormattedMessage.fromJson(
        data['formatted'] as Map<String, dynamic>,
      );
      
      print('✅ Message formatted: ${formatted.originalLength} → ${formatted.characterCount} chars');
      
      return formatted;
    } catch (e) {
      print('❌ Error formatting message: $e');
      rethrow;
    }
  }

  /// Quick format: condense only
  Future<FormattedMessage> condenseMessage(String message) {
    return formatMessage(message: message, condense: true);
  }

  /// Quick format: add structure
  Future<FormattedMessage> structureMessage(String message) {
    return formatMessage(message: message, addStructure: true, chunk: true);
  }

  /// Quick format: full formatting (all options)
  Future<FormattedMessage> fullFormat(String message) {
    return formatMessage(
      message: message,
      condense: true,
      chunk: true,
      addTldr: true,
      addStructure: true,
    );
  }

  /// Detect the situation/context of a message
  Future<String> detectSituation(String message) async {
    try {
      print('🔍 Detecting situation for message...');
      
      final response = await _supabase.functions.invoke(
        'ai-format-message',
        body: {
          'message': message,
          'detect_situation': true,
        },
      );

      if (response.data == null) {
        throw Exception('No response from situation detection service');
      }

      final data = response.data as Map<String, dynamic>;
      
      if (data['success'] != true) {
        throw Exception(data['error'] ?? 'Situation detection failed');
      }

      final situation = data['situation'] as String? ?? 'unknown';
      
      print('✅ Situation detected: $situation');
      
      return situation;
    } catch (e) {
      print('❌ Error detecting situation: $e');
      return 'unknown';
    }
  }
}
</file>

<file path="lib/services/message_interpreter_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/models/ai_analysis.dart';

/// Service for interpreting messages (Phase 1: Smart Message Interpreter)
/// Calls ai-interpret-message Edge Function which returns enhanced tone analysis
/// with RSD triggers, alternative interpretations, and evidence
class MessageInterpreterService {
  final SupabaseClient _supabase;

  MessageInterpreterService(this._supabase);

  /// Interpret a message with alternative meanings, RSD detection, and evidence
  /// Returns full AIAnalysis with enhanced interpretation fields
  Future<AIAnalysis> interpretMessage(String messageId, String messageBody) async {
    try {
      print('🔍 Interpreting message...');
      
      final response = await _supabase.functions.invoke(
        'ai-interpret-message',
        body: {
          'message_id': messageId,
          'message_body': messageBody,
        },
      );

      if (response.data == null) {
        throw Exception('No response from message interpreter service');
      }

      final data = response.data as Map<String, dynamic>;
      
      if (data['success'] != true) {
        throw Exception(data['error'] ?? 'Message interpretation failed');
      }

      // Backend returns full enhanced tone analysis with interpretations
      final analysis = AIAnalysis.fromJson(
        data['interpretation'] as Map<String, dynamic>,
      );
      
      print('✅ Message interpreted: '
            '${analysis.alternativeInterpretations?.length ?? 0} alternatives, '
            '${analysis.rsdTriggers?.length ?? 0} RSD triggers');
      
      return analysis;
    } catch (e) {
      print('❌ Error interpreting message: $e');
      rethrow;
    }
  }

  /// Quick check: does message have RSD triggers?
  Future<bool> hasRsdTriggers(String messageId, String messageBody) async {
    final analysis = await interpretMessage(messageId, messageBody);
    return analysis.rsdTriggers?.isNotEmpty ?? false;
  }

  /// Get alternative interpretations for a message
  Future<List<MessageInterpretation>> getAlternativeInterpretations(
    String messageId, 
    String messageBody,
  ) async {
    final analysis = await interpretMessage(messageId, messageBody);
    return analysis.alternativeInterpretations ?? [];
  }

  /// Get RSD triggers for a message
  Future<List<RSDTrigger>> getRsdTriggers(
    String messageId,
    String messageBody,
  ) async {
    final analysis = await interpretMessage(messageId, messageBody);
    return analysis.rsdTriggers ?? [];
  }

  /// Get evidence points for interpretation
  Future<List<Evidence>> getEvidence(
    String messageId,
    String messageBody,
  ) async {
    final analysis = await interpretMessage(messageId, messageBody);
    return analysis.evidence ?? [];
  }
}
</file>

<file path="lib/services/message_service.dart">
import 'package:uuid/uuid.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/core/errors/error_handler.dart';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/services/ai_analysis_service.dart';

class MessageService {
  static final MessageService _instance = MessageService._internal();

  factory MessageService() {
    return _instance;
  }

  MessageService._internal();

  final _db = AppDb.instance;
  final _supabase = SupabaseClientProvider.client;
  final _errorHandler = ErrorHandler();
  final _aiAnalysis = AIAnalysisService();
  
  // Callback for when message is successfully sent (for triggering push notifications)
  void Function(String conversationId, String messageId)? onMessageSent;

  /// Send a new message
  Future<Message> sendMessage({
    required String conversationId,
    required String body,
    String? mediaUrl,
  }) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final messageId = const Uuid().v4();
      
      final message = Message(
        id: messageId,
        conversationId: conversationId,
        senderId: currentUser.id,
        body: body,
        mediaUrl: mediaUrl,
        createdAt: now,
        updatedAt: now,
        isSynced: false,
      );

      // Save to local database first (optimistic UI)
      try {
        await _db.messageDao.upsertMessage(message);
        await _db.conversationDao.updateLastMessageTime(conversationId);
      } catch (error, stackTrace) {
        // Critical: Can't even save locally
        throw _errorHandler.handleError(
          error, 
          stackTrace: stackTrace, 
          context: 'Save Message Locally',
        );
      }

      // Sync to backend
      try {
        final payload = {
          'id': messageId,
          'conversation_id': conversationId,
          'sender_id': currentUser.id,
          'body': body,
          'media_url': mediaUrl,
          'created_at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
          'updated_at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
        };
        
        await _supabase.from('messages').insert(payload);
        await _db.messageDao.markMessageAsSynced(messageId);
        
        // Trigger push notifications (don't wait for it)
        _sendPushNotification(conversationId, messageId, body).catchError((e) {
          print('⚠️ Push notification failed: $e');
        });
        
        // Trigger AI analysis for sent messages (don't wait for it)
        _triggerAIAnalysis(messageId, body).catchError((e) {
          print('⚠️ AI analysis failed: $e');
        });
      } catch (error, stackTrace) {
        // Convert to AppError
        final appError = _errorHandler.handleError(
          error, 
          stackTrace: stackTrace, 
          context: 'Send Message',
        );
        
        // If it's a network error, message is saved locally for retry
        if (_errorHandler.isNetworkError(appError)) {
          // Don't throw - message will sync later
        } else if (!appError.isRetryable) {
          // For non-retryable errors (like unauthorized), delete the local message
          await _db.messageDao.deleteMessage(messageId);
          throw appError;
        } else {
          // For other errors, throw so UI can handle
          throw appError;
        }
      }

      return message;
    } catch (error, stackTrace) {
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error, 
        stackTrace: stackTrace, 
        context: 'Send Message',
      );
    }
  }

  /// Sync messages from backend for a conversation
  Future<void> syncMessages(String conversationId) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) {
        throw AuthError.sessionExpired();
      }

      // Fetch messages from backend ordered by created_at
      final response = await _supabase
          .from('messages')
          .select('*')
          .eq('conversation_id', conversationId)
          .order('created_at', ascending: true);

      // Save to local database with proper timestamps
      for (final msgData in response as List) {
        final createdAt = DateTime.parse(msgData['created_at'] as String);
        final updatedAt = DateTime.parse(msgData['updated_at'] as String);
        
        final message = Message(
          id: msgData['id'] as String,
          conversationId: msgData['conversation_id'] as String,
          senderId: msgData['sender_id'] as String,
          body: msgData['body'] as String,
          mediaUrl: msgData['media_url'] as String?,
          createdAt: createdAt.millisecondsSinceEpoch ~/ 1000,
          updatedAt: updatedAt.millisecondsSinceEpoch ~/ 1000,
          isSynced: true,
        );

        // Use upsert to avoid duplicates
        await _db.messageDao.upsertMessage(message);
      }
    } catch (error, stackTrace) {
      if (error is AppError) {
        rethrow;
      }
      throw _errorHandler.handleError(
        error, 
        stackTrace: stackTrace, 
        context: 'Sync Messages',
      );
    }
  }

  /// Get messages for a conversation (with optional sync)
  Future<List<Message>> getMessagesByConversation(
    String conversationId, {
    bool syncFirst = false,
  }) async {
    if (syncFirst) {
      await syncMessages(conversationId);
    }
    return _db.messageDao.getMessagesByConversation(conversationId);
  }

  /// Get recent messages for a conversation
  Future<List<Message>> getRecentMessages(String conversationId, {int limit = 50}) async {
    return _db.messageDao.getRecentMessages(conversationId, limit: limit);
  }

  /// Get message by ID
  Future<Message?> getMessageById(String id) async {
    return _db.messageDao.getMessageById(id);
  }

  /// Delete message
  Future<void> deleteMessage(String id) async {
    await _db.messageDao.deleteMessage(id);
  }

  /// Get current user ID
  String? getCurrentUserId() {
    return _supabase.auth.currentUser?.id;
  }

  /// Send push notification for new message
  Future<void> _sendPushNotification(
    String conversationId,
    String messageId,
    String messageBody,
  ) async {
    try {
      final currentUser = _supabase.auth.currentUser;
      if (currentUser == null) return;

      // Get sender profile for notification (use maybeSingle to handle missing profile)
      final profile = await _supabase
          .from('profiles')
          .select('username, email')
          .eq('user_id', currentUser.id)
          .maybeSingle();

      final senderName = profile?['username'] as String? ?? 
                         profile?['email'] as String? ?? 
                         currentUser.email ?? 
                         'Someone';

      // Call push notification edge function with auth header
      final accessToken = _supabase.auth.currentSession?.accessToken;
      if (accessToken == null) return;
      
      print('🔔 Sending push notification for message: ${messageId.substring(0, 8)}');
      final response = await _supabase.functions.invoke(
        'push_notify',
        body: {
          'message_id': messageId,
          'conversation_id': conversationId,
          'sender_id': currentUser.id,
          'sender_name': senderName,
          'title': senderName,
          'body': messageBody,
        },
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      );
      print('✅ Push notification sent: ${response.data}');
    } catch (e) {
      print('❌ Failed to send push notification: $e');
    }
  }
  
  /// Trigger AI analysis for a message (non-blocking)
  Future<void> _triggerAIAnalysis(String messageId, String messageBody) async {
    try {
      final analysis = await _aiAnalysis.requestAnalysis(messageId, messageBody);
      if (analysis != null) {
        print('✨ AI analysis completed for ${messageId.substring(0, 8)}: ${analysis.tone}');
      }
    } catch (e) {
      print('⚠️ AI analysis failed for ${messageId.substring(0, 8)}: $e');
    }
  }
}
</file>

<file path="lib/services/network_connectivity_service.dart">
import 'dart:async';
import 'package:flutter/foundation.dart';

/// Network connectivity states
enum ConnectivityStatus {
  online,
  offline,
  unknown,
}

/// Service for monitoring network connectivity
/// Note: For production, consider using connectivity_plus package
class NetworkConnectivityService {
  static final NetworkConnectivityService _instance =
      NetworkConnectivityService._internal();

  factory NetworkConnectivityService() {
    return _instance;
  }

  NetworkConnectivityService._internal();

  final _statusController = StreamController<ConnectivityStatus>.broadcast();
  ConnectivityStatus _currentStatus = ConnectivityStatus.unknown;
  Timer? _pingTimer;
  bool _isMonitoring = false;

  /// Get current connectivity status
  ConnectivityStatus get currentStatus => _currentStatus;

  /// Stream of connectivity status changes
  Stream<ConnectivityStatus> get onStatusChange => _statusController.stream;

  /// Check if currently online
  bool get isOnline => _currentStatus == ConnectivityStatus.online;

  /// Check if currently offline
  bool get isOffline => _currentStatus == ConnectivityStatus.offline;

  /// Start monitoring connectivity
  void startMonitoring({Duration checkInterval = const Duration(seconds: 10)}) {
    if (_isMonitoring) {
      print('⚠️  Connectivity monitoring already started');
      return;
    }

    _isMonitoring = true;
    print('🌐 Starting connectivity monitoring (every ${checkInterval.inSeconds}s)');

    // Check immediately
    _checkConnectivity();

    // Then check periodically
    _pingTimer = Timer.periodic(checkInterval, (_) {
      _checkConnectivity();
    });
  }

  /// Stop monitoring connectivity
  void stopMonitoring() {
    _pingTimer?.cancel();
    _pingTimer = null;
    _isMonitoring = false;
    print('🌐 Stopped connectivity monitoring');
  }

  /// Check connectivity status
  Future<void> _checkConnectivity() async {
    try {
      // Simple connectivity check
      // In production, use connectivity_plus package for better detection
      final previousStatus = _currentStatus;
      final newStatus = await _performConnectivityCheck();

      if (newStatus != previousStatus) {
        _currentStatus = newStatus;
        _statusController.add(_currentStatus);
        _logStatusChange(previousStatus, newStatus);
      }
    } catch (e) {
      print('❌ Error checking connectivity: $e');
    }
  }

  /// Perform actual connectivity check
  /// Override this method to use connectivity_plus or other packages
  Future<ConnectivityStatus> _performConnectivityCheck() async {
    try {
      // For now, we assume online unless explicitly set offline
      // In production, use connectivity_plus to check actual network state
      
      // You can enhance this by:
      // 1. Using connectivity_plus package
      // 2. Pinging a known endpoint
      // 3. Checking platform-specific APIs
      
      return ConnectivityStatus.online;
    } catch (e) {
      return ConnectivityStatus.offline;
    }
  }

  /// Manually set connectivity status (useful for testing)
  void setStatus(ConnectivityStatus status) {
    if (_currentStatus != status) {
      final previousStatus = _currentStatus;
      _currentStatus = status;
      _statusController.add(_currentStatus);
      _logStatusChange(previousStatus, status);
    }
  }

  /// Force a connectivity check now
  Future<ConnectivityStatus> checkNow() async {
    final status = await _performConnectivityCheck();
    if (status != _currentStatus) {
      final previousStatus = _currentStatus;
      _currentStatus = status;
      _statusController.add(_currentStatus);
      _logStatusChange(previousStatus, status);
    }
    return _currentStatus;
  }

  /// Log status changes
  void _logStatusChange(
    ConnectivityStatus previous,
    ConnectivityStatus current,
  ) {
    final emoji = current == ConnectivityStatus.online ? '✅' : '📴';
    print('$emoji Connectivity: ${previous.name} → ${current.name}');
  }

  /// Dispose resources
  void dispose() {
    stopMonitoring();
    _statusController.close();
  }
}

/// Extension for convenience methods
extension ConnectivityStatusExtension on ConnectivityStatus {
  bool get isOnline => this == ConnectivityStatus.online;
  bool get isOffline => this == ConnectivityStatus.offline;
  bool get isUnknown => this == ConnectivityStatus.unknown;
}
</file>

<file path="lib/services/notification_service.dart">
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/foundation.dart' show kIsWeb;

/// Notification payload model
class NotificationPayload {
  final String? title;
  final String? body;
  final Map<String, dynamic> data;
  final String? messageId;

  NotificationPayload({
    this.title,
    this.body,
    required this.data,
    this.messageId,
  });

  /// Extract conversation ID from payload
  String? get conversationId => data['conversation_id'] as String?;

  /// Extract sender ID from payload
  String? get senderId => data['sender_id'] as String?;

  /// Extract message ID from payload
  String? get messageIdFromPayload => data['message_id'] as String?;

  /// Extract message body from payload
  String? get messageBody => data['message_body'] as String?;
}

/// Firebase Cloud Messaging service
class NotificationService {
  final FirebaseMessaging _messaging = FirebaseMessaging.instance;
  
  static const String _channelId = 'messages';
  static const String _channelName = 'Message Notifications';

  /// Initialize Firebase Messaging
  Future<void> initialize({
    required Function(NotificationPayload) onMessageReceived,
    required Function(String) onTokenRefresh,
  }) async {
    print('🔔 ========================================');
    print('🔔 INITIALIZING FIREBASE MESSAGING');
    print('🔔 ========================================');
    
    // Skip Firebase Messaging on web due to compatibility issues
    if (kIsWeb) {
      print('⚠️  Firebase Messaging not supported on web platform');
      return;
    }
    
    print('📱 Platform: Mobile (FCM supported)');
    
    try {
      print('📝 Requesting notification permissions...');
      // Request notification permissions
      final settings = await _messaging.requestPermission(
        alert: true,
        announcement: false,
        badge: true,
        criticalAlert: false,
        provisional: false,
        sound: true,
      );

      print('✅ Permission status: ${settings.authorizationStatus}');

      // Get initial token
      print('📱 Getting FCM device token...');
      final token = await getDeviceToken();
      if (token != null) {
        print('✅ FCM Token obtained: ${token.substring(0, 50)}...');
        print('   Full token: $token');
      } else {
        print('⚠️  No FCM token obtained');
      }

      // Listen for token refresh
      FirebaseMessaging.instance.onTokenRefresh.listen((newToken) {
        print('FCM Token refreshed: $newToken');
        onTokenRefresh(newToken);
      });

      // Listen for foreground messages
      FirebaseMessaging.onMessage.listen((RemoteMessage message) {
        print('Got a message whilst in the foreground!');
        print('Message data: ${message.data}');

        final payload = NotificationPayload(
          title: message.notification?.title,
          body: message.notification?.body,
          data: message.data,
          messageId: message.messageId,
        );

        onMessageReceived(payload);
      });

      // Handle background message (top-level function)
      // This should be registered before the app starts
    } catch (e, stackTrace) {
      print('❌ ========================================');
      print('❌ ERROR INITIALIZING FIREBASE MESSAGING');
      print('❌ ========================================');
      print('Error: $e');
      print('Stack trace: $stackTrace');
      print('❌ ========================================');
    }
  }

  /// Get device token for sending notifications
  Future<String?> getDeviceToken() async {
    if (kIsWeb) return null;
    
    try {
      final token = await _messaging.getToken();
      return token;
    } catch (e) {
      print('Error getting device token: $e');
      return null;
    }
  }

  /// Subscribe to a topic
  Future<void> subscribeToTopic(String topic) async {
    if (kIsWeb) return;
    
    try {
      await _messaging.subscribeToTopic(topic);
      print('Subscribed to topic: $topic');
    } catch (e) {
      print('Error subscribing to topic: $e');
    }
  }

  /// Unsubscribe from a topic
  Future<void> unsubscribeFromTopic(String topic) async {
    if (kIsWeb) return;
    
    try {
      await _messaging.unsubscribeFromTopic(topic);
      print('Unsubscribed from topic: $topic');
    } catch (e) {
      print('Error unsubscribing from topic: $e');
    }
  }

  /// Check if notifications are enabled
  Future<bool> areNotificationsEnabled() async {
    if (kIsWeb) return false;
    
    try {
      final settings = await _messaging.getNotificationSettings();
      return settings.authorizationStatus == AuthorizationStatus.authorized;
    } catch (e) {
      print('Error checking notification settings: $e');
      return false;
    }
  }

  /// Handle notification tap
  Future<void> setupNotificationTapHandler({
    required Function(String) onNotificationTapped,
  }) async {
    if (kIsWeb) return;
    
    try {
      // When the app is in foreground and user taps notification
      FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
        print('Notification tapped: ${message.data}');
        final conversationId = message.data['conversation_id'] as String?;
        if (conversationId != null) {
          onNotificationTapped(conversationId);
        }
      });

      // Check if app was opened from a notification when app was terminated
      final initialMessage = await _messaging.getInitialMessage();
      if (initialMessage != null) {
        print('App opened from notification: ${initialMessage.data}');
        final conversationId = initialMessage.data['conversation_id'] as String?;
        if (conversationId != null) {
          onNotificationTapped(conversationId);
        }
      }
    } catch (e) {
      print('Error setting up notification tap handler: $e');
    }
  }
}

/// Provider for notification service
final notificationServiceProvider = Provider<NotificationService>((ref) {
  return NotificationService();
});

/// Store device token
final deviceTokenProvider = StateProvider<String?>((ref) {
  return null;
});

/// Handle notification reception
final notificationHandlerProvider = FutureProvider<void>((ref) async {
  final service = ref.watch(notificationServiceProvider);
  
  // This would be called after the service is initialized
  // Placeholder for notification setup
});
</file>

<file path="lib/services/offline_queue_service.dart">
import 'dart:async';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/services/network_connectivity_service.dart';
import 'package:messageai/services/retry_service.dart';
import 'package:messageai/core/errors/app_error.dart';

/// Service for managing offline message queue and auto-sync
class OfflineQueueService {
  static final OfflineQueueService _instance =
      OfflineQueueService._internal();

  factory OfflineQueueService() {
    return _instance;
  }

  OfflineQueueService._internal();

  final _db = AppDb.instance;
  final _supabase = SupabaseClientProvider.client;
  final _connectivityService = NetworkConnectivityService();
  final _retryService = RetryService();

  StreamSubscription<ConnectivityStatus>? _connectivitySubscription;
  Timer? _syncTimer;
  bool _isSyncing = false;
  bool _isMonitoring = false;

  /// Start monitoring and auto-syncing
  void startMonitoring() {
    if (_isMonitoring) {
      return;
    }

    _isMonitoring = true;

    // Listen for connectivity changes - only sync when coming back online
    _connectivitySubscription = _connectivityService.onStatusChange.listen((status) {
      if (status == ConnectivityStatus.online) {
        syncPendingMessages();
      }
    });

    // No periodic polling - sync only happens:
    // 1. When connectivity is restored
    // 2. When explicitly requested (e.g., after sending a message)
  }

  /// Stop monitoring
  void stopMonitoring() {
    _connectivitySubscription?.cancel();
    _connectivitySubscription = null;
    _syncTimer?.cancel();
    _syncTimer = null;
    _isMonitoring = false;
    print('📦 Stopped offline queue monitoring');
  }

  /// Get count of pending messages
  Future<int> getPendingMessageCount() async {
    try {
      final messages = await _db.messageDao.getUnsyncedMessages();
      return messages.length;
    } catch (e) {
      print('❌ Error getting pending message count: $e');
      return 0;
    }
  }

  /// Sync all pending messages
  Future<SyncResult> syncPendingMessages() async {
    if (_isSyncing) {
      return SyncResult.alreadyRunning();
    }

    if (_connectivityService.isOffline) {
      return SyncResult.offline();
    }

    _isSyncing = true;
    int successCount = 0;
    int failureCount = 0;
    final List<String> failedMessageIds = [];

    try {
      final pendingMessages = await _db.messageDao.getUnsyncedMessages();

      if (pendingMessages.isEmpty) {
        return SyncResult.noMessages();
      }

      for (final message in pendingMessages) {
        final result = await _syncSingleMessage(message);
        if (result) {
          successCount++;
        } else {
          failureCount++;
          failedMessageIds.add(message.id);
        }
      }

      if (failureCount > 0) {
        print('⚠️ Sync: $successCount succeeded, $failureCount failed');
      }

      return SyncResult(
        totalMessages: pendingMessages.length,
        successCount: successCount,
        failureCount: failureCount,
        failedMessageIds: failedMessageIds,
      );
    } catch (e) {
      print('❌ Error syncing: $e');
      return SyncResult.error(e.toString());
    } finally {
      _isSyncing = false;
    }
  }

  /// Sync a single message with retry
  Future<bool> _syncSingleMessage(Message message) async {
    try {
      final result = await _retryService.execute(
        operation: () => _sendMessageToBackend(message),
        operationName: 'Sync Message ${message.id.substring(0, 8)}',
        config: RetryConfig.defaultConfig,
      );

      if (result.succeeded) {
        await _db.messageDao.markMessageAsSynced(message.id);
        return true;
      } else {
        final error = result.error;
        
        // If error is non-retryable, delete the message from queue
        if (error != null && !error.isRetryable) {
          print('🗑️ Removed invalid message: ${error.code}');
          await _db.messageDao.deleteMessage(message.id);
          return true;
        }
        
        return false;
      }
    } catch (e) {
      return false;
    }
  }

  /// Send message to backend
  Future<void> _sendMessageToBackend(Message message) async {
    final payload = {
      'id': message.id,
      'conversation_id': message.conversationId,
      'sender_id': message.senderId,
      'body': message.body,
      'media_url': message.mediaUrl,
      'created_at': DateTime.fromMillisecondsSinceEpoch(message.createdAt * 1000)
          .toIso8601String(),
      'updated_at': DateTime.fromMillisecondsSinceEpoch(message.updatedAt * 1000)
          .toIso8601String(),
    };

    await _supabase.from('messages').insert(payload);
    
    // Send push notification (don't wait for it)
    _sendPushNotification(message).catchError((e) {
      // Silently fail - push notifications are not critical
    });
  }

  /// Send push notification for message
  Future<void> _sendPushNotification(Message message) async {
    try {
      // Get sender profile (use maybeSingle to handle missing profile)
      final profile = await _supabase
          .from('profiles')
          .select('username, email')
          .eq('user_id', message.senderId)
          .maybeSingle();

      final senderName = profile?['username'] as String? ?? 
                         profile?['email'] as String? ?? 
                         'Someone';

      // Call push notification edge function with auth header
      final accessToken = _supabase.auth.currentSession?.accessToken;
      if (accessToken == null) return;
      
      await _supabase.functions.invoke(
        'push_notify',
        body: {
          'message_id': message.id,
          'conversation_id': message.conversationId,
          'sender_id': message.senderId,
          'sender_name': senderName,
          'title': senderName,
          'body': message.body,
        },
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      );
    } catch (e) {
      // Ignore errors
    }
  }

  /// Force sync now (called by user action)
  Future<SyncResult> forceSyncNow() async {
    print('🔄 Force sync requested');
    return await syncPendingMessages();
  }

  /// Check if any messages are pending
  Future<bool> hasPendingMessages() async {
    final count = await getPendingMessageCount();
    return count > 0;
  }

  /// Dispose resources
  void dispose() {
    stopMonitoring();
  }
}

/// Result of sync operation
class SyncResult {
  final int totalMessages;
  final int successCount;
  final int failureCount;
  final List<String> failedMessageIds;
  final String? errorMessage;
  final SyncStatus status;

  SyncResult({
    required this.totalMessages,
    required this.successCount,
    required this.failureCount,
    this.failedMessageIds = const [],
    this.errorMessage,
    this.status = SyncStatus.completed,
  });

  SyncResult.noMessages()
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          status: SyncStatus.noMessages,
        );

  SyncResult.offline()
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          status: SyncStatus.offline,
        );

  SyncResult.alreadyRunning()
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          status: SyncStatus.alreadyRunning,
        );

  SyncResult.error(String message)
      : this(
          totalMessages: 0,
          successCount: 0,
          failureCount: 0,
          errorMessage: message,
          status: SyncStatus.error,
        );

  bool get hasErrors => failureCount > 0 || errorMessage != null;
  bool get isSuccess => failureCount == 0 && errorMessage == null;
  bool get isPartialSuccess => successCount > 0 && failureCount > 0;
}

/// Status of sync operation
enum SyncStatus {
  completed,
  noMessages,
  offline,
  alreadyRunning,
  error,
}
</file>

<file path="lib/services/presence_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Service for tracking user presence and online status
class PresenceService {
  static final PresenceService _instance = PresenceService._internal();

  factory PresenceService() {
    return _instance;
  }

  PresenceService._internal();

  final _supabase = SupabaseClientProvider.client;
  final Map<String, RealtimeChannel> _channels = {};
  final Map<String, Set<String>> _onlineUsers = {};

  /// Subscribe to presence updates for a conversation
  Future<void> subscribeToPresence(String conversationId) async {
    if (_channels.containsKey(conversationId)) {
      return; // Already subscribed
    }

    final channel = _supabase.realtime.channel('presence:$conversationId');

    // Listen for presence events using the 'on' method
    channel.on(RealtimeListenTypes.presence, ChannelFilter(event: 'sync'), (payload, [ref]) {
      print('👥 Presence sync for $conversationId');
      _updateOnlineUsers(conversationId, channel);
    });

    channel.on(RealtimeListenTypes.presence, ChannelFilter(event: 'join'), (payload, [ref]) {
      print('👋 User joined: ${payload['user_id'] ?? 'unknown'}');
      _updateOnlineUsers(conversationId, channel);
    });

    channel.on(RealtimeListenTypes.presence, ChannelFilter(event: 'leave'), (payload, [ref]) {
      print('👋 User left: ${payload['user_id'] ?? 'unknown'}');
      _updateOnlineUsers(conversationId, channel);
    });

    // Subscribe with extended timeout for slower connections
    channel.subscribe(
      (status, [err]) {
        print('Presence subscription status: $status');
        if (status == 'SUBSCRIBED') {
          _updateOnlineUsers(conversationId, channel);
          // Periodically update to catch any missed events
          Future.delayed(const Duration(seconds: 1), () {
            _updateOnlineUsers(conversationId, channel);
          });
        }
        if (err != null) {
          print('Error subscribing to presence: $err');
        }
      },
      const Duration(seconds: 30), // Increased timeout for mobile networks
    );

    _channels[conversationId] = channel;
  }

  /// Unsubscribe from presence updates
  Future<void> unsubscribeFromPresence(String conversationId) async {
    final channel = _channels.remove(conversationId);
    if (channel != null) {
      await channel.unsubscribe();
    }
    _onlineUsers.remove(conversationId);
  }

  /// Broadcast user presence
  Future<void> setPresenceStatus(String conversationId, bool isOnline) async {
    final channel = _channels[conversationId];
    if (channel == null) return;

    final currentUser = _supabase.auth.currentUser;
    if (currentUser == null) return;

    try {
      await channel.track({
        'user_id': currentUser.id,
        'online': isOnline,
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('Error setting presence: $e');
    }
  }

  /// Get online users for a conversation
  Set<String> getOnlineUsers(String conversationId) {
    return _onlineUsers[conversationId] ?? {};
  }

  /// Check if a user is online
  bool isUserOnline(String conversationId, String userId) {
    return _onlineUsers[conversationId]?.contains(userId) ?? false;
  }

  void _updateOnlineUsers(String conversationId, RealtimeChannel channel) {
    try {
      final presenceState = channel.presenceState();
      final onlineSet = <String>{};

      // Iterate through all presence states
      for (final entry in presenceState.entries) {
        for (final presence in entry.value) {
          // Access the payload property which contains the tracked data
          final payload = presence.payload;
          if (payload is Map<String, dynamic>) {
            if (payload['online'] == true) {
              final userId = payload['user_id'] as String?;
              if (userId != null) {
                onlineSet.add(userId);
              }
            }
          }
        }
      }

      _onlineUsers[conversationId] = onlineSet;
      print('📊 Online users updated: ${onlineSet.length} users online');
    } catch (e) {
      print('Error updating online users: $e');
    }
  }

  /// Clean up all subscriptions
  Future<void> dispose() async {
    for (final channel in _channels.values) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        print('Error unsubscribing: $e');
      }
    }
    _channels.clear();
    _onlineUsers.clear();
  }
}
</file>

<file path="lib/services/realtime_diagnostic_service.dart">
import 'dart:async';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Diagnostic information about a Realtime channel
class RealtimeChannelDiagnostics {
  final String channelName;
  final String status;
  final DateTime subscribedAt;
  final DateTime? lastMessageAt;
  final int messagesReceived;
  final List<String> errors;
  final Duration? latency;

  RealtimeChannelDiagnostics({
    required this.channelName,
    required this.status,
    required this.subscribedAt,
    this.lastMessageAt,
    this.messagesReceived = 0,
    this.errors = const [],
    this.latency,
  });

  bool get isHealthy => status == 'SUBSCRIBED' && errors.isEmpty;
  
  Duration get timeSinceLastMessage => 
      lastMessageAt != null 
          ? DateTime.now().difference(lastMessageAt!)
          : Duration.zero;
}

/// Service for diagnosing and monitoring Realtime connections
class RealtimeDiagnosticService {
  static final RealtimeDiagnosticService _instance =
      RealtimeDiagnosticService._internal();

  factory RealtimeDiagnosticService() {
    return _instance;
  }

  RealtimeDiagnosticService._internal();

  final _supabase = SupabaseClientProvider.client;
  final Map<String, RealtimeChannelDiagnostics> _channelDiagnostics = {};
  final Map<String, DateTime> _messageTimestamps = {};
  Timer? _healthCheckTimer;
  bool _isMonitoring = false;

  /// Start monitoring Realtime health
  void startMonitoring({Duration checkInterval = const Duration(seconds: 5)}) {
    if (_isMonitoring) {
      return;
    }

    _isMonitoring = true;
    _healthCheckTimer = Timer.periodic(checkInterval, (_) {
      _performHealthCheck();
    });
  }

  /// Stop monitoring
  void stopMonitoring() {
    _healthCheckTimer?.cancel();
    _healthCheckTimer = null;
    _isMonitoring = false;
  }

  /// Register a channel for monitoring
  void registerChannel(String channelName, RealtimeChannel channel) {
    _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
      channelName: channelName,
      status: 'SUBSCRIBING',
      subscribedAt: DateTime.now(),
    );
  }

  /// Update channel status
  void updateChannelStatus(String channelName, String status) {
    final current = _channelDiagnostics[channelName];
    if (current != null) {
      _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
        channelName: channelName,
        status: status,
        subscribedAt: current.subscribedAt,
        lastMessageAt: current.lastMessageAt,
        messagesReceived: current.messagesReceived,
        errors: current.errors,
        latency: current.latency,
      );
    }
  }

  /// Record message received
  void recordMessageReceived(String channelName) {
    final current = _channelDiagnostics[channelName];
    if (current != null) {
      final now = DateTime.now();
      
      // Calculate latency if we have a timestamp
      Duration? latency;
      if (_messageTimestamps.containsKey(channelName)) {
        latency = now.difference(_messageTimestamps[channelName]!);
      }

      _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
        channelName: channelName,
        status: current.status,
        subscribedAt: current.subscribedAt,
        lastMessageAt: now,
        messagesReceived: current.messagesReceived + 1,
        errors: current.errors,
        latency: latency,
      );
    }
  }

  /// Record error
  void recordError(String channelName, String error) {
    final current = _channelDiagnostics[channelName];
    if (current != null) {
      final newErrors = List<String>.from(current.errors)..add(error);
      
      _channelDiagnostics[channelName] = RealtimeChannelDiagnostics(
        channelName: channelName,
        status: current.status,
        subscribedAt: current.subscribedAt,
        lastMessageAt: current.lastMessageAt,
        messagesReceived: current.messagesReceived,
        errors: newErrors,
        latency: current.latency,
      );

      print('❌ Error on $channelName: $error');
    }
  }

  /// Mark message send timestamp (for latency calculation)
  void markMessageSent(String channelName) {
    _messageTimestamps[channelName] = DateTime.now();
  }

  /// Perform health check on all channels
  void _performHealthCheck() {
    print('🏥 Realtime Health Check');
    print('━' * 60);

    if (_channelDiagnostics.isEmpty) {
      print('   No active channels');
      return;
    }

    for (final entry in _channelDiagnostics.entries) {
      final channel = entry.key;
      final diag = entry.value;

      final healthEmoji = diag.isHealthy ? '✅' : '⚠️';
      final statusEmoji = _getStatusEmoji(diag.status);

      print('$healthEmoji $channel');
      print('   $statusEmoji Status: ${diag.status}');
      print('   📊 Messages: ${diag.messagesReceived}');
      
      if (diag.lastMessageAt != null) {
        final timeSince = DateTime.now().difference(diag.lastMessageAt!);
        print('   ⏱️  Last message: ${timeSince.inSeconds}s ago');
      }

      if (diag.latency != null) {
        print('   🚀 Latency: ${diag.latency!.inMilliseconds}ms');
      }

      if (diag.errors.isNotEmpty) {
        print('   ❌ Errors: ${diag.errors.length}');
        for (final error in diag.errors.take(3)) {
          print('      - $error');
        }
      }

      final uptime = DateTime.now().difference(diag.subscribedAt);
      print('   ⏰ Uptime: ${_formatDuration(uptime)}');
      print('');
    }

    print('━' * 60);
  }

  /// Get emoji for status
  String _getStatusEmoji(String status) {
    switch (status) {
      case 'SUBSCRIBED':
        return '✅';
      case 'SUBSCRIBING':
        return '🔄';
      case 'CLOSED':
        return '⏸️';
      case 'CHANNEL_ERROR':
        return '❌';
      case 'TIMED_OUT':
        return '⏰';
      default:
        return '❓';
    }
  }

  /// Format duration nicely
  String _formatDuration(Duration duration) {
    if (duration.inSeconds < 60) {
      return '${duration.inSeconds}s';
    } else if (duration.inMinutes < 60) {
      return '${duration.inMinutes}m ${duration.inSeconds % 60}s';
    } else {
      return '${duration.inHours}h ${duration.inMinutes % 60}m';
    }
  }

  /// Get diagnostics for a channel
  RealtimeChannelDiagnostics? getDiagnostics(String channelName) {
    return _channelDiagnostics[channelName];
  }

  /// Get all diagnostics
  Map<String, RealtimeChannelDiagnostics> getAllDiagnostics() {
    return Map.from(_channelDiagnostics);
  }

  /// Test Realtime connection
  Future<RealtimeTestResult> testConnection() async {
    print('🧪 Testing Realtime connection...');
    
    final startTime = DateTime.now();
    final testChannel = _supabase.realtime.channel('test_${startTime.millisecondsSinceEpoch}');
    
    try {
      final completer = Completer<RealtimeTestResult>();
      var subscribeStatus = 'UNKNOWN';

      testChannel.subscribe(
        (status, [error]) {
          subscribeStatus = status;
          
          if (status == 'SUBSCRIBED') {
            final latency = DateTime.now().difference(startTime);
            completer.complete(RealtimeTestResult(
              success: true,
              latency: latency,
              status: status,
            ));
          } else if (status == 'CHANNEL_ERROR' || status == 'TIMED_OUT') {
            completer.complete(RealtimeTestResult(
            success: false,
            status: status,
            error: error?.toString(),
          ));
        }
      },
      const Duration(seconds: 30), // Test with 30s timeout
      );

      // Timeout after 10 seconds
      final result = await completer.future.timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          return RealtimeTestResult(
            success: false,
            status: 'TIMEOUT',
            error: 'Connection test timed out after 10 seconds',
          );
        },
      );

      // Clean up
      await testChannel.unsubscribe();

      return result;
    } catch (e) {
      return RealtimeTestResult(
        success: false,
        status: 'ERROR',
        error: e.toString(),
      );
    }
  }

  /// Generate diagnostic report
  String generateReport() {
    final buffer = StringBuffer();
    
    buffer.writeln('═' * 60);
    buffer.writeln('REALTIME DIAGNOSTICS REPORT');
    buffer.writeln('Generated: ${DateTime.now()}');
    buffer.writeln('═' * 60);
    buffer.writeln();

    if (_channelDiagnostics.isEmpty) {
      buffer.writeln('No active channels');
      return buffer.toString();
    }

    for (final entry in _channelDiagnostics.entries) {
      final diag = entry.value;
      
      buffer.writeln('Channel: ${diag.channelName}');
      buffer.writeln('  Status: ${diag.status} ${diag.isHealthy ? '✓' : '✗'}');
      buffer.writeln('  Messages Received: ${diag.messagesReceived}');
      buffer.writeln('  Subscribed At: ${diag.subscribedAt}');
      
      if (diag.lastMessageAt != null) {
        buffer.writeln('  Last Message: ${diag.lastMessageAt}');
        buffer.writeln('  Time Since Last: ${diag.timeSinceLastMessage.inSeconds}s');
      }
      
      if (diag.latency != null) {
        buffer.writeln('  Latency: ${diag.latency!.inMilliseconds}ms');
      }
      
      if (diag.errors.isNotEmpty) {
        buffer.writeln('  Errors: ${diag.errors.length}');
        for (final error in diag.errors) {
          buffer.writeln('    - $error');
        }
      }
      
      buffer.writeln();
    }

    buffer.writeln('═' * 60);
    return buffer.toString();
  }

  /// Dispose resources
  void dispose() {
    stopMonitoring();
    _channelDiagnostics.clear();
    _messageTimestamps.clear();
  }
}

/// Result of Realtime connection test
class RealtimeTestResult {
  final bool success;
  final Duration? latency;
  final String status;
  final String? error;

  RealtimeTestResult({
    required this.success,
    this.latency,
    required this.status,
    this.error,
  });

  @override
  String toString() {
    if (success) {
      return 'SUCCESS: Connected in ${latency?.inMilliseconds}ms (Status: $status)';
    } else {
      return 'FAILED: $status${error != null ? ' - $error' : ''}';
    }
  }
}
</file>

<file path="lib/services/realtime_message_service.dart">
import 'dart:async';
import 'package:uuid/uuid.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/services/realtime_diagnostic_service.dart';
import 'package:messageai/services/ai_analysis_service.dart';

/// Service for real-time message synchronization
class RealTimeMessageService {
  static final RealTimeMessageService _instance =
      RealTimeMessageService._internal();

  factory RealTimeMessageService() {
    return _instance;
  }

  RealTimeMessageService._internal();

  final _supabase = SupabaseClientProvider.client;
  final _db = AppDb.instance;
  final _diagnostics = RealtimeDiagnosticService();
  final _aiAnalysis = AIAnalysisService();
  final Map<String, RealtimeChannel> _channels = {};
  final Map<String, RealtimeChannel> _receiptChannels = {};
  final Map<String, StreamController<List<Message>>> _messageControllers = {};
  final Map<String, StreamController<List<Receipt>>> _receiptControllers = {};

  /// Subscribe to real-time messages for a conversation
  Stream<List<Message>> subscribeToMessages(String conversationId) {
    if (_messageControllers.containsKey(conversationId)) {
      return _messageControllers[conversationId]!.stream;
    }

    final controller = StreamController<List<Message>>.broadcast();
    _messageControllers[conversationId] = controller;

    _setupRealtimeListener(conversationId, controller);

    return controller.stream;
  }

  void _setupRealtimeListener(
    String conversationId,
    StreamController<List<Message>> controller,
  ) {
    try {
      final channelName = 'messages:$conversationId';
      final channel = _supabase.realtime.channel(channelName);
      
      // Register channel for diagnostics
      _diagnostics.registerChannel(channelName, channel);
      
      // Listen for postgres changes using the correct API
      channel.on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          filter: 'conversation_id=eq.$conversationId',
        ),
        (payload, [ref]) async {
          _diagnostics.recordMessageReceived(channelName);
          print('📨 Realtime message received');
          
          try {
            final data = payload['new'] as Map<String, dynamic>;
            final timestamp = DateTime.parse(data['created_at'] as String)
                .millisecondsSinceEpoch ~/
                1000;
            
            final message = Message(
              id: data['id'] as String,
              conversationId: data['conversation_id'] as String,
              senderId: data['sender_id'] as String,
              body: data['body'] as String,
              mediaUrl: data['media_url'] as String?,
              createdAt: timestamp,
              updatedAt: DateTime.parse(data['updated_at'] as String)
                  .millisecondsSinceEpoch ~/
                  1000,
              isSynced: true,
            );
            
            await _db.messageDao.upsertMessage(message);
            
            // Refresh the stream
            final messages =
                await _db.messageDao.getMessagesByConversation(conversationId);
            controller.add(messages);
            print('✅ UI updated with ${messages.length} messages');
            
            // Create delivery receipt for received message
            final currentUser = _supabase.auth.currentUser;
            if (currentUser != null && message.senderId != currentUser.id) {
              await _createReceipt(message.id, currentUser.id, 'delivered');
              
              // Trigger AI analysis for received messages (non-blocking)
              _triggerAIAnalysis(message);
            }
          } catch (e) {
            print('❌ Error processing message: $e');
          }
        },
      );

      // Subscribe with extended timeout for slower connections
      channel.subscribe(
        (status, [err]) {
          _diagnostics.updateChannelStatus(channelName, status);
          
          // Log all status changes for debugging
          print('📡 Realtime [$conversationId]: $status');
          
          if (status == 'CHANNEL_ERROR' || status == 'TIMED_OUT' || err != null) {
            print('❌ Realtime error for $conversationId: $status ${err ?? ""}');
            if (err != null) {
              _diagnostics.recordError(channelName, err.toString());
              controller.addError(err);
            }
          }
        },
        const Duration(seconds: 30), // Increased timeout for mobile networks
      );

      _channels[conversationId] = channel;
      
      // Load initial messages
      Future.delayed(Duration.zero, () async {
        try {
          final messages =
              await _db.messageDao.getMessagesByConversation(conversationId);
          controller.add(messages);
        } catch (e) {
          controller.addError(e);
        }
      });
    } catch (e) {
      print('Error setting up realtime listener: $e');
      controller.addError(e);
    }
  }

  /// Trigger AI analysis for a message (non-blocking)
  void _triggerAIAnalysis(Message message) {
    // Run in background, don't await
    _aiAnalysis.requestAnalysis(message.id, message.body).then((analysis) {
      if (analysis != null) {
        print('✨ AI analysis completed for ${message.id.substring(0, 8)}: ${analysis.tone}');
      }
    }).catchError((error) {
      print('⚠️ AI analysis failed for ${message.id.substring(0, 8)}: $error');
    });
  }

  Future<void> _createReceipt(String messageId, String userId, String status) async {
    try {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final receiptId = const Uuid().v4();
      
      await _db.receiptDao.addReceipt(Receipt(
        id: receiptId,
        messageId: messageId,
        userId: userId,
        status: status,
        createdAt: now,
        updatedAt: now,
        isSynced: false,
      ));
      
      // Note: message_receipts table uses 'at' column, not 'created_at'
      await _supabase.from('message_receipts').insert({
        'id': receiptId,
        'message_id': messageId,
        'user_id': userId,
        'status': status,
        'at': DateTime.fromMillisecondsSinceEpoch(now * 1000).toIso8601String(),
      });
      
      await _db.receiptDao.markReceiptAsSynced(receiptId);
    } catch (e) {
      // Silently fail - receipts are not critical
    }
  }

  /// Subscribe to real-time receipts for a conversation
  Stream<List<Receipt>> subscribeToReceipts(String conversationId) {
    if (_receiptControllers.containsKey(conversationId)) {
      return _receiptControllers[conversationId]!.stream;
    }

    final controller = StreamController<List<Receipt>>.broadcast();
    _receiptControllers[conversationId] = controller;

    _setupReceiptListener(conversationId, controller);

    return controller.stream;
  }

  void _setupReceiptListener(
    String conversationId,
    StreamController<List<Receipt>> controller,
  ) {
    try {
      final channelName = 'receipts:$conversationId';
      final channel = _supabase.realtime.channel(channelName);
      
      // Listen for receipt changes
      channel.on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: '*',  // All events (INSERT, UPDATE)
          schema: 'public',
          table: 'message_receipts',
        ),
        (payload, [ref]) async {
          print('📨 Receipt change received');
          
          try {
            // Reload all receipts for this conversation
            final receipts = await _db.receiptDao.getReceiptsByConversation(conversationId);
            controller.add(receipts);
          } catch (e) {
            print('❌ Error processing receipt: $e');
          }
        },
      );

      channel.subscribe(
        (status, [err]) {
          print('📡 Receipts [$conversationId]: $status');
          if (err != null) {
            controller.addError(err);
          }
        },
        const Duration(seconds: 30),
      );

      _receiptChannels[conversationId] = channel;
      
      // Load initial receipts
      Future.delayed(Duration.zero, () async {
        try {
          final receipts = await _db.receiptDao.getReceiptsByConversation(conversationId);
          controller.add(receipts);
        } catch (e) {
          controller.addError(e);
        }
      });
    } catch (e) {
      print('Error setting up receipt listener: $e');
      controller.addError(e);
    }
  }

  /// Unsubscribe from real-time messages
  Future<void> unsubscribeFromMessages(String conversationId) async {
    final controller = _messageControllers.remove(conversationId);
    controller?.close();

    final channel = _channels.remove(conversationId);
    if (channel != null) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
  }

  /// Unsubscribe from real-time receipts
  Future<void> unsubscribeFromReceipts(String conversationId) async {
    final controller = _receiptControllers.remove(conversationId);
    controller?.close();

    final channel = _receiptChannels.remove(conversationId);
    if (channel != null) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
  }

  /// Clean up all subscriptions
  Future<void> dispose() async {
    for (final controller in _messageControllers.values) {
      controller.close();
    }
    _messageControllers.clear();

    for (final controller in _receiptControllers.values) {
      controller.close();
    }
    _receiptControllers.clear();

    for (final channel in _channels.values) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
    _channels.clear();

    for (final channel in _receiptChannels.values) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        // Ignore unsubscribe errors
      }
    }
    _receiptChannels.clear();
    
    _diagnostics.dispose();
  }

  /// Get diagnostic report
  String getDiagnosticsReport() {
    return _diagnostics.generateReport();
  }

  /// Start diagnostic monitoring
  void startDiagnostics() {
    _diagnostics.startMonitoring();
  }

  /// Stop diagnostic monitoring
  void stopDiagnostics() {
    _diagnostics.stopMonitoring();
  }

  /// Test Realtime connection
  Future<RealtimeTestResult> testConnection() {
    return _diagnostics.testConnection();
  }
}
</file>

<file path="lib/services/relationship_service.dart">
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/models/relationship_profile.dart';
import 'package:messageai/models/safe_topic.dart';

/// Service for managing relationship profiles
class RelationshipService {
  static final RelationshipService _instance = RelationshipService._internal();
  factory RelationshipService() => _instance;
  RelationshipService._internal();

  final _supabase = SupabaseClientProvider.client;

  /// Get relationship profile for a conversation
  Future<RelationshipProfile?> getProfile(String conversationId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return null;

      final response = await _supabase.rpc('get_relationship_profile', params: {
        'p_user_id': userId,
        'p_conversation_id': conversationId,
      });

      if (response == null || response.isEmpty) return null;

      return RelationshipProfile.fromJson({
        'user_id': userId,
        'conversation_id': conversationId,
        ...response as Map<String, dynamic>,
      });
    } catch (e) {
      print('Error getting relationship profile: $e');
      return null;
    }
  }

  /// Get safe topics for a conversation
  Future<List<SafeTopic>> getSafeTopics(String conversationId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return [];

      final response = await _supabase.rpc('get_safe_topics', params: {
        'p_user_id': userId,
        'p_conversation_id': conversationId,
      });

      if (response == null) return [];

      return (response as List)
          .map((data) => SafeTopic.fromJson(data as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('Error getting safe topics: $e');
      return [];
    }
  }

  /// Update relationship notes
  Future<void> updateNotes(String conversationId, String notes) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      await _supabase
          .from('relationship_profiles')
          .update({'relationship_notes': notes})
          .eq('user_id', userId)
          .eq('conversation_id', conversationId);
    } catch (e) {
      print('Error updating notes: $e');
      rethrow;
    }
  }

  /// Update relationship type
  Future<void> updateRelationshipType(
    String conversationId,
    String relationshipType,
  ) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return;

      await _supabase
          .from('relationship_profiles')
          .update({'relationship_type': relationshipType})
          .eq('user_id', userId)
          .eq('conversation_id', conversationId);
    } catch (e) {
      print('Error updating relationship type: $e');
      rethrow;
    }
  }
}
</file>

<file path="lib/services/relationship_summary_service.dart">
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/models/relationship_profile.dart';

/// Service for generating relationship summaries (Phase 3: Context System)
class RelationshipSummaryService {
  final SupabaseClient _supabase;

  RelationshipSummaryService(this._supabase);

  /// Generate or update relationship summary
  Future<RelationshipProfile> generateSummary({
    required String conversationId,
    bool forceRegenerate = false,
  }) async {
    try {
      print('👥 Generating relationship summary...');
      
      final response = await _supabase.functions.invoke(
        'ai-relationship-summary',
        body: {
          'conversation_id': conversationId,
          'force_regenerate': forceRegenerate,
        },
      );

      if (response.data == null) {
        throw Exception('No response from relationship summary service');
      }

      final data = response.data as Map<String, dynamic>;
      
      if (data['success'] != true) {
        throw Exception(data['error'] ?? 'Summary generation failed');
      }

      final profile = RelationshipProfile.fromJson(
        data['profile'] as Map<String, dynamic>,
      );
      
      print('✅ Relationship summary generated');
      
      return profile;
    } catch (e) {
      print('❌ Error generating relationship summary: $e');
      rethrow;
    }
  }

  /// Refresh relationship summary (force regenerate)
  Future<RelationshipProfile> refreshSummary({
    required String conversationId,
  }) async {
    return generateSummary(
      conversationId: conversationId,
      forceRegenerate: true,
    );
  }
}
</file>

<file path="lib/services/response_template_service.dart">
import 'package:messageai/models/response_template.dart';
import 'package:messageai/models/situation_type.dart';

/// Service for managing response templates
class ResponseTemplateService {
  static final ResponseTemplateService _instance = 
      ResponseTemplateService._internal();
  factory ResponseTemplateService() => _instance;
  ResponseTemplateService._internal();

  // In-memory template storage (loaded from backend)
  final Map<String, ResponseTemplate> _templates = {};
  final Map<SituationType, List<String>> _templatesBySituation = {};
  bool _initialized = false;

  /// Initialize templates (call on app start)
  Future<void> loadTemplates() async {
    if (_initialized) return;
    
    // TODO: Load from backend or local storage
    // For now, using hardcoded templates
    _initializeHardcodedTemplates();
    _initialized = true;
  }

  /// Get template by ID
  ResponseTemplate? getTemplate(String id) {
    return _templates[id];
  }

  /// Get templates for a situation type
  List<ResponseTemplate> getTemplatesForSituation(SituationType situation) {
    final templateIds = _templatesBySituation[situation] ?? [];
    return templateIds
        .map((id) => _templates[id])
        .whereType<ResponseTemplate>()
        .toList();
  }

  /// Get all templates
  List<ResponseTemplate> getAllTemplates() {
    return _templates.values.toList();
  }

  /// Search templates by keywords
  List<ResponseTemplate> searchTemplates(String query) {
    final lowerQuery = query.toLowerCase();
    return _templates.values.where((template) {
      return template.name.toLowerCase().contains(lowerQuery) ||
             template.situation.toLowerCase().contains(lowerQuery) ||
             template.context.any((c) => c.toLowerCase().contains(lowerQuery));
    }).toList();
  }

  void _initializeHardcodedTemplates() {
    // Declining templates
    final decliningTemplates = [
      ResponseTemplate(
        id: 'decline_polite',
        name: 'Polite Decline',
        situation: 'When you need to say no professionally',
        template: "Thank you for thinking of me! Unfortunately, I won't be able to {activity} {timeframe}. I appreciate your understanding.",
        tone: 'polite',
        context: ['can you', 'would you', 'invitation'],
        neurodivergentFriendly: true,
        customizableFields: ['activity', 'timeframe'],
      ),
      ResponseTemplate(
        id: 'decline_no_explanation',
        name: 'Direct Decline',
        situation: "When you don't owe an explanation",
        template: "Thanks for the invite, but I'm not able to join this time.",
        tone: 'direct',
        context: ['party', 'event', 'hangout'],
        neurodivergentFriendly: true,
      ),
      ResponseTemplate(
        id: 'decline_with_alternative',
        name: 'Decline with Counter-Offer',
        situation: 'When you want to participate but need different terms',
        template: "I can't {original_request}, but I could {alternative}. Would that work?",
        tone: 'casual',
        context: ['meeting', 'call', 'hangout'],
        neurodivergentFriendly: true,
        customizableFields: ['original_request', 'alternative'],
      ),
      ResponseTemplate(
        id: 'decline_capacity',
        name: 'At Capacity (Mental Health)',
        situation: 'When you need to protect your energy',
        template: "I really appreciate you thinking of me, but I need to be mindful of my capacity right now. I'll have to pass on this one.",
        tone: 'apologetic',
        context: ['favor', 'help', 'support'],
        neurodivergentFriendly: true,
      ),
    ];

    // Boundary templates
    final boundaryTemplates = [
      ResponseTemplate(
        id: 'boundary_time',
        name: 'Time Boundary',
        situation: 'When someone expects 24/7 availability',
        template: "I'm available to discuss this during {your_hours}. Can we schedule a time within those hours?",
        tone: 'direct',
        context: ['urgent', 'right now', 'immediately'],
        neurodivergentFriendly: true,
        customizableFields: ['your_hours'],
      ),
      ResponseTemplate(
        id: 'boundary_communication',
        name: 'Communication Preference',
        situation: "When someone uses a communication method that doesn't work for you",
        template: "I process information better through {preferred_method}. Could we switch to that for this conversation?",
        tone: 'direct',
        context: ['call', 'video', 'meeting'],
        neurodivergentFriendly: true,
        customizableFields: ['preferred_method'],
      ),
      ResponseTemplate(
        id: 'boundary_topic',
        name: 'Topic Boundary',
        situation: "When someone brings up something you don't want to discuss",
        template: "I'm not comfortable discussing {topic}. Let's talk about something else.",
        tone: 'direct',
        context: ['personal', 'private', 'politics'],
        neurodivergentFriendly: true,
        customizableFields: ['topic'],
      ),
    ];

    // Info-dump templates
    final infoDumpTemplates = [
      ResponseTemplate(
        id: 'infodump_intro',
        name: 'Info-Dump with Warning',
        situation: 'When you want to share a lot about something you love',
        template: "I'm really excited about {topic}! Fair warning: I could talk about this for hours 😊 Are you interested in hearing more?",
        tone: 'casual',
        context: ['excited', 'interesting', 'found'],
        neurodivergentFriendly: true,
        customizableFields: ['topic'],
      ),
      ResponseTemplate(
        id: 'infodump_chunked',
        name: 'Info-Dump in Chunks',
        situation: 'When you want to share but keep it digestible',
        template: "Quick version: {short_summary}\n\nWant the details? I can break it down into:\n1. {aspect_1}\n2. {aspect_2}\n3. {aspect_3}\n\nLet me know what interests you!",
        tone: 'casual',
        context: ['explain', 'tell', 'share'],
        neurodivergentFriendly: true,
        customizableFields: ['short_summary', 'aspect_1', 'aspect_2', 'aspect_3'],
      ),
    ];

    // Apologizing templates
    final apologizingTemplates = [
      ResponseTemplate(
        id: 'apology_genuine',
        name: 'Genuine Apology',
        situation: 'When you actually did something wrong',
        template: "I'm sorry for {what_you_did}. I understand that {impact}. Going forward, I'll {corrective_action}.",
        tone: 'apologetic',
        context: ['mistake', 'wrong', 'messed up'],
        neurodivergentFriendly: true,
        customizableFields: ['what_you_did', 'impact', 'corrective_action'],
      ),
      ResponseTemplate(
        id: 'apology_no_need',
        name: 'Replace Unnecessary Apology',
        situation: "When you're apologizing out of habit",
        template: "Thank you for {what_they_did}. I appreciate {specific_thing}.",
        tone: 'polite',
        context: ['sorry for', 'apologies for'],
        neurodivergentFriendly: true,
        customizableFields: ['what_they_did', 'specific_thing'],
      ),
    ];

    // Clarifying templates
    final clarifyingTemplates = [
      ResponseTemplate(
        id: 'clarify_misunderstand',
        name: 'Admit Confusion',
        situation: "When you don't understand something",
        template: "I want to make sure I understand correctly. Are you saying {your_interpretation}?",
        tone: 'direct',
        context: ['confused', 'unclear', 'not sure'],
        neurodivergentFriendly: true,
        customizableFields: ['your_interpretation'],
      ),
      ResponseTemplate(
        id: 'clarify_literal',
        name: 'Ask for Literal Meaning',
        situation: 'When you need things stated directly',
        template: "I'm having trouble reading between the lines. Could you tell me directly what you need from me?",
        tone: 'direct',
        context: ['ambiguous', 'vague', 'hint'],
        neurodivergentFriendly: true,
      ),
    ];

    // Store templates
    final allTemplates = [
      ...decliningTemplates,
      ...boundaryTemplates,
      ...infoDumpTemplates,
      ...apologizingTemplates,
      ...clarifyingTemplates,
    ];
    
    for (final template in allTemplates) {
      _templates[template.id] = template;
    }

    // Index by situation
    _templatesBySituation[SituationType.declining] = 
        decliningTemplates.map((t) => t.id).toList();
    _templatesBySituation[SituationType.boundarySetting] = 
        boundaryTemplates.map((t) => t.id).toList();
    _templatesBySituation[SituationType.infoDumping] = 
        infoDumpTemplates.map((t) => t.id).toList();
    _templatesBySituation[SituationType.apologizing] = 
        apologizingTemplates.map((t) => t.id).toList();
    _templatesBySituation[SituationType.clarifying] = 
        clarifyingTemplates.map((t) => t.id).toList();
  }
}
</file>

<file path="lib/services/retry_service.dart">
import 'dart:async';
import 'dart:math';
import 'package:messageai/core/errors/app_error.dart';
import 'package:messageai/core/errors/error_handler.dart';

/// Configuration for retry behavior
class RetryConfig {
  final int maxAttempts;
  final Duration initialDelay;
  final Duration maxDelay;
  final double backoffMultiplier;
  final bool useJitter;

  const RetryConfig({
    this.maxAttempts = 3,
    this.initialDelay = const Duration(seconds: 1),
    this.maxDelay = const Duration(seconds: 30),
    this.backoffMultiplier = 2.0,
    this.useJitter = true,
  });

  /// Aggressive retry (more attempts, faster)
  static const aggressive = RetryConfig(
    maxAttempts: 5,
    initialDelay: Duration(milliseconds: 500),
    maxDelay: Duration(seconds: 15),
  );

  /// Conservative retry (fewer attempts, slower)
  static const conservative = RetryConfig(
    maxAttempts: 2,
    initialDelay: Duration(seconds: 2),
    maxDelay: Duration(seconds: 60),
  );

  /// Default retry configuration
  static const defaultConfig = RetryConfig();
}

/// Result of a retry operation
class RetryResult<T> {
  final T? data;
  final AppError? error;
  final int attempts;
  final bool succeeded;

  RetryResult({
    this.data,
    this.error,
    required this.attempts,
    required this.succeeded,
  });

  RetryResult.success(T data, int attempts)
      : this(
          data: data,
          succeeded: true,
          attempts: attempts,
        );

  RetryResult.failure(AppError error, int attempts)
      : this(
          error: error,
          succeeded: false,
          attempts: attempts,
        );
}

/// Service for handling retries with exponential backoff
class RetryService {
  static final RetryService _instance = RetryService._internal();

  factory RetryService() {
    return _instance;
  }

  RetryService._internal();

  final _errorHandler = ErrorHandler();
  final _random = Random();

  /// Execute operation with retry logic
  Future<RetryResult<T>> execute<T>({
    required Future<T> Function() operation,
    required String operationName,
    RetryConfig config = RetryConfig.defaultConfig,
    bool Function(AppError)? shouldRetry,
  }) async {
    int attemptNumber = 0;
    AppError? lastError;

    while (attemptNumber < config.maxAttempts) {
      attemptNumber++;

      try {
        final result = await operation();
        return RetryResult.success(result, attemptNumber);
      } catch (error, stackTrace) {
        // Convert to AppError
        final appError = error is AppError
            ? error
            : _errorHandler.handleError(
                error,
                stackTrace: stackTrace,
                context: operationName,
              );

        lastError = appError;

        // Check if we should retry
        final shouldRetryThis = shouldRetry?.call(appError) ??
            _errorHandler.shouldRetry(appError, attemptNumber, maxAttempts: config.maxAttempts);

        if (!shouldRetryThis) {
          return RetryResult.failure(appError, attemptNumber);
        }

        // Calculate delay before next attempt
        if (attemptNumber < config.maxAttempts) {
          final delay = _calculateDelay(
            attemptNumber,
            config: config,
          );
          await Future.delayed(delay);
        }
      }
    }

    return RetryResult.failure(
      lastError ?? AppError(
        category: ErrorCategory.unknown,
        severity: ErrorSeverity.error,
        code: 'RETRY001',
        message: 'Max retry attempts exceeded',
        userMessage: 'Operation failed after multiple attempts',
      ),
      attemptNumber,
    );
  }

  /// Calculate delay for next retry attempt (exponential backoff with jitter)
  Duration _calculateDelay(int attemptNumber, {required RetryConfig config}) {
    // Calculate base delay: initialDelay * (backoffMultiplier ^ attemptNumber)
    final exponentialDelay = config.initialDelay.inMilliseconds *
        pow(config.backoffMultiplier, attemptNumber - 1);

    // Cap at max delay
    final cappedDelay = min(exponentialDelay, config.maxDelay.inMilliseconds.toDouble());

    // Add jitter to avoid thundering herd
    final delayWithJitter = config.useJitter
        ? _addJitter(cappedDelay.toDouble())
        : cappedDelay.toDouble();

    return Duration(milliseconds: delayWithJitter.round());
  }

  /// Add random jitter to delay (±25%)
  double _addJitter(double delay) {
    final jitterRange = delay * 0.25; // ±25%
    final jitter = (_random.nextDouble() * 2 - 1) * jitterRange;
    return delay + jitter;
  }

  /// Execute with simple retry (no configuration)
  Future<T> executeSimple<T>({
    required Future<T> Function() operation,
    int maxAttempts = 3,
  }) async {
    final result = await execute(
      operation: operation,
      operationName: 'Operation',
      config: RetryConfig(maxAttempts: maxAttempts),
    );

    if (result.succeeded) {
      return result.data as T;
    } else {
      throw result.error!;
    }
  }

  /// Execute with timeout and retry
  Future<RetryResult<T>> executeWithTimeout<T>({
    required Future<T> Function() operation,
    required String operationName,
    Duration timeout = const Duration(seconds: 30),
    RetryConfig config = RetryConfig.defaultConfig,
  }) async {
    return execute<T>(
      operation: () async {
        return await operation().timeout(
          timeout,
          onTimeout: () {
            throw AppError(
              category: ErrorCategory.network,
              severity: ErrorSeverity.warning,
              code: 'NET002',
              message: 'Operation timeout',
              userMessage: 'The operation took too long. Please try again.',
              isRetryable: true,
            );
          },
        );
      },
      operationName: operationName,
      config: config,
    );
  }
}

/// Extension to add retry capability to Future
extension RetryExtension<T> on Future<T> {
  /// Retry this future with exponential backoff
  Future<T> withRetry({
    String operationName = 'Operation',
    int maxAttempts = 3,
  }) async {
    final retryService = RetryService();
    return retryService.executeSimple(
      operation: () => this,
      maxAttempts: maxAttempts,
    );
  }

  /// Retry with full configuration
  Future<RetryResult<T>> withRetryConfig({
    required String operationName,
    RetryConfig config = RetryConfig.defaultConfig,
  }) async {
    final retryService = RetryService();
    return retryService.execute(
      operation: () => this,
      operationName: operationName,
      config: config,
    );
  }
}
</file>

<file path="lib/services/typing_indicator_service.dart">
import 'dart:async';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:messageai/data/remote/supabase_client.dart';

/// Service to handle typing indicators using Supabase Realtime
class TypingIndicatorService {
  static final TypingIndicatorService _instance = TypingIndicatorService._internal();
  factory TypingIndicatorService() => _instance;
  TypingIndicatorService._internal();

  final _supabase = SupabaseClientProvider.client;
  final Map<String, RealtimeChannel> _channels = {};
  final Map<String, Set<String>> _typingUsers = {}; // conversationId -> Set of userIds
  final Map<String, StreamController<Set<String>>> _typingControllers = {};
  final Map<String, Timer?> _typingTimeouts = {}; // userId -> Timer

  static const _typingTimeout = Duration(seconds: 3);

  /// Subscribe to typing events for a conversation
  Stream<Set<String>> subscribeToTyping(String conversationId) {
    // Return existing stream if already subscribed
    if (_typingControllers.containsKey(conversationId)) {
      return _typingControllers[conversationId]!.stream;
    }

    // Create new stream controller
    final controller = StreamController<Set<String>>.broadcast();
    _typingControllers[conversationId] = controller;
    _typingUsers[conversationId] = {};

    // Create channel for this conversation
    final channel = _supabase.channel('typing:$conversationId');
    _channels[conversationId] = channel;

    // Listen for typing events using on() method
    channel.on(
      RealtimeListenTypes.broadcast,
      ChannelFilter(event: 'typing'),
      (payload, [ref]) {
        final data = payload as Map<String, dynamic>;
        final userId = data['user_id'] as String?;
        final isTyping = data['is_typing'] as bool? ?? false;
        final currentUserId = _supabase.auth.currentUser?.id;

        // Ignore own typing events
        if (userId == null || userId == currentUserId) return;

        final typingSet = _typingUsers[conversationId] ?? {};

        if (isTyping) {
          typingSet.add(userId);
          
          // Clear existing timeout for this user
          _typingTimeouts['$conversationId:$userId']?.cancel();
          
          // Set timeout to remove user from typing after inactivity
          _typingTimeouts['$conversationId:$userId'] = Timer(_typingTimeout, () {
            typingSet.remove(userId);
            _typingUsers[conversationId] = typingSet;
            if (!controller.isClosed) {
              controller.add(Set.from(typingSet));
            }
          });
        } else {
          typingSet.remove(userId);
          _typingTimeouts['$conversationId:$userId']?.cancel();
        }

        _typingUsers[conversationId] = typingSet;
        if (!controller.isClosed) {
          controller.add(Set.from(typingSet));
        }
      },
    );

    // Subscribe to channel with extended timeout
    channel.subscribe(
      (status, [err]) {
        print('Typing indicator subscription status: $status');
        if (err != null) {
          print('Error subscribing to typing indicator: $err');
        }
      },
      const Duration(seconds: 30), // Increased timeout for mobile networks
    );

    return controller.stream;
  }

  /// Send typing indicator
  Future<void> sendTypingIndicator(String conversationId, bool isTyping) async {
    final channel = _channels[conversationId];
    if (channel == null) return;

    final currentUserId = _supabase.auth.currentUser?.id;
    if (currentUserId == null) return;

    try {
      channel.send(
        type: RealtimeListenTypes.broadcast,
        event: 'typing',
        payload: {
          'user_id': currentUserId,
          'is_typing': isTyping,
        },
      );
    } catch (e) {
      print('Error sending typing indicator: $e');
    }
  }

  /// Unsubscribe from typing events for a conversation
  Future<void> unsubscribeFromTyping(String conversationId) async {
    final channel = _channels[conversationId];
    if (channel != null) {
      await channel.unsubscribe();
      _channels.remove(conversationId);
    }

    final controller = _typingControllers[conversationId];
    if (controller != null && !controller.isClosed) {
      await controller.close();
    }
    _typingControllers.remove(conversationId);
    _typingUsers.remove(conversationId);

    // Clear all timeouts for this conversation
    final keysToRemove = _typingTimeouts.keys
        .where((key) => key.startsWith('$conversationId:'))
        .toList();
    for (final key in keysToRemove) {
      _typingTimeouts[key]?.cancel();
      _typingTimeouts.remove(key);
    }
  }

  /// Get current typing users for a conversation
  Set<String> getTypingUsers(String conversationId) {
    return Set.from(_typingUsers[conversationId] ?? {});
  }

  /// Clean up all subscriptions
  Future<void> dispose() async {
    for (final channel in _channels.values) {
      await channel.unsubscribe();
    }
    _channels.clear();

    for (final controller in _typingControllers.values) {
      if (!controller.isClosed) {
        await controller.close();
      }
    }
    _typingControllers.clear();
    _typingUsers.clear();

    for (final timer in _typingTimeouts.values) {
      timer?.cancel();
    }
    _typingTimeouts.clear();
  }
}
</file>

<file path="lib/state/ai_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart' hide Provider;
import 'package:messageai/models/ai_analysis.dart';
import 'package:messageai/models/draft_analysis.dart';
import 'package:messageai/models/relationship_profile.dart';
import 'package:messageai/models/follow_up_item.dart';
import 'package:messageai/services/ai_analysis_service.dart';
import 'package:messageai/services/draft_analysis_service.dart';
import 'package:messageai/services/message_interpreter_service.dart';
import 'package:messageai/services/response_template_service.dart';
import 'package:messageai/services/message_formatter_service.dart';
import 'package:messageai/services/relationship_service.dart';
import 'package:messageai/services/relationship_summary_service.dart';
import 'package:messageai/services/context_preloader_service.dart';
import 'package:messageai/services/follow_up_service.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/state/providers.dart';

/// Provider for AI Analysis Service singleton
final aiAnalysisServiceProvider = Provider<AIAnalysisService>((ref) {
  return AIAnalysisService();
});

/// Provider for Message Interpreter Service (Phase 1: Smart Message Interpreter)
final messageInterpreterServiceProvider = Provider<MessageInterpreterService>((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  return MessageInterpreterService(supabase);
});

// =============================================================================
// PHASE 2: Adaptive Response Assistant Providers
// =============================================================================

/// Provider for Response Template Service (Phase 2)
final responseTemplateServiceProvider = Provider<ResponseTemplateService>((ref) {
  final service = ResponseTemplateService();
  // Initialize templates on first access
  service.loadTemplates();
  return service;
});

/// Provider for Message Formatter Service (Phase 2)
final messageFormatterServiceProvider = Provider<MessageFormatterService>((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  return MessageFormatterService(supabase);
});

/// StateNotifier to track when to refresh analysis
class AnalysisRefreshNotifier extends StateNotifier<int> {
  AnalysisRefreshNotifier() : super(0);
  
  void refresh() {
    state++;
  }
}

final analysisRefreshProvider = StateNotifierProvider<AnalysisRefreshNotifier, int>((ref) {
  final notifier = AnalysisRefreshNotifier();
  
  // Listen to realtime updates on message_ai_analysis table
  final supabase = SupabaseClientProvider.client;
  final channel = supabase.realtime.channel('ai_analysis_updates');
  
  channel.on(
    RealtimeListenTypes.postgresChanges,
    ChannelFilter(
      event: 'INSERT',
      schema: 'public',
      table: 'message_ai_analysis',
    ),
    (payload, [ref]) {
      print('🔄 AI analysis updated, refreshing providers...');
      notifier.refresh();
    },
  );
  
  channel.subscribe(
    (status, [error]) {
      if (status == 'SUBSCRIBED') {
        print('✅ AI analysis realtime listener subscribed');
      } else if (error != null) {
        print('❌ AI analysis realtime error: $error');
      }
    },
  );
  
  ref.onDispose(() {
    channel.unsubscribe();
  });
  
  return notifier;
});

/// Fetch analysis for a single message (auto-refreshes on realtime updates)
final messageAnalysisProvider = FutureProvider.family<AIAnalysis?, String>(
  (ref, messageId) async {
    // Watch the refresh notifier to trigger rebuilds
    ref.watch(analysisRefreshProvider);
    
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getAnalysis(messageId);
  },
);

/// Fetch all analyses for a conversation (auto-refreshes on realtime updates)
final conversationAnalysisProvider = FutureProvider.family<Map<String, AIAnalysis>, String>(
  (ref, conversationId) async {
    // Watch the refresh notifier to trigger rebuilds
    ref.watch(analysisRefreshProvider);
    
    final service = ref.watch(aiAnalysisServiceProvider);
    return await service.getConversationAnalyses(conversationId);
  },
);

/// Provider for triggering analysis requests
final requestAnalysisProvider = Provider((ref) {
  final service = ref.watch(aiAnalysisServiceProvider);
  return (String messageId, String messageBody) => 
      service.requestAnalysis(messageId, messageBody);
});

// =============================================================================
// DRAFT ANALYSIS PROVIDERS (for outgoing messages)
// =============================================================================

/// Provider for Draft Analysis Service
final draftAnalysisServiceProvider = Provider<DraftAnalysisService>((ref) {
  final supabase = SupabaseClientProvider.client;
  return DraftAnalysisService(supabase);
});

/// State notifier for managing draft analysis state (manual trigger)
class DraftAnalysisNotifier extends StateNotifier<AsyncValue<DraftAnalysis?>> {
  final DraftAnalysisService _service;

  DraftAnalysisNotifier(this._service) : super(const AsyncValue.data(null));

  /// Analyze a draft (called when user clicks "Check Message" button)
  Future<void> analyzeDraft({
    required String draftMessage,
    String? conversationId,
    RelationshipType? relationshipType,
    List<String>? conversationHistory,
  }) async {
    // Clear if draft is empty
    if (draftMessage.trim().isEmpty) {
      state = const AsyncValue.data(null);
      return;
    }

    // Set loading state
    state = const AsyncValue.loading();

    try {
      final analysis = await _service.analyzeDraft(
        draftMessage: draftMessage,
        conversationId: conversationId,
        relationshipType: relationshipType,
        conversationHistory: conversationHistory,
      );
      state = AsyncValue.data(analysis);
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  /// Clear current analysis
  void clear() {
    state = const AsyncValue.data(null);
  }
}

/// Provider for draft analysis state (manual trigger)
final draftAnalysisProvider =
    StateNotifierProvider<DraftAnalysisNotifier, AsyncValue<DraftAnalysis?>>(
  (ref) {
    final service = ref.watch(draftAnalysisServiceProvider);
    return DraftAnalysisNotifier(service);
  },
);

// =============================================================================
// PHASE 3: Smart Inbox with Context Providers
// =============================================================================

/// Provider for Relationship Service (Phase 3)
final relationshipServiceProvider = Provider<RelationshipService>((ref) {
  return RelationshipService();
});

/// Provider for Relationship Summary Service (Phase 3)
final relationshipSummaryServiceProvider = Provider<RelationshipSummaryService>((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  return RelationshipSummaryService(supabase);
});

/// Provider for Context Preloader Service (Phase 3)
final contextPreloaderServiceProvider = Provider<ContextPreloaderService>((ref) {
  return ContextPreloaderService();
});

/// Provider to fetch relationship profile for a conversation
final relationshipProfileProvider = FutureProvider.family<RelationshipProfile?, String>(
  (ref, conversationId) async {
    final service = ref.watch(relationshipServiceProvider);
    return await service.getProfile(conversationId);
  },
);

/// Provider to generate/refresh relationship summary
/// This is a manual trigger - call ref.refresh(generateRelationshipSummaryProvider(conversationId))
final generateRelationshipSummaryProvider = FutureProvider.family<RelationshipProfile, String>(
  (ref, conversationId) async {
    final service = ref.watch(relationshipSummaryServiceProvider);
    return await service.generateSummary(conversationId: conversationId);
  },
);

// =============================================================================
// PHASE 4: Smart Follow-up System Providers
// =============================================================================

/// Provider for Follow-Up Service (Phase 4)
final followUpServiceProvider = Provider<FollowUpService>((ref) {
  return FollowUpService();
});

/// Provider to get all pending follow-ups for the user
final pendingFollowUpsProvider = FutureProvider<List<FollowUpItem>>((ref) async {
  final service = ref.watch(followUpServiceProvider);
  return await service.getPendingFollowUps();
});

/// Provider to get follow-ups for a specific conversation
final conversationFollowUpsProvider = FutureProvider.family<List<FollowUpItem>, String>(
  (ref, conversationId) async {
    final service = ref.watch(followUpServiceProvider);
    return await service.getConversationFollowUps(conversationId);
  },
);

/// State notifier for managing follow-up extraction
class FollowUpExtractionNotifier extends StateNotifier<AsyncValue<void>> {
  final FollowUpService _service;

  FollowUpExtractionNotifier(this._service) : super(const AsyncValue.data(null));

  /// Extract follow-ups from a conversation
  Future<void> extractFollowUps(String conversationId, {bool scanAll = false}) async {
    state = const AsyncValue.loading();
    
    try {
      await _service.extractFollowUps(conversationId, scanAll: scanAll);
      state = const AsyncValue.data(null);
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }
}

/// Provider for follow-up extraction (manual trigger)
final followUpExtractionProvider = StateNotifierProvider<FollowUpExtractionNotifier, AsyncValue<void>>(
  (ref) {
    final service = ref.watch(followUpServiceProvider);
    return FollowUpExtractionNotifier(service);
  },
);
</file>

<file path="lib/state/database_provider.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/conversation_dao.dart';
import 'package:messageai/data/drift/daos/message_dao.dart';
import 'package:messageai/data/drift/daos/participant_dao.dart';
import 'package:messageai/data/drift/daos/receipt_dao.dart';
import 'package:messageai/data/drift/daos/pending_outbox_dao.dart';

/// Provides the main database instance
final appDbProvider = Provider<AppDb>((ref) {
  return AppDb.instance;
});

/// Provides the ConversationDao
final conversationDaoProvider = Provider<ConversationDao>((ref) {
  final db = ref.watch(appDbProvider);
  return ConversationDao(db);
});

/// Provides the MessageDao
final messageDaoProvider = Provider<MessageDao>((ref) {
  final db = ref.watch(appDbProvider);
  return MessageDao(db);
});

/// Provides the ParticipantDao
final participantDaoProvider = Provider<ParticipantDao>((ref) {
  final db = ref.watch(appDbProvider);
  return ParticipantDao(db);
});

/// Provides the ReceiptDao
final receiptDaoProvider = Provider<ReceiptDao>((ref) {
  final db = ref.watch(appDbProvider);
  return ReceiptDao(db);
});

/// Provides the PendingOutboxDao
final pendingOutboxDaoProvider = Provider<PendingOutboxDao>((ref) {
  final db = ref.watch(appDbProvider);
  return PendingOutboxDao(db);
});

/// Stream of all conversations (watching for changes)
final conversationsStreamProvider = StreamProvider<List<Conversation>>((ref) async* {
  final dao = ref.watch(conversationDaoProvider);
  
  // Initial load
  yield await dao.getAllConversations();
  
  // TODO: Set up watch stream for real-time updates
  // For now, update every time this is accessed
});

/// Stream of messages for a specific conversation
final messagesStreamProvider = StreamProvider.family<List<Message>, String>((ref, conversationId) async* {
  final dao = ref.watch(messageDaoProvider);
  
  // Initial load
  yield await dao.getMessagesByConversation(conversationId);
  
  // TODO: Set up watch stream for real-time updates
});

/// Stream of pending operations count (for UI indicators)
final pendingOperationsCountProvider = StreamProvider<int>((ref) async* {
  final dao = ref.watch(pendingOutboxDaoProvider);
  
  // Initial load
  yield await dao.getPendingOperationCount();
  
  // TODO: Set up periodic check or subscription
});

/// Check if there are any pending operations
final hasPendingOperationsProvider = FutureProvider<bool>((ref) async {
  final dao = ref.watch(pendingOutboxDaoProvider);
  return dao.hasPendingOperations();
});
</file>

<file path="lib/state/notification_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/services/notification_service.dart';
import 'package:messageai/services/local_notification_service.dart';
import 'package:messageai/services/deep_link_handler.dart';
import 'package:messageai/services/device_registration_service.dart';
import 'package:messageai/app.dart' show navigatorKey;

/// Device token state
final deviceTokenProvider = StateProvider<String?>((ref) {
  return null;
});

/// Notification service provider
final notificationServiceProvider = Provider<NotificationService>((ref) {
  return NotificationService();
});

/// Local notification service provider
final localNotificationServiceProvider = Provider<LocalNotificationService>((ref) {
  return LocalNotificationService();
});

/// Device registration service provider
final deviceRegistrationServiceProvider = Provider<DeviceRegistrationService>((ref) {
  return DeviceRegistrationService();
});

/// Initialize notifications (Firebase + Local)
final initializeNotificationsProvider = FutureProvider<void>((ref) async {
  print('📢 ========================================');
  print('📢 STARTING NOTIFICATION INITIALIZATION');
  print('📢 ========================================');
  
  final fcmService = ref.watch(notificationServiceProvider);
  final localService = ref.watch(localNotificationServiceProvider);
  final deviceRegistrationService = ref.watch(deviceRegistrationServiceProvider);

  print('📱 Initializing local notifications...');
  // Initialize local notifications first
  await localService.initialize();
  print('✅ Local notifications initialized');

  print('🔥 Initializing Firebase Messaging...');
  // Initialize Firebase Messaging
  await fcmService.initialize(
    onMessageReceived: (payload) {
      // Handle foreground message
      _handleForegroundMessage(ref, payload, localService);
    },
    onTokenRefresh: (token) async {
      // Update device token state
      ref.read(deviceTokenProvider.notifier).state = token;
      print('🔄 Device token refreshed: ${token.substring(0, 20)}...');
      
      // Register refreshed token with backend
      try {
        await deviceRegistrationService.registerDeviceToken(token);
        print('✅ Refreshed token registered with backend');
      } catch (e) {
        print('❌ Failed to register refreshed token: $e');
      }
    },
  );

  // Setup notification tap handler
  await fcmService.setupNotificationTapHandler(
    onNotificationTapped: (conversationId) {
      _handleNotificationTap(ref, conversationId);
    },
  );

  // Get initial device token
  final token = await fcmService.getDeviceToken();
  if (token != null) {
    ref.read(deviceTokenProvider.notifier).state = token;
    
    // Register token with backend
    try {
      await deviceRegistrationService.registerDeviceToken(token);
      print('✅ Initial token registered with backend');
    } catch (e) {
      print('❌ Failed to register initial token: $e');
      // Don't fail initialization if registration fails
    }
  }

  print('Notifications initialized successfully');
});

/// Handle foreground notification message
void _handleForegroundMessage(
  Ref ref,
  NotificationPayload payload,
  LocalNotificationService localService,
) async {
  try {
    final conversationId = payload.conversationId;
    final senderName = payload.data['sender_name'] as String? ?? 'New Message';
    final messageBody = payload.messageBody ?? payload.body ?? '';

    if (conversationId != null && messageBody.isNotEmpty) {
      await localService.showMessageNotification(
        conversationId: conversationId,
        senderName: senderName,
        messageBody: messageBody,
      );
    }
  } catch (e) {
    print('Error handling foreground message: $e');
  }
}

/// Handle notification tap
void _handleNotificationTap(Ref ref, String conversationId) {
  print('📱 Notification tapped: $conversationId');
  
  try {
    // Use the global navigator key to navigate
    final navigator = navigatorKey.currentState;
    
    if (navigator == null) {
      print('❌ Navigator not available');
      return;
    }
    
    // Navigate to conversation detail screen
    navigator.pushNamed(
      '/conversation/$conversationId',
      arguments: {'title': 'Conversation'},
    );
    
    print('✅ Navigated to conversation: $conversationId');
  } catch (e) {
    print('❌ Error navigating to conversation: $e');
  }
}

/// Notification permission state
final notificationPermissionProvider = FutureProvider<bool>((ref) async {
  final fcmService = ref.watch(notificationServiceProvider);
  return fcmService.areNotificationsEnabled();
});

/// Subscribe to conversation topic for group notifications
final subscribeToConversationTopicProvider = FutureProvider.autoDispose
    .family<void, String>((ref, conversationId) async {
  final fcmService = ref.watch(notificationServiceProvider);
  await fcmService.subscribeToTopic('conversation_$conversationId');
});

/// Unsubscribe from conversation topic
final unsubscribeFromConversationTopicProvider = FutureProvider.autoDispose
    .family<void, String>((ref, conversationId) async {
  final fcmService = ref.watch(notificationServiceProvider);
  await fcmService.unsubscribeFromTopic('conversation_$conversationId');
});

/// Subscribe to user topic for direct messages
final subscribeToUserTopicProvider = FutureProvider<void>((ref) async {
  final fcmService = ref.watch(notificationServiceProvider);
  // Subscribe to user's personal notification topic
  // (would use current user ID in real app)
  await fcmService.subscribeToTopic('user_direct_messages');
});

/// Notification state for UI
final notificationStateProvider = StateProvider<NotificationState>((ref) {
  return const NotificationState();
});

/// Notification state model
class NotificationState {
  final bool isInitialized;
  final bool hasPermission;
  final String? deviceToken;
  final int unreadCount;
  final List<String> subscribedTopics;

  const NotificationState({
    this.isInitialized = false,
    this.hasPermission = false,
    this.deviceToken,
    this.unreadCount = 0,
    this.subscribedTopics = const [],
  });

  NotificationState copyWith({
    bool? isInitialized,
    bool? hasPermission,
    String? deviceToken,
    int? unreadCount,
    List<String>? subscribedTopics,
  }) {
    return NotificationState(
      isInitialized: isInitialized ?? this.isInitialized,
      hasPermission: hasPermission ?? this.hasPermission,
      deviceToken: deviceToken ?? this.deviceToken,
      unreadCount: unreadCount ?? this.unreadCount,
      subscribedTopics: subscribedTopics ?? this.subscribedTopics,
    );
  }
}

/// Initialize notification system
final notificationInitializerProvider = FutureProvider<void>((ref) async {
  try {
    // Initialize notifications
    await ref.watch(initializeNotificationsProvider.future);

    // Check permissions
    final hasPermission = await ref.watch(notificationPermissionProvider.future);

    // Get device token
    final deviceToken = ref.watch(deviceTokenProvider);

    // Update state
    ref.read(notificationStateProvider.notifier).state =
        ref.read(notificationStateProvider).copyWith(
          isInitialized: true,
          hasPermission: hasPermission,
          deviceToken: deviceToken,
        );

    print('Notification system initialized');
  } catch (e) {
    print('Error initializing notification system: $e');
    rethrow;
  }
});
</file>

<file path="lib/state/presence_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/providers.dart';

/// User presence status
enum PresenceStatus {
  online,
  away,
  offline,
}

/// User presence information
class UserPresence {
  final String userId;
  final String conversationId;
  final PresenceStatus status;
  final DateTime lastSeen;

  UserPresence({
    required this.userId,
    required this.conversationId,
    required this.status,
    required this.lastSeen,
  });
}

/// Manages user presence for a conversation
class PresenceManager {
  final Ref ref;
  final String conversationId;
  final String userId;
  
  PresenceManager({
    required this.ref,
    required this.conversationId,
    required this.userId,
  });

  /// Join presence channel (user is viewing conversation)
  Future<void> joinPresence() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    // Subscribe to presence channel
    final presence = supabase.channel('presence:$conversationId');

    // Subscribe to presence channel
    presence.subscribe(
      (status, [err]) {
        print('Presence subscription: $status - $err');
      },
    );

    // Track this user's presence
    await presence.track({
      'user_id': userId,
      'status': 'online',
      'last_seen': DateTime.now().toIso8601String(),
    });
  }

  /// Leave presence channel (user is no longer viewing)
  Future<void> leavePresence() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('presence:$conversationId');
    await presence.unsubscribe();
  }

  /// Update user status
  Future<void> updateStatus(PresenceStatus status) async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('presence:$conversationId');
    await presence.track({
      'user_id': userId,
      'status': status.name,
      'last_seen': DateTime.now().toIso8601String(),
    });
  }

  /// Get all users' presence in conversation
  Future<List<UserPresence>> getConversationPresence() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('presence:$conversationId');
    final state = presence.presenceState();
    
    final presences = <UserPresence>[];
    
    for (final entry in state.entries) {
      for (final presence in entry.value) {
        final presenceMap = presence as Map<String, dynamic>;
        presences.add(UserPresence(
          userId: presenceMap['user_id'] as String,
          conversationId: conversationId,
          status: PresenceStatus.values.firstWhere(
            (s) => s.name == (presenceMap['status'] as String),
            orElse: () => PresenceStatus.offline,
          ),
          lastSeen: DateTime.parse(presenceMap['last_seen'] as String),
        ));
      }
    }
    
    return presences;
  }

  /// Check if user is online
  Future<bool> isUserOnline(String otherUserId) async {
    final presences = await getConversationPresence();
    return presences.any((p) =>
        p.userId == otherUserId && p.status == PresenceStatus.online);
  }
}

/// Provider for presence manager
final presenceManagerProvider = Provider.family<PresenceManager, (String, String)>((ref, args) {
  final (conversationId, userId) = args;
  return PresenceManager(
    ref: ref,
    conversationId: conversationId,
    userId: userId,
  );
});

/// Stream of user presence in a conversation
final conversationPresenceProvider =
    StreamProvider.autoDispose.family<List<UserPresence>, String>((ref, conversationId) async* {
  // This would typically subscribe to realtime presence updates
  // For now, we'll yield an empty list
  yield [];
  
  // TODO: Set up realtime presence stream
});

/// Check if a specific user is online
final userOnlineProvider = FutureProvider.autoDispose
    .family<bool, (String, String)>((ref, args) async {
  final (conversationId, userId) = args;
  final manager = ref.watch(presenceManagerProvider((conversationId, userId)));
  return manager.isUserOnline(userId);
});
</file>

<file path="lib/state/providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart' as fpr;
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:dio/dio.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:messageai/gen/api/clients/messages_api.dart';
import 'package:messageai/gen/api/clients/receipts_api.dart';

/// Provides the Supabase client instance
final supabaseClientProvider = fpr.Provider<SupabaseClient>((ref) {
  return SupabaseClientProvider.client;
});

/// Provides the Supabase auth client
final authProvider = fpr.Provider((ref) {
  return ref.watch(supabaseClientProvider).auth;
});

/// Provides the current authenticated user
final currentUserProvider = fpr.StreamProvider((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  return supabase.auth.onAuthStateChange.map((data) => data.session?.user);
});

/// Provides a Dio HTTP client configured for the API
final dioProvider = fpr.Provider<Dio>((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  final dio = Dio(
    BaseOptions(
      baseUrl: supabase.restUrl,
      headers: {
        'Authorization': 'Bearer ${supabase.auth.currentSession?.accessToken}',
        'apikey': supabase.auth.currentSession?.user.id ?? '',
      },
    ),
  );
  return dio;
});

/// Provides the Messages API client
final messagesApiProvider = fpr.Provider<MessagesApi>((ref) {
  final dio = ref.watch(dioProvider);
  final supabase = ref.watch(supabaseClientProvider);
  return MessagesApi(
    dio: dio,
    baseUrl: supabase.restUrl,
  );
});

/// Provides the Receipts API client
final receiptsApiProvider = fpr.Provider<ReceiptsApi>((ref) {
  final dio = ref.watch(dioProvider);
  final supabase = ref.watch(supabaseClientProvider);
  return ReceiptsApi(
    dio: dio,
    baseUrl: supabase.restUrl,
  );
});

/// Indicates whether the user is currently authenticated
final isAuthenticatedProvider = fpr.StreamProvider<bool>((ref) async* {
  final authState = ref.watch(currentUserProvider);
  yield* authState.when(
    data: (user) async* {
      yield user != null;
    },
    loading: () async* {
      yield false;
    },
    error: (err, st) async* {
      yield false;
    },
  );
});
</file>

<file path="lib/state/realtime_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/state/database_provider.dart';
import 'package:messageai/state/providers.dart';

/// Manages realtime subscriptions to conversation messages
class RealtimeManager {
  final Ref ref;
  final Map<String, dynamic> _subscriptions = {};

  RealtimeManager({required this.ref});

  /// Subscribe to messages in a conversation
  void subscribeToConversationMessages(String conversationId) {
    final supabase = ref.watch(supabaseClientProvider);
    
    // Create a channel for this conversation's messages
    final subscription = supabase.channel('public:messages:$conversationId');
    
    // Subscribe to the channel
    subscription.subscribe((status, [error]) async {
      if (status == 'SUBSCRIBED') {
        // Successfully subscribed
        // Note: In Supabase v1.x, realtime postgres changes work differently
        // This is a placeholder - the actual message sync happens through
        // the existing realtime message service
      }
    });
    
    _subscriptions[conversationId] = subscription;
  }

  /// Unsubscribe from conversation messages
  Future<void> unsubscribeFromConversation(String conversationId) async {
    final subscription = _subscriptions.remove(conversationId);
    if (subscription != null) {
      await subscription.unsubscribe();
    }
  }

  /// Cleanup all subscriptions
  Future<void> cleanup() async {
    for (final subscription in _subscriptions.values) {
      await subscription.unsubscribe();
    }
    _subscriptions.clear();
  }
}

/// Provider for realtime manager
final realtimeManagerProvider = Provider.autoDispose<RealtimeManager>((ref) {
  return RealtimeManager(ref: ref);
});

/// Subscribe to messages in a conversation
final conversationMessagesRealtimeProvider = 
    FutureProvider.autoDispose.family<void, String>((ref, conversationId) async {
  final manager = ref.watch(realtimeManagerProvider);
  manager.subscribeToConversationMessages(conversationId);
  
  // Cleanup on dispose
  ref.onDispose(() {
    manager.unsubscribeFromConversation(conversationId);
  });
});

/// Watch for realtime message updates in a conversation
final realtimeConversationMessagesProvider = 
    StreamProvider.autoDispose.family<List<Message>, String>((ref, conversationId) async* {
  // Enable realtime subscription
  await ref.watch(conversationMessagesRealtimeProvider(conversationId).future);
  
  // Watch the local messages - use .stream instead
  yield* ref.watch(messagesStreamProvider(conversationId).stream);
});
</file>

<file path="lib/state/repository_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/data/repositories/message_repository.dart';
import 'package:messageai/data/repositories/receipt_repository.dart';
import 'package:messageai/data/repositories/group_repository.dart';
import 'package:messageai/state/database_provider.dart';
import 'package:messageai/state/providers.dart';

/// Provides the MessageRepository
final messageRepositoryProvider = Provider<MessageRepository>((ref) {
  final messagesApi = ref.watch(messagesApiProvider);
  final messageDao = ref.watch(messageDaoProvider);
  final outboxDao = ref.watch(pendingOutboxDaoProvider);
  
  return MessageRepository(
    messagesApi: messagesApi,
    messageDao: messageDao,
    outboxDao: outboxDao,
  );
});

/// Provides the ReceiptRepository
final receiptRepositoryProvider = Provider<ReceiptRepository>((ref) {
  final receiptsApi = ref.watch(receiptsApiProvider);
  final receiptDao = ref.watch(receiptDaoProvider);
  final outboxDao = ref.watch(pendingOutboxDaoProvider);
  
  return ReceiptRepository(
    receiptsApi: receiptsApi,
    receiptDao: receiptDao,
    outboxDao: outboxDao,
  );
});

/// Provides the GroupRepository
final groupRepositoryProvider = Provider<GroupRepository>((ref) {
  final conversationDao = ref.watch(conversationDaoProvider);
  final participantDao = ref.watch(participantDaoProvider);
  
  return GroupRepository(
    conversationDao: conversationDao,
    participantDao: participantDao,
  );
});

// Add receiptDaoProvider to database_provider.dart if not already there
// final receiptDaoProvider = Provider<ReceiptDao>((ref) {
//   final db = ref.watch(appDbProvider);
//   return ReceiptDao(db);
// });
</file>

<file path="lib/state/send_queue.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/state/repository_providers.dart';

/// Message to send
class SendableMessage {
  final String id;
  final String conversationId;
  final String senderId;
  final String body;
  final String? mediaUrl;

  SendableMessage({
    required this.id,
    required this.conversationId,
    required this.senderId,
    required this.body,
    this.mediaUrl,
  });
}

/// Manages sending messages with optimistic updates
class SendQueue {
  final Ref ref;
  
  SendQueue({required this.ref});

  /// Send a message
  Future<Message> sendMessage({
    required String conversationId,
    required String senderId,
    required String body,
    String? mediaUrl,
  }) async {
    // Generate unique ID
    const uuid = Uuid();
    final messageId = uuid.v4();
    
    // Get repository
    final messageRepo = ref.watch(messageRepositoryProvider);
    
    // Send optimistically (local first)
    final message = await messageRepo.sendMessage(
      id: messageId,
      conversationId: conversationId,
      senderId: senderId,
      body: body,
      mediaUrl: mediaUrl,
    );
    
    // Queue background sync
    _scheduleSyncIfNeeded();
    
    return message;
  }

  /// Drain the send queue (sync pending messages)
  Future<void> drainQueue() async {
    final messageRepo = ref.watch(messageRepositoryProvider);
    final receiptRepo = ref.watch(receiptRepositoryProvider);
    
    try {
      // Sync messages
      await messageRepo.syncUnsyncedMessages();
      
      // Sync receipts
      await receiptRepo.syncUnsyncedReceipts();
    } catch (e) {
      print('Error draining send queue: $e');
      rethrow;
    }
  }

  /// Schedule sync if there are pending operations
  void _scheduleSyncIfNeeded() {
    // In a real app, this would use a periodic timer or background service
    // For now, we'll just sync immediately for demo purposes
    _syncInBackground();
  }

  /// Sync in background
  void _syncInBackground() {
    // Run sync without awaiting (fire and forget)
    drainQueue().catchError((e) {
      print('Background sync error: $e');
    });
  }

  /// Get pending message count
  Future<int> getPendingCount() async {
    final messageRepo = ref.watch(messageRepositoryProvider);
    return messageRepo.getPendingMessageCount();
  }
}

/// Provider for send queue
final sendQueueProvider = Provider<SendQueue>((ref) {
  return SendQueue(ref: ref);
});

/// State notifier for managing message sends
class SendMessageNotifier extends StateNotifier<AsyncValue<void>> {
  final Ref ref;

  SendMessageNotifier({required this.ref}) : super(const AsyncValue.data(null));

  /// Send a message
  Future<Message> sendMessage({
    required String conversationId,
    required String senderId,
    required String body,
    String? mediaUrl,
  }) async {
    state = const AsyncValue.loading();
    
    try {
      final sendQueue = ref.watch(sendQueueProvider);
      final message = await sendQueue.sendMessage(
        conversationId: conversationId,
        senderId: senderId,
        body: body,
        mediaUrl: mediaUrl,
      );
      
      state = const AsyncValue.data(null);
      return message;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }

  /// Retry pending messages
  Future<void> retryPending() async {
    state = const AsyncValue.loading();
    
    try {
      final sendQueue = ref.watch(sendQueueProvider);
      await sendQueue.drainQueue();
      state = const AsyncValue.data(null);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }
}

/// State notifier provider for sending messages
final sendMessageNotifierProvider = 
    StateNotifierProvider<SendMessageNotifier, AsyncValue<void>>((ref) {
  return SendMessageNotifier(ref: ref);
});

/// Get pending message count
final pendingMessageCountProvider = FutureProvider<int>((ref) async {
  final sendQueue = ref.watch(sendQueueProvider);
  return sendQueue.getPendingCount();
});
</file>

<file path="lib/state/typing_providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/state/providers.dart';

/// User typing information
class TypingUser {
  final String userId;
  final DateTime startedAt;
  final Duration timeout;

  TypingUser({
    required this.userId,
    required this.startedAt,
    this.timeout = const Duration(seconds: 3),
  });

  /// Check if typing indicator has expired
  bool get isExpired {
    return DateTime.now().difference(startedAt) > timeout;
  }
}

/// Manages typing indicators for a conversation
class TypingManager {
  final Ref ref;
  final String conversationId;
  final String userId;
  
  final Map<String, TypingUser> _typingUsers = {};
  static const Duration _debounceDelay = Duration(milliseconds: 300);
  DateTime? _lastTypingSent;

  TypingManager({
    required this.ref,
    required this.conversationId,
    required this.userId,
  });

  /// Broadcast that user is typing
  Future<void> sendTypingIndicator() async {
    final now = DateTime.now();
    
    // Debounce: only send every 300ms
    if (_lastTypingSent != null &&
        now.difference(_lastTypingSent!) < _debounceDelay) {
      return;
    }
    
    _lastTypingSent = now;
    
    final supabase = ref.watch(supabaseClientProvider);
    
    // Send typing indicator through presence
    final presence = supabase.channel('typing:$conversationId');
    
    try {
      // Subscribe to the channel (returns void, no await needed)
      presence.subscribe(
        (status, [err]) {
          print('Typing subscription: $status - $err');
        },
      );
      
      await presence.track({
        'user_id': userId,
        'typing': true,
        'timestamp': now.toIso8601String(),
      });
    } catch (e) {
      print('Error sending typing indicator: $e');
    }
  }

  /// Stop broadcasting typing
  Future<void> stopTypingIndicator() async {
    final supabase = ref.watch(supabaseClientProvider);
    
    final presence = supabase.channel('typing:$conversationId');
    
    try {
      await presence.track({
        'user_id': userId,
        'typing': false,
      });
      
      await presence.unsubscribe();
    } catch (e) {
      print('Error stopping typing indicator: $e');
    }
  }

  /// Add a typing user (received from server)
  void addTypingUser(String otherUserId) {
    _typingUsers[otherUserId] = TypingUser(userId: otherUserId, startedAt: DateTime.now());
  }

  /// Remove a typing user
  void removeTypingUser(String otherUserId) {
    _typingUsers.remove(otherUserId);
  }

  /// Get list of currently typing users (excluding expired ones)
  List<TypingUser> getTypingUsers() {
    // Remove expired entries
    _typingUsers.removeWhere((_, user) => user.isExpired);
    return _typingUsers.values.toList();
  }

  /// Get typing users display text
  String getTypingText() {
    final typingUsers = getTypingUsers();
    
    if (typingUsers.isEmpty) return '';
    if (typingUsers.length == 1) return '${typingUsers.first.userId} is typing...';
    if (typingUsers.length == 2) {
      return '${typingUsers[0].userId} and ${typingUsers[1].userId} are typing...';
    }
    
    return '${typingUsers.length} people are typing...';
  }

  /// Check if anyone is typing
  bool get anyoneTyping => getTypingUsers().isNotEmpty;
}

/// Provider for typing manager
final typingManagerProvider =
    Provider.family<TypingManager, (String, String)>((ref, args) {
  final (conversationId, userId) = args;
  return TypingManager(
    ref: ref,
    conversationId: conversationId,
    userId: userId,
  );
});

/// Stream of typing users in a conversation
final conversationTypingProvider = StreamProvider.autoDispose
    .family<List<TypingUser>, String>((ref, conversationId) async* {
  // This would typically subscribe to realtime typing updates
  // For now, we'll yield an empty list
  yield [];
  
  // TODO: Set up realtime typing stream
});

/// Get typing status text for display
final typingStatusTextProvider = StreamProvider.autoDispose
    .family<String, String>((ref, conversationId) async* {
  yield* ref.watch(conversationTypingProvider(conversationId)).when(
        data: (typingUsers) async* {
          if (typingUsers.isEmpty) {
            yield '';
          } else if (typingUsers.length == 1) {
            yield '${typingUsers.first.userId} is typing...';
          } else {
            yield '${typingUsers.length} people are typing...';
          }
        },
        loading: () async* {
          yield '';
        },
        error: (err, st) async* {
          yield '';
        },
      );
});
</file>

<file path="lib/widgets/network_status_banner.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/network_connectivity_service.dart';
import 'package:messageai/services/offline_queue_service.dart';

/// Banner that shows network status and pending message count
class NetworkStatusBanner extends StatefulWidget {
  const NetworkStatusBanner({Key? key}) : super(key: key);

  @override
  State<NetworkStatusBanner> createState() => _NetworkStatusBannerState();
}

class _NetworkStatusBannerState extends State<NetworkStatusBanner> {
  final _connectivityService = NetworkConnectivityService();
  final _offlineQueueService = OfflineQueueService();
  
  ConnectivityStatus _status = ConnectivityStatus.unknown;
  int _pendingMessages = 0;

  @override
  void initState() {
    super.initState();
    _status = _connectivityService.currentStatus;
    _loadPendingCount();
    
    // Listen to connectivity changes
    _connectivityService.onStatusChange.listen((status) {
      if (mounted) {
        setState(() => _status = status);
        _loadPendingCount();
      }
    });
  }

  Future<void> _loadPendingCount() async {
    final count = await _offlineQueueService.getPendingMessageCount();
    if (mounted) {
      setState(() => _pendingMessages = count);
    }
  }

  Future<void> _handleSyncTap() async {
    // Show loading
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Row(
          children: [
            SizedBox(
              width: 16,
              height: 16,
              child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),
            ),
            SizedBox(width: 12),
            Text('Syncing pending messages...'),
          ],
        ),
        duration: Duration(seconds: 2),
      ),
    );

    final result = await _offlineQueueService.forceSyncNow();
    
    if (!mounted) return;

    ScaffoldMessenger.of(context).hideCurrentSnackBar();
    
    if (result.isSuccess) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.check_circle, color: Colors.white),
              const SizedBox(width: 12),
              Text('${result.successCount} messages synced'),
            ],
          ),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 2),
        ),
      );
      _loadPendingCount();
    } else if (result.status == SyncStatus.noMessages) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Row(
            children: [
              Icon(Icons.check_circle, color: Colors.white),
              SizedBox(width: 12),
              Text('All messages are synced'),
            ],
          ),
          backgroundColor: Colors.blue,
          duration: Duration(seconds: 2),
        ),
      );
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.error, color: Colors.white),
              const SizedBox(width: 12),
              Text('Failed to sync: ${result.errorMessage ?? "Unknown error"}'),
            ],
          ),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    // Only show banner when offline or has pending messages
    if (_status == ConnectivityStatus.online && _pendingMessages == 0) {
      return const SizedBox.shrink();
    }

    return Material(
      color: _getBannerColor(),
      child: InkWell(
        onTap: _status == ConnectivityStatus.online && _pendingMessages > 0
            ? _handleSyncTap
            : null,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: Row(
            children: [
              Icon(
                _getBannerIcon(),
                size: 20,
                color: Colors.white,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  _getBannerText(),
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 14,
                  ),
                ),
              ),
              if (_status == ConnectivityStatus.online && _pendingMessages > 0)
                const Icon(
                  Icons.sync,
                  size: 20,
                  color: Colors.white,
                ),
            ],
          ),
        ),
      ),
    );
  }

  Color _getBannerColor() {
    if (_status == ConnectivityStatus.offline) {
      return Colors.red.shade700;
    } else if (_pendingMessages > 0) {
      return Colors.orange.shade700;
    }
    return Colors.blue;
  }

  IconData _getBannerIcon() {
    if (_status == ConnectivityStatus.offline) {
      return Icons.cloud_off;
    } else if (_pendingMessages > 0) {
      return Icons.cloud_sync;
    }
    return Icons.cloud_done;
  }

  String _getBannerText() {
    if (_status == ConnectivityStatus.offline) {
      if (_pendingMessages > 0) {
        return 'Offline • $_pendingMessages message${_pendingMessages == 1 ? '' : 's'} pending';
      }
      return 'You are offline';
    } else if (_pendingMessages > 0) {
      return 'Syncing $_pendingMessages message${_pendingMessages == 1 ? '' : 's'} • Tap to sync now';
    }
    return 'All messages synced';
  }
}

/// Small inline network indicator
class NetworkStatusIndicator extends StatefulWidget {
  final bool showLabel;

  const NetworkStatusIndicator({
    Key? key,
    this.showLabel = true,
  }) : super(key: key);

  @override
  State<NetworkStatusIndicator> createState() => _NetworkStatusIndicatorState();
}

class _NetworkStatusIndicatorState extends State<NetworkStatusIndicator> {
  final _connectivityService = NetworkConnectivityService();
  ConnectivityStatus _status = ConnectivityStatus.unknown;

  @override
  void initState() {
    super.initState();
    _status = _connectivityService.currentStatus;
    
    _connectivityService.onStatusChange.listen((status) {
      if (mounted) {
        setState(() => _status = status);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          width: 8,
          height: 8,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: _getStatusColor(),
          ),
        ),
        if (widget.showLabel) ...[
          const SizedBox(width: 6),
          Text(
            _getStatusLabel(),
            style: TextStyle(
              fontSize: 12,
              color: Colors.grey[600],
            ),
          ),
        ],
      ],
    );
  }

  Color _getStatusColor() {
    switch (_status) {
      case ConnectivityStatus.online:
        return Colors.green;
      case ConnectivityStatus.offline:
        return Colors.red;
      case ConnectivityStatus.unknown:
        return Colors.grey;
    }
  }

  String _getStatusLabel() {
    switch (_status) {
      case ConnectivityStatus.online:
        return 'Online';
      case ConnectivityStatus.offline:
        return 'Offline';
      case ConnectivityStatus.unknown:
        return 'Unknown';
    }
  }
}
</file>

<file path="lib/widgets/sliding_panel.dart">
import 'package:flutter/material.dart';
import 'package:messageai/core/theme/app_theme.dart';

/// A sliding panel widget that can be dragged up and down
/// Used for the message screen to slide over AI insights
class SlidingPanel extends StatefulWidget {
  /// Builder function to create the child with scroll controller
  final Widget Function(ScrollController)? builder;
  
  /// The content to display in the sliding panel (deprecated, use builder instead)
  final Widget? child;
  
  /// Called when the panel position changes (0.0 = collapsed, 1.0 = fully expanded)
  final ValueChanged<double>? onSlide;
  
  /// Minimum height as a fraction of screen (0.0 - 1.0)
  final double minHeight;
  
  /// Maximum height as a fraction of screen (0.0 - 1.0)
  final double maxHeight;
  
  /// Initial height as a fraction of screen (0.0 - 1.0)
  final double initialHeight;
  
  /// Snap positions for the panel (as fractions of screen height)
  final List<double> snapSizes;
  
  /// Background color of the panel
  final Color? backgroundColor;
  
  /// Border radius for the top corners
  final double borderRadius;
  
  /// Whether to show the drag handle
  final bool showDragHandle;

  const SlidingPanel({
    Key? key,
    this.builder,
    this.child,
    this.onSlide,
    this.minHeight = 0.2,
    this.maxHeight = 0.95,
    this.initialHeight = 0.8,
    this.snapSizes = const [0.2, 0.5, 0.8, 0.95],
    this.backgroundColor,
    this.borderRadius = 16.0,
    this.showDragHandle = true,
  }) : assert(builder != null || child != null, 'Either builder or child must be provided'),
       super(key: key);

  @override
  State<SlidingPanel> createState() => _SlidingPanelState();
}

class _SlidingPanelState extends State<SlidingPanel> {
  final DraggableScrollableController _controller = DraggableScrollableController();
  
  @override
  void initState() {
    super.initState();
    // Add listener to track position changes
    _controller.addListener(_onPositionChanged);
  }
  
  @override
  void dispose() {
    _controller.removeListener(_onPositionChanged);
    _controller.dispose();
    super.dispose();
  }
  
  void _onPositionChanged() {
    if (_controller.isAttached) {
      final size = _controller.size;
      // Normalize the size to 0.0 - 1.0 range
      final normalizedPosition = (size - widget.minHeight) / (widget.maxHeight - widget.minHeight);
      widget.onSlide?.call(normalizedPosition.clamp(0.0, 1.0));
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final bgColor = widget.backgroundColor ?? 
                    (isDark ? AppTheme.black : AppTheme.white);
    
    return NotificationListener<DraggableScrollableNotification>(
      onNotification: (notification) {
        // Update position for smoother tracking
        if (widget.onSlide != null) {
          final normalizedPosition = (notification.extent - widget.minHeight) / 
                                     (widget.maxHeight - widget.minHeight);
          widget.onSlide?.call(normalizedPosition.clamp(0.0, 1.0));
        }
        return false;
      },
      child: DraggableScrollableSheet(
        controller: _controller,
        initialChildSize: widget.initialHeight,
        minChildSize: widget.minHeight,
        maxChildSize: widget.maxHeight,
        snap: true,
        snapSizes: widget.snapSizes,
        expand: false,
        builder: (BuildContext context, ScrollController scrollController) {
          return Container(
            decoration: BoxDecoration(
              color: bgColor,
              borderRadius: BorderRadius.only(
                topLeft: Radius.circular(widget.borderRadius),
                topRight: Radius.circular(widget.borderRadius),
              ),
              boxShadow: isDark ? AppTheme.shadow2Dark : AppTheme.shadow3Light,
            ),
            child: Column(
              children: [
                // Drag handle - simple tap to cycle through positions
                if (widget.showDragHandle)
                  InkWell(
                    onTap: () => _snapToNextPosition(),
                    child: Container(
                      width: double.infinity,
                      padding: const EdgeInsets.symmetric(
                        vertical: AppTheme.spacingM,
                      ),
                      child: Center(
                        child: Container(
                          width: 40,
                          height: 5,
                          decoration: BoxDecoration(
                            color: isDark ? AppTheme.gray600 : AppTheme.gray400,
                            borderRadius: BorderRadius.circular(AppTheme.radiusPill),
                          ),
                        ),
                      ),
                    ),
                  ),
                
                // Panel content with scroll controller for dragging
                Expanded(
                  child: widget.builder != null 
                    ? widget.builder!(scrollController) 
                    : (widget.child != null 
                        ? SingleChildScrollView(
                            controller: scrollController,
                            child: widget.child!,
                          )
                        : const SizedBox.shrink()),
                ),
              ],
            ),
          );
        },
      ),
    );
  }
  
  /// Snaps the panel to the next position in the snapSizes list
  void _snapToNextPosition() {
    if (!_controller.isAttached) return;
    
    final currentSize = _controller.size;
    final sortedSnaps = List<double>.from(widget.snapSizes)..sort();
    
    // Find the next snap position
    final nextSnap = sortedSnaps.firstWhere(
      (snap) => snap > currentSize + 0.05, // Add small buffer for floating point
      orElse: () => sortedSnaps.first, // Wrap around to first
    );
    
    _controller.animateTo(
      nextSnap,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
  }
}

/// Extension to provide convenience methods for sliding panel
extension SlidingPanelController on DraggableScrollableController {
  /// Animate to a specific size
  Future<void> animateToSize(
    double size, {
    Duration duration = const Duration(milliseconds: 300),
    Curve curve = Curves.easeInOut,
  }) {
    return animateTo(
      size,
      duration: duration,
      curve: curve,
    );
  }
  
  /// Jump to a specific size without animation
  void jumpToSize(double size) {
    jumpTo(size);
  }
  
  /// Get current size
  double get currentSize => isAttached ? size : 0.0;
}
</file>

<file path="lib/widgets/user_avatar.dart">
import 'package:flutter/material.dart';
import 'package:messageai/services/avatar_service.dart';

/// Reusable widget for displaying user avatars
/// Fetches avatar from backend or shows fallback initial
class UserAvatar extends StatefulWidget {
  final String? userId;
  final String? avatarUrl;
  final String fallbackText;
  final double radius;
  final bool isGroup;

  const UserAvatar({
    Key? key,
    this.userId,
    this.avatarUrl,
    required this.fallbackText,
    this.radius = 20,
    this.isGroup = false,
  }) : super(key: key);

  @override
  State<UserAvatar> createState() => _UserAvatarState();
}

class _UserAvatarState extends State<UserAvatar> {
  final _avatarService = AvatarService();
  String? _fetchedAvatarUrl;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _loadAvatar();
  }

  @override
  void didUpdateWidget(UserAvatar oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Reload if userId changed
    if (oldWidget.userId != widget.userId || oldWidget.avatarUrl != widget.avatarUrl) {
      _loadAvatar();
    }
  }

  Future<void> _loadAvatar() async {
    // If avatarUrl is directly provided, use it
    if (widget.avatarUrl != null) {
      setState(() {
        _fetchedAvatarUrl = widget.avatarUrl;
      });
      return;
    }

    // If userId provided, fetch avatar
    if (widget.userId != null) {
      setState(() => _isLoading = true);
      
      try {
        final url = await _avatarService.getAvatarUrl(widget.userId!);
        if (mounted) {
          setState(() {
            _fetchedAvatarUrl = url;
            _isLoading = false;
          });
        }
      } catch (e) {
        if (mounted) {
          setState(() => _isLoading = false);
        }
        // Silently fail - fallback will be shown
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    // Show loading indicator
    if (_isLoading) {
      return CircleAvatar(
        radius: widget.radius,
        backgroundColor: theme.colorScheme.primary.withOpacity(0.2),
        child: SizedBox(
          width: widget.radius,
          height: widget.radius,
          child: const CircularProgressIndicator(strokeWidth: 2),
        ),
      );
    }

    // Show avatar image if available
    if (_fetchedAvatarUrl != null && _fetchedAvatarUrl!.isNotEmpty) {
      return CircleAvatar(
        radius: widget.radius,
        backgroundColor: theme.colorScheme.primary,
        backgroundImage: NetworkImage(_fetchedAvatarUrl!),
        // Error handling: show fallback if image fails to load
        onBackgroundImageError: (exception, stackTrace) {
          print('Error loading avatar: $exception');
        },
        child: Container(), // Empty container as placeholder
      );
    }

    // Fallback: Show initial or group icon
    return CircleAvatar(
      radius: widget.radius,
      backgroundColor: theme.colorScheme.primary,
      child: widget.isGroup
          ? Icon(
              Icons.group,
              color: Colors.white,
              size: widget.radius * 1.2,
            )
          : Text(
              _getInitial(widget.fallbackText),
              style: TextStyle(
                fontSize: widget.radius * 0.9,
                fontWeight: FontWeight.bold,
                color: Colors.white,
              ),
            ),
    );
  }

  /// Get first letter of name for fallback
  String _getInitial(String text) {
    if (text.isEmpty) return '?';
    return text[0].toUpperCase();
  }
}
</file>

<file path="Makefile">
contracts/gen: ; npm --prefix ../contracts run gen:dart
fmt: ; dart format .
dev: ; flutter run --dart-define-from-file=.env.dev.json
test: ; flutter test
</file>

<file path="pubspec.yaml">
name: messageai
description: MessageAI - Cross-platform messaging app with Flutter
version: 0.1.0+1
publish_to: none

environment:
  sdk: ^3.0.0
  flutter: ">=3.10.0"

dependencies:
  flutter:
    sdk: flutter

  # Network & API
  supabase_flutter: ^1.10.0
  dio: ^5.3.0

  # State management
  riverpod: ^2.4.0
  flutter_riverpod: ^2.4.0

  # Local database
  drift: ^2.14.0
  drift_flutter: ^0.2.7
  sqlite3_flutter_libs: ^0.5.16

  # Firebase
  firebase_core: ^2.27.0
  firebase_messaging: ^14.6.0

  # Local notifications (Phase 06)
  flutter_local_notifications: ^19.0.0

  # UI
  cupertino_icons: ^1.0.2

  # Utilities
  uuid: ^4.0.0
  image_picker: ^1.0.4
  path: ^1.8.3
  http: ^1.2.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter

  flutter_lints: ^3.0.0

  # Code generation
  build_runner: ^2.4.0
  drift_dev: ^2.14.0

flutter:
  uses-material-design: true

dependency_overrides:
  # Completely exclude sign_in_with_apple (uses deprecated Flutter APIs incompatible with latest Android)
  sign_in_with_apple:
  sign_in_with_apple_platform_interface:
  sign_in_with_apple_web:
</file>

<file path="test/models/action_item_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/action_item.dart';

void main() {
  group('ActionItem', () {
    test('fromJson creates correct instance', () {
      final json = {
        'id': 'action-123',
        'follow_up_item_id': 'follow-456',
        'action_type': 'send',
        'action_target': 'quarterly report',
        'commitment_text': "I'll send you the quarterly report by Friday",
        'mentioned_deadline': 'by Friday',
        'extracted_deadline': 1640000000,
      };

      final action = ActionItem.fromJson(json);

      expect(action.id, 'action-123');
      expect(action.followUpItemId, 'follow-456');
      expect(action.actionType, 'send');
      expect(action.actionTarget, 'quarterly report');
      expect(action.commitmentText, "I'll send you the quarterly report by Friday");
      expect(action.mentionedDeadline, 'by Friday');
      expect(action.extractedDeadline, 1640000000);
    });

    test('fromJson handles null optional fields', () {
      final json = {
        'id': 'action-123',
        'follow_up_item_id': 'follow-456',
        'action_type': 'call',
        'commitment_text': "I'll call you later",
      };

      final action = ActionItem.fromJson(json);

      expect(action.actionTarget, isNull);
      expect(action.mentionedDeadline, isNull);
      expect(action.extractedDeadline, isNull);
    });

    group('getActionEmoji', () {
      test('returns correct emoji for send', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'send',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '📤');
      });

      test('returns correct emoji for call', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'call',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '📞');
      });

      test('returns correct emoji for meet', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'meet',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '🤝');
      });

      test('returns correct emoji for review', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'review',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '📋');
      });

      test('returns correct emoji for decide', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'decide',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '🤔');
      });

      test('returns correct emoji for follow_up', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'follow_up',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '🔄');
      });

      test('returns correct emoji for check', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'check',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '✅');
      });

      test('returns correct emoji for schedule', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'schedule',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '📅');
      });

      test('returns default emoji for unknown type', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'unknown',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '📌');
      });

      test('handles case insensitive action types', () {
        final action = ActionItem(
          id: 'test',
          followUpItemId: 'follow',
          actionType: 'SEND',
          commitmentText: 'test',
        );
        expect(action.getActionEmoji(), '📤');
      });
    });
  });
}
</file>

<file path="test/models/ai_analysis_enhanced_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('AIAnalysis Enhanced Fields', () {
    test('parses complete enhanced analysis from JSON', () {
      final json = {
        'id': 'test-id-123',
        'message_id': 'msg-456',
        'tone': 'Overwhelmed',
        'urgency_level': 'High',
        'intent': 'expressing severe stress',
        'confidence_score': 0.92,
        'analysis_timestamp': 1234567890,
        'intensity': 'very_high',
        'secondary_tones': ['Frustrated', 'Concerned'],
        'context_flags': {
          'tone_indicator_present': true,
          'sarcasm_detected': false,
          'ambiguous': false,
        },
        'anxiety_assessment': {
          'risk_level': 'high',
          'mitigation_suggestions': [
            'Urgent tone detected. Consider asking for a specific timeline.'
          ],
        },
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.id, 'test-id-123');
      expect(analysis.messageId, 'msg-456');
      expect(analysis.tone, 'Overwhelmed');
      expect(analysis.urgencyLevel, 'High');
      expect(analysis.intent, 'expressing severe stress');
      expect(analysis.confidenceScore, 0.92);
      expect(analysis.intensity, 'very_high');
      expect(analysis.secondaryTones, ['Frustrated', 'Concerned']);
      expect(analysis.contextFlags?['tone_indicator_present'], true);
      expect(analysis.anxietyAssessment?['risk_level'], 'high');
    });

    test('parses analysis without enhanced fields (backward compatibility)', () {
      final json = {
        'id': 'test-id-123',
        'message_id': 'msg-456',
        'tone': 'Friendly',
        'urgency_level': 'Low',
        'intent': 'greeting',
        'confidence_score': 0.85,
        'analysis_timestamp': 1234567890,
        // No enhanced fields
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.tone, 'Friendly');
      expect(analysis.intensity, null);
      expect(analysis.secondaryTones, null);
      expect(analysis.contextFlags, null);
      expect(analysis.anxietyAssessment, null);
    });

    test('toJson includes all enhanced fields', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Playful',
        urgencyLevel: 'Low',
        intent: 'joking around',
        confidenceScore: 0.88,
        analysisTimestamp: 1234567890,
        intensity: 'medium',
        secondaryTones: ['Friendly'],
        contextFlags: {'tone_indicator_present': true},
        anxietyAssessment: {'risk_level': 'low'},
      );

      final json = analysis.toJson();

      expect(json['tone'], 'Playful');
      expect(json['intensity'], 'medium');
      expect(json['secondary_tones'], ['Friendly']);
      expect(json['context_flags'], {'tone_indicator_present': true});
      expect(json['anxiety_assessment'], {'risk_level': 'low'});
    });

    test('toJson excludes null enhanced fields', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Neutral',
        analysisTimestamp: 1234567890,
        // All optional fields are null
      );

      final json = analysis.toJson();

      expect(json.containsKey('intensity'), false);
      expect(json.containsKey('secondary_tones'), false);
      expect(json.containsKey('context_flags'), false);
      expect(json.containsKey('anxiety_assessment'), false);
    });

    test('toString includes intensity field', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Excited',
        intensity: 'high',
        analysisTimestamp: 1234567890,
      );

      final str = analysis.toString();

      expect(str.contains('Excited'), true);
      expect(str.contains('high'), true);
    });

    test('handles all 23 tone types', () {
      final tones = [
        'Friendly', 'Professional', 'Urgent', 'Casual', 'Formal', 'Concerned',
        'Excited', 'Neutral', 'Apologetic', 'Appreciative', 'Frustrated', 'Playful',
        'Sarcastic', 'Empathetic', 'Inquisitive', 'Assertive', 'Tentative', 'Defensive',
        'Encouraging', 'Disappointed', 'Overwhelmed', 'Relieved', 'Confused'
      ];

      for (final tone in tones) {
        final json = {
          'id': 'test-id',
          'message_id': 'msg-id',
          'tone': tone,
          'analysis_timestamp': 1234567890,
        };

        final analysis = AIAnalysis.fromJson(json);
        expect(analysis.tone, tone);
      }
    });

    test('handles all 5 intensity levels', () {
      final intensities = ['very_low', 'low', 'medium', 'high', 'very_high'];

      for (final intensity in intensities) {
        final json = {
          'id': 'test-id',
          'message_id': 'msg-id',
          'tone': 'Friendly',
          'intensity': intensity,
          'analysis_timestamp': 1234567890,
        };

        final analysis = AIAnalysis.fromJson(json);
        expect(analysis.intensity, intensity);
      }
    });

    test('parses complex context flags', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-id',
        'tone': 'Sarcastic',
        'analysis_timestamp': 1234567890,
        'context_flags': {
          'sarcasm_detected': true,
          'tone_indicator_present': true,
          'ambiguous': false,
          'figurative_language': true,
        },
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.contextFlags?['sarcasm_detected'], true);
      expect(analysis.contextFlags?['tone_indicator_present'], true);
      expect(analysis.contextFlags?['ambiguous'], false);
      expect(analysis.contextFlags?['figurative_language'], true);
    });

    test('parses anxiety assessment with suggestions', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-id',
        'tone': 'Urgent',
        'analysis_timestamp': 1234567890,
        'anxiety_assessment': {
          'risk_level': 'high',
          'mitigation_suggestions': [
            'Urgent tone detected. Consider asking for a specific timeline.',
            'Take a deep breath before responding.',
          ],
        },
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.anxietyAssessment?['risk_level'], 'high');
      final suggestions = analysis.anxietyAssessment?['mitigation_suggestions'] as List;
      expect(suggestions.length, 2);
      expect(suggestions[0], contains('Urgent tone'));
    });
  });
}
</file>

<file path="test/models/ai_analysis_phase1_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('AIAnalysis Phase 1 Integration Tests', () {
    test('fromJson parses Phase 1 fields correctly', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-123',
        'tone': 'Neutral',
        'urgency_level': 'Low',
        'intent': 'Quick acknowledgment',
        'confidence_score': 0.85,
        'analysis_timestamp': 1234567890,
        'rsd_triggers': [
          {
            'pattern': 'ok',
            'severity': 'high',
            'explanation': 'Single-word responses can trigger RSD',
            'reassurance': 'This is likely just a quick acknowledgment',
          }
        ],
        'alternative_interpretations': [
          {
            'interpretation': 'Simple acknowledgment',
            'tone': 'Neutral',
            'likelihood': 70,
            'reasoning': 'Most common use',
            'context_clues': ['No conflict'],
          }
        ],
        'evidence': [
          {
            'type': 'length',
            'quote': 'ok',
            'supports': 'brevity',
            'reasoning': 'Very short message',
          }
        ],
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.id, 'test-id');
      expect(analysis.messageId, 'msg-123');
      expect(analysis.tone, 'Neutral');
      
      // Check Phase 1 fields
      expect(analysis.rsdTriggers, isNotNull);
      expect(analysis.rsdTriggers!.length, 1);
      expect(analysis.rsdTriggers![0].pattern, 'ok');
      expect(analysis.rsdTriggers![0].severity, 'high');
      
      expect(analysis.alternativeInterpretations, isNotNull);
      expect(analysis.alternativeInterpretations!.length, 1);
      expect(analysis.alternativeInterpretations![0].interpretation, 'Simple acknowledgment');
      expect(analysis.alternativeInterpretations![0].likelihood, 70);
      
      expect(analysis.evidence, isNotNull);
      expect(analysis.evidence!.length, 1);
      expect(analysis.evidence![0].type, 'length');
      expect(analysis.evidence![0].quote, 'ok');
    });

    test('toJson serializes Phase 1 fields correctly', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-123',
        tone: 'Neutral',
        urgencyLevel: 'Low',
        intent: 'Test',
        confidenceScore: 0.85,
        analysisTimestamp: 1234567890,
        rsdTriggers: [
          const RSDTrigger(
            pattern: 'ok',
            severity: 'high',
            explanation: 'test',
            reassurance: 'test',
          )
        ],
        alternativeInterpretations: [
          const MessageInterpretation(
            interpretation: 'test',
            tone: 'Neutral',
            likelihood: 70,
            reasoning: 'test',
            contextClues: [],
          )
        ],
        evidence: [
          const Evidence(
            type: 'keyword',
            quote: 'ASAP',
            supports: 'urgency',
            reasoning: 'test',
          )
        ],
      );

      final json = analysis.toJson();

      expect(json['rsd_triggers'], isNotNull);
      expect(json['rsd_triggers'], isList);
      expect((json['rsd_triggers'] as List).length, 1);
      
      expect(json['alternative_interpretations'], isNotNull);
      expect(json['alternative_interpretations'], isList);
      expect((json['alternative_interpretations'] as List).length, 1);
      
      expect(json['evidence'], isNotNull);
      expect(json['evidence'], isList);
      expect((json['evidence'] as List).length, 1);
    });

    test('fromJson handles null Phase 1 fields', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-123',
        'tone': 'Neutral',
        'analysis_timestamp': 1234567890,
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.rsdTriggers, null);
      expect(analysis.alternativeInterpretations, null);
      expect(analysis.evidence, null);
    });

    test('fromJson handles empty Phase 1 arrays', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-123',
        'tone': 'Neutral',
        'analysis_timestamp': 1234567890,
        'rsd_triggers': [],
        'alternative_interpretations': [],
        'evidence': [],
      };

      final analysis = AIAnalysis.fromJson(json);

      expect(analysis.rsdTriggers, isNotNull);
      expect(analysis.rsdTriggers!.isEmpty, true);
      expect(analysis.alternativeInterpretations, isNotNull);
      expect(analysis.alternativeInterpretations!.isEmpty, true);
      expect(analysis.evidence, isNotNull);
      expect(analysis.evidence!.isEmpty, true);
    });
  });
}
</file>

<file path="test/models/ai_analysis_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('AIAnalysis Model', () {
    test('fromJson creates valid object with all fields', () {
      final json = {
        'id': 'test-id-123',
        'message_id': 'msg-456',
        'tone': 'Professional',
        'urgency_level': 'Medium',
        'intent': 'requesting information',
        'confidence_score': 0.85,
        'analysis_timestamp': 1234567890,
      };
      
      final analysis = AIAnalysis.fromJson(json);
      
      expect(analysis.id, equals('test-id-123'));
      expect(analysis.messageId, equals('msg-456'));
      expect(analysis.tone, equals('Professional'));
      expect(analysis.urgencyLevel, equals('Medium'));
      expect(analysis.intent, equals('requesting information'));
      expect(analysis.confidenceScore, equals(0.85));
      expect(analysis.analysisTimestamp, equals(1234567890));
    });
    
    test('fromJson handles null optional fields', () {
      final json = {
        'id': 'test-id',
        'message_id': 'msg-id',
        'tone': 'Neutral',
        'analysis_timestamp': 1234567890,
      };
      
      final analysis = AIAnalysis.fromJson(json);
      
      expect(analysis.tone, equals('Neutral'));
      expect(analysis.urgencyLevel, isNull);
      expect(analysis.intent, isNull);
      expect(analysis.confidenceScore, isNull);
    });
    
    test('toJson creates correct map', () {
      final analysis = AIAnalysis(
        id: 'id-1',
        messageId: 'msg-1',
        tone: 'Friendly',
        urgencyLevel: 'Low',
        intent: 'greeting',
        confidenceScore: 0.9,
        analysisTimestamp: 9876543210,
      );
      
      final json = analysis.toJson();
      
      expect(json['id'], equals('id-1'));
      expect(json['message_id'], equals('msg-1'));
      expect(json['tone'], equals('Friendly'));
      expect(json['urgency_level'], equals('Low'));
      expect(json['intent'], equals('greeting'));
      expect(json['confidence_score'], equals(0.9));
      expect(json['analysis_timestamp'], equals(9876543210));
    });
    
    test('equality works correctly', () {
      final a1 = AIAnalysis(
        id: 'same-id',
        messageId: 'same-msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );
      
      final a2 = AIAnalysis(
        id: 'same-id',
        messageId: 'same-msg',
        tone: 'Professional', // Different tone
        analysisTimestamp: 456, // Different timestamp
      );
      
      final a3 = AIAnalysis(
        id: 'different-id',
        messageId: 'same-msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );
      
      expect(a1, equals(a2)); // Same ID and message ID
      expect(a1, isNot(equals(a3))); // Different ID
    });
    
    test('hashCode is consistent', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Casual',
        analysisTimestamp: 123,
      );
      
      final hash1 = analysis.hashCode;
      final hash2 = analysis.hashCode;
      
      expect(hash1, equals(hash2));
    });
    
    test('toString includes key information', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-id',
        tone: 'Urgent',
        urgencyLevel: 'High',
        intent: 'needs response',
        confidenceScore: 0.95,
        analysisTimestamp: 123456,
      );
      
      final str = analysis.toString();
      
      expect(str, contains('test-id'));
      expect(str, contains('msg-id'));
      expect(str, contains('Urgent'));
      expect(str, contains('High'));
    });
    
    test('handles double and int confidence scores', () {
      // Test with integer
      final json1 = {
        'id': 'id-1',
        'message_id': 'msg-1',
        'tone': 'Neutral',
        'confidence_score': 1,
        'analysis_timestamp': 123,
      };
      
      final analysis1 = AIAnalysis.fromJson(json1);
      expect(analysis1.confidenceScore, equals(1.0));
      
      // Test with double
      final json2 = {
        'id': 'id-2',
        'message_id': 'msg-2',
        'tone': 'Neutral',
        'confidence_score': 0.75,
        'analysis_timestamp': 123,
      };
      
      final analysis2 = AIAnalysis.fromJson(json2);
      expect(analysis2.confidenceScore, equals(0.75));
    });
    
    test('round-trip JSON serialization preserves data', () {
      final original = AIAnalysis(
        id: 'round-trip-id',
        messageId: 'round-trip-msg',
        tone: 'Excited',
        urgencyLevel: 'Medium',
        intent: 'celebration',
        confidenceScore: 0.88,
        analysisTimestamp: 1111111111,
      );
      
      final json = original.toJson();
      final reconstructed = AIAnalysis.fromJson(json);
      
      expect(reconstructed, equals(original));
      expect(reconstructed.id, equals(original.id));
      expect(reconstructed.messageId, equals(original.messageId));
      expect(reconstructed.tone, equals(original.tone));
      expect(reconstructed.urgencyLevel, equals(original.urgencyLevel));
      expect(reconstructed.intent, equals(original.intent));
      expect(reconstructed.confidenceScore, equals(original.confidenceScore));
      expect(reconstructed.analysisTimestamp, equals(original.analysisTimestamp));
    });
  });
}
</file>

<file path="test/models/conversation_context_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/conversation_context.dart';

void main() {
  group('KeyPoint', () {
    test('fromJson creates KeyPoint correctly', () {
      final json = {
        'text': 'Discussed project deadline',
        'timestamp': 1640000000,
      };

      final keyPoint = KeyPoint.fromJson(json);

      expect(keyPoint.text, 'Discussed project deadline');
      expect(keyPoint.timestamp, 1640000000);
    });

    test('getTimeAgo returns "just now" for recent timestamps', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final keyPoint = KeyPoint(
        text: 'Test',
        timestamp: now - 30, // 30 seconds ago
      );

      expect(keyPoint.getTimeAgo(), 'just now');
    });

    test('getTimeAgo returns minutes for timestamps < 1 hour', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final keyPoint = KeyPoint(
        text: 'Test',
        timestamp: now - 600, // 10 minutes ago
      );

      expect(keyPoint.getTimeAgo(), '10m ago');
    });

    test('getTimeAgo returns hours for timestamps < 1 day', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final keyPoint = KeyPoint(
        text: 'Test',
        timestamp: now - 7200, // 2 hours ago
      );

      expect(keyPoint.getTimeAgo(), '2h ago');
    });

    test('getTimeAgo returns days for timestamps < 1 week', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final keyPoint = KeyPoint(
        text: 'Test',
        timestamp: now - 259200, // 3 days ago
      );

      expect(keyPoint.getTimeAgo(), '3d ago');
    });

    test('getTimeAgo returns weeks for older timestamps', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final keyPoint = KeyPoint(
        text: 'Test',
        timestamp: now - 1209600, // 2 weeks ago
      );

      expect(keyPoint.getTimeAgo(), '2w ago');
    });
  });

  group('ConversationContext', () {
    test('fromJson creates ConversationContext correctly', () {
      final json = {
        'conversation_id': 'conv-123',
        'last_discussed': 'Project deadline and budget',
        'key_points': [
          {'text': 'Deadline is next Friday', 'timestamp': 1640000000},
          {'text': 'Budget approved', 'timestamp': 1640001000},
        ],
        'pending_questions': ['When can we start?', 'Who is the lead?'],
        'from_cache': true,
        'cache_age': 120,
      };

      final context = ConversationContext.fromJson(json);

      expect(context.conversationId, 'conv-123');
      expect(context.lastDiscussed, 'Project deadline and budget');
      expect(context.keyPoints.length, 2);
      expect(context.keyPoints[0].text, 'Deadline is next Friday');
      expect(context.keyPoints[1].text, 'Budget approved');
      expect(context.pendingQuestions.length, 2);
      expect(context.pendingQuestions[0], 'When can we start?');
      expect(context.fromCache, true);
      expect(context.cacheAge, 120);
    });

    test('fromJson handles missing optional fields', () {
      final json = {
        'conversation_id': 'conv-123',
        'last_discussed': 'Project deadline',
        'key_points': [],
      };

      final context = ConversationContext.fromJson(json);

      expect(context.conversationId, 'conv-123');
      expect(context.keyPoints.isEmpty, true);
      expect(context.pendingQuestions.isEmpty, true);
      expect(context.fromCache, false);
      expect(context.cacheAge, null);
    });

    test('fromJson defaults conversation_id to empty string if null', () {
      final json = {
        'last_discussed': 'Test',
        'key_points': [],
      };

      final context = ConversationContext.fromJson(json);

      expect(context.conversationId, '');
    });

    test('handles empty key_points and pending_questions lists', () {
      final json = {
        'conversation_id': 'conv-123',
        'last_discussed': 'Test',
        'key_points': [],
        'pending_questions': [],
      };

      final context = ConversationContext.fromJson(json);

      expect(context.keyPoints.isEmpty, true);
      expect(context.pendingQuestions.isEmpty, true);
    });
  });
}
</file>

<file path="test/models/evidence_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('Evidence Model Tests', () {
    test('fromJson parses correctly', () {
      final json = {
        'type': 'keyword',
        'quote': 'ASAP',
        'supports': 'urgency',
        'reasoning': 'Explicit urgency marker',
      };

      final evidence = Evidence.fromJson(json);

      expect(evidence.type, 'keyword');
      expect(evidence.quote, 'ASAP');
      expect(evidence.supports, 'urgency');
      expect(evidence.reasoning, 'Explicit urgency marker');
    });

    test('toJson serializes correctly', () {
      const evidence = Evidence(
        type: 'punctuation',
        quote: '!!!',
        supports: 'high intensity',
        reasoning: 'Multiple exclamation marks show strong emotion',
      );

      final json = evidence.toJson();

      expect(json['type'], 'punctuation');
      expect(json['quote'], '!!!');
      expect(json['supports'], 'high intensity');
      expect(json['reasoning'], 'Multiple exclamation marks show strong emotion');
    });

    test('isKeywordEvidence returns true for keyword type', () {
      const evidence = Evidence(
        type: 'keyword',
        quote: 'ASAP',
        supports: 'urgency',
        reasoning: 'test',
      );

      expect(evidence.isKeywordEvidence, true);
      expect(evidence.isPunctuationEvidence, false);
      expect(evidence.isEmojiEvidence, false);
    });

    test('isPunctuationEvidence returns true for punctuation type', () {
      const evidence = Evidence(
        type: 'punctuation',
        quote: '!!!',
        supports: 'intensity',
        reasoning: 'test',
      );

      expect(evidence.isKeywordEvidence, false);
      expect(evidence.isPunctuationEvidence, true);
      expect(evidence.isEmojiEvidence, false);
    });

    test('isEmojiEvidence returns true for emoji type', () {
      const evidence = Evidence(
        type: 'emoji',
        quote: '😊',
        supports: 'friendly tone',
        reasoning: 'test',
      );

      expect(evidence.isKeywordEvidence, false);
      expect(evidence.isPunctuationEvidence, false);
      expect(evidence.isEmojiEvidence, true);
    });
  });
}
</file>

<file path="test/models/follow_up_item_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/follow_up_item.dart';

void main() {
  group('FollowUpItemType', () {
    test('fromString returns correct enum', () {
      expect(
        FollowUpItemType.fromString('action_item'),
        FollowUpItemType.actionItem,
      );
      expect(
        FollowUpItemType.fromString('unanswered_question'),
        FollowUpItemType.unansweredQuestion,
      );
    });

    test('fromString returns default for invalid value', () {
      expect(
        FollowUpItemType.fromString('invalid'),
        FollowUpItemType.pendingResponse,
      );
    });

    test('getColor returns correct colors', () {
      expect(
        FollowUpItemType.actionItem.getColor().value,
        greaterThan(0),
      );
    });

    test('enum has correct values', () {
      expect(FollowUpItemType.actionItem.value, 'action_item');
      expect(FollowUpItemType.actionItem.displayName, 'Action Item');
    });
  });

  group('FollowUpStatus', () {
    test('fromString returns correct enum', () {
      expect(FollowUpStatus.fromString('pending'), FollowUpStatus.pending);
      expect(FollowUpStatus.fromString('completed'), FollowUpStatus.completed);
    });

    test('fromString returns default for invalid value', () {
      expect(FollowUpStatus.fromString('invalid'), FollowUpStatus.pending);
    });
  });

  group('FollowUpItem', () {
    late FollowUpItem item;

    setUp(() {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      item = FollowUpItem(
        id: 'test-id',
        userId: 'user-123',
        conversationId: 'conv-456',
        itemType: FollowUpItemType.actionItem,
        title: 'Send report',
        description: 'Send quarterly report to client',
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now - 3600, // 1 hour ago
        dueAt: now + 7200, // 2 hours from now
      );
    });

    test('fromJson creates correct instance', () {
      final json = {
        'id': 'test-id',
        'user_id': 'user-123',
        'conversation_id': 'conv-456',
        'item_type': 'action_item',
        'title': 'Test',
        'status': 'pending',
        'priority': 50,
        'detected_at': 1000,
      };

      final item = FollowUpItem.fromJson(json);

      expect(item.id, 'test-id');
      expect(item.userId, 'user-123');
      expect(item.conversationId, 'conv-456');
      expect(item.itemType, FollowUpItemType.actionItem);
      expect(item.status, FollowUpStatus.pending);
    });

    test('isOverdue returns false for future due date', () {
      expect(item.isOverdue, false);
    });

    test('isOverdue returns true for past due date', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final overdueItem = FollowUpItem(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        itemType: FollowUpItemType.actionItem,
        title: 'Overdue',
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now - 7200,
        dueAt: now - 3600, // 1 hour ago
      );

      expect(overdueItem.isOverdue, true);
    });

    test('isDueSoon returns true for items due within 24h', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final dueSoonItem = FollowUpItem(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        itemType: FollowUpItemType.actionItem,
        title: 'Due Soon',
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now,
        dueAt: now + (12 * 3600), // 12 hours from now
      );

      expect(dueSoonItem.isDueSoon, true);
    });

    test('isDueSoon returns false for items due later', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final laterItem = FollowUpItem(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        itemType: FollowUpItemType.actionItem,
        title: 'Later',
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now,
        dueAt: now + (48 * 3600), // 48 hours from now
      );

      expect(laterItem.isDueSoon, false);
    });

    test('getTimeUntilDue returns correct format', () {
      expect(item.getTimeUntilDue(), isNotEmpty);
    });

    test('getTimeUntilDue returns "Overdue" for past due', () {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final overdueItem = FollowUpItem(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        itemType: FollowUpItemType.actionItem,
        title: 'Overdue',
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now - 7200,
        dueAt: now - 3600,
      );

      expect(overdueItem.getTimeUntilDue(), 'Overdue');
    });

    test('getTimeSinceDetected returns correct format', () {
      expect(item.getTimeSinceDetected(), contains('ago'));
    });

    test('fromJson handles item_id or id field', () {
      final json1 = {
        'item_id': 'test-1',
        'user_id': 'user',
        'conversation_id': 'conv',
        'item_type': 'action_item',
        'title': 'Test',
        'status': 'pending',
        'priority': 50,
        'detected_at': 1000,
      };

      final json2 = {
        'id': 'test-2',
        'user_id': 'user',
        'conversation_id': 'conv',
        'item_type': 'action_item',
        'title': 'Test',
        'status': 'pending',
        'priority': 50,
        'detected_at': 1000,
      };

      expect(FollowUpItem.fromJson(json1).id, 'test-1');
      expect(FollowUpItem.fromJson(json2).id, 'test-2');
    });
  });
}
</file>

<file path="test/models/message_interpretation_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('MessageInterpretation Model Tests', () {
    test('fromJson parses correctly', () {
      final json = {
        'interpretation': 'Simple acknowledgment',
        'tone': 'Neutral',
        'likelihood': 70,
        'reasoning': 'Most common use of ok',
        'context_clues': ['No prior conflict', 'Normal conversation flow'],
      };

      final interp = MessageInterpretation.fromJson(json);

      expect(interp.interpretation, 'Simple acknowledgment');
      expect(interp.tone, 'Neutral');
      expect(interp.likelihood, 70);
      expect(interp.reasoning, 'Most common use of ok');
      expect(interp.contextClues.length, 2);
      expect(interp.contextClues[0], 'No prior conflict');
    });

    test('toJson serializes correctly', () {
      const interp = MessageInterpretation(
        interpretation: 'Mildly annoyed',
        tone: 'Frustrated',
        likelihood: 20,
        reasoning: 'Brief response could indicate frustration',
        contextClues: ['Shorter than usual', 'No warmth markers'],
      );

      final json = interp.toJson();

      expect(json['interpretation'], 'Mildly annoyed');
      expect(json['tone'], 'Frustrated');
      expect(json['likelihood'], 20);
      expect(json['reasoning'], 'Brief response could indicate frustration');
      expect((json['context_clues'] as List).length, 2);
    });

    test('isLikely returns true for likelihood >= 60', () {
      const interp = MessageInterpretation(
        interpretation: 'test',
        tone: 'test',
        likelihood: 70,
        reasoning: 'test',
        contextClues: [],
      );

      expect(interp.isLikely, true);
      expect(interp.isPossible, false);
      expect(interp.isUnlikely, false);
    });

    test('isPossible returns true for likelihood 30-59', () {
      const interp = MessageInterpretation(
        interpretation: 'test',
        tone: 'test',
        likelihood: 45,
        reasoning: 'test',
        contextClues: [],
      );

      expect(interp.isLikely, false);
      expect(interp.isPossible, true);
      expect(interp.isUnlikely, false);
    });

    test('isUnlikely returns true for likelihood < 30', () {
      const interp = MessageInterpretation(
        interpretation: 'test',
        tone: 'test',
        likelihood: 10,
        reasoning: 'test',
        contextClues: [],
      );

      expect(interp.isLikely, false);
      expect(interp.isPossible, false);
      expect(interp.isUnlikely, true);
    });

    test('edge case: likelihood = 60 is likely', () {
      const interp = MessageInterpretation(
        interpretation: 'test',
        tone: 'test',
        likelihood: 60,
        reasoning: 'test',
        contextClues: [],
      );

      expect(interp.isLikely, true);
    });

    test('edge case: likelihood = 30 is possible', () {
      const interp = MessageInterpretation(
        interpretation: 'test',
        tone: 'test',
        likelihood: 30,
        reasoning: 'test',
        contextClues: [],
      );

      expect(interp.isPossible, true);
    });
  });
}
</file>

<file path="test/models/relationship_profile_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/relationship_profile.dart';

void main() {
  group('RelationshipProfile', () {
    test('fromJson creates RelationshipProfile correctly', () {
      final json = {
        'profile_id': 'profile-123',
        'user_id': 'user-456',
        'conversation_id': 'conv-789',
        'participant_name': 'John Doe',
        'participant_user_id': 'user-999',
        'relationship_type': 'colleague',
        'relationship_notes': 'Works in marketing',
        'conversation_summary': 'We discuss project updates',
        'safe_topics': ['work', 'sports', 'weather'],
        'topics_to_avoid': ['politics', 'religion'],
        'communication_style': 'Direct and professional',
        'typical_response_time': 3600, // 1 hour
        'total_messages': 150,
        'first_message_at': 1640000000,
        'last_message_at': 1650000000,
      };

      final profile = RelationshipProfile.fromJson(json);

      expect(profile.id, 'profile-123');
      expect(profile.userId, 'user-456');
      expect(profile.conversationId, 'conv-789');
      expect(profile.participantName, 'John Doe');
      expect(profile.participantUserId, 'user-999');
      expect(profile.relationshipType, 'colleague');
      expect(profile.relationshipNotes, 'Works in marketing');
      expect(profile.conversationSummary, 'We discuss project updates');
      expect(profile.safeTopics, ['work', 'sports', 'weather']);
      expect(profile.topicsToAvoid, ['politics', 'religion']);
      expect(profile.communicationStyle, 'Direct and professional');
      expect(profile.typicalResponseTime, 3600);
      expect(profile.totalMessages, 150);
      expect(profile.firstMessageAt, 1640000000);
      expect(profile.lastMessageAt, 1650000000);
    });

    test('fromJson handles id field if profile_id is missing', () {
      final json = {
        'id': 'profile-123',
        'user_id': 'user-456',
        'conversation_id': 'conv-789',
        'participant_name': 'Jane Doe',
      };

      final profile = RelationshipProfile.fromJson(json);

      expect(profile.id, 'profile-123');
    });

    test('fromJson handles missing optional fields', () {
      final json = {
        'profile_id': 'profile-123',
        'user_id': 'user-456',
        'conversation_id': 'conv-789',
        'participant_name': 'John Doe',
      };

      final profile = RelationshipProfile.fromJson(json);

      expect(profile.participantUserId, null);
      expect(profile.relationshipType, null);
      expect(profile.safeTopics, []);
      expect(profile.topicsToAvoid, []);
      expect(profile.totalMessages, 0);
    });

    test('getRelationshipEmoji returns correct emoji for each type', () {
      final testCases = {
        'boss': '👔',
        'colleague': '🤝',
        'friend': '😊',
        'family': '👨‍👩‍👧‍👦',
        'client': '💼',
        'unknown': '👤',
      };

      testCases.forEach((type, expectedEmoji) {
        final profile = RelationshipProfile(
          id: 'test',
          userId: 'user',
          conversationId: 'conv',
          participantName: 'Test',
          relationshipType: type == 'unknown' ? null : type,
        );

        expect(profile.getRelationshipEmoji(), expectedEmoji);
      });
    });

    test('getRelationshipEmoji is case-insensitive', () {
      final profile = RelationshipProfile(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        participantName: 'Test',
        relationshipType: 'BOSS',
      );

      expect(profile.getRelationshipEmoji(), '👔');
    });

    test('formatResponseTime returns "Unknown" for null', () {
      final profile = RelationshipProfile(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        participantName: 'Test',
      );

      expect(profile.formatResponseTime(), 'Unknown');
    });

    test('formatResponseTime returns minutes for < 1 hour', () {
      final profile = RelationshipProfile(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        participantName: 'Test',
        typicalResponseTime: 1800, // 30 minutes
      );

      expect(profile.formatResponseTime(), '30 min');
    });

    test('formatResponseTime returns hours for < 1 day', () {
      final profile = RelationshipProfile(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        participantName: 'Test',
        typicalResponseTime: 7200, // 2 hours
      );

      expect(profile.formatResponseTime(), '2 hr');
    });

    test('formatResponseTime returns days for >= 1 day', () {
      final profile = RelationshipProfile(
        id: 'test',
        userId: 'user',
        conversationId: 'conv',
        participantName: 'Test',
        typicalResponseTime: 172800, // 2 days
      );

      expect(profile.formatResponseTime(), '2 days');
    });
  });
}
</file>

<file path="test/models/rsd_trigger_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('RSDTrigger Model Tests', () {
    test('fromJson parses correctly', () {
      final json = {
        'pattern': 'ok',
        'severity': 'high',
        'explanation': 'Single-word responses can trigger RSD',
        'reassurance': 'This is likely just a quick acknowledgment',
      };

      final trigger = RSDTrigger.fromJson(json);

      expect(trigger.pattern, 'ok');
      expect(trigger.severity, 'high');
      expect(trigger.explanation, 'Single-word responses can trigger RSD');
      expect(trigger.reassurance, 'This is likely just a quick acknowledgment');
    });

    test('toJson serializes correctly', () {
      const trigger = RSDTrigger(
        pattern: 'fine',
        severity: 'high',
        explanation: 'Fine can feel passive-aggressive',
        reassurance: 'They might genuinely mean it',
      );

      final json = trigger.toJson();

      expect(json['pattern'], 'fine');
      expect(json['severity'], 'high');
      expect(json['explanation'], 'Fine can feel passive-aggressive');
      expect(json['reassurance'], 'They might genuinely mean it');
    });

    test('isHighSeverity returns true for high severity', () {
      const trigger = RSDTrigger(
        pattern: 'ok',
        severity: 'high',
        explanation: 'test',
        reassurance: 'test',
      );

      expect(trigger.isHighSeverity, true);
      expect(trigger.isMediumSeverity, false);
      expect(trigger.isLowSeverity, false);
    });

    test('isMediumSeverity returns true for medium severity', () {
      const trigger = RSDTrigger(
        pattern: 'sure',
        severity: 'medium',
        explanation: 'test',
        reassurance: 'test',
      );

      expect(trigger.isHighSeverity, false);
      expect(trigger.isMediumSeverity, true);
      expect(trigger.isLowSeverity, false);
    });

    test('isLowSeverity returns true for low severity', () {
      const trigger = RSDTrigger(
        pattern: 'no worries',
        severity: 'low',
        explanation: 'test',
        reassurance: 'test',
      );

      expect(trigger.isHighSeverity, false);
      expect(trigger.isMediumSeverity, false);
      expect(trigger.isLowSeverity, true);
    });
  });
}
</file>

<file path="test/models/safe_topic_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/safe_topic.dart';

void main() {
  group('SafeTopic', () {
    test('fromJson creates SafeTopic correctly', () {
      final json = {
        'id': 'topic-123',
        'topic_name': 'Project Updates',
        'topic_keywords': ['deadline', 'status', 'progress'],
        'message_count': 25,
        'avg_response_time': 1800,
        'positive_tone_rate': 0.85,
        'is_safe': true,
        'last_discussed': 1640000000,
      };

      final topic = SafeTopic.fromJson(json);

      expect(topic.id, 'topic-123');
      expect(topic.topicName, 'Project Updates');
      expect(topic.keywords, ['deadline', 'status', 'progress']);
      expect(topic.messageCount, 25);
      expect(topic.avgResponseTime, 1800);
      expect(topic.positiveToneRate, 0.85);
      expect(topic.isSafe, true);
      expect(topic.lastDiscussed, 1640000000);
    });

    test('fromJson handles missing optional fields', () {
      final json = {
        'id': 'topic-123',
        'topic_name': 'General',
        'message_count': 10,
      };

      final topic = SafeTopic.fromJson(json);

      expect(topic.keywords, []);
      expect(topic.avgResponseTime, null);
      expect(topic.positiveToneRate, null);
      expect(topic.isSafe, true);
      expect(topic.lastDiscussed, null);
    });

    test('getTopicColor returns green for high positive rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.9,
      );

      expect(topic.getTopicColor(), Colors.green);
    });

    test('getTopicColor returns blue for medium positive rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.7,
      );

      expect(topic.getTopicColor(), Colors.blue);
    });

    test('getTopicColor returns orange for low positive rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.5,
      );

      expect(topic.getTopicColor(), Colors.orange);
    });

    test('getTopicColor returns grey for null positive rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
      );

      expect(topic.getTopicColor(), Colors.grey);
    });

    test('getEngagementLabel returns "Great topic!" for high rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.85,
      );

      expect(topic.getEngagementLabel(), 'Great topic!');
    });

    test('getEngagementLabel returns "Good topic" for medium rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.65,
      );

      expect(topic.getEngagementLabel(), 'Good topic');
    });

    test('getEngagementLabel returns "Neutral" for low rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
        positiveToneRate: 0.5,
      );

      expect(topic.getEngagementLabel(), 'Neutral');
    });

    test('getEngagementLabel returns "Unknown" for null rate', () {
      final topic = SafeTopic(
        id: 'test',
        topicName: 'Test',
        keywords: [],
        messageCount: 10,
      );

      expect(topic.getEngagementLabel(), 'Unknown');
    });

    test('isSafe defaults to true', () {
      final json = {
        'id': 'topic-123',
        'topic_name': 'Test',
        'message_count': 10,
      };

      final topic = SafeTopic.fromJson(json);

      expect(topic.isSafe, true);
    });
  });
}
</file>

<file path="test/offline_queue_test.dart">
import 'package:flutter_test/flutter_test.dart';

/// Placeholder test for offline queue functionality
/// Full implementation requires database mocking setup
void main() {
  group('Offline Message Queue', () {
    test('Offline queue service exists', () {
      // Basic test to ensure the test file compiles
      expect(true, isTrue);
    });

    test('Network connectivity service can be instantiated', () {
      // Placeholder test
      expect(1 + 1, equals(2));
    });

    test('Retry service handles exponential backoff', () {
      // Placeholder test
      expect(true, isTrue);
    });
  });

  group('Message Syncing', () {
    test('Messages can be queued', () {
      // Placeholder test
      expect(true, isTrue);
    });

    test('Messages can be synced when online', () {
      // Placeholder test
      expect(true, isTrue);
    });
  });
}
</file>

<file path="test/realtime_diagnostic_test.dart">
import 'package:flutter_test/flutter_test.dart';

/// Placeholder test for realtime diagnostic functionality
void main() {
  group('Realtime Diagnostics', () {
    test('Realtime diagnostic service exists', () {
      // Basic test to ensure the test file compiles
      expect(true, isTrue);
    });

    test('Channel diagnostics can be tracked', () {
      // Placeholder test
      expect(1 + 1, equals(2));
    });

    test('Health checks can be performed', () {
      // Placeholder test  
      expect(true, isTrue);
    });
  });

  group('Connection Testing', () {
    test('Connection test can be executed', () {
      // Placeholder test
      expect(true, isTrue);
    });

    test('Latency can be measured', () {
      // Placeholder test
      expect(true, isTrue);
    });
  });
}
</file>

<file path="test/services/ai_analysis_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  // Note: Service tests that require Supabase client are skipped in unit tests
  // These should be tested in integration tests with proper Supabase setup
  
  group('AIAnalysisService - Unit Tests', () {
    test('service requires Supabase initialization', () {
      // This test documents that the service requires Supabase
      // Full service tests should be done in integration tests
      expect(true, isTrue);
    });
  });
  
  group('AIAnalysis Model Integration', () {
    test('AIAnalysis can be stored and retrieved', () {
      final analysis = AIAnalysis(
        id: 'test-id',
        messageId: 'msg-123',
        tone: 'Friendly',
        urgencyLevel: 'Low',
        intent: 'greeting',
        confidenceScore: 0.9,
        analysisTimestamp: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );
      
      expect(analysis.id, equals('test-id'));
      expect(analysis.messageId, equals('msg-123'));
      expect(analysis.tone, equals('Friendly'));
    });
    
    test('Multiple AIAnalysis objects can coexist', () {
      final analysis1 = AIAnalysis(
        id: 'id-1',
        messageId: 'msg-1',
        tone: 'Professional',
        analysisTimestamp: 123,
      );
      
      final analysis2 = AIAnalysis(
        id: 'id-2',
        messageId: 'msg-2',
        tone: 'Casual',
        analysisTimestamp: 456,
      );
      
      expect(analysis1.id, isNot(equals(analysis2.id)));
      expect(analysis1.tone, isNot(equals(analysis2.tone)));
    });
  });
}
</file>

<file path="test/services/context_preloader_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/services/context_preloader_service.dart';

/// Phase 3: ContextPreloaderService Tests
void main() {
  group('ContextPreloaderService', () {
    late ContextPreloaderService service;

    setUp(() {
      service = ContextPreloaderService();
    });

    group('Singleton Pattern', () {
      test('returns same instance', () {
        final instance1 = ContextPreloaderService();
        final instance2 = ContextPreloaderService();
        expect(identical(instance1, instance2), isTrue);
      });
    });

    group('loadContext', () {
      test('accepts conversationId parameter', () async {
        try {
          final context = await service.loadContext(
            conversationId: 'test-conv-123',
          );
          
          expect(context, isNotNull);
        } catch (e) {
          // Expected to fail without auth/backend
          expect(e.toString(), isNotEmpty);
        }
      });

      test('handles invalid conversation ID', () async {
        try {
          final context = await service.loadContext(conversationId: '');
          expect(context, isNotNull);
        } catch (e) {
          // Expected - should handle gracefully
          expect(e.toString(), isNotEmpty);
        }
      });

      test('handles non-existent conversation', () async {
        try {
          final context = await service.loadContext(
            conversationId: 'non-existent-conv',
          );
          expect(context, isNotNull);
        } catch (e) {
          // Expected
          expect(e.toString(), isNotEmpty);
        }
      });
    });

    group('Cache Management', () {
      test('invalidate method exists', () {
        expect(service.invalidate, isA<Function>());
      });

      test('invalidate accepts conversationId', () {
        expect(
          () => service.invalidate('test-conv-123'),
          returnsNormally,
        );
      });

      test('invalidate handles null/empty conversationId', () {
        expect(() => service.invalidate(''), returnsNormally);
        expect(() => service.invalidate(null), returnsNormally);
      });
    });

    group('Performance', () {
      test('caches results for performance', () async {
        final conversationId = 'test-conv-cache';
        
        try {
          // First load
          final start1 = DateTime.now();
          await service.loadContext(conversationId: conversationId);
          final duration1 = DateTime.now().difference(start1);

          // Second load (should be cached)
          final start2 = DateTime.now();
          await service.loadContext(conversationId: conversationId);
          final duration2 = DateTime.now().difference(start2);

          // Cache should be faster (or at least not slower)
          expect(duration2.inMilliseconds, lessThanOrEqualTo(duration1.inMilliseconds + 100));
        } catch (e) {
          // Expected without backend
        }
      });

      test('invalidate clears cache', () async {
        final conversationId = 'test-conv-invalidate';
        
        try {
          // Load and cache
          await service.loadContext(conversationId: conversationId);
          
          // Invalidate
          service.invalidate(conversationId);
          
          // Load again (should not be cached)
          final context = await service.loadContext(conversationId: conversationId);
          expect(context, isNotNull);
        } catch (e) {
          // Expected without backend
        }
      });
    });

    group('Error Handling', () {
      test('handles network errors gracefully', () async {
        expect(
          () => service.loadContext(conversationId: 'test'),
          returnsNormally,
        );
      });

      test('handles authentication errors', () async {
        // Without auth, should throw or return null
        try {
          await service.loadContext(conversationId: 'test');
        } catch (e) {
          expect(e.toString(), isNotEmpty);
        }
      });
    });

    group('API Methods', () {
      test('has all required methods', () {
        expect(service.loadContext, isA<Function>());
        expect(service.invalidate, isA<Function>());
      });
    });
  });
}
</file>

<file path="test/services/follow_up_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/services/follow_up_service.dart';
import 'package:messageai/models/follow_up_item.dart';

/// Phase 4: FollowUpService Tests
/// Note: These tests require Supabase authentication to be mocked or a test environment
void main() {
  group('FollowUpService', () {
    late FollowUpService service;

    setUp(() {
      service = FollowUpService();
    });

    group('Singleton Pattern', () {
      test('returns same instance', () {
        final instance1 = FollowUpService();
        final instance2 = FollowUpService();
        expect(identical(instance1, instance2), isTrue);
      });
    });

    group('getPendingFollowUps', () {
      test('returns list of follow-up items', () async {
        // Note: This will fail without authentication
        // In a real test, we'd mock the Supabase client
        try {
          final items = await service.getPendingFollowUps();
          expect(items, isList);
          
          // All items should be pending
          for (final item in items) {
            expect(item.status, equals(FollowUpStatus.pending));
          }
        } catch (e) {
          // Expected to fail without auth - skip test
          expect(e.toString(), contains(['auth', 'user', 'session']));
        }
      });

      test('returns empty list when no user authenticated', () async {
        final items = await service.getPendingFollowUps();
        expect(items, isEmpty);
      });
    });

    group('getConversationFollowUps', () {
      test('returns items for specific conversation', () async {
        try {
          final conversationId = 'test-conv-123';
          final items = await service.getConversationFollowUps(conversationId);
          
          expect(items, isList);
          
          // All items should be for the specified conversation
          for (final item in items) {
            expect(item.conversationId, equals(conversationId));
          }
        } catch (e) {
          // Expected to fail without auth
          expect(e.toString(), contains(['auth', 'user', 'session']));
        }
      });

      test('returns empty list for non-existent conversation', () async {
        final items = await service.getConversationFollowUps('non-existent');
        expect(items, isEmpty);
      });
    });

    group('Duration Parameter', () {
      test('snoozeFollowUp accepts Duration object', () async {
        // Test that the method signature accepts Duration
        expect(
          () => service.snoozeFollowUp('test-id', const Duration(hours: 1)),
          returnsNormally,
        );
      });

      test('Duration is converted to seconds correctly', () {
        const duration = Duration(hours: 2, minutes: 30);
        expect(duration.inSeconds, equals(9000));
      });
    });

    group('Error Handling', () {
      test('handles network errors gracefully', () async {
        // Without auth, should return empty list instead of throwing
        final items = await service.getPendingFollowUps();
        expect(items, isEmpty);
      });

      test('handles invalid conversation ID', () async {
        final items = await service.getConversationFollowUps('');
        expect(items, isEmpty);
      });
    });

    group('API Methods', () {
      test('has all required CRUD methods', () {
        expect(service.getPendingFollowUps, isA<Function>());
        expect(service.getConversationFollowUps, isA<Function>());
        expect(service.extractFollowUps, isA<Function>());
        expect(service.completeFollowUp, isA<Function>());
        expect(service.snoozeFollowUp, isA<Function>());
        expect(service.dismissFollowUp, isA<Function>());
      });
    });
  });
}
</file>

<file path="test/services/message_formatter_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/services/message_formatter_service.dart';

/// Phase 2: MessageFormatterService Tests
void main() {
  group('MessageFormatterService', () {
    late MessageFormatterService service;

    setUp(() {
      service = MessageFormatterService(userId: 'test-user-123');
    });

    group('Initialization', () {
      test('requires userId parameter', () {
        expect(() => MessageFormatterService(userId: ''), returnsNormally);
        expect(() => MessageFormatterService(userId: 'user-123'), returnsNormally);
      });

      test('stores userId correctly', () {
        final service = MessageFormatterService(userId: 'test-user-456');
        expect(service, isNotNull);
      });
    });

    group('formatMessage', () {
      test('accepts required message parameter', () async {
        try {
          final result = await service.formatMessage(
            message: "I can't make it to the party",
          );
          
          expect(result, isNotNull);
          expect(result.formattedMessage, isNotEmpty);
        } catch (e) {
          // May fail without backend - that's OK
          expect(e.toString(), isNotEmpty);
        }
      });

      test('handles empty message', () async {
        try {
          final result = await service.formatMessage(message: '');
          expect(result, isNotNull);
        } catch (e) {
          // Expected - empty messages should be handled
          expect(e.toString(), isNotEmpty);
        }
      });

      test('handles long messages', () async {
        final longMessage = 'This is a very long message. ' * 50;
        
        try {
          final result = await service.formatMessage(message: longMessage);
          expect(result, isNotNull);
          expect(result.formattedMessage, isNotEmpty);
        } catch (e) {
          // May fail without backend
          expect(e.toString(), isNotEmpty);
        }
      });
    });

    group('Message Types', () {
      test('handles declining messages', () async {
        final messages = [
          "I can't make it",
          "Sorry, I have to decline",
          "I won't be able to attend",
        ];

        for (final message in messages) {
          try {
            final result = await service.formatMessage(message: message);
            expect(result, isNotNull);
          } catch (e) {
            // Expected without backend
          }
        }
      });

      test('handles boundary messages', () async {
        final messages = [
          "I need you to stop calling me after 9pm",
          "Please respect my time off",
          "I'm not comfortable with that",
        ];

        for (final message in messages) {
          try {
            final result = await service.formatMessage(message: message);
            expect(result, isNotNull);
          } catch (e) {
            // Expected without backend
          }
        }
      });

      test('handles apology messages', () async {
        final messages = [
          "I'm sorry for the delay",
          "I apologize for the mistake",
          "Sorry about that",
        ];

        for (final message in messages) {
          try {
            final result = await service.formatMessage(message: message);
            expect(result, isNotNull);
          } catch (e) {
            // Expected without backend
          }
        }
      });
    });

    group('Error Handling', () {
      test('handles network errors gracefully', () async {
        expect(
          () => service.formatMessage(message: 'test'),
          returnsNormally,
        );
      });

      test('handles authentication errors', () async {
        final unauthService = MessageFormatterService(userId: 'invalid');
        
        expect(
          () => unauthService.formatMessage(message: 'test'),
          returnsNormally,
        );
      });
    });
  });
}
</file>

<file path="test/services/relationship_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/services/relationship_service.dart';

void main() {
  group('RelationshipService', () {
    late RelationshipService service;

    setUp(() {
      service = RelationshipService();
    });

    test('is singleton', () {
      final instance1 = RelationshipService();
      final instance2 = RelationshipService();

      expect(identical(instance1, instance2), true);
    });

    group('getProfile', () {
      test('returns null when user not authenticated', () async {
        // This requires mocking Supabase client
        // In a real test, we'd inject a mock Supabase client
        // For now, document this as needing integration testing
        expect(true, true); // Placeholder
      });

      test('returns null when no profile exists', () async {
        // Would test with mocked Supabase returning null/empty response
        expect(true, true); // Placeholder
      });
    });

    group('getSafeTopics', () {
      test('returns empty list when user not authenticated', () async {
        // Would test with mocked Supabase client
        expect(true, true); // Placeholder
      });

      test('returns empty list when no topics exist', () async {
        // Would test with mocked Supabase returning empty list
        expect(true, true); // Placeholder
      });
    });

    group('updateNotes', () {
      test('updates notes successfully', () async {
        // Would test with mocked Supabase client
        expect(true, true); // Placeholder
      });

      test('handles errors gracefully', () async {
        // Would test error handling
        expect(true, true); // Placeholder
      });
    });

    group('updateRelationshipType', () {
      test('updates relationship type successfully', () async {
        // Would test with mocked Supabase client
        expect(true, true); // Placeholder
      });

      test('handles errors gracefully', () async {
        // Would test error handling
        expect(true, true); // Placeholder
      });
    });
  });
}

// NOTE: These service tests are placeholders. Full implementation requires:
// 1. Mocking Supabase client (could use mockito or create a test double)
// 2. Injecting dependencies through constructor or factory
// 3. Testing actual RPC calls and responses
//
// For a production app, consider:
// - Creating an abstract interface for Supabase operations
// - Using dependency injection to provide mock implementations
// - Writing integration tests that use a test Supabase instance
</file>

<file path="test/widget_test.dart">
// Basic Flutter widget test for MessageAI app

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:messageai/app.dart';

void main() {
  testWidgets('MessageAI app loads', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(
      const ProviderScope(
        child: MessageAIApp(),
      ),
    );

    // Verify app loads without errors
    expect(find.byType(MaterialApp), findsOneWidget);
  });
}
</file>

<file path="test/widgets/context_preview_card_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/features/conversations/widgets/context_preview_card.dart';
import 'package:messageai/models/conversation_context.dart';

void main() {
  group('ContextPreviewCard', () {
    testWidgets('displays last discussed topic', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project deadline and budget',
        keyPoints: [],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('Last Conversation'), findsOneWidget);
      expect(find.text('Project deadline and budget'), findsOneWidget);
    });

    testWidgets('displays key points', (tester) async {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [
          KeyPoint(text: 'Deadline is Friday', timestamp: now - 3600),
          KeyPoint(text: 'Budget approved', timestamp: now - 7200),
          KeyPoint(text: 'Team meeting scheduled', timestamp: now - 10800),
        ],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('Recent topics:'), findsOneWidget);
      expect(find.text('Deadline is Friday'), findsOneWidget);
      expect(find.text('Budget approved'), findsOneWidget);
      expect(find.text('Team meeting scheduled'), findsOneWidget);
    });

    testWidgets('limits key points to 3', (tester) async {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [
          KeyPoint(text: 'Point 1', timestamp: now),
          KeyPoint(text: 'Point 2', timestamp: now),
          KeyPoint(text: 'Point 3', timestamp: now),
          KeyPoint(text: 'Point 4', timestamp: now),
          KeyPoint(text: 'Point 5', timestamp: now),
        ],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('Point 1'), findsOneWidget);
      expect(find.text('Point 2'), findsOneWidget);
      expect(find.text('Point 3'), findsOneWidget);
      expect(find.text('Point 4'), findsNothing);
      expect(find.text('Point 5'), findsNothing);
    });

    testWidgets('displays pending questions badge', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: ['When do we start?', 'Who is the lead?'],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('2 unanswered questions'), findsOneWidget);
      expect(find.byIcon(Icons.help_outline), findsOneWidget);
    });

    testWidgets('displays singular form for single question', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: ['When do we start?'],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('1 unanswered question'), findsOneWidget);
    });

    testWidgets('displays cached indicator when fromCache is true',
        (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
        fromCache: true,
        cacheAge: 120,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('cached'), findsOneWidget);
    });

    testWidgets('does not display cached indicator when fromCache is false',
        (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
        fromCache: false,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('cached'), findsNothing);
    });

    testWidgets('calls onTap callback when tapped', (tester) async {
      bool tapped = false;
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(
              context: context,
              onTap: () => tapped = true,
            ),
          ),
        ),
      );

      await tester.tap(find.byType(ContextPreviewCard));
      expect(tapped, true);
    });

    testWidgets('does not crash when onTap is null', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      await tester.tap(find.byType(ContextPreviewCard));
      // Should not crash
      expect(find.byType(ContextPreviewCard), findsOneWidget);
    });

    testWidgets('hides key points section when empty', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.text('Recent topics:'), findsNothing);
    });

    testWidgets('hides pending questions section when empty', (tester) async {
      final context = ConversationContext(
        conversationId: 'conv-123',
        lastDiscussed: 'Project updates',
        keyPoints: [],
        pendingQuestions: [],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ContextPreviewCard(context: context),
          ),
        ),
      );

      expect(find.byIcon(Icons.help_outline), findsNothing);
    });
  });
}
</file>

<file path="test/widgets/follow_up_card_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/models/follow_up_item.dart';
import 'package:messageai/features/followups/widgets/follow_up_card.dart';

/// Phase 4: FollowUpCard Widget Tests
void main() {
  group('FollowUpCard Widget', () {
    late FollowUpItem testItem;
    bool completeCalled = false;
    bool snoozeCalled = false;
    bool dismissCalled = false;

    setUp(() {
      completeCalled = false;
      snoozeCalled = false;
      dismissCalled = false;

      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      testItem = FollowUpItem(
        id: 'test-123',
        userId: 'user-456',
        conversationId: 'conv-789',
        itemType: FollowUpItemType.actionItem,
        title: 'Send quarterly report',
        description: 'Review and send Q4 financial report to client',
        extractedText: "I'll send you the Q4 report by Friday",
        status: FollowUpStatus.pending,
        priority: 80,
        detectedAt: now - 3600,
        dueAt: now + 7200,
      );
    });

    testWidgets('renders all basic elements', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () => completeCalled = true,
              onSnooze: () => snoozeCalled = true,
              onDismiss: () => dismissCalled = true,
            ),
          ),
        ),
      );

      // Check title is displayed
      expect(find.text('Send quarterly report'), findsOneWidget);

      // Check description is displayed
      expect(find.text('Review and send Q4 financial report to client'), findsOneWidget);

      // Check action buttons exist
      expect(find.text('Done'), findsOneWidget);
      expect(find.text('Snooze'), findsOneWidget);
      expect(find.widgetWithIcon(IconButton, Icons.close), findsOneWidget);
    });

    testWidgets('displays type icon', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () {},
              onSnooze: () {},
              onDismiss: () {},
            ),
          ),
        ),
      );

      // Action item should have task_alt icon
      expect(find.byIcon(Icons.task_alt), findsOneWidget);
    });

    testWidgets('displays extracted text for action items', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () {},
              onSnooze: () {},
              onDismiss: () {},
            ),
          ),
        ),
      );

      // Should show quote icon and extracted text
      expect(find.byIcon(Icons.format_quote), findsOneWidget);
      expect(find.text("I'll send you the Q4 report by Friday"), findsOneWidget);
    });

    testWidgets('displays priority and time metadata', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () {},
              onSnooze: () {},
              onDismiss: () {},
            ),
          ),
        ),
      );

      // Should show priority
      expect(find.textContaining('Priority: 80'), findsOneWidget);

      // Should show time since detected
      expect(find.textContaining('ago'), findsOneWidget);
    });

    testWidgets('displays due date badge when present', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () {},
              onSnooze: () {},
              onDismiss: () {},
            ),
          ),
        ),
      );

      // Should show time until due
      final timeUntilDue = testItem.getTimeUntilDue();
      expect(find.text(timeUntilDue), findsOneWidget);
    });

    testWidgets('highlights overdue items in red', (tester) async {
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final overdueItem = FollowUpItem(
        id: 'overdue-123',
        userId: 'user-456',
        conversationId: 'conv-789',
        itemType: FollowUpItemType.actionItem,
        title: 'Overdue task',
        status: FollowUpStatus.pending,
        priority: 90,
        detectedAt: now - 7200,
        dueAt: now - 3600, // 1 hour ago
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: overdueItem,
              onComplete: () {},
              onSnooze: () {},
              onDismiss: () {},
            ),
          ),
        ),
      );

      // Should display "Overdue"
      expect(find.text('Overdue'), findsOneWidget);

      // Card should have red background (from Colors.red.shade50)
      final card = tester.widget<Card>(find.byType(Card));
      expect(card.color, equals(Colors.red.shade50));
    });

    testWidgets('calls onComplete when Done button tapped', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () => completeCalled = true,
              onSnooze: () => snoozeCalled = true,
              onDismiss: () => dismissCalled = true,
            ),
          ),
        ),
      );

      // Tap Done button
      await tester.tap(find.text('Done'));
      await tester.pumpAndSettle();

      expect(completeCalled, isTrue);
      expect(snoozeCalled, isFalse);
      expect(dismissCalled, isFalse);
    });

    testWidgets('calls onSnooze when Snooze button tapped', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () => completeCalled = true,
              onSnooze: () => snoozeCalled = true,
              onDismiss: () => dismissCalled = true,
            ),
          ),
        ),
      );

      // Tap Snooze button
      await tester.tap(find.text('Snooze'));
      await tester.pumpAndSettle();

      expect(snoozeCalled, isTrue);
      expect(completeCalled, isFalse);
      expect(dismissCalled, isFalse);
    });

    testWidgets('calls onDismiss when close button tapped', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: testItem,
              onComplete: () => completeCalled = true,
              onSnooze: () => snoozeCalled = true,
              onDismiss: () => dismissCalled = true,
            ),
          ),
        ),
      );

      // Tap close button
      await tester.tap(find.widgetWithIcon(IconButton, Icons.close));
      await tester.pumpAndSettle();

      expect(dismissCalled, isTrue);
      expect(completeCalled, isFalse);
      expect(snoozeCalled, isFalse);
    });

    testWidgets('renders without description', (tester) async {
      final itemWithoutDescription = FollowUpItem(
        id: 'test-123',
        userId: 'user-456',
        conversationId: 'conv-789',
        itemType: FollowUpItemType.actionItem,
        title: 'Simple task',
        status: FollowUpStatus.pending,
        priority: 50,
        detectedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FollowUpCard(
              item: itemWithoutDescription,
              onComplete: () {},
              onSnooze: () {},
              onDismiss: () {},
            ),
          ),
        ),
      );

      expect(find.text('Simple task'), findsOneWidget);
    });

    testWidgets('renders different item types with correct icons', (tester) async {
      final types = [
        FollowUpItemType.actionItem,
        FollowUpItemType.unansweredQuestion,
        FollowUpItemType.pendingResponse,
        FollowUpItemType.scheduledFollowup,
      ];

      for (final type in types) {
        final item = FollowUpItem(
          id: 'test-${type.value}',
          userId: 'user',
          conversationId: 'conv',
          itemType: type,
          title: 'Test ${type.displayName}',
          status: FollowUpStatus.pending,
          priority: 50,
          detectedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
        );

        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: FollowUpCard(
                item: item,
                onComplete: () {},
                onSnooze: () {},
                onDismiss: () {},
              ),
            ),
          ),
        );

        // Should have the correct icon (at least one, may appear in multiple places)
        expect(find.byIcon(type.icon), findsWidgets);

        await tester.pumpAndSettle();
      }
    });
  });
}
</file>

<file path="test/widgets/tone_badge_enhanced_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('ToneBadge Enhanced Features', () {
    testWidgets('displays all 23 tones with correct emojis', (tester) async {
      final toneEmojiMap = {
        'Friendly': '😊',
        'Professional': '💼',
        'Urgent': '⚠️',
        'Casual': '😎',
        'Formal': '🎩',
        'Concerned': '😟',
        'Excited': '🎉',
        'Neutral': '😐',
        'Apologetic': '🙏',
        'Appreciative': '🙌',
        'Frustrated': '😤',
        'Playful': '😜',
        'Sarcastic': '🙄',
        'Empathetic': '🤗',
        'Inquisitive': '🤔',
        'Assertive': '💪',
        'Tentative': '😬',
        'Defensive': '🛡️',
        'Encouraging': '💚',
        'Disappointed': '😞',
        'Overwhelmed': '😵',
        'Relieved': '😌',
        'Confused': '😕',
      };

      for (final entry in toneEmojiMap.entries) {
        final analysis = AIAnalysis(
          id: 'test',
          messageId: 'msg',
          tone: entry.key,
          analysisTimestamp: 123,
        );

        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: ToneBadge(analysis: analysis),
            ),
          ),
        );

        expect(find.text(entry.value), findsOneWidget, reason: 'Emoji for ${entry.key}');
        expect(find.text(entry.key), findsOneWidget, reason: 'Label for ${entry.key}');
      }
    });

    testWidgets('displays intensity indicator dot', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        intensity: 'high',
        analysisTimestamp: 123,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      // Should have 2 containers: main badge container + intensity dot
      expect(find.byType(Container), findsWidgets);
      
      // Verify the intensity dot exists (6x6 size)
      final containers = tester.widgetList<Container>(find.byType(Container)).toList();
      final hasDot = containers.any((container) {
        final decoration = container.decoration;
        if (decoration is BoxDecoration) {
          return decoration.shape == BoxShape.circle;
        }
        return false;
      });
      expect(hasDot, true, reason: 'Should have intensity dot');
    });

    testWidgets('displays both intensity and urgency dots', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Overwhelmed',
        intensity: 'very_high',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      // Should have circular indicators for both intensity and urgency
      final containers = tester.widgetList<Container>(find.byType(Container)).toList();
      final circleDots = containers.where((container) {
        final decoration = container.decoration;
        if (decoration is BoxDecoration) {
          return decoration.shape == BoxShape.circle;
        }
        return false;
      }).toList();
      
      expect(circleDots.length, greaterThanOrEqualTo(2), reason: 'Should have both dots');
    });

    testWidgets('does not show intensity dot when intensity is null', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Neutral',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
        // intensity is null
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      // Should only have urgency dot, not intensity
      final containers = tester.widgetList<Container>(find.byType(Container)).toList();
      final circleDots = containers.where((container) {
        final decoration = container.decoration;
        if (decoration is BoxDecoration) {
          return decoration.shape == BoxShape.circle;
        }
        return false;
      }).toList();
      
      expect(circleDots.length, 1, reason: 'Should only have urgency dot');
    });

    testWidgets('calls onTap callback when tapped', (tester) async {
      bool tapped = false;
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(
              analysis: analysis,
              onTap: () => tapped = true,
            ),
          ),
        ),
      );

      await tester.tap(find.byType(ToneBadge));
      expect(tapped, true);
    });

    testWidgets('handles case-insensitive tone matching', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'FRIENDLY', // uppercase
        analysisTimestamp: 123,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      expect(find.text('😊'), findsOneWidget);
    });

    testWidgets('uses default emoji for unknown tone', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'UnknownTone',
        analysisTimestamp: 123,
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );

      expect(find.text('💬'), findsOneWidget, reason: 'Default emoji');
    });
  });
}
</file>

<file path="test/widgets/tone_badge_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/features/messages/widgets/tone_badge.dart';
import 'package:messageai/models/ai_analysis.dart';

void main() {
  group('ToneBadge Widget', () {
    testWidgets('displays Friendly tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        urgencyLevel: 'Low',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('😊'), findsOneWidget);
      expect(find.text('Friendly'), findsOneWidget);
    });
    
    testWidgets('displays Professional tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Professional',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('💼'), findsOneWidget);
      expect(find.text('Professional'), findsOneWidget);
    });
    
    testWidgets('displays Urgent tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Urgent',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('⚡'), findsOneWidget);
      expect(find.text('Urgent'), findsOneWidget);
    });
    
    testWidgets('displays Casual tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Casual',
        urgencyLevel: 'Low',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('😎'), findsOneWidget);
      expect(find.text('Casual'), findsOneWidget);
    });
    
    testWidgets('displays Formal tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Formal',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('👔'), findsOneWidget);
      expect(find.text('Formal'), findsOneWidget);
    });
    
    testWidgets('displays Excited tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Excited',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('🎉'), findsOneWidget);
      expect(find.text('Excited'), findsOneWidget);
    });
    
    testWidgets('displays Concerned tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Concerned',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('😟'), findsOneWidget);
      expect(find.text('Concerned'), findsOneWidget);
    });
    
    testWidgets('displays Neutral tone with correct emoji', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Neutral',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('💬'), findsOneWidget);
      expect(find.text('Neutral'), findsOneWidget);
    });
    
    testWidgets('shows urgency indicator for High urgency', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Urgent',
        urgencyLevel: 'High',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      // Urgency dot should be present (multiple Containers exist)
      expect(find.byType(Container), findsWidgets);
      expect(find.text('Urgent'), findsOneWidget);
    });
    
    testWidgets('shows urgency indicator for Critical urgency', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Professional',
        urgencyLevel: 'Critical',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.byType(Container), findsWidgets);
      expect(find.text('Professional'), findsOneWidget);
    });
    
    testWidgets('does not show urgency indicator for Low urgency', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Casual',
        urgencyLevel: 'Low',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      expect(find.text('Casual'), findsOneWidget);
    });
    
    testWidgets('calls onTap callback when tapped', (tester) async {
      bool wasTapped = false;
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Excited',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(
              analysis: analysis,
              onTap: () => wasTapped = true,
            ),
          ),
        ),
      );
      
      await tester.tap(find.byType(ToneBadge));
      await tester.pump();
      
      expect(wasTapped, isTrue);
    });
    
    testWidgets('can be tapped without onTap callback', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'Friendly',
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      // Should not throw when tapped without callback
      await tester.tap(find.byType(ToneBadge));
      await tester.pump();
      
      expect(find.byType(ToneBadge), findsOneWidget);
    });
    
    testWidgets('handles case-insensitive tone names', (tester) async {
      final analysis = AIAnalysis(
        id: 'test',
        messageId: 'msg',
        tone: 'FRIENDLY', // Uppercase
        analysisTimestamp: 123,
      );
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ToneBadge(analysis: analysis),
          ),
        ),
      );
      
      // Should still show the emoji (case handling in _getToneInfo)
      expect(find.text('😊'), findsOneWidget);
    });
  });
}
</file>

<file path="test/widgets/who_is_this_button_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:messageai/features/conversations/widgets/who_is_this_button.dart';

void main() {
  group('WhoIsThisButton', () {
    testWidgets('displays icon button in compact mode', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: WhoIsThisButton(
              conversationId: 'conv-123',
              compact: true,
            ),
          ),
        ),
      );

      expect(find.byType(IconButton), findsOneWidget);
      expect(find.byIcon(Icons.info_outline), findsOneWidget);
      expect(find.text('Who is this?'), findsNothing);
    });

    testWidgets('displays outlined button in non-compact mode',
        (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: WhoIsThisButton(
              conversationId: 'conv-123',
              compact: false,
            ),
          ),
        ),
      );

      // OutlinedButton.icon creates a complex widget tree, just check for text and icon
      expect(find.text('Who is this?'), findsOneWidget);
      expect(find.byIcon(Icons.info_outline), findsOneWidget);
      expect(find.byType(IconButton), findsNothing);
    });

    testWidgets('defaults to compact=false', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: WhoIsThisButton(
              conversationId: 'conv-123',
            ),
          ),
        ),
      );

      // Should show text label (not compact mode)
      expect(find.text('Who is this?'), findsOneWidget);
    });

    testWidgets('has correct tooltip in compact mode', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: WhoIsThisButton(
              conversationId: 'conv-123',
              compact: true,
            ),
          ),
        ),
      );

      final iconButton = tester.widget<IconButton>(find.byType(IconButton));
      expect(iconButton.tooltip, 'Who is this?');
    });

    // Skipping tests that require Supabase initialization
    // These would be better tested in integration tests with proper setup
    
    testWidgets('tapping compact button does not crash', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: WhoIsThisButton(
              conversationId: 'conv-123',
              compact: true,
            ),
          ),
        ),
      );

      // Just verify the button exists and is tappable
      expect(find.byType(IconButton), findsOneWidget);
      
      // Note: Actually tapping would open RelationshipSummarySheet which
      // requires Supabase initialization. Skipping for unit test.
    });

    testWidgets('widget renders without crashing', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: Column(
              children: [
                WhoIsThisButton(
                  conversationId: 'conv-123',
                  compact: false,
                ),
                WhoIsThisButton(
                  conversationId: 'conv-123',
                  compact: true,
                ),
              ],
            ),
          ),
        ),
      );

      // Just verify both modes render without crashing
      expect(find.byType(WhoIsThisButton), findsNWidgets(2));
      expect(find.text('Who is this?'), findsOneWidget); // Only in non-compact
      expect(find.byIcon(Icons.info_outline), findsNWidgets(2)); // In both
    });
  });
}
</file>

<file path="web/index.html">
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="messageai">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>messageai</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>
</file>

<file path="web/manifest.json">
{
    "name": "messageai",
    "short_name": "messageai",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}
</file>

<file path="windows/.gitignore">
flutter/ephemeral/

# Visual Studio user-specific files.
*.suo
*.user
*.userosscache
*.sln.docstates

# Visual Studio build-related files.
x64/
x86/

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/
</file>

<file path="windows/CMakeLists.txt">
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(messageai LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "messageai")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)
</file>

<file path="windows/flutter/CMakeLists.txt">
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)
</file>

<file path="windows/runner/CMakeLists.txt">
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)
</file>

<file path="windows/runner/flutter_window.cpp">
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}
</file>

<file path="windows/runner/flutter_window.h">
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_
</file>

<file path="windows/runner/main.cpp">
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"messageai", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}
</file>

<file path="windows/runner/resource.h">
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
</file>

<file path="windows/runner/runner.exe.manifest">
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>
</file>

<file path="windows/runner/Runner.rc">
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "com.example" "\0"
            VALUE "FileDescription", "messageai" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "messageai" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2025 com.example. All rights reserved." "\0"
            VALUE "OriginalFilename", "messageai.exe" "\0"
            VALUE "ProductName", "messageai" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
</file>

<file path="windows/runner/utils.cpp">
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}
</file>

<file path="windows/runner/utils.h">
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_
</file>

<file path="windows/runner/win32_window.cpp">
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}
</file>

<file path="windows/runner/win32_window.h">
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_
</file>

</files>
