import 'package:drift/drift.dart';
import 'package:messageai/data/drift/app_db.dart';

part 'ai_analysis_dao.g.dart';

/// Data Access Object for AI Analysis operations
@DriftAccessor(tables: [AiAnalysis])
class AIAnalysisDao extends DatabaseAccessor<AppDb> with _$AIAnalysisDaoMixin {
  AIAnalysisDao(AppDb db) : super(db);

  /// Get all AI analyses
  Future<List<AiAnalysi>> getAllAnalyses() {
    return select(aiAnalysis).get();
  }

  /// Get analysis by ID
  Future<AiAnalysi?> getAnalysisById(String id) {
    return (select(aiAnalysis)..where((a) => a.id.equals(id))).getSingleOrNull();
  }

  /// Get analysis for a specific message
  Future<AiAnalysi?> getAnalysisByMessageId(String messageId) {
    return (select(aiAnalysis)..where((a) => a.messageId.equals(messageId)))
        .getSingleOrNull();
  }

  /// Get all analyses for multiple messages
  Future<List<AiAnalysi>> getAnalysesByMessageIds(List<String> messageIds) {
    return (select(aiAnalysis)..where((a) => a.messageId.isIn(messageIds))).get();
  }

  /// Get analyses for a conversation (requires joining with messages)
  /// Note: This is a simple version. For better performance, you might want to
  /// pass in message IDs from the conversation
  Future<List<AiAnalysi>> getAnalysesForConversation(List<String> messageIds) {
    return (select(aiAnalysis)
          ..where((a) => a.messageId.isIn(messageIds))
          ..orderBy([(a) => OrderingTerm.desc(a.analysisTimestamp)]))
        .get();
  }

  /// Add a new analysis
  Future<int> addAnalysis(AiAnalysisCompanion analysis) {
    return into(aiAnalysis).insert(analysis);
  }

  /// Add or update analysis
  Future<void> upsertAnalysis(AiAnalysisCompanion analysis) {
    return into(aiAnalysis).insertOnConflictUpdate(analysis);
  }

  /// Update analysis
  Future<bool> updateAnalysis(AiAnalysi analysis) {
    return update(aiAnalysis).replace(analysis);
  }

  /// Delete analysis
  Future<int> deleteAnalysis(String id) {
    return (delete(aiAnalysis)..where((a) => a.id.equals(id))).go();
  }

  /// Delete analysis by message ID
  Future<int> deleteAnalysisByMessageId(String messageId) {
    return (delete(aiAnalysis)..where((a) => a.messageId.equals(messageId))).go();
  }

  /// Mark analysis as synced
  Future<void> markAsSynced(String id) {
    return (update(aiAnalysis)..where((a) => a.id.equals(id)))
        .write(const AiAnalysisCompanion(isSynced: Value(1)));
  }

  /// Get unsynced analyses
  Future<List<AiAnalysi>> getUnsyncedAnalyses() {
    return (select(aiAnalysis)..where((a) => a.isSynced.equals(0))).get();
  }

  /// Get analyses with specific tone
  Future<List<AiAnalysi>> getAnalysesByTone(String tone) {
    return (select(aiAnalysis)..where((a) => a.tone.equals(tone))).get();
  }

  /// Get analyses with specific urgency level
  Future<List<AiAnalysi>> getAnalysesByUrgencyLevel(String urgencyLevel) {
    return (select(aiAnalysis)
          ..where((a) => a.urgencyLevel.equals(urgencyLevel)))
        .get();
  }

  /// Get analyses with high confidence (> threshold)
  Future<List<AiAnalysi>> getHighConfidenceAnalyses({double threshold = 0.8}) {
    return (select(aiAnalysis)
          ..where((a) => a.confidenceScore.isBiggerOrEqualValue(threshold)))
        .get();
  }

  /// Get recent analyses (within last N seconds)
  Future<List<AiAnalysi>> getRecentAnalyses({int seconds = 3600}) {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final cutoff = now - seconds;
    return (select(aiAnalysis)
          ..where((a) => a.analysisTimestamp.isBiggerOrEqualValue(cutoff))
          ..orderBy([(a) => OrderingTerm.desc(a.analysisTimestamp)]))
        .get();
  }

  /// Delete old analyses (older than N days)
  Future<int> deleteOldAnalyses({int days = 30}) {
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    final cutoff = now - (days * 24 * 60 * 60);
    return (delete(aiAnalysis)
          ..where((a) => a.analysisTimestamp.isSmallerThanValue(cutoff)))
        .go();
  }

  /// Clear all analyses
  Future<int> clearAllAnalyses() {
    return delete(aiAnalysis).go();
  }

  /// Get analysis count
  Future<int> getAnalysisCount() async {
    final count = countAll();
    final query = selectOnly(aiAnalysis)..addColumns([count]);
    final result = await query.getSingle();
    return result.read(count) ?? 0;
  }

  /// Get analysis count by tone
  Future<Map<String, int>> getAnalysisCountByTone() async {
    final query = selectOnly(aiAnalysis)
      ..addColumns([aiAnalysis.tone, countAll()])
      ..groupBy([aiAnalysis.tone]);

    final results = await query.get();
    return Map.fromEntries(
      results.map((row) {
        final tone = row.read(aiAnalysis.tone) ?? 'Unknown';
        final count = row.read(countAll()) ?? 0;
        return MapEntry(tone, count);
      }),
    );
  }

  /// Stream of all analyses
  Stream<List<AiAnalysi>> watchAllAnalyses() {
    return select(aiAnalysis).watch();
  }

  /// Stream analysis for a specific message
  Stream<AiAnalysi?> watchAnalysisForMessage(String messageId) {
    return (select(aiAnalysis)..where((a) => a.messageId.equals(messageId)))
        .watchSingleOrNull();
  }
}

