import 'dart:async';
import 'dart:convert';
import 'package:messageai/data/drift/app_db.dart';
import 'package:messageai/data/drift/daos/ai_analysis_dao.dart';
import 'package:messageai/data/remote/supabase_client.dart';
import 'package:uuid/uuid.dart';

/// Service for managing AI message analysis (tone, intent, urgency)
class AIAnalysisService {
  final _analysisDao = AppDb.instance.aiAnalysisDao;
  final _supabase = SupabaseClientProvider.client;
  final _uuid = const Uuid();

  // Debouncing: Track pending analysis requests to avoid duplicates
  final Map<String, Timer> _pendingRequests = {};
  final Duration _debounceDelay = const Duration(milliseconds: 500);

  /// Request AI analysis for a message
  /// Debounces requests to avoid spamming the API
  Future<AiAnalysi?> requestAnalysis(
    String messageId,
    String messageBody, {
    List<String>? conversationContext,
    bool forceRefresh = false,
  }) async {
    // Cancel any pending request for this message
    _pendingRequests[messageId]?.cancel();

    // Check if we already have cached analysis
    if (!forceRefresh) {
      final cached = await _analysisDao.getAnalysisByMessageId(messageId);
      if (cached != null) {
        print('üìä Using cached analysis for message ${messageId.substring(0, 8)}');
        return cached;
      }
    }

    // Create a debounced request
    final completer = Completer<AiAnalysi?>();
    
    _pendingRequests[messageId] = Timer(_debounceDelay, () async {
      try {
        print('ü§ñ Requesting AI analysis for message ${messageId.substring(0, 8)}...');
        
        final analysis = await _callAnalysisAPI(
          messageId,
          messageBody,
          conversationContext,
        );
        
        if (!completer.isCompleted) {
          completer.complete(analysis);
        }
      } catch (e) {
        print('‚ùå Analysis request failed: $e');
        if (!completer.isCompleted) {
          completer.completeError(e);
        }
      } finally {
        _pendingRequests.remove(messageId);
      }
    });

    return completer.future;
  }

  /// Call the AI analysis Edge Function
  Future<AiAnalysi> _callAnalysisAPI(
    String messageId,
    String messageBody,
    List<String>? conversationContext,
  ) async {
    try {
      final response = await _supabase.functions.invoke(
        'ai_analyze_tone',
        body: {
          'message_id': messageId,
          'message_body': messageBody,
          if (conversationContext != null)
            'conversation_context': conversationContext,
        },
      );

      if (response.status != 200) {
        throw Exception('API returned status ${response.status}');
      }

      final data = response.data;
      if (data == null || !data['success']) {
        throw Exception(data?['error'] ?? 'Unknown error');
      }

      final analysisData = data['analysis'];
      
      // Store in local database
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final analysis = AiAnalysisCompanion.insert(
        id: analysisData['id'] as String,
        messageId: messageId,
        tone: analysisData['tone'] as String,
        urgencyLevel: Value(analysisData['urgency_level'] as String?),
        intent: Value(analysisData['intent'] as String?),
        confidenceScore: Value(
          (analysisData['confidence_score'] as num?)?.toDouble(),
        ),
        analysisTimestamp: analysisData['analysis_timestamp'] as int? ?? now,
        isSynced: const Value(true),
        createdAt: now,
        updatedAt: now,
      );

      await _analysisDao.upsertAnalysis(analysis);
      
      print('‚úÖ Analysis complete: ${analysisData['tone']} (${analysisData['urgency_level']})');
      
      // Return the stored analysis
      return (await _analysisDao.getAnalysisByMessageId(messageId))!;
    } catch (e) {
      print('‚ùå Failed to call analysis API: $e');
      rethrow;
    }
  }

  /// Get analysis for a specific message
  Future<AiAnalysi?> getAnalysis(String messageId) async {
    return _analysisDao.getAnalysisByMessageId(messageId);
  }

  /// Get analyses for multiple messages
  Future<Map<String, AiAnalysi>> getAnalysesForMessages(
    List<String> messageIds,
  ) async {
    final analyses = await _analysisDao.getAnalysesByMessageIds(messageIds);
    return Map.fromEntries(
      analyses.map((a) => MapEntry(a.messageId, a)),
    );
  }

  /// Get analyses for a conversation
  Future<Map<String, AiAnalysi>> getConversationAnalysis(
    String conversationId,
    List<String> messageIds,
  ) async {
    final analyses = await _analysisDao.getAnalysesForConversation(messageIds);
    return Map.fromEntries(
      analyses.map((a) => MapEntry(a.messageId, a)),
    );
  }

  /// Sync analysis from backend for a message
  Future<AiAnalysi?> syncAnalysisFromBackend(String messageId) async {
    try {
      print('üîÑ Syncing analysis for message ${messageId.substring(0, 8)} from backend...');
      
      final response = await _supabase.rpc(
        'get_message_ai_analysis',
        params: {'p_message_id': messageId},
      );

      if (response == null || (response as List).isEmpty) {
        print('‚ÑπÔ∏è No analysis found on backend');
        return null;
      }

      final data = (response as List).first;
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      
      final analysis = AiAnalysisCompanion.insert(
        id: data['id'] as String,
        messageId: messageId,
        tone: data['tone'] as String,
        urgencyLevel: Value(data['urgency_level'] as String?),
        intent: Value(data['intent'] as String?),
        confidenceScore: Value((data['confidence_score'] as num?)?.toDouble()),
        analysisTimestamp: data['analysis_timestamp'] as int? ?? now,
        isSynced: const Value(true),
        createdAt: now,
        updatedAt: now,
      );

      await _analysisDao.upsertAnalysis(analysis);
      
      return _analysisDao.getAnalysisByMessageId(messageId);
    } catch (e) {
      print('‚ùå Failed to sync analysis from backend: $e');
      return null;
    }
  }

  /// Sync analyses for a conversation from backend
  Future<void> syncConversationAnalysesFromBackend(
    String conversationId,
  ) async {
    try {
      print('üîÑ Syncing analyses for conversation ${conversationId.substring(0, 8)}...');
      
      final response = await _supabase.rpc(
        'get_conversation_ai_analysis',
        params: {'p_conversation_id': conversationId},
      );

      if (response == null || (response as List).isEmpty) {
        print('‚ÑπÔ∏è No analyses found on backend');
        return;
      }

      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final analyses = (response as List).cast<Map<String, dynamic>>();
      
      for (final data in analyses) {
        final analysis = AiAnalysisCompanion.insert(
          id: _uuid.v4(),
          messageId: data['message_id'] as String,
          tone: data['tone'] as String,
          urgencyLevel: Value(data['urgency_level'] as String?),
          intent: Value(data['intent'] as String?),
          confidenceScore: Value((data['confidence_score'] as num?)?.toDouble()),
          analysisTimestamp: data['analysis_timestamp'] as int? ?? now,
          isSynced: const Value(true),
          createdAt: now,
          updatedAt: now,
        );

        await _analysisDao.upsertAnalysis(analysis);
      }
      
      print('‚úÖ Synced ${analyses.length} analyses from backend');
    } catch (e) {
      print('‚ùå Failed to sync conversation analyses: $e');
    }
  }

  /// Delete analysis for a message
  Future<void> deleteAnalysis(String messageId) async {
    await _analysisDao.deleteAnalysisByMessageId(messageId);
  }

  /// Clear old analyses (older than N days)
  Future<void> cleanupOldAnalyses({int days = 30}) async {
    final deleted = await _analysisDao.deleteOldAnalyses(days: days);
    print('üßπ Cleaned up $deleted old analyses');
  }

  /// Get analysis statistics
  Future<Map<String, dynamic>> getAnalysisStats() async {
    final count = await _analysisDao.getAnalysisCount();
    final byTone = await _analysisDao.getAnalysisCountByTone();
    
    return {
      'total_count': count,
      'by_tone': byTone,
    };
  }

  /// Stream analysis for a message
  Stream<AiAnalysi?> watchAnalysis(String messageId) {
    return _analysisDao.watchAnalysisForMessage(messageId);
  }

  /// Cancel pending analysis request
  void cancelPendingRequest(String messageId) {
    _pendingRequests[messageId]?.cancel();
    _pendingRequests.remove(messageId);
  }

  /// Cancel all pending requests
  void cancelAllPendingRequests() {
    for (final timer in _pendingRequests.values) {
      timer.cancel();
    }
    _pendingRequests.clear();
  }

  /// Dispose resources
  void dispose() {
    cancelAllPendingRequests();
  }
}

